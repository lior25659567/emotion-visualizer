<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ›ï¸ Admin Panel - Emotion Analyzer</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' fill='%23667eea'/%3E%3Ctext x='16' y='22' text-anchor='middle' font-family='Arial' font-size='16' fill='white'%3Eâš™ï¸%3C/text%3E%3C/svg%3E">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <script src="performance_monitor.js?v=2.3&bust=1751295800"></script>
    <script src="fix_tooltip_hover.js"></script>

    <script>
        // Define functions globally to ensure they're available for onclick handlers
        window.switchTab = function(tabName) {
            console.log('switchTab called with:', tabName);
            
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
            });
            
            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });
            
            // Show the selected tab content
            const selectedTabContent = document.getElementById(`${tabName}-tab`);
            if (selectedTabContent) {
                selectedTabContent.classList.add('active');
                selectedTabContent.style.display = 'block';
            }
            
            // Add active class to the clicked tab button
            const clickedButton = event ? event.target.closest('.tab-button') : 
                document.querySelector(`.tab-button[onclick*="${tabName}"]`);
            if (clickedButton) {
                clickedButton.classList.add('active');
            }
            
            // Initialize specific tab functionality
            if (tabName === 'editor') {
                setTimeout(() => {
                    if (typeof initializeEditor === 'function') {
                        initializeEditor();
                    }
                }, 100);
            } else if (tabName === 'upload') {
                setTimeout(() => {
                    if (typeof initializeUpload === 'function') {
                        initializeUpload();
                    }
                }, 100);
            } else if (tabName === 'experiments') {
                setTimeout(() => {
                    if (typeof initializeExperiments === 'function') {
                        initializeExperiments();
                    }
                }, 100);
            } else if (tabName === 'metadata') {
                setTimeout(() => {
                    if (typeof initializeMetadata === 'function') {
                        initializeMetadata();
                    }
                }, 100);
            } else if (tabName === 'people') {
                setTimeout(() => {
                    if (typeof initializePeople === 'function') {
                        initializePeople();
                    }
                }, 100);
            } else if (tabName === 'emotions') {
                setTimeout(() => {
                    if (typeof initializeEmotions === 'function') {
                        initializeEmotions();
                    }
                }, 100);
            }
        };
        
        // Removed duplicate function - see proper definition below
        
        window.openConfigEditor = function() {
            console.log('Opening config editor...');
            // Ask user confirmation before navigating to avoid accidental navigation
            if (confirm('×¤×ª×— ×¢×•×¨×š ×”×’×“×¨×•×ª AI? (×–×” ×™×¢×–×•×‘ ××ª ×”×“×£ ×”× ×•×›×—×™)')) {
                window.location.href = 'config_editor.html';
            }
        };
    </script>
    <style>
        /* Base styles */
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: #f0f2f5;
            direction: rtl;
            color: #1a1a1a;
        }
        
        /* Modern Enhanced Edit Parameters Tab Styles */
        .modern-conversation-card {
            background: white;
            border-radius: 12px;
            margin-bottom: 0.75rem;
            overflow: hidden;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            cursor: pointer;
            position: relative;
        }

        .modern-conversation-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
            border-color: rgba(102, 126, 234, 0.2);
        }

        .modern-conversation-card.active {
            border-color: #667eea;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.2);
            transform: translateY(-1px);
        }

        .conversation-card-header {
            padding: 1rem;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-bottom: 1px solid #e9ecef;
        }

        .conversation-card-title {
            font-weight: 600;
            font-size: 1rem;
            color: #2c3e50;
            margin: 0 0 0.25rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .conversation-card-meta {
            font-size: 0.8rem;
            color: #6c757d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .conversation-card-body {
            padding: 0.75rem 1rem;
        }

        .conversation-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            color: #6c757d;
        }

        .modern-segment-card {
            background: white;
            border-radius: 10px;
            margin-bottom: 0.75rem;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
            overflow: hidden;
            cursor: pointer;
            position: relative;
        }

        .modern-segment-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }

        .modern-segment-card.active {
            border-color: #667eea;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.15);
            background: linear-gradient(135deg, #fff 0%, #f8f9ff 100%);
        }

        .segment-card-header {
            padding: 0.75rem 1rem;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .segment-card-title {
            font-weight: 600;
            font-size: 0.9rem;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .segment-card-body {
            padding: 0.75rem 1rem;
        }

        .segment-emotions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-bottom: 0.5rem;
        }

        .emotion-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .segment-transcript-preview {
            font-size: 0.8rem;
            color: #6c757d;
            line-height: 1.4;
            max-height: 2.8rem;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .modern-parameter-editor {
            background: white;
            border-radius: 16px;
            padding: 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }

        .parameter-editor-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            position: relative;
        }

        .parameter-editor-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin: 0 0 0.5rem 0;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .parameter-editor-subtitle {
            opacity: 0.9;
            font-size: 0.9rem;
            margin: 0;
        }

        .parameter-editor-body {
            padding: 0;
        }

        .parameter-section {
            border-bottom: 1px solid #f1f3f4;
            transition: all 0.3s ease;
        }

        .parameter-section:last-child {
            border-bottom: none;
        }

        .parameter-section-header {
            background: #f8f9fa;
            padding: 1rem 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            border-bottom: 1px solid #e9ecef;
        }

        .parameter-section-header:hover {
            background: #e9ecef;
        }

        .parameter-section-title {
            font-weight: 600;
            font-size: 1rem;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .parameter-section-toggle {
            color: #667eea;
            transition: transform 0.3s ease;
        }

        .parameter-section.collapsed .parameter-section-toggle {
            transform: rotate(-90deg);
        }

        .parameter-section-body {
            padding: 1.5rem;
            background: white;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .parameter-section.collapsed .parameter-section-body {
            max-height: 0;
            padding: 0 1.5rem;
        }

        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .parameter-grid-2 {
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        }

        .parameter-grid-3 {
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        }

        .parameter-item {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
        }

        .parameter-item:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
        }

        .parameter-label {
            font-weight: 600;
            font-size: 0.9rem;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .parameter-help {
            color: #6c757d;
            cursor: help;
            font-size: 0.8rem;
        }

        .modern-input {
            width: 100%;
            padding: 0.6rem 0.8rem;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            background: white;
        }

        .modern-input:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            outline: none;
        }

        .modern-select {
            width: 100%;
            padding: 0.6rem 0.8rem;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            background: white;
            cursor: pointer;
        }

        .modern-select:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            outline: none;
        }

        .modern-range {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            outline: none;
            transition: all 0.3s ease;
            margin: 0.5rem 0;
        }

        .modern-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
        }

        .modern-range::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .modern-range::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);
        }

        .range-value {
            background: #667eea;
            color: white;
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            min-width: 40px;
            text-align: center;
        }

        /* âœ¨ ENHANCED SLIDERS - Modern, responsive design with smooth animations */
        .enhanced-slider {
            flex: 1;
            height: 24px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            border-radius: 12px;
            outline: none;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            margin: 2px 0;
        }

        .enhanced-slider::-webkit-slider-track {
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, var(--slider-color, #667eea) 0%, var(--slider-color, #667eea) var(--slider-percent, 50%), #e9ecef var(--slider-percent, 50%), #e9ecef 100%);
            transition: all 0.2s ease;
            border: none;
        }

        .enhanced-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-color, #667eea);
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
            transform: translateY(-6px);
        }

        .enhanced-slider::-webkit-slider-thumb:hover {
            transform: translateY(-6px) scale(1.15);
            box-shadow: 0 6px 20px rgba(0,0,0,0.25), 0 4px 8px rgba(0,0,0,0.15);
        }

        .enhanced-slider::-webkit-slider-thumb:active {
            transform: translateY(-6px) scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        /* Firefox styles */
        .enhanced-slider::-moz-range-track {
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, var(--slider-color, #667eea) 0%, var(--slider-color, #667eea) var(--slider-percent, 50%), #e9ecef var(--slider-percent, 50%), #e9ecef 100%);
            border: none;
        }

        .enhanced-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-color, #667eea);
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }

        .enhanced-slider:hover {
            transform: translateY(-1px);
        }

        .enhanced-slider:focus {
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        /* ğŸ“‹ COMPACT DROPDOWN SELECTS - For segment quick controls */
        .modern-select-compact {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            background: #fff;
            font-size: 0.8rem;
            color: #495057;
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
            font-family: inherit;
            direction: rtl;
        }

        .modern-select-compact:hover {
            border-color: #667eea;
            background: #f8f9ff;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.1);
        }

        .modern-select-compact:focus {
            border-color: #667eea;
            background: #fff;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.15);
            transform: translateY(-1px);
        }

        .modern-select-compact option {
            padding: 8px;
            background: #fff;
            color: #495057;
            direction: rtl;
        }

        .modern-select-compact option:hover {
            background: #f8f9ff;
        }

        .modern-checkbox {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
            font-size: 0.9rem;
            color: #2c3e50;
        }

        .modern-checkbox input[type="checkbox"] {
            appearance: none;
            width: 20px;
            height: 20px;
            border: 2px solid #e9ecef;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modern-checkbox input[type="checkbox"]:checked {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
        }

        .modern-checkbox input[type="checkbox"]:checked::after {
            content: 'âœ“';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .transcript-editor {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 1rem;
            min-height: 100px;
            font-size: 0.9rem;
            line-height: 1.6;
            transition: all 0.3s ease;
            direction: rtl;
        }

        .transcript-editor:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            outline: none;
        }

        .transcript-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
            align-items: center;
        }

        .modern-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
        }

        .modern-btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .modern-btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .modern-btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .modern-btn-success:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .modern-btn-info {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
        }

        .modern-btn-info:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(23, 162, 184, 0.3);
        }

        .modern-btn-secondary {
            background: #f8f9fa;
            color: #6c757d;
            border: 1px solid #e9ecef;
        }

        .modern-btn-secondary:hover {
            background: #e9ecef;
            color: #495057;
        }

        .modern-btn-sm {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        .emotion-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .emotion-option {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 20px;
            padding: 0.4rem 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
            user-select: none;
        }

        .emotion-option:hover {
            border-color: #667eea;
            background: #f0f8ff;
        }

        .emotion-option.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }

        .visual-effects-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .effect-control {
            text-align: center;
        }

        .effect-control-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .effect-value-display {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: 600;
            margin-top: 0.5rem;
            display: inline-block;
        }

        .advanced-parameters {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            z-index: 10;
        }

        .modern-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .progress-bar {
            background: #e9ecef;
            border-radius: 10px;
            height: 8px;
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .progress-fill {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .status-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #28a745;
        }

        .status-indicator.pending {
            background: #ffc107;
            animation: pulse 2s infinite;
        }

        .status-indicator.error {
            background: #dc3545;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        .modern-analysis-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            transition: all 0.3s ease;
        }

        .analysis-panel-title {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .analysis-settings {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .analysis-setting {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
        }

        .analysis-setting input[type="checkbox"] {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }

        .analysis-setting input[type="checkbox"]:checked {
            background: white;
            border-color: white;
        }

        .analysis-setting input[type="checkbox"]:checked::after {
            content: 'âœ“';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #667eea;
            font-size: 10px;
            font-weight: bold;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            margin: 0;
            font-size: 2rem;
            font-weight: 300;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .header p {
            margin: 0.5rem 0 0 0;
            opacity: 0.9;
        }
        
        /* Tab navigation */
        .tab-nav {
            background: white;
            padding: 0 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            gap: 1rem;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .tab-button {
            background: none;
            border: none;
            padding: 1rem 2rem;
            cursor: pointer;
            font-size: 1rem;
            color: #666;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }
        
        .tab-button:hover {
            color: #333;
            background: #f8f9fa;
        }
        
        .tab-button.active {
            color: #667eea;
            border-bottom-color: #667eea;
            font-weight: 600;
        }
        
        .tab-button i {
            font-size: 1.2rem;
        }
        
        /* Tab content */
        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
            min-height: calc(100vh - 200px);
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Common panel styles */
        .panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 2rem;
            margin: 1rem;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #f0f2f5;
        }
        
        .panel-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
            margin: 0;
        }
        
        /* Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5a67d8;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        .btn-secondary {
            background: #e0e0e0;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #d0d0d0;
        }
        
        .btn-success {
            background: #48bb78;
            color: white;
        }
        
        .btn-success:hover {
            background: #38a169;
        }
        
        .btn-danger {
            background: #f56565;
            color: white;
        }
        
        .btn-danger:hover {
            background: #e53e3e;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        /* Form elements */
        input, textarea, select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s ease;
            font-family: inherit;
        }
        
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #555;
        }
        
        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        
        .loading-spinner {
            background: white;
            padding: 2rem 3rem;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Status messages */
        .status-message {
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .status-success {
            background: #c6f6d5;
            color: #276749;
            border: 1px solid #9ae6b4;
        }
        
        .status-error {
            background: #fed7d7;
            color: #742a2a;
            border: 1px solid #feb2b2;
        }
        
        .status-info {
            background: #bee3f8;
            color: #2a4e7c;
            border: 1px solid #90cdf4;
        }
        
        /* Refresh button */
        .refresh-all-btn {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            background: #f56565;
            color: white;
            padding: 1rem;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(245, 101, 101, 0.3);
            transition: all 0.2s ease;
            z-index: 1000;
            width: 72px;
            height: 72px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .refresh-all-btn:hover {
            background: #e53e3e;
            transform: translateY(-2px) rotate(180deg);
            box-shadow: 0 6px 16px rgba(245, 101, 101, 0.4);
        }
        
        .refresh-all-btn i {
            font-size: 1.5rem;
        }
        
        /* Conversation list styles */
        .conversation-item {
            background: #f8f9fa;
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .conversation-item:hover {
            background: #e9ecef;
            transform: none; /* Removed transform that interferes with tooltips */
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
        }
        
        .conversation-item.active {
            background: #e8f0fe;
            border-color: #667eea;
        }
        
        /* Improved tooltip behavior */
        .conversation-item {
            position: relative;
            transition: all 0.3s ease;
        }
        
        /* Custom tooltip styles */
        .custom-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            white-space: pre-wrap;
            max-width: 350px;
            z-index: 10000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: tooltipFadeIn 0.2s ease-in-out;
        }
        
        @keyframes tooltipFadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .conversation-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.85rem;
            color: #666;
        }
        
        /* Segment styles */
        .segment-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .segment-item:hover {
            background-color: #f5f5f5;
            border-color: #d0d0d0;
        }
        
        .segment-item.active {
            background-color: #e3f2fd;
            border-color: #2196F3;
            box-shadow: 0 2px 4px rgba(33, 150, 243, 0.2);
        }
        
        /* Emotion tags */
        .emotion-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0;
        }
        
        .emotion-tag {
            background: #e3f2fd;
            color: #1976d2;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .emotion-tag:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .emotion-tag .remove-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 0;
            margin-right: -0.25rem;
            font-size: 1rem;
        }
        
        .emotion-tag .remove-btn:hover {
            color: #d32f2f;
        }
        
        /* Upload area */
        .upload-area.dragover {
            background: #e8eaf6;
            border-color: #5c6bc0;
        }
        
        /* Small button variant */
        .btn-sm {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }
        
        /* Speaker indicators */
        .speaker-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .speaker-0 { background-color: #FF6B6B; }
        .speaker-1 { background-color: #4ECDC4; }
        
        /* Process option buttons */
        .process-option {
            padding: 0.75rem;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            font-weight: 500;
        }
        
        .process-option:hover {
            background: #e9ecef;
            border-color: #667eea;
            transform: translateY(-2px);
        }
        
        /* Conversation Topics Styling */
        #conversation-topics {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid #e8f0fe;
        }
        
        #conversation-topics label {
            background: rgba(102, 126, 234, 0.05);
            padding: 0.5rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        #conversation-topics label:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }
        
        #conversation-topics input[type="checkbox"]:checked + span {
            font-weight: 600;
            color: #667eea;
        }
        
        #custom-topics {
            margin-top: 0.5rem;
            border: 2px dashed #d0d0d0;
            padding: 0.75rem;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
        }
        
        #custom-topics:focus {
            border-color: #667eea;
            background: white;
        }
        
        /* Enhanced Main Emotions Styling */
        #main-emotions-selector {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid #ffeaea;
        }
        
        #main-emotions-selector label {
            background: rgba(229, 62, 62, 0.05);
            padding: 0.5rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        #main-emotions-selector label:hover {
            background: rgba(229, 62, 62, 0.1);
            transform: translateY(-1px);
        }
        
        #main-emotions-selector input[type="checkbox"]:checked + span {
            font-weight: 600;
            color: #e53e3e;
        }

        /* Parameter inputs styling */
        .segment-content input[type="number"],
        .segment-content select,
        .segment-content textarea {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        
        .segment-content input[type="number"]:focus,
        .segment-content select:focus,
        .segment-content textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }
        
        .segment-content label {
            display: block;
            margin-bottom: 4px;
            font-size: 13px;
            font-weight: 600;
            color: #495057;
        }
        
        .segment-content input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        /* Character size group styling */
        .segment-content > div[style*="background: #f0f8ff"] {
            margin-top: 10px;
        }
        
        /* Transcript editor styles */
        .transcript-box {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
            font-family: inherit;
            font-size: 14px;
            line-height: 1.6;
            transition: border-color 0.3s;
        }
        
        .transcript-box:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }
        
        .transcript-box[data-changed="true"] {
            border-color: #ff9800;
        }
        
        .transcript-actions {
            display: flex;
            gap: 10px;
            margin-top: 8px;
            align-items: center;
        }
        
        .transcript-status {
            font-size: 12px;
            color: #666;
            margin-left: auto;
        }
        
        /* Loop button active state */
        .btn.active {
            background-color: #f44336 !important;
            color: white !important;
        }
        
        /* Hide scrollbars for transcript containers */
        #conversations-list::-webkit-scrollbar {
            display: none;
        }
        
        #segments-list-container::-webkit-scrollbar {
            display: none;
        }
        
        #people-list::-webkit-scrollbar {
            display: none;
        }
        
        #metadata-conversations-list::-webkit-scrollbar {
            display: none;
        }
        
        #conversation-grid-container::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <h1>
            <i class="material-icons">admin_panel_settings</i>
            Admin Panel - Emotion Analyzer
        </h1>
        <p>× ×™×”×•×œ ××œ× ×©×œ ×”×©×™×—×•×ª, ×¢×¨×™×›×ª ×¤×¨××˜×¨×™×, ×”×¢×œ××” ×•× ×™×¡×•×™×™×</p>
    </header>

    <!-- Tab Navigation -->
    <nav class="tab-nav">
        <button class="tab-button active" onclick="switchTab('editor')">
            <i class="material-icons">edit_note</i>
            ×¢×•×¨×š ×¤×¨××˜×¨×™×
        </button>
        <button class="tab-button" onclick="switchTab('upload')">
            <i class="material-icons">cloud_upload</i>
            ×”×¢×œ××” ×•×¢×™×‘×•×“
        </button>
        <button class="tab-button" onclick="switchTab('experiments')">
            <i class="material-icons">science</i>
            × ×™×¡×•×™×™×
        </button>
        <button class="tab-button" onclick="switchTab('metadata')">
            <i class="material-icons">info</i>
            × ×ª×•× ×™ ×©×™×—×•×ª
        </button>
        <button class="tab-button" onclick="switchTab('people')">
            <i class="material-icons">people</i>
            × ×™×”×•×œ ×× ×©×™×
        </button>
        <button class="tab-button" onclick="switchTab('videos')">
            <i class="material-icons">videocam</i>
            ×™×™×¦×•×¨ ×•×™×“××•
        </button>
        <button class="tab-button" onclick="switchTab('settings')">
            <i class="material-icons">settings</i>
            ×”×’×“×¨×•×ª
        </button>
        <button class="tab-button" onclick="switchTab('emotions')">
            <i class="material-icons">emoji_emotions</i>
            × ×™×”×•×œ ×¨×’×©×•×ª
        </button>
        <button class="tab-button" onclick="window.open('video_manager.html', '_blank')" style="background: linear-gradient(135deg, #e74c3c, #c0392b); color: white;">
            <i class="material-icons">movie</i>
            ×× ×”×œ ×¡×¨×˜×•× ×™×
        </button>
        <button type="button" class="tab-button" onclick="openConfigEditor()">
            <i class="material-icons">tune</i>
            ×¢×•×¨×š ×”×’×“×¨×•×ª AI
        </button>
        <button type="button" class="tab-button" onclick="window.open('modern_parameters_editor.html', '_blank')" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white;">
            <i class="material-icons">palette</i>
            ×¢×•×¨×š ×¤×¨××˜×¨×™× ××•×“×¨× ×™
        </button>
    </nav>

    <!-- Tab 1: Enhanced Editor -->
    <div id="editor-tab" class="tab-content active">
        <div style="display: flex; height: calc(100vh - 180px); gap: 1rem; padding: 1rem;">
            <!-- Left Panel - Conversations List (Smaller) -->
            <div class="panel" style="flex: 0 0 280px; padding: 0; display: flex; flex-direction: column;">
                <div class="panel-header" style="padding: 1.5rem; margin: 0;">
                    <h2 class="panel-title">×©×™×—×•×ª ×–××™× ×•×ª</h2>
                    <div style="display: flex; gap: 0.5rem;">
                        <button type="button" onclick="openConversationVisualSelector('editor')" class="btn btn-primary" title="×‘×—×™×¨×” ×•×™×–×•××œ×™×ª">
                            <i class="material-icons">visibility</i>
                            ×‘×—×™×¨×” ×•×™×–×•××œ×™×ª
                        </button>
                        <button type="button" onclick="refreshConversationsList()" class="btn btn-secondary">
                            <i class="material-icons">refresh</i>
                            ×¨×¢× ×Ÿ
                        </button>
                        <button type="button" onclick="hideLoading(); showStatus('×‘×•×˜×œ', 'info');" class="btn btn-secondary" title="×‘×˜×œ ×˜×¢×™× ×”">
                            <i class="material-icons">cancel</i>
                        </button>
                    </div>
                </div>
                <div id="conversations-list" style="flex: 1; overflow-y: auto; padding: 0 1rem 1rem; scrollbar-width: none; -ms-overflow-style: none;">
                    <!-- Conversations will be loaded here -->
                </div>
            </div>
            
            <!-- Middle Panel - Segments List (Much Larger) -->
            <div class="panel" style="flex: 1; padding: 0; display: flex; flex-direction: column; min-width: 500px;">
                <div id="no-selection" style="text-align: center; padding: 4rem; color: #999;">
                    <i class="material-icons" style="font-size: 64px; display: block; margin-bottom: 1rem;">folder_open</i>
                    <p style="font-size: 1.2rem;">×‘×—×¨ ×©×™×—×” ××”×¨×©×™××”</p>
                </div>
                
                <div id="conversation-editor" style="display: none; flex: 1;">
                    <div class="panel" style="display: flex; flex-direction: column; height: 100%;">
                        <div class="panel-header" style="flex-shrink: 0;">
                            <div>
                                <h2 class="panel-title" id="conversation-title">×©×™×—×”</h2>
                                <div id="analysis-progress" style="display: none; margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <div class="spinner" style="width: 20px; height: 20px; margin: 0;"></div>
                                        <span id="analysis-progress-text">×× ×ª×—...</span>
                                    </div>
                                </div>
                            </div>
                            <!-- Modern Analysis Panel - Simplified -->
                            <div class="modern-analysis-panel" id="analysis-panel" style="margin-bottom: 0.5rem;">
                                <button type="button" class="modern-btn modern-btn-primary" onclick="analyzeEntireConversationComprehensive()" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem; flex-direction: column; margin-bottom: 0.5rem;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <i class="material-icons">auto_awesome</i>
                                        × ×™×ª×•×— ××œ× ×¢× AI - ×›×œ ×”×©×™×—×”
                                    </div>
                                    <small style="opacity: 0.8; font-size: 0.85em;">(×¨×’×©×•×ª ××¨×•×‘×™× + × ×™×ª×•×— ××•×“×™×• + ×›×œ 92 ×”×¨×’×©×•×ª)</small>
                                </button>
                                <button type="button" class="modern-btn modern-btn-warning" onclick="transcribeAndAnalyzeEntireConversation()" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem; flex-direction: column; margin-bottom: 0.5rem;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <i class="material-icons">record_voice_over</i>
                                        ×ª××œ×•×œ + × ×™×ª×•×— ××œ× ×¢× AI - ×›×œ ×”×©×™×—×”
                                    </div>
                                    <small style="opacity: 0.8; font-size: 0.85em;">(×ª××œ×•×œ ×—×›× + ×¨×’×©×•×ª ××¨×•×‘×™× + × ×™×ª×•×— ××•×“×™×• + ×›×œ 92 ×”×¨×’×©×•×ª)</small>
                                </button>
                                
                                <!-- AI Summary and Insights Buttons -->
                                <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                                    <button type="button" class="modern-btn modern-btn-info" onclick="generateCurrentConversationSummary()" style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem;">
                                        <i class="material-icons">summarize</i>
                                        ×¦×•×¨ ×¡×™×›×•× AI
                                    </button>
                                    <button type="button" class="modern-btn modern-btn-success" onclick="generateCurrentConversationInsights()" style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem;">
                                        <i class="material-icons">lightbulb</i>
                                        ×¦×•×¨ ×ª×•×‘× ×•×ª AI
                                    </button>
                                </div>
                                
                                <button type="button" class="modern-btn modern-btn-secondary" onclick="generateCurrentConversationBoth()" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem;">
                                    <i class="material-icons">psychology</i>
                                    ×¦×•×¨ ×¡×™×›×•× ×•×ª×•×‘× ×•×ª ×™×—×“
                                </button>

                            </div>
                            
                            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <!-- Auto-Analysis Toggle -->
                                <button type="button" class="modern-btn modern-btn-sm" id="auto-analysis-toggle" onclick="toggleAutoAnalysis()" 
                                        style="background: linear-gradient(135deg, #28a745, #20c997); color: white;"
                                        title="× ×™×ª×•×— ××•×˜×•××˜×™ ×›×©××¢×“×›× ×™× ×˜×¨× ×¡×§×¨×™×¤×˜">
                                    <i class="material-icons">smart_toy</i>
                                    × ×™×ª×•×— ××•×˜×•××˜×™: ×¤×¢×™×œ
                                </button>
                                                    <button type="button" class="modern-btn modern-btn-success modern-btn-sm" onclick="saveAllChanges()" id="save-all-btn" disabled>
                        <i class="material-icons">save</i>
                        ×©××•×¨ ×©×™× ×•×™×™×
                    </button>
                    <button type="button" class="modern-btn modern-btn-warning modern-btn-sm" onclick="applyEnhancedEffectsToAllSegments()" 
                            style="background: linear-gradient(135deg, #e83e8c, #fd7e14);"
                            title="×©×¤×¨ ××¤×§×˜×™× ×•×™×–×•××œ×™×™× (×˜×©×˜×•×©, ×‘×¨×§, ×”×•××•×¨) ×œ×›×œ ×”×§×˜×¢×™× ×”×§×™×™××™×">
                        ğŸ¨ ×©×¤×¨ ××¤×§×˜×™× ×œ×›×•×œ×
                    </button>
                    <button type="button" class="modern-btn modern-btn-info modern-btn-sm" onclick="generateAllPreviewVideos()" 
                            style="background: linear-gradient(135deg, #17a2b8, #138496);"
                            title="×¦×•×¨ ×•×™×“××• preview ×‘×Ÿ 15 ×©× ×™×•×ª ×œ×œ× ×¤×× ×œ ×¦×“ ×¢×‘×•×¨ ×›×œ ×”×©×™×—×•×ª">
                        ğŸ¬ ×¦×•×¨ Preview ×œ×›×œ ×”×©×™×—×•×ª
                    </button>
                                <button type="button" class="modern-btn modern-btn-secondary modern-btn-sm" onclick="exportConversationData()">
                                    <i class="material-icons">download</i>
                                    ×™×™×¦× × ×ª×•× ×™×
                                </button>
                                <button type="button" class="modern-btn modern-btn-secondary modern-btn-sm" onclick="playAllSegmentsSequentially()" title="× ×’×Ÿ ××ª ×›×œ ×”×§×˜×¢×™× ×‘×¨×¦×£">
                                    <i class="material-icons">playlist_play</i>
                                    × ×’×Ÿ ×¨×¦×£
                                </button>
                            </div>
                        </div>
                        
                        <!-- Segments List -->
                        <div id="segments-list-container" style="flex: 1; overflow-y: auto; padding: 0.5rem; scrollbar-width: none; -ms-overflow-style: none;">
                            <div id="segments-container">
                                <!-- Initial helpful message -->
                                <div style="text-align: center; padding: 60px 20px; color: #6c757d;">
                                    <div style="font-size: 3rem; margin-bottom: 20px;">ğŸµ</div>
                                    <h3 style="color: #495057; margin-bottom: 15px;">×‘×¨×•×›×™× ×”×‘××™× ×œ×¢×•×¨×š ×”×¤×¨××˜×¨×™×</h3>
                                    <p style="margin-bottom: 20px; line-height: 1.6;">
                                        ×‘×—×¨ ×©×™×—×” ××”×¨×©×™××” ×‘×¦×“ ×©×××œ ×›×“×™ ×œ×”×ª×—×™×œ ×¢×¨×™×›×ª ×¤×¨××˜×¨×™×
                                    </p>
                                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: right;">
                                        <h4 style="color: #495057; margin-bottom: 10px;">ğŸ“‹ ××” ××¤×©×¨ ×œ×¢×©×•×ª ×›××Ÿ:</h4>
                                        <ul style="list-style: none; padding: 0;">
                                            <li style="margin-bottom: 8px;">ğŸ­ ×¢×¨×™×›×ª ×¨×’×©×•×ª ×œ×›×œ ×§×˜×¢</li>
                                            <li style="margin-bottom: 8px;">ğŸ¨ ×©×™× ×•×™ ××¤×§×˜×™× ×•×™×–×•××œ×™×™×</li>
                                            <li style="margin-bottom: 8px;">ğŸ“ ×¢×¨×™×›×ª ×˜×¨× ×¡×§×¨×™×¤×˜×™×</li>
                                            <li style="margin-bottom: 8px;">ğŸ¤– × ×™×ª×•×— ×¢× ChatGPT ××ª×§×“×</li>
                                            <li style="margin-bottom: 8px;">ğŸ”Š ×”×©××¢×” ×•×”×ª×××ª ×¤×¨××˜×¨×™ ××•×“×™×•</li>
                                        </ul>
                                    </div>
                                    <div style="color: #007bff; font-weight: 600;">
                                        ğŸ‘ˆ ×”×ª×—×œ ×¢×œ ×™×“×™ ×‘×—×™×¨×ª ×©×™×—×” ××”×¨×©×™××” ×‘×¦×“ ×©×××œ
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel - Segment Editor and Live Preview (Smaller) -->
            <div class="panel" style="flex: 0 0 400px; padding: 0; display: flex; flex-direction: column; min-width: 350px;">
                <div id="no-segment-selected" style="text-align: center; padding: 4rem; color: #999;">
                    <i class="material-icons" style="font-size: 64px; display: block; margin-bottom: 1rem;">edit</i>
                    <p style="font-size: 1.2rem;">×‘×—×¨ ×§×˜×¢ ×œ×¢×¨×™×›×”</p>
                </div>
                
                <div id="segment-editor-panel" style="display: none; height: 100%; display: flex; flex-direction: column;">
                    <!-- Live Preview at Top -->
                    <div style="height: 300px; border-bottom: 2px solid #e0e0e0; position: relative;">
                        <div style="position: absolute; top: 10px; right: 10px; z-index: 100; display: flex; gap: 10px;">
                            <button onclick="toggleSegmentLoop()" class="btn btn-sm" id="main-loop-btn" style="background: #4CAF50; color: white;">
                                <i class="material-icons">loop</i>
                                ×œ×•×œ××” ×¨×¦×™×¤×”
                            </button>
                            <button onclick="playCurrentSegment()" class="btn btn-sm btn-primary">
                                <i class="material-icons">play_arrow</i>
                                × ×’×Ÿ
                            </button>
                        </div>
                        <iframe id="segment-preview-iframe" style="width: 100%; height: 100%; border: none;">
                        </iframe>
                    </div>
                    
                    <!-- Segment Editor Content -->
                    <div style="flex: 1; overflow-y: auto; padding: 1.5rem;">
                        <div id="active-segment-editor">
                            <!-- Active segment editor will be loaded here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tab 2: Upload & Process -->
    <div id="upload-tab" class="tab-content">
        <div style="max-width: 1200px; margin: 0 auto; padding: 2rem;">
            <div class="panel">
                <div class="panel-header">
                    <h2 class="panel-title">ğŸµ ×”×¢×œ××ª ×§×•×‘×¥ ××•×“×™×• ×—×“×©</h2>
                    <p style="color: #666; margin: 0;">×”×¢×œ×” ×§×•×‘×¥ ××•×“×™×• ×•×¢×‘×“ ××•×ª×• ×¢× ×ª××œ×•×œ ×•× ×™×ª×•×— ×¨×’×©×•×ª ××ª×§×“×</p>
                </div>
                
                <!-- File Upload Area -->
                <div class="upload-area" id="upload-area" style="border: 3px dashed #667eea; border-radius: 12px; padding: 3rem; text-align: center; background: #f8f9ff; cursor: pointer; transition: all 0.3s ease;">
                    <i class="material-icons" style="font-size: 64px; color: #667eea; display: block; margin-bottom: 1rem;">cloud_upload</i>
                    <h3 style="margin: 0 0 0.5rem 0; color: #667eea;">×’×¨×•×¨ ×§×•×‘×¥ ××•×“×™×• ×œ×›××Ÿ ××• ×œ×—×¥ ×œ×‘×—×™×¨×”</h3>
                    <p style="color: #666; margin: 0;">×ª×•××š ×‘: MP3, M4A, WAV, FLAC, AAC, OGG â€¢ ××§×¡×™××•× 100MB</p>
                    <input type="file" id="fileInput" accept=".mp3,.m4a,.wav,.flac,.aac,.ogg" style="display: none;">
                </div>
                
                <!-- Upload Status -->
                <div id="upload-status" style="margin-top: 1rem;"></div>

                <!-- Processing Options -->
                <div id="processing-options" style="display: none; margin-top: 2rem;">
                    <div style="background: #f0f8ff; padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem;">
                        <h3 style="margin: 0 0 1rem 0; color: #2196f3;">ğŸµ ×§×•×‘×¥ ×”×•×¢×œ×” ×‘×”×¦×œ×—×”</h3>
                        <div id="file-info" style="margin-bottom: 1rem;">
                            <!-- File information will appear here -->
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                            <div>
                                <label>×©× ×”×©×™×—×” ×”×—×“×©×”:</label>
                                <input type="text" id="new-conversation-name" placeholder="×œ×“×•×’××”: ×©×™×—×” ×¢× ×“× ×™" style="width: 100%;">
                            </div>
                            <div>
                                <label>×¡×•×’ ×”×©×™×—×”:</label>
                                <select id="conversation-type" style="width: 100%;">
                                    <option value="general">×©×™×—×” ×›×œ×œ×™×ª</option>
                                    <option value="therapy">×©×™×—×ª ×˜×™×¤×•×œ</option>
                                    <option value="interview">×¨××™×•×Ÿ</option>
                                    <option value="meeting">×¤×’×™×©×”</option>
                                    <option value="lecture">×”×¨×¦××”</option>
                                    <option value="other">××—×¨</option>
                                </select>
                            </div>
                        </div>

                        <!-- Enhanced Transcription Quality Options -->
                        <div style="background: #e8f5e8; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
                            <h4 style="margin: 0 0 0.5rem 0; color: #2e7d32;">ğŸ¯ ××™×›×•×ª ×ª××œ×•×œ ×•× ×™×ª×•×—</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                                <div class="quality-option" onclick="selectQuality('chatgpt4_best')" style="border: 2px solid #e0e0e0; border-radius: 8px; padding: 1rem; cursor: pointer; transition: all 0.3s ease; background: white;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                        <i class="material-icons" style="color: #4caf50;">star</i>
                                        <strong>×”×›×™ ×˜×•×‘ - ChatGPT-4</strong>
                                    </div>
                                    <p style="margin: 0; font-size: 0.9rem; color: #666;">×ª××œ×•×œ ××ª×§×“× ×¢× GPT-4 ×œ×¢×‘×¨×™×ª ××•×©×œ××ª</p>
                                </div>
                                <div class="quality-option" onclick="selectQuality('whisper_accurate')" style="border: 2px solid #e0e0e0; border-radius: 8px; padding: 1rem; cursor: pointer; transition: all 0.3s ease; background: white;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                        <i class="material-icons" style="color: #2196f3;">auto_awesome</i>
                                        <strong>××“×•×™×§ - Whisper + GPT-4</strong>
                                    </div>
                                    <p style="margin: 0; font-size: 0.9rem; color: #666;">Whisper ×¢× ×©×™×¤×•×¨ GPT-4 ×œ×¢×‘×¨×™×ª</p>
                                </div>
                                <div class="quality-option" onclick="selectQuality('openai_fast')" style="border: 2px solid #e0e0e0; border-radius: 8px; padding: 1rem; cursor: pointer; transition: all 0.3s ease; background: white;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                        <i class="material-icons" style="color: #ff9800;">flash_on</i>
                                        <strong>××”×™×¨ - OpenAI Whisper</strong>
                                    </div>
                                    <p style="margin: 0; font-size: 0.9rem; color: #666;">×ª××œ×•×œ ××”×™×¨ ×¢× ×©×™×¤×•×¨ ×‘×¡×™×¡×™</p>
                                </div>
                            </div>
                            <input type="hidden" id="selected-quality" value="chatgpt4_best">
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                            <div>
                                <label>××•×¨×š ×§×˜×¢ (×©× ×™×•×ª):</label>
                                <select id="segment-length">
                                    <option value="10">10 ×©× ×™×•×ª (××¤×•×¨×˜ ×××•×“)</option>
                                    <option value="15">15 ×©× ×™×•×ª (××¤×•×¨×˜)</option>
                                    <option value="20" selected>20 ×©× ×™×•×ª (×¨×’×™×œ)</option>
                                    <option value="30">30 ×©× ×™×•×ª (×›×œ×œ×™)</option>
                                    <option value="60">60 ×©× ×™×•×ª (×‘×¡×™×¡×™)</option>
                                </select>
                            </div>
                            <div>
                                <label>× ×™×ª×•×— ×¨×’×©×•×ª:</label>
                                <select id="emotion-analysis-level">
                                    <option value="comprehensive" selected>××§×™×£ (×›×œ 92 ×”×¨×’×©×•×ª)</option>
                                    <option value="standard">×¨×’×™×œ (×¨×’×©×•×ª ×‘×¡×™×¡×™×™×)</option>
                                    <option value="minimal">××™× ×™××œ×™ (×¨×’×©×•×ª ×¨××©×™×™×)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Processing Progress -->
                    <div id="processing-progress" style="display: none; background: #fff3cd; padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem;">
                        <h4 style="margin: 0 0 1rem 0; color: #856404;">âš™ï¸ ××¢×‘×“ ×©×™×—×” ×—×“×©×”...</h4>
                        
                        <!-- Enhanced Progress Info -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1rem; font-size: 0.9rem;">
                            <div style="text-align: center; padding: 0.5rem; background: #f8f9fa; border-radius: 4px;">
                                <div style="font-weight: bold; color: #007bff;" id="progress-percentage">0%</div>
                                <div style="color: #666;">×”×ª×§×“××•×ª</div>
                            </div>
                            <div style="text-align: center; padding: 0.5rem; background: #f8f9fa; border-radius: 4px;">
                                <div style="font-weight: bold; color: #28a745;" id="time-elapsed">00:00</div>
                                <div style="color: #666;">×–××Ÿ ×©×¢×‘×¨</div>
                            </div>
                            <div style="text-align: center; padding: 0.5rem; background: #f8f9fa; border-radius: 4px;">
                                <div style="font-weight: bold; color: #ffc107;" id="time-remaining">--:--</div>
                                <div style="color: #666;">×–××Ÿ × ×•×ª×¨</div>
                            </div>
                        </div>

                        <!-- Main Progress Bar -->
                        <div style="margin-bottom: 1rem;">
                            <div style="background: #e0e0e0; height: 12px; border-radius: 6px; overflow: hidden; position: relative;">
                                <div id="progress-bar" style="background: linear-gradient(45deg, #4caf50, #81c784); height: 100%; width: 0%; transition: width 0.3s ease; position: relative;">
                                    <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent); animation: shimmer 2s infinite;"></div>
                                </div>
                            </div>
                            <div id="progress-text" style="text-align: center; margin-top: 0.5rem; font-size: 0.9rem; color: #666; font-weight: 500;">
                                ××›×™×Ÿ ×œ×¢×™×‘×•×“...
                            </div>
                        </div>

                        <!-- Sub-task Progress (for transcription/analysis) -->
                        <div id="sub-progress-container" style="display: none; margin-bottom: 1rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                <span id="sub-progress-title" style="font-size: 0.85rem; color: #555; font-weight: 500;">××ª××œ×œ ×§×˜×¢×™×...</span>
                                <span id="sub-progress-counter" style="font-size: 0.85rem; color: #666;">0/0</span>
                            </div>
                            <div style="background: #e0e0e0; height: 6px; border-radius: 3px; overflow: hidden;">
                                <div id="sub-progress-bar" style="background: #17a2b8; height: 100%; width: 0%; transition: width 0.2s ease;"></div>
                            </div>
                        </div>

                        <!-- Processing Steps Log -->
                        <div id="progress-steps" style="max-height: 150px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 4px; padding: 0.75rem; background: #f8f9fa; font-size: 0.85rem;">
                            <!-- Processing steps will appear here -->
                        </div>
                    </div>

                    <style>
                        @keyframes shimmer {
                            0% { transform: translateX(-100%); }
                            100% { transform: translateX(100%); }
                        }
                        #progress-steps::-webkit-scrollbar {
                            width: 6px;
                        }
                        #progress-steps::-webkit-scrollbar-track {
                            background: #f1f1f1;
                            border-radius: 3px;
                        }
                        #progress-steps::-webkit-scrollbar-thumb {
                            background: #c1c1c1;
                            border-radius: 3px;
                        }
                        #progress-steps::-webkit-scrollbar-thumb:hover {
                            background: #a8a8a8;
                        }
                    </style>

                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 1rem;">
                        <button id="start-processing-btn" class="btn btn-success" style="flex: 1;">
                            <i class="material-icons">auto_awesome</i>
                            ×¦×•×¨ ×©×™×—×” ×—×“×©×” ×•×¢×‘×“
                        </button>
                        <button id="cancel-upload-btn" class="btn btn-secondary">
                            <i class="material-icons">cancel</i>
                            ×‘×˜×œ
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Quick Actions Section -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">âš¡ × ×™×ª×•×— ××”×™×¨ (×œ×œ× ×ª××œ×•×œ)</h3>
                    </div>
                    <p style="color: #666; margin-bottom: 1rem;">× ×™×ª×•×— ×¨×’×©×•×ª ×‘×œ×‘×“ ×¢×œ ×‘×¡×™×¡ ×”×ª××œ×•×œ ×”×§×™×™×</p>
                    <div id="quick-analysis-options" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem;">
                        <!-- Options will be loaded here -->
                    </div>
                </div>
                
                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">ğŸ”„ ×ª××œ×•×œ ×•× ×™×ª×•×— ××œ×</h3>
                    </div>
                    <p style="color: #666; margin-bottom: 1rem;">×ª××œ×•×œ ××—×“×© ×¢× Whisper ×•× ×™×ª×•×— ×¨×’×©×•×ª</p>
                    <div id="full-reprocess-options" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem;">
                        <!-- Options will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tab 3: Experiments -->
    <div id="experiments-tab" class="tab-content">
        <div style="max-width: 1000px; margin: 0 auto; padding: 2rem;">
            <div class="panel">
                <div class="panel-header">
                    <h2 class="panel-title">×¡×‘×™×‘×ª × ×™×¡×•×™×™× ×œ× ×™×ª×•×— ×¨×’×©×•×ª</h2>
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <label>×”×–×Ÿ ×˜×§×¡×˜ ×œ× ×™×ª×•×—:</label>
                    <textarea id="test-text-input" rows="4" placeholder="×”×§×œ×“ ×›××Ÿ ×˜×§×¡×˜ ×œ× ×™×ª×•×— ×‘×–××Ÿ ×××ª...">×—×—×— ××™×–×” ×§×•×¨×¢, ××‘×œ ×œ× ××¡×›×™× ×¢× ×–×” ×‘×›×œ×œ</textarea>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                    <div>
                        <label>×¡×£ ×¨×’×™×©×•×ª:</label>
                        <input type="range" id="sensitivity-slider" min="0" max="1" step="0.1" value="0.5">
                        <span id="sensitivity-value">0.5</span>
                    </div>
                    <div>
                        <label>××¦×‘ × ×™×ª×•×—:</label>
                        <select id="analysis-mode">
                            <option value="standard">×¨×’×™×œ</option>
                            <option value="strict">××—××™×¨</option>
                            <option value="lenient">××§×œ</option>
                        </select>
                    </div>
                </div>
                
                <h3>×ª×•×¦××•×ª ×”× ×™×ª×•×—:</h3>
                <div style="background: #2d3436; color: #dfe6e9; padding: 1.5rem; border-radius: 8px; font-family: 'Courier New', monospace; white-space: pre-wrap; min-height: 300px;" id="analysis-output">
×”×ª×•×¦××•×ª ×™×•×¤×™×¢×• ×›××Ÿ...
                </div>
            </div>
        </div>
    </div>

    <!-- Tab 4: Metadata -->
    <div id="metadata-tab" class="tab-content">
    
    <!-- Tab 5: People Management -->
    <div id="people-tab" class="tab-content">
        <div style="display: flex; height: calc(100vh - 180px); gap: 1rem; padding: 1rem;">
            <!-- Left Panel - People List -->
            <div class="panel" style="flex: 0 0 400px; padding: 0; display: flex; flex-direction: column;">
                <div class="panel-header" style="padding: 1.5rem; margin: 0;">
                    <h2 class="panel-title">× ×™×”×•×œ ×× ×©×™×</h2>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="addNewPerson()" class="btn btn-success btn-sm">
                            <i class="material-icons">person_add</i>
                            ×”×•×¡×£ ××“×
                        </button>
                        <button onclick="refreshPeopleList()" class="btn btn-secondary btn-sm">
                            <i class="material-icons">refresh</i>
                            ×¨×¢× ×Ÿ
                        </button>
                    </div>
                </div>
                <div id="people-list" style="flex: 1; overflow-y: auto; padding: 0 1rem 1rem;">
                    <!-- People items will be loaded here -->
                </div>
            </div>

            <!-- Right Panel - Person Editor -->
            <div class="panel" style="flex: 1; padding: 0; display: flex; flex-direction: column;">
                <div id="no-person-selection" style="text-align: center; padding: 4rem; color: #999;">
                    <i class="material-icons" style="font-size: 64px; display: block; margin-bottom: 1rem;">person</i>
                    <p style="font-size: 1.2rem;">×‘×—×¨ ××“× ×œ×¢×¨×™×›×” ××• ×¦×•×¨ ××“× ×—×“×©</p>
                </div>

                <div id="person-editor-panel" style="display: none; flex: 1; padding: 2rem;">
                    <div class="panel-header" style="margin: 0 0 2rem 0;">
                        <h2 class="panel-title" id="person-editor-title">×¢×¨×™×›×ª ××“×</h2>
                        <div style="display: flex; gap: 1rem;">
                            <button type="button" onclick="savePerson()" class="btn btn-success" id="save-person-btn">
                                <i class="material-icons">save</i>
                                ×©××•×¨ ××“×
                            </button>
                            <button type="button" onclick="deletePerson()" class="btn btn-danger" id="delete-person-btn">
                                <i class="material-icons">delete</i>
                                ××—×§ ××“×
                            </button>
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem;">
                        <!-- Person Info -->
                        <div style="background: #f8f9ff; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin: 0 0 1rem 0; color: #667eea;">××™×“×¢ ×‘×¡×™×¡×™</h3>
                            
                            <label>×©× ×”××“×:</label>
                            <input type="text" id="person-name" placeholder="×”×–×Ÿ ×©× ××œ×" style="margin-bottom: 1rem; width: 100%;">
                            
                            <label>×ª×™××•×¨ ×§×¦×¨:</label>
                            <textarea id="person-description" placeholder="×ª×™××•×¨ ×§×¦×¨ ×©×œ ×”××“× (××•×¤×¦×™×•× ×œ×™)" style="margin-bottom: 1rem; width: 100%; height: 80px; resize: vertical;"></textarea>
                            
                            <label>×¦×‘×¢ ×™×™×—×•×“×™:</label>
                            <input type="color" id="person-color" value="#667eea" style="margin-bottom: 1rem; width: 100%; height: 40px;">
                            
                            <label>×¡×˜×˜×•×¡:</label>
                            <select id="person-status" style="margin-bottom: 1rem; width: 100%;">
                                <option value="active">×¤×¢×™×œ</option>
                                <option value="inactive">×œ× ×¤×¢×™×œ</option>
                                <option value="archived">×‘××¨×›×™×•×Ÿ</option>
                            </select>
                        </div>

                        <!-- Assigned Conversations -->
                        <div style="background: #fff5f5; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin: 0 0 1rem 0; color: #e53e3e;">×©×™×—×•×ª ×•×ª×¤×§×™×“×™ ×“×•×‘×¨</h3>
                            
                            <div style="margin-bottom: 1rem;">
                                <label>×‘×—×¨ ×©×™×—×•×ª ×œ×©×™×•×š:</label>
                                <div id="available-conversations" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem;">
                                    <!-- Available conversations will be loaded here -->
                                </div>
                            </div>
                            
                            <div>
                                <label>×©×™×—×•×ª ××©×•×™×›×•×ª ×¢× ×ª×¤×§×™×“ ×“×•×‘×¨:</label>
                                <div id="assigned-conversations" style="max-height: 250px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem; background: #f8f9fa;">
                                    <!-- Currently assigned conversations will be shown here -->
                                </div>
                            </div>
                            
                            <div style="margin-top: 1rem; padding: 1rem; background: rgba(102, 126, 234, 0.1); border-radius: 6px;">
                                <h4 style="margin: 0 0 0.5rem 0; color: #667eea;">× ×™×”×•×œ ×“×•×‘×¨×™×</h4>
                                <p style="font-size: 0.9rem; color: #666; margin: 0 0 1rem 0;">
                                    ×”×’×“×¨ ××™×–×” ×“×•×‘×¨ (0, 1, 2...) ××™×™×¦×’ ××ª ×”××“× ×”×–×” ×‘×›×œ ×©×™×—×”
                                </p>
                                <div>
                                    <label>×“×•×‘×¨ ×‘×¨×™×¨×ª ××—×“×œ:</label>
                                    <select id="person-default-speaker" style="width: 100%; margin-top: 0.25rem;">
                                        <option value="0">×“×•×‘×¨ 0 (×‘×“×¨×š ×›×œ×œ ×¨××©×™)</option>
                                        <option value="1">×“×•×‘×¨ 1 (×‘×“×¨×š ×›×œ×œ ×©× ×™)</option>
                                        <option value="2">×“×•×‘×¨ 2</option>
                                        <option value="3">×“×•×‘×¨ 3</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Statistics -->
                    <div style="background: #f0f8ff; padding: 1.5rem; border-radius: 8px;">
                        <h3 style="margin: 0 0 1rem 0; color: #2196f3;">×¡×˜×˜×™×¡×˜×™×§×•×ª</h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem;">
                            <div>
                                <label>××¡×¤×¨ ×©×™×—×•×ª:</label>
                                <div id="person-conversations-count" style="font-size: 1.2rem; font-weight: bold; color: #2196f3;">
                                    0
                                </div>
                            </div>
                            <div>
                                <label>×¡×”"×› ×§×˜×¢×™×:</label>
                                <div id="person-segments-count" style="font-size: 1.2rem; font-weight: bold; color: #2196f3;">
                                    0
                                </div>
                            </div>
                            <div>
                                <label>××©×š ×›×•×œ×œ:</label>
                                <div id="person-total-duration" style="font-size: 1.2rem; font-weight: bold; color: #2196f3;">
                                    0:00
                                </div>
                            </div>
                            <div>
                                <label>×¡×˜×˜×•×¡:</label>
                                <div id="person-status-display" style="font-size: 1.2rem; font-weight: bold; color: #2196f3;">
                                    ×¤×¢×™×œ
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
        <div style="display: flex; height: calc(100vh - 180px); gap: 1rem; padding: 1rem;">
            <!-- Left Panel - Conversations List for Metadata -->
            <div class="panel" style="flex: 0 0 350px; padding: 0; display: flex; flex-direction: column;">
                <div class="panel-header" style="padding: 1.5rem; margin: 0;">
                    <h2 class="panel-title">×‘×—×¨ ×©×™×—×” ×œ×¢×¨×™×›×”</h2>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="refreshMetadataList()" class="btn btn-secondary">
                            <i class="material-icons">refresh</i>
                            ×¨×¢× ×Ÿ
                        </button>
                        <button onclick="calculateAllDurations()" class="btn btn-primary btn-sm">
                            <i class="material-icons">timer</i>
                            ×—×©×‘ ××©×›×™×
                        </button>
                        <button onclick="showDeleteAllConfirm()" class="btn btn-danger btn-sm" title="××—×§ ×©×™×—×•×ª ××¨×•×‘×•×ª">
                            <i class="material-icons">delete_sweep</i>
                            ××—×™×§×” ××¨×•×‘×”
                        </button>
                    </div>
                </div>
                <div id="metadata-conversations-list" style="flex: 1; overflow-y: auto; padding: 0 1rem 1rem;">
                    <!-- Conversation items with metadata preview will be loaded here -->
                </div>
            </div>

            <!-- Right Panel - Metadata Editor -->
            <div class="panel" style="flex: 1; padding: 0; display: flex; flex-direction: column;">
                <div id="no-metadata-selection" style="text-align: center; padding: 4rem; color: #999;">
                    <i class="material-icons" style="font-size: 64px; display: block; margin-bottom: 1rem;">info</i>
                    <p style="font-size: 1.2rem;">×‘×—×¨ ×©×™×—×” ×œ×¢×¨×™×›×ª ×”× ×ª×•× ×™×</p>
                </div>

                <div id="metadata-editor-panel" style="display: none; flex: 1; padding: 2rem;">
                    <div class="panel-header" style="margin: 0 0 2rem 0;">
                        <h2 class="panel-title" id="metadata-conversation-title">× ×ª×•× ×™ ×©×™×—×”</h2>
                        <div style="display: flex; gap: 1rem;">
                            <button type="button" onclick="saveMetadata()" class="btn btn-success" id="save-metadata-btn">
                                <i class="material-icons">save</i>
                                ×©××•×¨ × ×ª×•× ×™×
                            </button>
                            <button type="button" onclick="previewMetadata()" class="btn btn-primary">
                                <i class="material-icons">preview</i>
                                ×ª×¦×•×’×” ××§×“×™××”
                            </button>
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem;">
                        <!-- Basic Info -->
                        <div style="background: #f8f9ff; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin: 0 0 1rem 0; color: #667eea;">××™×“×¢ ×‘×¡×™×¡×™</h3>
                            
                            <label>×ª××¨×™×š ×”×©×™×—×”:</label>
                            <input type="date" id="conversation-date" style="margin-bottom: 1rem;">
                            
                            <label>×©× ×”×©×™×—×”:</label>
                            <input type="text" id="conversation-name" placeholder="×©× ××•×ª×× ×œ×©×™×—×”" style="margin-bottom: 1rem;">
                            
                            <!-- Speaker Names Section -->
                            <div style="background: #f0f8ff; padding: 1rem; border-radius: 6px; margin-bottom: 1rem;">
                                <h4 style="margin: 0 0 0.5rem 0; color: #1976d2; font-size: 14px;">×©××•×ª ×”×“×•×‘×¨×™×</h4>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                    <div>
                                        <label style="font-size: 13px; color: #d32f2f;">×“×•×‘×¨ 1 (××“×•×):</label>
                                        <input type="text" id="speaker-1-name" placeholder="×©× ×“×•×‘×¨ 1" style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                    </div>
                                    <div>
                                        <label style="font-size: 13px; color: #00796b;">×“×•×‘×¨ 2 (×˜×•×¨×§×™×–):</label>
                                        <input type="text" id="speaker-2-name" placeholder="×©× ×“×•×‘×¨ 2" style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                    </div>
                                </div>
                                <small style="color: #666; font-size: 12px; margin-top: 0.5rem; display: block;">×”×©××•×ª ×™×•×¦×’×• ×‘××§×•× "×“×•×‘×¨ 1" ×•"×“×•×‘×¨ 2" ×‘×›×œ ×”×©×™×—×”</small>
                            </div>
                            
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">
                                <div style="flex: 1;">
                                    <label>××©×ª×ª×£ ×¢×™×§×¨×™ ×‘×©×™×—×”:</label>
                                    <select id="main-participant" style="width: 100%;">
                                        <option value="">×‘×—×¨ ××©×ª×ª×£...</option>
                                        <!-- Dynamic options will be loaded here -->
                                    </select>
                                </div>
                                <button type="button" onclick="openPeopleManager()" class="btn btn-secondary btn-sm" title="× ×”×œ ×¨×©×™××ª ×× ×©×™×" style="margin-top: 20px;">
                                    <i class="material-icons">people</i>
                                </button>
                            </div>
                            
                            <div id="custom-participant-input" style="display: none; margin-bottom: 1rem;">
                                <label>×©× ××•×ª××:</label>
                                <input type="text" id="custom-participant-name" placeholder="×”×–×Ÿ ×©× ××•×ª××">
                            </div>

                            <label>× ×•×©××™ ×”×©×™×—×” ×”×¢×™×§×¨×™×™×:</label>
                            <div id="conversation-topics" style="margin-bottom: 1rem;">
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; margin-bottom: 0.5rem;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="family">ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ ××©×¤×—×”
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="work">ğŸ’¼ ×¢×‘×•×“×”
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="relationships">â¤ï¸ ×™×—×¡×™×
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="health">ğŸ¥ ×‘×¨×™××•×ª
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="personal">ğŸŒ± ××™×©×™
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="therapy">ğŸ›‹ï¸ ×˜×™×¤×•×œ
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="memories">ğŸ’­ ×–×™×›×¨×•× ×•×ª
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="future">ğŸ”® ×¢×ª×™×“
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="emotions">ğŸ’« ×¨×’×©×•×ª
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="decisions">âš–ï¸ ×”×—×œ×˜×•×ª
                                    </label>
                                </div>
                                <input type="text" id="custom-topics" placeholder="× ×•×©××™× × ×•×¡×¤×™× (××•×¤×¨×“×™× ×‘×¤×¡×™×§×™×)" style="width: 100%; font-size: 0.9rem;">
                            </div>
                        </div>

                        <!-- Emotional Profile -->
                        <div style="background: #fff5f5; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin: 0 0 1rem 0; color: #e53e3e;">×¤×¨×•×¤×™×œ ×¨×’×©×™</h3>
                            
                            <label>×¨×’×©×•×ª ×¢×™×§×¨×™×™× ×‘×©×™×—×” (×›×œ 92 ×”×¨×’×©×•×ª):</label>
                            
                            <!-- Search and filter controls -->
                            <div style="margin-bottom: 0.5rem; display: flex; gap: 0.5rem; align-items: center;">
                                <input type="text" id="emotions-search" placeholder="×—×¤×© ×¨×’×©..." style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9rem;">
                                <button type="button" onclick="selectAllEmotions()" class="btn btn-secondary btn-sm" style="padding: 0.5rem 0.75rem; font-size: 0.8rem;">
                                    ×‘×—×¨ ×”×›×œ
                                </button>
                                <button type="button" onclick="clearAllEmotions()" class="btn btn-secondary btn-sm" style="padding: 0.5rem 0.75rem; font-size: 0.8rem;">
                                    × ×§×” ×”×›×œ
                                </button>
                                                <button type="button" onclick="forceLoadEmotions()" class="btn btn-info btn-sm" style="padding: 0.5rem 0.75rem; font-size: 0.8rem;" title="×˜×¢×Ÿ ×¨×’×©×•×ª ××—×“×© ×× ×œ× × ×˜×¢× ×•">
                    ğŸ”„ ×˜×¢×Ÿ ×¨×’×©×•×ª
                </button>
                            </div>
                            
                            <!-- ChatGPT Main Emotion Analysis Button -->
                            <div style="margin-bottom: 1rem; padding: 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px;">
                                <button type="button" onclick="analyzeMainEmotionWithChatGPT()" class="btn" style="width: 100%; background: white; color: #667eea; border: none; padding: 0.75rem; border-radius: 6px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                                    <i class="material-icons">psychology</i>
                                    × ×™×ª×•×— ×”×¨×’×© ×”×¢×™×§×¨×™ ×¢× ChatGPT
                                </button>
                                <div id="main-emotion-analysis-result" style="margin-top: 0.75rem; padding: 0.75rem; background: rgba(255,255,255,0.1); border-radius: 6px; color: white; font-size: 0.9rem; display: none;">
                                    <div style="font-weight: 600; margin-bottom: 0.25rem;">×”×¨×’×© ×”×¢×™×§×¨×™ ×©×–×•×”×”:</div>
                                    <div id="detected-main-emotion" style="font-size: 1.1rem; font-weight: bold; margin-bottom: 0.5rem;"></div>
                                    <div id="emotion-explanation" style="font-size: 0.85rem; opacity: 0.9; line-height: 1.4; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.2);"></div>
                                    <div id="analysis-stats" style="font-size: 0.75rem; opacity: 0.7; margin-top: 0.5rem; display: flex; gap: 1rem;">
                                        <span id="segments-count"></span>
                                        <span id="confidence-score"></span>
                                    </div>
                                </div>
                            </div>
                            
                            <div id="main-emotions-selector" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 0.4rem; margin-bottom: 1rem; border: 1px solid #f0f0f0; padding: 1rem; border-radius: 8px;">
                                <!-- Emotions will be loaded dynamically from config/emotions_config.json -->
                                <div style="grid-column: 1/-1; text-align: center; color: #999; font-style: italic; padding: 2rem;">
                                    ×˜×•×¢×Ÿ ×¨×’×©×•×ª...
                                </div>
                            </div>
                            
                            <label>××™× ×˜× ×¡×™×‘×™×•×ª ×¨×’×©×™×ª (1-10):</label>
                            <input type="range" id="emotional-intensity" min="1" max="10" value="5" style="width: 100%; margin-bottom: 0.5rem;">
                            <div style="text-align: center; font-size: 0.9rem; color: #666;">
                                <span id="intensity-display">5</span> / 10
                            </div>
                        </div>
                    </div>




                </div>
            </div>
        </div>
    </div>

    <!-- Tab 5: Enhanced Video Management -->
    <div id="videos-tab" class="tab-content">
        <div style="max-width: 1200px; margin: 0 auto; padding: 2rem;">
            <!-- Video Generation Panel -->
            <div class="panel">
                <div class="panel-header">
                    <h2 class="panel-title">ğŸ¬ × ×™×”×•×œ ×•×™×“××• ××ª×§×“×</h2>
                    <div style="display: flex; gap: 1rem;">
                        <button onclick="generateAllVideos()" class="btn btn-primary">
                            <i class="material-icons">video_library</i>
                            ×¦×•×¨ ××”××¢×¨×›×ª
                        </button>
                        <button onclick="refreshVideoList()" class="btn btn-secondary">
                            <i class="material-icons">refresh</i>
                            ×¨×¢× ×Ÿ ×¨×©×™××”
                        </button>
                        <button onclick="deleteAllVideos()" class="btn btn-danger">
                            <i class="material-icons">delete</i>
                            ××—×§ ×”×›×œ
                        </button>
                    </div>
                </div>
                
                <!-- Video Mode Selection -->
                <div style="margin-bottom: 2rem;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <!-- Enhanced System Generation Panel -->
                        <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 12px; border: 2px solid #e9ecef;">
                            <h3 style="color: #495057; margin: 0 0 1rem 0; display: flex; align-items: center; gap: 0.5rem;">
                                <i class="material-icons" style="color: #007bff;">smart_display</i>
                                ×™×™×¦×•×¨ ××•×˜×•××˜×™ ××ª×§×“× ××”××¢×¨×›×ª
                            </h3>
                            <p style="color: #6c757d; margin-bottom: 1rem; font-size: 0.9rem;">
                                ×¦×•×¨ ×§×‘×¦×™ MP4 ××”×•×•×™×–×•××œ×™×–×¦×™×•×ª ×¢× ×‘×§×¨×” ××œ××” ×¢×œ ××™×›×•×ª, ×’×•×“×œ ×•××–×•×¨ ×”×§×œ×˜×”
                            </p>
                            
                            <!-- Conversation Selection for System Generation -->
                            <div style="background: #e3f2fd; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                                <label style="display: block; margin-bottom: 0.5rem; color: #1976d2; font-weight: 500;">
                                    <i class="material-icons" style="font-size: 1.2rem; vertical-align: middle;">chat</i>
                                    ×‘×—×¨ ×©×™×—×” ×œ×™×™×¦×•×¨ ×•×™×“××•:
                                </label>
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <select id="generation-conversation-select" style="flex: 1; padding: 0.75rem; border: 1px solid #90caf9; border-radius: 6px; background: white;">
                                        <option value="all">×›×œ ×”×©×™×—×•×ª</option>
                                        <option value="">-- ×‘×—×¨ ×©×™×—×” ×¡×¤×¦×™×¤×™×ª --</option>
                                    </select>
                                    <button onclick="openConversationVisualSelector('generation')" style="padding: 0.75rem 1rem; background: #2196f3; color: white; border: none; border-radius: 6px; cursor: pointer; white-space: nowrap;">
                                        <i class="material-icons" style="font-size: 1rem; vertical-align: middle;">visibility</i>
                                        ×‘×—×™×¨×” ×•×™×–×•××œ×™×ª
                                    </button>
                                    <button onclick="openVisualCropSelector()" style="padding: 0.75rem 1rem; background: #ff9800; color: white; border: none; border-radius: 6px; cursor: pointer; white-space: nowrap;">
                                        <i class="material-icons" style="font-size: 1rem; vertical-align: middle;">crop</i>
                                        ×—×™×ª×•×š ×•×™×–×•××œ×™
                                    </button>
                                </div>
                                <div id="generation-conversation-info" style="margin-top: 0.5rem; padding: 0.5rem; background: rgba(33, 150, 243, 0.1); border-radius: 4px; display: none;">
                                    <small style="color: #1976d2; font-weight: 500;">× ×‘×—×¨: <span id="generation-conversation-name"></span></small>
                                </div>
                            </div>
                            
                            <!-- Basic Settings Row -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 1rem;">
                                <label style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="font-size: 0.9rem; color: #495057; min-width: 60px;">××™×›×•×ª:</span>
                                    <select id="video-quality" style="flex: 1; padding: 0.5rem; border: 1px solid #ced4da; border-radius: 4px;">
                                        <option value="720">720p (××”×™×¨)</option>
                                        <option value="1080" selected>1080p (××™×›×•×ª ×’×‘×•×”×”)</option>
                                        <option value="1440">1440p (××™×›×•×ª ××™×¨×‘×™×ª)</option>
                                        <option value="2160">4K (××™×›×•×ª ××§×¡×™××œ×™×ª)</option>
                                    </select>
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="font-size: 0.9rem; color: #495057; min-width: 60px;">FPS:</span>
                                    <select id="video-fps" style="flex: 1; padding: 0.5rem; border: 1px solid #ced4da; border-radius: 4px;">
                                        <option value="15">15 FPS (×—×¡×›×•× ×™)</option>
                                        <option value="24">24 FPS (×¡×˜× ×“×¨×˜×™)</option>
                                        <option value="30" selected>30 FPS (×—×œ×§)</option>
                                        <option value="60">60 FPS (××©×•×‘×—)</option>
                                        <option value="120">120 FPS (×¤×¨×™××™×•×)</option>
                                    </select>
                                </label>
                            </div>
                            
                            <!-- Duration Control -->
                            <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">
                                <span style="font-size: 0.9rem; color: #495057; min-width: 60px;">××©×š:</span>
                                <input type="range" id="video-duration" min="5" max="60" value="12" style="flex: 1;" oninput="updateDurationDisplay(this.value)">
                                <span id="duration-display" style="font-size: 0.9rem; color: #495057; min-width: 70px;">12 ×©× ×™×•×ª</span>
                            </label>
                            
                            <!-- Frame Size & Crop Area Settings -->
                            <div style="background: #e3f2fd; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                                <h4 style="margin: 0 0 0.75rem 0; color: #1976d2; font-size: 0.95rem; display: flex; align-items: center; gap: 0.5rem;">
                                    <i class="material-icons" style="font-size: 1.1rem;">crop</i>
                                    ×’×•×“×œ ××¡×’×¨×ª ×•××–×•×¨ ×”×§×œ×˜×”
                                </h4>
                                
                                <!-- Frame Size Presets -->
                                <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                                    <span style="font-size: 0.9rem; color: #1976d2; min-width: 80px;">×’×•×“×œ ××¡×’×¨×ª:</span>
                                    <select id="frame-size-preset" onchange="updateFrameSizeFields()" style="flex: 1; padding: 0.5rem; border: 1px solid #90caf9; border-radius: 4px;">
                                        <option value="full">××¡×š ××œ× (×‘×¨×™×¨×ª ××—×“×œ)</option>
                                        <option value="16:9">16:9 (×¨×—×‘ ×¡×˜× ×“×¨×˜×™)</option>
                                        <option value="4:3">4:3 (×§×œ××¡×™)</option>
                                        <option value="1:1">1:1 (×¨×™×‘×•×¢)</option>
                                        <option value="9:16">9:16 (×× ×›×™)</option>
                                        <option value="21:9">21:9 (×§×•×œ× ×•×¢ ×¨×—×‘)</option>
                                        <option value="custom">××•×ª×× ××™×©×™×ª</option>
                                    </select>
                                </label>
                                
                                <!-- Custom Dimensions -->
                                <div id="custom-dimensions" style="display: none;">
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.75rem;">
                                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                                            <span style="font-size: 0.9rem; color: #1976d2;">×¨×•×—×‘:</span>
                                            <input type="number" id="custom-width" value="1920" min="480" max="3840" step="16" style="flex: 1; padding: 0.4rem; border: 1px solid #90caf9; border-radius: 4px;">
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                                            <span style="font-size: 0.9rem; color: #1976d2;">×’×•×‘×”:</span>
                                            <input type="number" id="custom-height" value="1080" min="270" max="2160" step="16" style="flex: 1; padding: 0.4rem; border: 1px solid #90caf9; border-radius: 4px;">
                                        </label>
                                    </div>
                                </div>
                                
                                <!-- Crop Area Controls -->
                                <div style="background: rgba(25, 118, 210, 0.1); padding: 0.75rem; border-radius: 6px;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                        <input type="checkbox" id="enable-crop" onchange="toggleCropControls()">
                                        <span style="font-size: 0.9rem; color: #1976d2; font-weight: 500;">××–×•×¨ ×”×§×œ×˜×” ××•×ª×× ××™×©×™×ª</span>
                                    </label>
                                    <div id="crop-controls" style="display: none;">
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.5rem;">
                                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                                <span style="font-size: 0.85rem; color: #1976d2;">X (××©×××œ):</span>
                                                <input type="number" id="crop-x" value="0" min="0" max="1920" style="flex: 1; padding: 0.3rem; border: 1px solid #90caf9; border-radius: 3px; font-size: 0.85rem;">
                                            </label>
                                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                                <span style="font-size: 0.85rem; color: #1976d2;">Y (××œ××¢×œ×”):</span>
                                                <input type="number" id="crop-y" value="0" min="0" max="1080" style="flex: 1; padding: 0.3rem; border: 1px solid #90caf9; border-radius: 3px; font-size: 0.85rem;">
                                            </label>
                                        </div>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                                <span style="font-size: 0.85rem; color: #1976d2;">×¨×•×—×‘:</span>
                                                <input type="number" id="crop-width" value="1920" min="100" max="1920" style="flex: 1; padding: 0.3rem; border: 1px solid #90caf9; border-radius: 3px; font-size: 0.85rem;">
                                            </label>
                                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                                <span style="font-size: 0.85rem; color: #1976d2;">×’×•×‘×”:</span>
                                                <input type="number" id="crop-height" value="1080" min="100" max="1080" style="flex: 1; padding: 0.3rem; border: 1px solid #90caf9; border-radius: 3px; font-size: 0.85rem;">
                                            </label>
                                        </div>
                                        <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem;">
                                            <button onclick="previewCropArea()" class="btn btn-sm btn-secondary" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                                                <i class="material-icons" style="font-size: 1rem;">visibility</i>
                                                ×ª×¦×•×’×” ××§×“×™××”
                                            </button>
                                            <button onclick="centerCropArea()" class="btn btn-sm btn-secondary" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                                                <i class="material-icons" style="font-size: 1rem;">center_focus_strong</i>
                                                ××¨×›×–
                                            </button>
                                            <button onclick="resetCropArea()" class="btn btn-sm btn-secondary" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                                                <i class="material-icons" style="font-size: 1rem;">refresh</i>
                                                ××™×¤×•×¡
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Advanced Options -->
                            <div style="background: #fff3e0; padding: 1rem; border-radius: 8px;">
                                <h4 style="margin: 0 0 0.75rem 0; color: #f57c00; font-size: 0.95rem; display: flex; align-items: center; gap: 0.5rem;">
                                    <i class="material-icons" style="font-size: 1.1rem;">tune</i>
                                    ××¤×©×¨×•×™×•×ª ××ª×§×“××•×ª
                                </h4>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="checkbox" id="enable-smooth-motion" checked>
                                        <span style="font-size: 0.9rem; color: #f57c00;">×ª× ×•×¢×” ×—×œ×§×”</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="checkbox" id="enable-background-blur">
                                        <span style="font-size: 0.9rem; color: #f57c00;">×˜×©×˜×•×© ×¨×§×¢</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="checkbox" id="enable-fade-effects" checked>
                                        <span style="font-size: 0.9rem; color: #f57c00;">××¤×§×˜×™ ×“×”×™×™×”</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="checkbox" id="enable-audio-sync">
                                        <span style="font-size: 0.9rem; color: #f57c00;">×¡× ×›×¨×•×Ÿ ××•×“×™×•</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Enhanced Custom Upload Panel with Conversation Selection -->
                        <div style="background: #fff3cd; padding: 1.5rem; border-radius: 12px; border: 2px solid #ffeaa7;">
                            <h3 style="color: #856404; margin: 0 0 1rem 0; display: flex; align-items: center; gap: 0.5rem;">
                                <i class="material-icons" style="color: #f39c12;">cloud_upload</i>
                                ×”×¢×œ××” ××•×ª×××ª ××™×©×™×ª ×¢× ×‘×—×™×¨×ª ×©×™×—×”
                            </h3>
                            <p style="color: #856404; margin-bottom: 1rem; font-size: 0.9rem;">
                                ×”×¢×œ×” ×§×‘×¦×™ ×•×™×“××• ××©×œ×š ×•×‘×—×¨ ×œ××™×–×• ×©×™×—×” ×œ×”×§×¦×•×ª ××•×ª×
                            </p>
                            
                            <!-- Conversation Selection for Upload -->
                            <div style="background: rgba(243, 156, 18, 0.1); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                                <label style="display: block; margin-bottom: 0.5rem; color: #f39c12; font-weight: 500;">
                                    <i class="material-icons" style="font-size: 1.2rem; vertical-align: middle;">chat</i>
                                    ×‘×—×¨ ×©×™×—×” ×œ×¦×™×¨×•×£ ×”×•×™×“××•:
                                </label>
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <select id="upload-conversation-select" style="flex: 1; padding: 0.75rem; border: 1px solid #f39c12; border-radius: 6px; background: white;">
                                        <option value="">-- ×‘×—×¨ ×©×™×—×” --</option>
                                    </select>
                                    <button onclick="openConversationVisualSelector('upload')" style="padding: 0.75rem 1rem; background: #f39c12; color: white; border: none; border-radius: 6px; cursor: pointer; white-space: nowrap;">
                                        <i class="material-icons" style="font-size: 1rem; vertical-align: middle;">visibility</i>
                                        ×‘×—×™×¨×” ×•×™×–×•××œ×™×ª
                                    </button>
                                </div>
                                <div id="selected-conversation-info" style="margin-top: 0.5rem; padding: 0.5rem; background: rgba(243, 156, 18, 0.2); border-radius: 4px; display: none;">
                                    <small style="color: #e67e22; font-weight: 500;">×©×™×—×” × ×‘×—×¨×”: <span id="selected-conversation-name"></span></small>
                                </div>
                            </div>
                            
                            <div id="custom-upload-area" style="
                                border: 2px dashed #f39c12; 
                                border-radius: 8px; 
                                padding: 2rem; 
                                text-align: center; 
                                background: rgba(255, 193, 7, 0.1);
                                cursor: pointer;
                                transition: all 0.3s ease;
                            " onclick="handleUploadAreaClick()">
                                <i class="material-icons" style="font-size: 3rem; color: #f39c12; margin-bottom: 1rem;">video_file</i>
                                <p style="margin: 0; color: #856404; font-weight: 500;">×œ×—×¥ ××• ×’×¨×•×¨ ×§×‘×¦×™ ×•×™×“××• ×œ×›××Ÿ</p>
                                <p style="margin: 0.5rem 0 0 0; color: #856404; font-size: 0.8rem;">× ×ª××š: MP4, MOV, AVI, WebM (×¢×“ 100MB)</p>
                            </div>
                            <input type="file" id="custom-video-input" accept="video/*" multiple style="display: none;" onchange="handleCustomVideoUpload(this.files)">
                        </div>
                    </div>
                </div>
                
                <div style="background: #f0f8ff; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;">
                    <h3 style="margin: 0 0 1rem 0; color: #2196f3;">ğŸ“¹ ×œ××” ×•×™×“××•?</h3>
                    <p style="margin: 0 0 1rem 0; color: #666; line-height: 1.6;">
                        ×”××¨×ª ×”×•×•×™×–×•××œ×™×–×¦×™×•×ª ×œ×§×‘×¦×™ ×•×™×“××• ×ª×©×¤×¨ ××©××¢×•×ª×™×ª ××ª ×”×‘×™×¦×•×¢×™×:
                        <strong>95% ×—×™×¡×›×•×Ÿ ×‘×¢×•××¡</strong> ×¢×œ ×”×“×¤×“×¤×Ÿ, ×˜×¢×™× ×” ××™×™×“×™×ª ×©×œ ×”×ª×¦×•×’×•×ª ×”××§×“×™××•×ª,
                        ×ª××™×›×” ×˜×•×‘×” ×™×•×ª×¨ ×‘××•×‘×™×™×œ, ×•×©××™×¨×ª ×”×’×¨×¤×™×§×” ×‘×–×™×›×¨×•×Ÿ ×”××˜××•×Ÿ.
                    </p>
                    <p style="margin: 1rem 0 0 0; color: #4a5568; font-weight: bold;">
                        âœ¨ ×”×•×™×“××• ×™×›×œ×•×œ ×¨×§ ××ª ×”×•×•×™×–×•××œ×™×–×¦×™×” ×¢×¦××” - ×œ×œ× ×¤×× ×œ ×¦×“ ×œ×ª×•×¦××” × ×§×™×™×” ×•×××•×§×“×ª
                    </p>
                    <div id="video-status-info" style="margin-top: 1rem; padding: 1rem; background: #fff; border-radius: 6px; border: 1px solid #ddd;">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <span style="font-weight: bold;">×¡×˜×˜×•×¡ ×™×›×•×œ×•×ª ×™×™×¦×•×¨ ×•×™×“××•:</span>
                            <button onclick="checkVideoStatus()" class="btn btn-sm btn-secondary" style="padding: 0.25rem 0.5rem;">
                                <i class="material-icons" style="font-size: 16px;">refresh</i>
                                ×‘×“×•×§
                            </button>
                        </div>
                        <div id="video-status-details">×˜×•×¢×Ÿ...</div>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem;">
                    <div>
                        <h3>×”×’×“×¨×•×ª ×•×™×“××•</h3>
                        <div style="margin-bottom: 1rem;">
                            <label>××™×›×•×ª ×•×™×“××•:</label>
                            <select id="video-quality" style="width: 100%;">
                                <option value="480">480p (×§×˜×Ÿ, ××”×™×¨)</option>
                                <option value="720" selected>720p (××™×›×•×ª ×˜×•×‘×”)</option>
                                <option value="1080">1080p (××™×›×•×ª ×’×‘×•×”×”)</option>
                            </select>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label>××©×š ×•×™×“××• (×©× ×™×•×ª):</label>
                            <input type="range" id="video-duration" min="5" max="60" value="15" style="width: 100%;">
                            <span id="duration-value">15</span> ×©× ×™×•×ª
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label>FPS:</label>
                            <select id="video-fps" style="width: 100%;">
                                <option value="10">10 FPS (×§×˜×Ÿ)</option>
                                <option value="15" selected>15 FPS (××•×ª××)</option>
                                <option value="24">24 FPS (×¡×™× ×™×™)</option>
                                <option value="30">30 FPS (×—×œ×§)</option>
                            </select>
                        </div>
                    </div>
                    
                    <div>
                        <h3>×”×’×“×¨×•×ª ×”×ª× ×”×’×•×ª</h3>
                        <div style="margin-bottom: 1rem;">
                            <label>
                                <input type="checkbox" id="auto-start" checked>
                                ×”×¤×¢×œ ××•×˜×•××˜×™×ª ×‘××—×•×•×ª
                            </label>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label>
                                <input type="checkbox" id="loop-video" checked>
                                ×œ×•×œ××” ×¨×¦×™×¤×”
                            </label>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label>
                                <input type="checkbox" id="mute-video" checked>
                                ×”×©×ª×§ ×•×™×“××• (×¨×§ ×’×¨×¤×™×§×”)
                            </label>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label>
                                <input type="checkbox" id="hover-only">
                                ×”×¤×¢×œ ×¨×§ ×‘××¢×‘×¨ ×¢×›×‘×¨
                            </label>
                        </div>
                    </div>
                </div>
                
                <div id="video-generation-progress" style="display: none; background: #fff3cd; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;">
                    <h4 style="margin: 0 0 1rem 0; color: #856404;">ğŸ¬ ×™×•×¦×¨ ×§×‘×¦×™ ×•×™×“××•...</h4>
                    <div id="video-progress-steps">
                        <!-- Progress steps will appear here -->
                    </div>
                    <div style="margin-top: 1rem;">
                        <div style="background: #e0e0e0; height: 8px; border-radius: 4px; overflow: hidden;">
                            <div id="video-progress-bar" style="background: #4caf50; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                        </div>
                        <div id="video-progress-text" style="text-align: center; margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
                            ××›×™×Ÿ...
                        </div>
                    </div>
                </div>
                
                <!-- Enhanced Video Management Grid -->
                <div style="margin-top: 2rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <h3 style="margin: 0; color: #333;">ğŸ“‹ ×¨×©×™××ª ×•×™×“××• ×¢× × ×™×”×•×œ ××ª×§×“×</h3>
                        <div style="display: flex; gap: 0.5rem;">
                            <select id="video-filter" onchange="filterVideoList()" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="all">×”×›×œ</option>
                                <option value="system">××¢×¨×›×ª</option>
                                <option value="custom">××•×ª×× ××™×©×™×ª</option>
                                <option value="missing">×—×¡×¨×™×</option>
                            </select>
                            <button onclick="exportVideoList()" class="btn btn-secondary btn-sm">
                                <i class="material-icons">download</i>
                                ×™×¦× ×¨×©×™××”
                            </button>
                        </div>
                    </div>
                    
                    <div id="video-management-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem;">
                        <!-- Video management cards will be generated here -->
                    </div>
                    
                    <!-- Bulk Operations Panel -->
                    <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-top: 2rem;">
                        <h4 style="margin: 0 0 1rem 0; color: #495057;">×¤×¢×•×œ×•×ª ××¨×•×‘×•×ª</h4>
                        <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                            <button onclick="selectAllVideos()" class="btn btn-secondary btn-sm">
                                <i class="material-icons">select_all</i>
                                ×‘×—×¨ ×”×›×œ
                            </button>
                            <button onclick="deselectAllVideos()" class="btn btn-secondary btn-sm">
                                <i class="material-icons">deselect</i>
                                ×‘×˜×œ ×‘×—×™×¨×”
                            </button>
                            <button onclick="regenerateSelectedVideos()" class="btn btn-primary btn-sm">
                                <i class="material-icons">refresh</i>
                                ×¦×•×¨ ××—×“×© × ×‘×—×¨×™×
                            </button>
                            <button onclick="downloadSelectedVideos()" class="btn btn-success btn-sm">
                                <i class="material-icons">download</i>
                                ×”×•×¨×“ × ×‘×—×¨×™×
                            </button>
                            <button onclick="deleteSelectedVideos()" class="btn btn-danger btn-sm">
                                <i class="material-icons">delete</i>
                                ××—×§ × ×‘×—×¨×™×
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tab 6: Settings -->
    <div id="settings-tab" class="tab-content">
        <div style="max-width: 800px; margin: 0 auto; padding: 2rem;">
            <div class="panel">
                <div class="panel-header">
                    <h2 class="panel-title">×”×’×“×¨×•×ª ××¢×¨×›×ª</h2>
                </div>
                
                <div style="margin-bottom: 2rem;">
                    <h3>×”×’×“×¨×•×ª API</h3>
                    <label>×›×ª×•×‘×ª ×©×¨×ª:</label>
                    <input type="text" id="api-server" value="http://localhost:8000" style="margin-bottom: 1rem;">
                    
                    <label>API Key (××•×¤×¦×™×•× ×œ×™):</label>
                    <input type="password" id="api-key" placeholder="×”×–×Ÿ API key ×× × ×“×¨×©">
                </div>
                
                <div style="margin-bottom: 2rem;">
                    <h3>×”×’×“×¨×•×ª ×ª×¦×•×’×”</h3>
                    <label>
                        <input type="checkbox" id="auto-refresh" checked>
                        ×¨×¢× ×•×Ÿ ××•×˜×•××˜×™ ×©×œ ×”×ª×¦×•×’×” ×”××§×“×™××”
                    </label>
                    <br><br>
                    <label>
                        <input type="checkbox" id="show-debug" checked>
                        ×”×¦×’ ××™×“×¢ ×“×™×‘××’
                    </label>
                </div>
                
                <button type="button" onclick="saveSettings()" class="btn btn-primary">
                    <i class="material-icons">save</i>
                    ×©××•×¨ ×”×’×“×¨×•×ª
                </button>
            </div>
        </div>
    </div>

    <!-- Tab 7: Emotions Management -->
    <div id="emotions-tab" class="tab-content">
        <div style="max-width: 1200px; margin: 0 auto; padding: 2rem;">
            <div class="panel">
                <div class="panel-header">
                    <h2 class="panel-title">× ×™×”×•×œ ×¨×’×©×•×ª ×•××¢×¨×›×ª ×¦×‘×¢×™×</h2>
                    <div style="display: flex; gap: 1rem;">
                        <button type="button" onclick="addNewEmotion()" class="btn btn-primary">
                            <i class="material-icons">add_circle</i>
                            ×”×•×¡×£ ×¨×’×© ×—×“×©
                        </button>
                        <button type="button" onclick="resetEmotionsToDefault()" class="btn btn-secondary">
                            <i class="material-icons">restore</i>
                            ×©×—×–×¨ ×œ×‘×¨×™×¨×ª ××—×“×œ
                        </button>
                        <button type="button" onclick="manualSaveEmotions()" class="btn btn-success">
                            <i class="material-icons">save</i>
                            ×©××•×¨ ×”×’×“×¨×•×ª (×™×“× ×™)
                        </button>
                        <button type="button" onclick="loadEmotionsConfig()" class="btn btn-info" title="×˜×¢×Ÿ ××—×“×© ××ª ×”×’×“×¨×•×ª ×”×¦×‘×¢×™× ××”×©×¨×ª">
                            <i class="material-icons">refresh</i>
                            ×¨×¢× ×Ÿ ×¦×‘×¢×™×
                        </button>
                        <button type="button" onclick="testEmotionColors()" class="btn btn-secondary">
                            <i class="material-icons">bug_report</i>
                            ×‘×“×•×§ ×¦×‘×¢×™×
                        </button>
                        <button type="button" onclick="forceColorUpdate()" class="btn btn-warning">
                            <i class="material-icons">palette</i>
                            ××œ×¥ ×¢×“×›×•×Ÿ ×¦×‘×¢×™×
                        </button>
                        <button type="button" onclick="testColorPersistence()" class="btn btn-info">
                            <i class="material-icons">storage</i>
                            ×‘×“×•×§ ×©××™×¨×ª ×¦×‘×¢×™×
                        </button>
                        <button type="button" onclick="immediateVisualRefresh()" class="btn btn-success">
                            <i class="material-icons">visibility</i>
                            ×¨×¢× ×Ÿ ×ª×¦×•×’×” ×¢×›×©×™×•
                        </button>
                        <button type="button" onclick="verifyColorSave()" class="btn btn-warning">
                            <i class="material-icons">check_circle</i>
                            ×‘×“×•×§ ×©××™×¨×”
                        </button>
                        <button type="button" onclick="reloadVisualizationColors()" class="btn btn-primary">
                            <i class="material-icons">sync</i>
                            ×˜×¢×Ÿ ×¦×‘×¢×™× ××—×“×©
                        </button>
                        <button type="button" onclick="forceVisualizationReload()" class="btn btn-danger">
                            <i class="material-icons">refresh</i>
                            ×¨×¢× ×Ÿ ×•×™×–×•××œ×™×–×¦×™×”
                        </button>
                        <button type="button" onclick="testDirectColorUpdate()" class="btn btn-secondary">
                            <i class="material-icons">colorize</i>
                            ×¢×“×›×•×Ÿ ×™×©×™×¨
                        </button>
                        <button type="button" onclick="testConversationColors()" class="btn btn-info">
                            <i class="material-icons">play_circle</i>
                            ×‘×“×•×§ ×©×™×—×”
                        </button>
                        <button type="button" onclick="testIndexPageColors()" class="btn btn-success">
                            <i class="material-icons">dashboard</i>
                            ×‘×“×•×§ ×¢××•×“ ×¨××©×™
                        </button>
                    </div>
                </div>
                
                <div style="background: #f0f8ff; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;">
                    <h3 style="margin: 0 0 1rem 0; color: #2196f3;">ğŸ¨ ××•×“×•×ª × ×™×”×•×œ ×¨×’×©×•×ª</h3>
                    <p style="margin: 0 0 1rem 0; color: #666; line-height: 1.6;">
                        ×›××Ÿ × ×™×ª×Ÿ ×œ× ×”×œ ××ª ×›×œ ×”×¨×’×©×•×ª ×”×–××™× ×™× ×‘××¢×¨×›×ª, ×œ×¢×¨×•×š ××ª ×”×¦×‘×¢×™× ×©×œ×”× ×•×œ×”×•×¡×™×£ ×¨×’×©×•×ª ×—×“×©×™×.
                        ×”×©×™× ×•×™×™× ×™×—×•×œ×• ×¢×œ ×›×œ ×”×•×•×™×–×•××œ×™×–×¦×™×•×ª ×•×”×××©×§.
                    </p>
                    <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                        <div style="background: white; padding: 1rem; border-radius: 6px; flex: 1;">
                            <strong>ğŸ“Š ×¡×”"×› ×¨×’×©×•×ª ×‘××¢×¨×›×ª:</strong>
                            <span id="total-emotions-count">--</span>
                        </div>
                        <div style="background: white; padding: 1rem; border-radius: 6px; flex: 1;">
                            <strong>ğŸ¯ ×¨×’×©×•×ª ×¤×¢×™×œ×™×:</strong>
                            <span id="active-emotions-count">--</span>
                        </div>
                        <div style="background: white; padding: 1rem; border-radius: 6px; flex: 1;">
                            <strong>ğŸ¨ ×¦×‘×¢×™× ××•×ª×××™×:</strong>
                            <span id="custom-colors-count">--</span>
                        </div>
                    </div>
                </div>
                
                <!-- Enhanced Emotions View Controls -->
                <div style="background: white; border-radius: 8px; padding: 2rem; margin-bottom: 2rem; border: 2px solid #667eea;">
                    <h3 style="margin: 0 0 1.5rem 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 0.5rem; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;">ğŸ­</span>
                        ×ª×¦×•×’×ª ×¨×’×©×•×ª ××¢×’×œ×™×ª ××©×•×¤×¨×ª
                    </h3>
                    
                    <div style="background: #f8f9ff; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;">
                        <p style="margin: 0 0 1rem 0; color: #666; line-height: 1.6;">
                            <strong>×ª×¦×•×’×” ×—×“×©×”!</strong> ×ª×¦×•×’×ª ×”×¨×’×©×•×ª ×¢×›×©×™×• ××§×‘×¦×ª ×©×™×—×•×ª ×œ×¤×™ ×”×¨×’×© ×”×¨××©×™ ×©×œ×”×Ÿ ×•××¦×™×’×” ××•×ª×Ÿ ×‘××¢×’×œ×™× × ×¤×¨×“×™×.
                            ×›×œ ×¨×’×© ××§×‘×œ ××¢×’×œ ××©×œ×• ×¢× ×›×œ ×”×©×™×—×•×ª ×”×©×™×™×›×•×ª ××œ×™×•.
                        </p>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-top: 1rem;">
                            <div style="background: white; padding: 1rem; border-radius: 6px; border-left: 4px solid #667eea;">
                                <strong>ğŸ“Š × ×™×ª×•×— ×¨×’×©×•×ª ×‘×©×™×—×•×ª:</strong>
                                <div id="emotion-analysis-stats">×˜×•×¢×Ÿ...</div>
                            </div>
                            <div style="background: white; padding: 1rem; border-radius: 6px; border-left: 4px solid #764ba2;">
                                <strong>ğŸ¯ ××¢×’×œ×™ ×¨×’×©×•×ª:</strong>
                                <div id="emotion-circles-stats">×˜×•×¢×Ÿ...</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 1rem; margin-bottom: 2rem;">
                        <button type="button" onclick="analyzeConversationEmotions()" class="btn btn-primary">
                            <i class="material-icons">analytics</i>
                            × ×ª×— ×¨×’×©×•×ª ×‘×©×™×—×•×ª
                        </button>
                        <button type="button" onclick="generateEmotionReport()" class="btn btn-secondary">
                            <i class="material-icons">assessment</i>
                            ×”×¤×§ ×“×•×— ×¨×’×©×•×ª
                        </button>
                        <button type="button" onclick="refreshEmotionView()" class="btn btn-success">
                            <i class="material-icons">refresh</i>
                            ×¨×¢× ×Ÿ ×ª×¦×•×’×ª ×¨×’×©×•×ª
                        </button>
                        <button type="button" onclick="window.open('index.html#emotions', '_blank')" class="btn" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white;">
                            <i class="material-icons">visibility</i>
                            ×¦×¤×” ×‘×ª×¦×•×’×ª ×¨×’×©×•×ª
                        </button>
                    </div>
                    
                    <div id="emotion-groups-preview" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem;">
                        <!-- Emotion groups preview will be loaded here -->
                    </div>
                </div>

                <!-- Emotions List -->
                <div style="background: white; border-radius: 8px; padding: 2rem; margin-bottom: 2rem;">
                    <h3 style="margin: 0 0 1.5rem 0;">ğŸ­ ×¨×©×™××ª ×¨×’×©×•×ª</h3>
                    <div style="margin-bottom: 1rem;">
                        <input type="text" id="emotions-search" placeholder="×—×¤×© ×¨×’×©..." 
                               style="width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 6px;"
                               onkeyup="filterEmotions(this.value)">
                    </div>
                    <div id="emotions-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem;">
                        <!-- Emotions will be loaded here -->
                    </div>
                </div>
                
                <!-- Color Palette -->
                <div style="background: white; border-radius: 8px; padding: 2rem;">
                    <h3 style="margin: 0 0 1.5rem 0;">ğŸ¨ ×¤×œ×˜×ª ×¦×‘×¢×™× ××•××œ×¦×ª</h3>
                    <div style="margin-bottom: 1rem;">
                        <p style="color: #666; margin: 0;">×œ×—×¥ ×¢×œ ×¦×‘×¢ ×›×“×™ ×œ×”×¢×ª×™×§ ××ª ×”×§×•×“ ×©×œ×•</p>
                    </div>
                    <div id="color-palette" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 1rem;">
                        <!-- Color palette will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>



    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner">
            <div class="spinner"></div>
            <p id="loading-text">×˜×•×¢×Ÿ...</p>
        </div>
        
        <!-- Enhanced Progress Display -->
        <div id="analysisProgressContainer" style="display: none; margin-top: 2rem; background: rgba(255,255,255,0.95); padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); max-width: 500px; width: 90%;">
            <div id="analysisProgressText" style="font-size: 1.1rem; font-weight: 600; margin-bottom: 1rem; color: #333; text-align: center;"></div>
            
            <!-- Progress Bar -->
            <div style="background: #e0e0e0; border-radius: 25px; overflow: hidden; margin-bottom: 1rem; height: 30px; position: relative;">
                <div id="analysisProgressBar" style="background: linear-gradient(90deg, #4CAF50 0%, #2196F3 100%); height: 100%; width: 0%; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; border-radius: 25px;"></div>
            </div>
            
            <!-- Progress Details -->
            <div id="analysisProgressDetails" style="font-size: 0.9rem; color: #555; line-height: 1.4; background: #f5f5f5; padding: 1rem; border-radius: 8px; text-align: right;">
                <div>ğŸ”„ ××ª×›×•× ×Ÿ ×œ× ×™×ª×•×—...</div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentConversation = null;
        let conversationsData = {};
        let uploadedFile = null;
        let apiBaseUrl = '';
        let emotionData = {};
        let pendingChanges = {};
        let hasUnsavedChanges = false;
        let currentLoopingAudio = null;
        let currentLoopingSegment = null;
        let currentSelectedSegment = null;
        let refreshInterval;
        let autoSaveTimeout;
        let lastAutoSaveTime = 0; // Track last auto-save time for smart debouncing
        let emotionConfigAutoSaveTimeout;
        let isLoadingEmotionData = false;
        let currentEmotionController = null;
        let conversationSelectTimeout = null;
        let isSelectingConversation = false;
        let lastRequestTime = 0;
        const MIN_REQUEST_INTERVAL = 1000; // Minimum 1 second between requests

        // Get all available emotions from emotions management
        function getAvailableEmotions() {
            // Get all emotions from emotions config (both active and inactive)
            if (emotionsConfig && Object.keys(emotionsConfig).length > 0) {
                return Object.keys(emotionsConfig).sort();
            }
            
            // Fallback to default emotions if config not loaded
            return Object.keys(DEFAULT_EMOTIONS).sort();
        }

        // Auto-sync configuration
        const AUTO_SYNC_ENABLED = false; // Set to true to enable sync to production (requires sync_to_production.py script)
        const SYNC_SCRIPT_URL = `${apiBaseUrl}/api/sync-to-production`;
        
        // Check if we're running on production server
        function isRunningOnProduction() {
            return window.location.hostname.includes('1on1.website') || 
                   window.location.hostname.includes('167.172.51.184');
        }
        
        // Auto-sync functions
        async function syncToProduction(conversationFolder = 'all', syncType = 'incremental') {
            if (!AUTO_SYNC_ENABLED) {
                console.log('â„¹ï¸ Auto-sync disabled - changes saved locally only');
                return { success: true, message: 'Changes saved locally - sync disabled' };
            }
            
            // If running on production, files are already where they need to be
            if (isRunningOnProduction()) {
                console.log('âœ… Running on production server - files already synchronized');
                updateSyncStatus('âœ… ×¤×•×¢×œ ×¢×œ ×©×¨×ª ×”×¤×§×” - ×”×§×‘×¦×™× ×›×‘×¨ ××¡×•× ×›×¨× ×™×!', 'success');
                return { success: true, message: 'Already on production server' };
            }
            
            try {
                console.log(`ğŸ”„ Starting sync to production: ${conversationFolder} (${syncType})`);
                updateSyncStatus('ğŸ”„ ××¡× ×›×¨×Ÿ ×œ×©×¨×ª ×”×¤×§×”...', 'info');
                
                // Try the API endpoint first with timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
                
                const response = await fetch(SYNC_SCRIPT_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        conversation: conversationFolder,
                        type: syncType
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.success) {
                        if (result.sync_skipped) {
                            console.log('â„¹ï¸ Sync to production skipped - script not found');
                            updateSyncStatus('â„¹ï¸ ×©×™× ×•×™×™× × ×©××¨×• ××§×•××™×ª - ×¡×™× ×›×¨×•×Ÿ ×œ×©×¨×ª ×“×•×œ×’', 'info');
                        } else {
                            console.log('âœ… Sync to production completed successfully');
                            updateSyncStatus('âœ… ×¡×™× ×›×¨×•×Ÿ ×œ×©×¨×ª ×”×¤×§×” ×”×•×©×œ× ×‘×”×¦×œ×—×”!', 'success');
                        }
                        return result;
                    } else {
                        console.error('âŒ Sync failed:', result.error);
                        // Only show sync error in status, don't fail the entire operation
                        updateSyncStatus(`âš ï¸ ×¡×™× ×›×¨×•×Ÿ × ×›×©×œ: ${result.error || '×©×’×™××” ×œ× ×™×“×•×¢×”'}`, 'warning');
                        return result;
                    }
                } else {
                    throw new Error(`Sync API failed: ${response.status}`);
                }
                
            } catch (error) {
                console.warn('âš ï¸ Sync to production unavailable:', error);
                
                // Handle different types of errors  
                let errorMessage = 'â„¹ï¸ ×©×™× ×•×™×™× × ×©××¨×• ××§×•××™×ª - ×¡×™× ×›×¨×•×Ÿ ××•×˜×•××˜×™ ×œ× ×–××™×Ÿ';
                if (error.name === 'AbortError') {
                    errorMessage = 'â„¹ï¸ ×©×™× ×•×™×™× × ×©××¨×• ××§×•××™×ª - ×¡×™× ×›×¨×•×Ÿ ×”×•×¤×¡×§ (×–××Ÿ ×ª×’×•×‘×” ××¨×•×š)';
                } else if (error.message.includes('ERR_CONNECTION_REFUSED')) {
                    errorMessage = 'â„¹ï¸ ×©×™× ×•×™×™× × ×©××¨×• ××§×•××™×ª - ×©×¨×ª ×”×¡×™× ×›×¨×•×Ÿ ×œ× ×–××™×Ÿ';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMessage = 'â„¹ï¸ ×©×™× ×•×™×™× × ×©××¨×• ××§×•××™×ª - ×‘×¢×™×” ×‘×—×™×‘×•×¨ ×œ×©×¨×ª ×”×¡×™× ×›×¨×•×Ÿ';
                }
                
                updateSyncStatus(errorMessage, 'info');
                
                return { success: false, error: error.message, fallback: true };
            }
        }
        
        // Show sync status in UI
        function createSyncStatusIndicator() {
            const syncIndicator = document.createElement('div');
            syncIndicator.id = 'sync-status-indicator';
            syncIndicator.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 10px 15px;
                border-radius: 8px;
                background: #e3f2fd;
                color: #1976d2;
                border: 1px solid #bbdefb;
                font-size: 14px;
                z-index: 1000;
                display: none;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            `;
            
            document.body.appendChild(syncIndicator);
            return syncIndicator;
        }
        
        // Update sync status indicator
        function updateSyncStatus(message, type = 'info') {
            let indicator = document.getElementById('sync-status-indicator');
            if (!indicator) {
                indicator = createSyncStatusIndicator();
            }
            
            const colors = {
                info: { bg: '#e3f2fd', border: '#bbdefb', text: '#1976d2' },
                success: { bg: '#e8f5e8', border: '#c8e6c8', text: '#2e7d32' },
                error: { bg: '#ffebee', border: '#ffcdd2', text: '#c62828' },
                warning: { bg: '#fff3e0', border: '#ffcc02', text: '#f57c00' }
            };
            
            const color = colors[type] || colors.info;
            indicator.style.background = color.bg;
            indicator.style.borderColor = color.border;
            indicator.style.color = color.text;
            indicator.innerHTML = message;
            indicator.style.display = 'block';
            
            // Auto-hide after 5 seconds for success/info messages
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 5000);
            }
        }
        
        // Add manual sync button to admin panel
        function addManualSyncButton() {
            const header = document.querySelector('.admin-header') || document.querySelector('h1')?.parentElement;
            if (header) {
                const syncButton = document.createElement('button');
                
                // Different button text based on where we're running
                if (isRunningOnProduction()) {
                    syncButton.innerHTML = 'âœ… ×¢×œ ×©×¨×ª ×”×¤×§×”';
                    syncButton.className = 'btn btn-success btn-sm';
                    syncButton.title = '××ª×” ×›×‘×¨ ×¤×•×¢×œ ×¢×œ ×©×¨×ª ×”×¤×§×” - ××™×Ÿ ×¦×•×¨×š ×‘×¡×™× ×›×¨×•×Ÿ';
                } else {
                    syncButton.innerHTML = 'ğŸ”„ ×¡× ×›×¨×Ÿ ×œ×¤×§×”';
                    syncButton.className = 'btn btn-primary btn-sm';
                    syncButton.title = '×¡× ×›×¨×Ÿ ××ª ×›×œ ×”×©×™×—×•×ª ×œ×©×¨×ª ×”×¤×§×”';
                }
                
                syncButton.style.cssText = 'margin-left: 10px; position: relative; z-index: 1000;';
                
                syncButton.onclick = async () => {
                    // Check if we're on production server
                    if (isRunningOnProduction()) {
                        alert(`âœ… ××ª×” ×›×‘×¨ ×¤×•×¢×œ ×¢×œ ×©×¨×ª ×”×¤×§×”!

ğŸŒ ×›×ª×•×‘×ª × ×•×›×—×™×ª: ${window.location.hostname}

×›×œ ×”×©×™× ×•×™×™× ×©××ª×” ×¢×•×©×” ×›××Ÿ ××•×¤×™×¢×™× ××™×“ ×‘××ª×¨:
â€¢ https://1on1.website - ×”××ª×¨ ×”×¨××©×™
â€¢ https://admin.1on1.website - ×”×¤×× ×œ ×”×–×”

××™×Ÿ ×¦×•×¨×š ×‘×¡×™× ×›×¨×•×Ÿ × ×•×¡×£! ğŸ‰`);
                        return;
                    }
                    
                    syncButton.disabled = true;
                    syncButton.innerHTML = 'ğŸ”„ ××¡× ×›×¨×Ÿ...';
                    
                    try {
                        const result = await syncToProduction('all', 'incremental');
                        
                        if (result.fallback) {
                            // Show instructions for manual sync
                            const instructions = `
×œ×¡×™× ×›×¨×•×Ÿ ×™×“× ×™ ××”××—×©×‘ ×”××§×•××™, ×”×¨×¥ ××—×“ ××”×¤×§×•×“×•×ª ×”×‘××•×ª ×‘×˜×¨××™× ×œ:

1. ×¡×™× ×›×¨×•×Ÿ ××”×™×¨ ×©×œ ×›×œ ×”×©×™×—×•×ª:
   python3 sync_to_production.py

2. ×¡×™× ×›×¨×•×Ÿ ×©×œ ×©×™×—×” ×¡×¤×¦×™×¤×™×ª:
   python3 sync_to_production.py convo1

3. ×¡×™× ×›×¨×•×Ÿ ××œ× (××—×§ ×§×‘×¦×™× ×™×©× ×™×):
   python3 sync_to_production.py all full

4. ××• ×”×©×ª××© ×‘-rsync ×™×©×™×¨×•×ª:
   rsync -av conversations/ root@167.172.51.184:/root/emotion-visualizer/conversations/
                            `;
                            
                            alert(instructions);
                        }
                        
                    } catch (error) {
                        console.error('Manual sync error:', error);
                        updateSyncStatus(`âŒ ×©×’×™××” ×‘×¡×™× ×›×¨×•×Ÿ ×™×“× ×™: ${error.message}`, 'error');
                    } finally {
                        syncButton.disabled = false;
                        syncButton.innerHTML = 'ğŸ”„ ×¡× ×›×¨×Ÿ ×œ×¤×§×”';
                    }
                };
                
                header.appendChild(syncButton);
                console.log('âœ… Manual sync button added to admin panel');
            } else {
                console.warn('âš ï¸ Could not find suitable location for sync button');
            }
        }

        // Global error handler
        window.addEventListener('error', function(e) {
            console.error('ğŸ’¥ Global JavaScript Error:', e.error);
            console.error('ğŸ“ Location:', e.filename, 'Line:', e.lineno, 'Column:', e.colno);
        });

        window.addEventListener('unhandledrejection', function(e) {
            console.error('ğŸ’¥ Unhandled Promise Rejection:', e.reason);
        });

        // Helper functions for save management
        function updateSaveButtonState() {
            const saveBtn = document.getElementById('save-all-btn');
            const changeCount = Object.keys(pendingChanges).length;
            
            if (saveBtn) {
                if (changeCount > 0) {
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = `<i class="material-icons">save</i> ×©××•×¨ ×©×™× ×•×™×™× (${changeCount})`;
                } else {
                    saveBtn.disabled = true;
                    saveBtn.innerHTML = `<i class="material-icons">save</i> ×©××•×¨ ×©×™× ×•×™×™×`;
                }
            }
        }
        
        function scheduleAutoSave() {
            // Clear existing timeout
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }
            
            // âœ… SMART DEBOUNCING: Prevent excessive auto-saves
            // Increase delay and track last save to avoid rapid firing
            const now = Date.now();
            const timeSinceLastSave = now - (lastAutoSaveTime || 0);
            
            // If we just saved recently (within 5 seconds), extend the delay significantly
            const baseDelay = 10000; // Increased from 5 to 10 seconds
            const extendedDelay = timeSinceLastSave < 5000 ? 15000 : baseDelay; // Much longer delays
            
            console.log(`â±ï¸ Scheduling auto-save in ${extendedDelay}ms (last save: ${timeSinceLastSave}ms ago)`);
            
            // Schedule auto-save after calculated delay
            autoSaveTimeout = setTimeout(async () => {
                if (hasUnsavedChanges && Object.keys(pendingChanges).length > 0) {
                    console.log('ğŸ¤– Auto-saving changes...');
                    lastAutoSaveTime = Date.now(); // Track save time
                    try {
                        await saveAllChanges();
                        showStatus('×”×©×™× ×•×™×™× × ×©××¨×• ××•×˜×•××˜×™×ª', 'success');
                    } catch (error) {
                        console.error('Auto-save failed:', error);
                        showStatus('×©×’×™××” ×‘×©××™×¨×” ××•×˜×•××˜×™×ª', 'error');
                    }
                }
            }, extendedDelay);
        }
        
        function scheduleEmotionConfigAutoSave() {
            // Clear existing timeout
            if (emotionConfigAutoSaveTimeout) {
                clearTimeout(emotionConfigAutoSaveTimeout);
            }
            
            // Schedule auto-save after 2 seconds of inactivity
            emotionConfigAutoSaveTimeout = setTimeout(async () => {
                console.log('ğŸ¨ Auto-saving emotion configuration...');
                try {
                    await saveEmotionsConfig(true); // isAutoSave = true
                    console.log('âœ… Emotion configuration auto-saved successfully');
                    
                    // Show brief success message
                    const statusDiv = document.createElement('div');
                    statusDiv.style.cssText = `
                        position: fixed; top: 20px; right: 20px; 
                        background: #c8e6c8; color: #2e7d32; 
                        padding: 8px 12px; border-radius: 4px; 
                        font-size: 0.85rem; z-index: 10001;
                        border: 1px solid #a5d6a7;
                    `;
                    statusDiv.textContent = 'ğŸ’¾ ×¦×‘×¢×™ ×¨×’×©×•×ª × ×©××¨×•';
                    document.body.appendChild(statusDiv);
                    
                    setTimeout(() => {
                        if (statusDiv.parentNode) {
                            statusDiv.remove();
                        }
                    }, 2000);
                    
                    // Automatically trigger color updates after auto-save
                    setTimeout(() => {
                        console.log('ğŸ¨ Auto-triggering color updates after auto-save...');
                        updateVisualizationColors();
                        
                        // Send update to main index page
                        if (window.opener) {
                            try {
                                window.opener.postMessage({
                                    type: 'emotionColorsUpdated',
                                    autoTrigger: true,
                                    timestamp: Date.now()
                                }, '*');
                                console.log('ğŸ“¤ Auto-sent color update to main index page');
                            } catch (e) {
                                console.log('ğŸ“¤ Could not send to opener:', e.message);
                            }
                        }
                        
                        // Broadcast to all tabs
                        try {
                            const bc = new BroadcastChannel('emotion-updates');
                            bc.postMessage({
                                type: 'emotionColorsUpdated', 
                                autoTrigger: true,
                                timestamp: Date.now()
                            });
                            bc.close();
                            console.log('ğŸ“» Auto-broadcast color update to all tabs');
                        } catch (e) {
                            console.log('ğŸ“» BroadcastChannel not available');
                        }
                    }, 1000);
                    
                } catch (error) {
                    console.error('âŒ Emotion config auto-save failed:', error);
                    showStatus('×©×’×™××” ×‘×©××™×¨×” ××•×˜×•××˜×™×ª ×©×œ ×”×’×“×¨×•×ª ×¨×’×©×•×ª', 'error');
                }
            }, 2000);
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', async () => {
            // Add small delays between initialization steps to avoid rate limiting
            await detectApiServer();
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            
            console.log('ğŸš€ Admin panel initializing with fresh conversation data...');
            await loadConversations(true); // Force refresh on admin panel page load
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            
            // Load emotion configuration early to ensure colors are available
            await loadEmotionsConfig();
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            
            populateRetranscriptionOptions();
            setupEventListeners();
            initializeExperiments();
            
            // Initialize auto-sync functionality
            addManualSyncButton();
            
            // Set up emotion color synchronization
            setupEmotionColorSync();
            
            // Initialize auto-analysis toggle
            initializeAutoAnalysis();
            
            // âœ¨ Initialize enhanced sliders on page load and standardize AI behavior
            setTimeout(() => {
                // Ensure consistent AI analysis behavior across all conversations and segments
                standardizeAIAnalysisBehavior();
                
                // Apply enhanced visual effects to existing segments
                applyEnhancedEffectsToAllSegments();
                
                initializeEnhancedSliders();
            }, 200);
            createSyncStatusIndicator();
            console.log('ğŸ”„ Auto-sync functionality initialized');
            
            // Smart auto-refresh with focus detection
            let isPageVisible = true;
            let lastRefreshTime = Date.now();
            
            // Detect page visibility
            document.addEventListener('visibilitychange', () => {
                isPageVisible = !document.hidden;
                if (isPageVisible && Date.now() - lastRefreshTime > 60000 && !isLoadingEmotionData) {
                    // Refresh if page becomes visible and hasn't refreshed in 60s
                    refreshEmotionData();
                }
            });
            
            // Smart refresh interval - only when page is visible and no loading in progress
            refreshInterval = setInterval(async () => {
                if (currentConversation && !hasUnsavedChanges && isPageVisible && !isLoadingEmotionData) {
                    await refreshEmotionData();
                    lastRefreshTime = Date.now();
                }
            }, 120000); // Refresh every 2 minutes to reduce server load
        });

        // Detect API server
        async function detectApiServer() {
            // First try the current page's origin
            try {
                const currentOrigin = window.location.origin;
                const url = `${currentOrigin}/config/conversations_config.json`;
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout
                
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    apiBaseUrl = currentOrigin;
                    console.log(`âœ… API server detected at current origin: ${apiBaseUrl}`);
                    showStatus(`âœ… ×©×¨×ª API ×–×•×”×” ×‘×”×¦×œ×—×”`, 'success');
                    return;
                }
            } catch (error) {
                console.log('Current origin not available, trying ports...');
            }
            
            // Then try common ports
            const ports = [8001, 8002, 8003, 8004, 8000]; // Try 8000 last since it often fails
            for (const port of ports) {
                try {
                    // Just check if we can reach the server with shorter timeout
                    const url = `http://localhost:${port}/config/conversations_config.json`;
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 1500); // Shorter timeout
                    
                    const response = await fetch(url, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        apiBaseUrl = `http://localhost:${port}`;
                        console.log(`âœ… API server detected at ${apiBaseUrl}`);
                        showStatus(`âœ… ×©×¨×ª API ×–×•×”×” ×‘×”×¦×œ×—×” ×‘×¤×•×¨×˜ ${port}`, 'success');
                        return;
                    }
                } catch (error) {
                    // Connection failed, try next port
                    console.log(`Port ${port} unavailable:`, error.message);
                    continue;
                }
            }
            // If no server detected, use current origin as fallback
            apiBaseUrl = window.location.origin || 'http://localhost:8000';
            console.warn('âš ï¸ No API server detected. Using fallback:', apiBaseUrl);
            showStatus('âš ï¸ ×©×¨×ª API ×œ× ×–×•×”×” - ××©×ª××© ×‘×”×’×“×¨×•×ª ×‘×¨×™×¨×ª ××—×“×œ', 'warning');
        }


        // Loading overlay
        function showLoading(text = '×˜×•×¢×Ÿ...') {
            document.getElementById('loading-text').textContent = text;
            document.getElementById('loading-overlay').style.display = 'flex';
            // Reset progress display
            const progressContainer = document.getElementById('analysisProgressContainer');
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
        }

        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
            // Hide progress display
            const progressContainer = document.getElementById('analysisProgressContainer');
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
        }

        function showAnalysisProgress(current, total, currentSegment, analysisType) {
            const progressContainer = document.getElementById('analysisProgressContainer');
            const progressBar = document.getElementById('analysisProgressBar');
            const progressText = document.getElementById('analysisProgressText');
            const progressDetails = document.getElementById('analysisProgressDetails');
            
            if (progressContainer && progressBar && progressText) {
                progressContainer.style.display = 'block';
                
                const percentage = Math.round((current / total) * 100);
                progressBar.style.width = `${percentage}%`;
                progressBar.textContent = `${percentage}%`;
                
                progressText.textContent = `×× ×ª×— ×§×˜×¢ ${current} ××ª×•×š ${total}`;
                
                if (progressDetails) {
                    progressDetails.innerHTML = `
                        <div>ğŸ“‚ ×§×˜×¢ × ×•×›×—×™: <strong>${currentSegment}</strong></div>
                        <div>ğŸ¯ ×¡×•×’ × ×™×ª×•×—: <strong>${analysisType}</strong></div>
                        <div>â³ × ×•×ª×¨×•: <strong>${total - current}</strong> ×§×˜×¢×™×</div>
                    `;
                }
            }
        }

        // Show status message
        function showStatus(message, type = 'info') {
            try {
                console.log(`ğŸ“¢ Status [${type}]: ${message}`);
                
                const statusDiv = document.createElement('div');
                statusDiv.className = `status-message status-${type}`;
                statusDiv.innerHTML = `
                    <i class="material-icons">${type === 'success' ? 'check_circle' : type === 'error' ? 'error' : 'info'}</i>
                    ${message}
                `;
                
                // Find a suitable container - with fallback
                let container = document.querySelector('.tab-content.active .panel');
                if (!container) {
                    container = document.querySelector('.tab-content.active');
                }
                if (!container) {
                    container = document.body;
                }
                
                if (container) {
                    if (container === document.body) {
                        // Position at top if adding to body
                        statusDiv.style.position = 'fixed';
                        statusDiv.style.top = '20px';
                        statusDiv.style.left = '50%';
                        statusDiv.style.transform = 'translateX(-50%)';
                        statusDiv.style.zIndex = '10000';
                    }
                    
                    container.insertBefore(statusDiv, container.firstChild);
                    setTimeout(() => {
                        if (statusDiv.parentNode) {
                            statusDiv.remove();
                        }
                    }, 5000);
                } else {
                    console.warn('âš ï¸ Could not find container for status message, using alert');
                    alert(`${type.toUpperCase()}: ${message}`);
                }
            } catch (error) {
                console.error('âŒ Error showing status:', error);
                // Fallback to alert if status system fails
                    alert(`${type.toUpperCase()}: ${message}`);
            }
        }

        // Enhanced Editor Functions
        async function loadConversations(forceRefresh = false) {
            try {
                showLoading('×˜×•×¢×Ÿ ×¨×©×™××ª ×©×™×—×•×ª...');
                
                // Add timeout and retry logic
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                
                // ğŸ” ENHANCED CACHE-BUSTING for edit parameters tab
                const cacheBuster = forceRefresh ? `?v=${Date.now()}&refresh=true` : `?v=${Date.now()}`;
                const configUrl = `${apiBaseUrl}/config/conversations_config.json${cacheBuster}`;
                
                console.log(`ğŸ“¡ Editor loading conversations from: ${configUrl}`);
                
                const response = await fetch(configUrl, {
                    signal: controller.signal,
                    cache: 'no-cache',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const responseText = await response.text();
                if (!responseText) {
                    throw new Error('Empty response received');
                }
                
                let config;
                try {
                    config = JSON.parse(responseText);
                } catch (parseError) {
                    throw new Error(`Invalid JSON: ${parseError.message}`);
                }
                
                if (config && config.conversations) {
                    conversationsData = config.conversations;
                    displayConversations();
                } else {
                    throw new Error('Invalid configuration format');
                }
            } catch (error) {
                console.error('Error loading conversations:', error);
                if (error.name === 'AbortError') {
                    showStatus('×©×¨×ª ×œ× ××’×™×‘ - ×‘×“×•×§ ×©×”×©×¨×ª ×¤×•×¢×œ', 'error');
                } else {
                    showStatus(`×©×’×™××” ×‘×˜×¢×™× ×ª ×”×©×™×—×•×ª: ${error.message}`, 'error');
                }
            } finally {
                hideLoading();
            }
        }

        function displayConversations() {
            const container = document.getElementById('conversations-list');
            container.innerHTML = '';

            // Check if we have conversations data
            if (!conversationsData || Object.keys(conversationsData).length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: #999;">
                        <i class="material-icons" style="font-size: 48px; display: block; margin-bottom: 1rem;">chat_bubble_outline</i>
                        <p style="font-size: 1.1rem; margin-bottom: 1rem;">××™×Ÿ ×©×™×—×•×ª ×–××™× ×•×ª</p>
                        <button onclick="loadConversations()" class="btn btn-primary btn-sm">
                            <i class="material-icons">refresh</i>
                            × ×¡×” ×©×•×‘
                        </button>
                    </div>
                `;
                return;
            }

            const sortedConvos = Object.entries(conversationsData)
                .sort(([,a], [,b]) => a.number - b.number);

            if (sortedConvos.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: #999;">
                        <p>××™×Ÿ ×©×™×—×•×ª ×œ×”×¦×’×”</p>
                    </div>
                `;
                return;
            }

            sortedConvos.forEach(([folder, data]) => {
                const metadata = data.metadata || {};
                const item = document.createElement('div');
                item.className = 'conversation-item';
                item.onclick = () => selectConversation(folder);
                
                // Create enhanced tooltip with metadata
                const tooltipContent = createConversationTooltip(folder, data);
                item.title = tooltipContent;
                
                // Enhanced display with metadata
                const displayName = metadata.name || `×©×™×—×” ${data.number}`;
                const participantInfo = metadata.participants?.length ? 
                    ` | ××©×ª×ª×¤×™×: ${metadata.participants.join(', ')}` : '';
                const durationInfo = metadata.duration ? ` | â±ï¸ ${metadata.duration}` : '';
                const emotionEmojis = metadata.mainEmotions?.length ? 
                    metadata.mainEmotions.map(e => getEmotionEmoji(e)).join('') : '';
                
                // Check if AI content exists
                const hasAISummary = metadata.ai_summary ? 'ğŸ¤–' : '';
                const hasAIInsights = metadata.ai_insights ? 'ğŸ¤–' : '';
                
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                        <div style="flex: 1;">
                            <h4 style="margin: 0 0 0.5rem 0; display: flex; align-items: center; gap: 0.5rem;">
                                ${displayName}
                                ${metadata.isImportant ? '<span style="color: #f44336;" title="×©×™×—×” ×—×©×•×‘×”">â­</span>' : ''}
                                ${metadata.isPrivate ? '<span style="color: #9c27b0;" title="×©×™×—×” ×¤×¨×˜×™×ª">ğŸ”’</span>' : ''}
                                ${metadata.needsReview ? '<span style="color: #ff9800;" title="×“×•×¨×© ×‘×“×™×§×”">âš ï¸</span>' : ''}
                            </h4>
                            <div style="font-size: 0.85rem; color: #666;">
                                ğŸ“… ${metadata.date || '×œ×œ× ×ª××¨×™×š'}${durationInfo}${participantInfo}
                            </div>
                            ${emotionEmojis ? `<div style="margin-top: 0.3rem;">${emotionEmojis} ${metadata.mainEmotions.join(', ')}</div>` : ''}
                        </div>
                        <div style="text-align: right; font-size: 0.8rem; color: #999;">
                            ğŸ“ ${folder}
                        </div>
                    </div>
                    <div class="conversation-stats">
                        <span>ğŸµ ${data.mp3_count || 0} ×§×˜×¢×™×</span>
                        <span>ğŸ“ ${metadata.totalWords || 0} ××™×œ×™×</span>
                        ${metadata.tags?.length ? `<span>ğŸ·ï¸ ${metadata.tags.slice(0, 2).join(', ')}${metadata.tags.length > 2 ? '...' : ''}</span>` : ''}
                        <span style="margin-right: auto;">
                            ${hasAISummary ? '<span title="×¡×™×›×•× AI ×§×™×™×">ğŸ“ğŸ¤–</span>' : ''}
                            ${hasAIInsights ? '<span title="×ª×•×‘× ×•×ª AI ×§×™×™××•×ª">ğŸ’¡ğŸ¤–</span>' : ''}
                        </span>
                    </div>
                    <div class="ai-actions" style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #eee; display: flex; gap: 0.25rem; flex-wrap: wrap;">
                        <button onclick="event.stopPropagation(); generateConversationSummary('${folder}')" 
                                class="btn btn-sm ${hasAISummary ? 'btn-success' : 'btn-outline-primary'}" 
                                style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" 
                                title="${hasAISummary ? '×¢×“×›×Ÿ ×¡×™×›×•× AI' : '×¦×•×¨ ×¡×™×›×•× AI'}">
                            ğŸ“ ${hasAISummary ? '×¢×“×›×Ÿ ×¡×™×›×•×' : '×¦×•×¨ ×¡×™×›×•×'}
                        </button>
                        <button onclick="event.stopPropagation(); generateConversationInsights('${folder}')" 
                                class="btn btn-sm ${hasAIInsights ? 'btn-success' : 'btn-outline-info'}" 
                                style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" 
                                title="${hasAIInsights ? '×¢×“×›×Ÿ ×ª×•×‘× ×•×ª AI' : '×¦×•×¨ ×ª×•×‘× ×•×ª AI'}">
                            ğŸ’¡ ${hasAIInsights ? '×¢×“×›×Ÿ ×ª×•×‘× ×•×ª' : '×¦×•×¨ ×ª×•×‘× ×•×ª'}
                        </button>
                        <button onclick="event.stopPropagation(); generateBothForConversation('${folder}')" 
                                class="btn btn-sm ${hasAISummary && hasAIInsights ? 'btn-success' : 'btn-outline-secondary'}" 
                                style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" 
                                title="×¦×•×¨/×¢×“×›×Ÿ ×¡×™×›×•× ×•×ª×•×‘× ×•×ª">
                            ğŸ¤– ${hasAISummary && hasAIInsights ? '×¢×“×›×Ÿ ×”×›×œ' : '×¦×•×¨ ×”×›×œ'}
                        </button>
                    </div>
                `;
                
                container.appendChild(item);
            });

            console.log(`âœ… Displayed ${sortedConvos.length} conversations with enhanced metadata`);
        }
        
        // Create detailed tooltip for conversation hover
        function createConversationTooltip(folder, data) {
            const metadata = data.metadata || {};
            
            const lines = [
                `ğŸ“ ${metadata.name || `×©×™×—×” ${data.number}`}`,
                `ğŸ“ ×ª×™×§×™×™×”: ${folder}`,
                metadata.date ? `ğŸ“… ×ª××¨×™×š: ${metadata.date}` : 'ğŸ“… ×ª××¨×™×š: ×œ× ×”×•×’×“×¨',
                metadata.participants?.length ? `ğŸ‘¥ ××©×ª×ª×¤×™×: ${metadata.participants.join(', ')}` : 'ğŸ‘¥ ××©×ª×ª×¤×™×: ×œ× ×”×•×’×“×¨',
                metadata.duration ? `â±ï¸ ××©×š: ${metadata.duration}` : 'â±ï¸ ××©×š: ×œ× ××—×•×©×‘',
                `ğŸµ ${data.mp3_count || 0} ×§×˜×¢×™× | ğŸ“ ${metadata.totalWords || 0} ××™×œ×™×`,
                metadata.mainEmotions?.length ? `ğŸ˜Š ×¨×’×©×•×ª ×¢×™×§×¨×™×™×: ${metadata.mainEmotions.join(', ')}` : 'ğŸ˜Š ×¨×’×©×•×ª ×¢×™×§×¨×™×™×: ×œ× ×”×•×’×“×¨',
                metadata.emotionalIntensity ? `ğŸ“Š ×¢×•×¦××” ×¨×’×©×™×ª: ${metadata.emotionalIntensity}/10` : 'ğŸ“Š ×¢×•×¦××” ×¨×’×©×™×ª: 5/10'
            ];
            
            if (metadata.tags?.length) {
                lines.push(`ğŸ·ï¸ ×ª×’×™×•×ª: ${metadata.tags.join(', ')}`);
            }
            
            if (metadata.notes) {
                lines.push(`ğŸ“‹ ×”×¢×¨×•×ª: ${metadata.notes.substring(0, 100)}${metadata.notes.length > 100 ? '...' : ''}`);
            }
            
            // Add status flags
            const flags = [];
            if (metadata.isImportant) flags.push('â­ ×©×™×—×” ×—×©×•×‘×”');
            if (metadata.isPrivate) flags.push('ğŸ”’ ×©×™×—×” ×¤×¨×˜×™×ª');
            if (metadata.needsReview) flags.push('âš ï¸ ×“×•×¨×© ×‘×“×™×§×”');
            
            if (flags.length > 0) {
                lines.push('', ...flags);
            }
            
            return lines.join('\n');
        }

        // Function to refresh conversations list
        window.refreshConversationsList = async function refreshConversationsList() {
            try {
                showLoading('××¨×¢× ×Ÿ ×¨×©×™××ª ×©×™×—×•×ª...');
                await loadConversations(true); // Force refresh for edit parameters tab
                
                // Also refresh metadata if it's loaded - FORCE REFRESH to bypass cache
                if (Object.keys(conversationMetadata).length > 0) {
                    await loadConversationMetadata(true); // Force refresh
                    displayMetadataConversations();
                }
                
                showStatus('×¨×©×™××ª ×”×©×™×—×•×ª ×¢×•×“×›× ×” ×‘×”×¦×œ×—×”', 'success');
            } catch (error) {
                console.error('Error refreshing conversations:', error);
                showStatus(`×©×’×™××” ×‘×¨×¢× ×•×Ÿ: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }
        
        // ğŸ” DEBUG FUNCTION: Test save/load cycle
        window.testSaveLoadCycle = async function(conversationFolder, newName) {
            console.log(`ğŸ§ª Testing save/load cycle for ${conversationFolder} with name: ${newName}`);
            
            try {
                // Load current metadata
                await loadConversationMetadata(true);
                const originalName = conversationMetadata[conversationFolder]?.metadata?.name;
                console.log(`ğŸ“ Original name: ${originalName}`);
                
                // Update the name
                if (conversationMetadata[conversationFolder]) {
                    conversationMetadata[conversationFolder].metadata.name = newName;
                    
                    // Save to server
                    const updatedConfig = {
                        conversations: conversationMetadata,
                        total_conversations: Object.keys(conversationMetadata).length,
                        file_mappings: Object.fromEntries(
                            Object.entries(conversationMetadata).map(([folder, data]) => [
                                folder,
                                data.emotion_file || `conversations/${folder}/emotions${data.number}.json`
                            ])
                        ),
                        last_metadata_update: new Date().toISOString()
                    };
                    
                    const response = await fetch(`${apiBaseUrl}/api/save-config`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            filename: 'config/conversations_config.json',
                            content: updatedConfig
                        })
                    });
                    
                    if (response.ok) {
                        console.log('âœ… Save successful');
                        
                        // Wait a moment, then reload
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        await loadConversationMetadata(true);
                        
                        const reloadedName = conversationMetadata[conversationFolder]?.metadata?.name;
                        console.log(`ğŸ“ Reloaded name: ${reloadedName}`);
                        
                        if (reloadedName === newName) {
                            console.log('âœ… Save/load cycle successful!');
                            return true;
                        } else {
                            console.error('âŒ Save/load cycle failed - names do not match');
                            return false;
                        }
                    } else {
                        console.error('âŒ Save failed:', response.status);
                        return false;
                    }
                } else {
                    console.error('âŒ Conversation not found:', conversationFolder);
                    return false;
                }
                         } catch (error) {
                 console.error('âŒ Test failed:', error);
                 return false;
             }
         }
         
         // ğŸ§ª COMPREHENSIVE TEST FUNCTION: Test name persistence across all components
         window.testNamePersistenceAcrossComponents = async function(conversationFolder = 'convo1', testName = null) {
             const uniqueTestName = testName || `Test Name ${Date.now()}`;
             console.log(`ğŸ§ª COMPREHENSIVE TEST: Testing name persistence for ${conversationFolder} with name: "${uniqueTestName}"`);
             
             try {
                 // Step 1: Save the name via metadata
                 console.log('ğŸ“ Step 1: Saving name via metadata system...');
                 
                 await loadConversationMetadata(true);
                 if (!conversationMetadata[conversationFolder]) {
                     console.error(`âŒ Conversation ${conversationFolder} not found`);
                     return false;
                 }
                 
                 const originalName = conversationMetadata[conversationFolder].metadata.name;
                 console.log(`ğŸ“ Original name: "${originalName}"`);
                 
                 // Update the name
                 conversationMetadata[conversationFolder].metadata.name = uniqueTestName;
                 
                 const updatedConfig = {
                     conversations: conversationMetadata,
                     total_conversations: Object.keys(conversationMetadata).length,
                     file_mappings: Object.fromEntries(
                         Object.entries(conversationMetadata).map(([folder, data]) => [
                             folder,
                             data.emotion_file || `conversations/${folder}/emotions${data.number}.json`
                         ])
                     ),
                     last_metadata_update: new Date().toISOString()
                 };
                 
                 const saveResponse = await fetch(`${apiBaseUrl}/api/save-config`, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({
                         filename: 'config/conversations_config.json',
                         content: updatedConfig
                     })
                 });
                 
                 if (!saveResponse.ok) {
                     console.error('âŒ Save failed:', saveResponse.status);
                     return false;
                 }
                 
                 console.log('âœ… Step 1 completed: Name saved to server');
                 
                 // Step 2: Test metadata tab reload
                 console.log('ğŸ”„ Step 2: Testing metadata tab reload...');
                 await new Promise(resolve => setTimeout(resolve, 500));
                 await loadConversationMetadata(true);
                 
                 const metadataReloadName = conversationMetadata[conversationFolder]?.metadata?.name;
                 console.log(`ğŸ“ Metadata reload name: "${metadataReloadName}"`);
                 
                 if (metadataReloadName !== uniqueTestName) {
                     console.error('âŒ Step 2 failed: Metadata tab reload name mismatch');
                     return false;
                 }
                 console.log('âœ… Step 2 completed: Metadata tab reload successful');
                 
                 // Step 3: Test edit parameters tab reload  
                 console.log('ğŸ”„ Step 3: Testing edit parameters tab reload...');
                 await loadConversations(true);
                 
                 const editTabReloadName = conversationsData[conversationFolder]?.metadata?.name;
                 console.log(`ğŸ“ Edit tab reload name: "${editTabReloadName}"`);
                 
                 if (editTabReloadName !== uniqueTestName) {
                     console.error('âŒ Step 3 failed: Edit parameters tab reload name mismatch');
                     return false;
                 }
                 console.log('âœ… Step 3 completed: Edit parameters tab reload successful');
                 
                 // Step 4: Test config file direct read
                 console.log('ğŸ”„ Step 4: Testing direct config file read...');
                 const directConfigResponse = await fetch(`${apiBaseUrl}/config/conversations_config.json?v=${Date.now()}`, {
                     cache: 'no-cache',
                     headers: {
                         'Cache-Control': 'no-cache, no-store, must-revalidate',
                         'Pragma': 'no-cache',
                         'Expires': '0'
                     }
                 });
                 
                 if (!directConfigResponse.ok) {
                     console.error('âŒ Step 4 failed: Could not read config file directly');
                     return false;
                 }
                 
                 const directConfig = await directConfigResponse.json();
                 const directConfigName = directConfig.conversations[conversationFolder]?.metadata?.name;
                 console.log(`ğŸ“ Direct config name: "${directConfigName}"`);
                 
                 if (directConfigName !== uniqueTestName) {
                     console.error('âŒ Step 4 failed: Direct config file read name mismatch');
                     return false;
                 }
                 console.log('âœ… Step 4 completed: Direct config file read successful');
                 
                 // Step 5: Restore original name
                 console.log('ğŸ”„ Step 5: Restoring original name...');
                 conversationMetadata[conversationFolder].metadata.name = originalName;
                 
                 const restoreConfig = {
                     conversations: conversationMetadata,
                     total_conversations: Object.keys(conversationMetadata).length,
                     file_mappings: Object.fromEntries(
                         Object.entries(conversationMetadata).map(([folder, data]) => [
                             folder,
                             data.emotion_file || `conversations/${folder}/emotions${data.number}.json`
                         ])
                     ),
                     last_metadata_update: new Date().toISOString()
                 };
                 
                 const restoreResponse = await fetch(`${apiBaseUrl}/api/save-config`, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({
                         filename: 'config/conversations_config.json',
                         content: restoreConfig
                     })
                 });
                 
                 if (restoreResponse.ok) {
                     console.log('âœ… Step 5 completed: Original name restored');
                 } else {
                     console.warn('âš ï¸ Step 5 warning: Could not restore original name');
                 }
                 
                 console.log('ğŸ‰ COMPREHENSIVE TEST PASSED: Name persistence works across all components!');
                 return true;
                 
             } catch (error) {
                 console.error('âŒ COMPREHENSIVE TEST FAILED:', error);
                 return false;
             }
         }

        async function selectConversation(folder) {
            // Debounce to prevent rapid clicking
            if (conversationSelectTimeout) {
                clearTimeout(conversationSelectTimeout);
            }
            
            conversationSelectTimeout = setTimeout(async () => {
                await selectConversationImmediate(folder);
            }, 300); // 300ms debounce
        }
        
        async function selectConversationImmediate(folder) {
            // Prevent multiple simultaneous selections
            if (isSelectingConversation) {
                console.log('â³ Already selecting conversation, skipping...');
                return;
            }
            
            // Don't reselect the same conversation
            if (currentConversation === folder) {
                console.log(`ğŸ“ Conversation ${folder} is already selected`);
                return;
            }
            
            console.log(`Selecting conversation: ${folder}`);
            isSelectingConversation = true;
            
            try {
                // Stop any current loops when switching conversations
            if (currentLoopingSegment) {
                stopLoop();
                const loopBtns = document.querySelectorAll('.loop-button');
                loopBtns.forEach(btn => {
                    btn.classList.remove('active');
                    btn.title = '×œ×•×œ××”';
                });
            }
            
            // Clear pending changes
            pendingChanges = {};
            hasUnsavedChanges = false;
            
            // Update save button state
            updateSaveButtonState();
            
            // Ensure emotions config is loaded before showing conversation
            if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                console.log('ğŸ¨ Emotions config not loaded, loading now...');
                await loadEmotionsConfig();
            }
            
            // Update UI - find the conversation item by folder and mark it as active
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.remove('active');
                // Check if this item corresponds to the selected folder by looking at the folder span
                const conversationStats = item.querySelector('.conversation-stats');
                if (conversationStats) {
                    const folderSpan = conversationStats.querySelector('span');
                    if (folderSpan && folderSpan.textContent === `ğŸ“ ${folder}`) {
                        item.classList.add('active');
                    }
                }
            });

            currentConversation = folder;
            const convData = conversationsData[folder];
            
            if (!convData) {
                console.error(`No conversation data found for ${folder}`);
                showStatus(`×œ× × ××¦××• × ×ª×•× ×™× ×¢×‘×•×¨ ${folder}`, 'error');
                return;
            }
            
            // Show editor
            document.getElementById('no-selection').style.display = 'none';
            document.getElementById('conversation-editor').style.display = 'flex';
            document.getElementById('conversation-title').textContent = `×©×™×—×” ${convData.number}`;

            // Clear existing segments and show loading
            const segmentsContainer = document.getElementById('segments-container');
            if (segmentsContainer) {
                segmentsContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666;">
                        <div style="margin-bottom: 20px;">ğŸ”„</div>
                        <div>×˜×•×¢×Ÿ ×§×˜×¢×™ ×©×™×—×” ${folder}...</div>
                    </div>
                `;
            }

            // Load emotion data
            await loadEmotionData(folder);
            
            // Ensure segments are displayed after loading
            if (emotionData && Object.keys(emotionData).length > 0) {
                console.log(`âœ… Successfully loaded conversation ${folder} with ${Object.keys(emotionData).length} items`);
                displaySegments();
                
                // Show success message with segment count
                const mp3Count = Object.keys(emotionData).filter(key => key.endsWith('.mp3')).length;
                showStatus(`âœ… × ×˜×¢× ×” ×©×™×—×” ${folder} ×¢× ${mp3Count} ×§×˜×¢×™ ××•×“×™×•`, 'success');
            } else {
                console.warn(`âš ï¸ No emotion data loaded for ${folder}`);
                if (segmentsContainer) {
                    segmentsContainer.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #999;">
                            <div style="margin-bottom: 20px;">âš ï¸</div>
                            <div>×œ× × ××¦××• ×§×˜×¢×™ ×©×™×—×” ×¢×‘×•×¨ ${folder}</div>
                            <button class="btn btn-primary" onclick="loadEmotionData('${folder}')" style="margin-top: 15px;">
                                ğŸ”„ × ×¡×” ×©×•×‘
                            </button>
                        </div>
                    `;
                }
                showStatus(`âš ï¸ ×œ× × ××¦××• × ×ª×•× ×™ ×¨×’×©×•×ª ×¢×‘×•×¨ ${folder}`, 'warning');
            }
            } finally {
                isSelectingConversation = false;
            }
        }

        async function loadEmotionData(folder) {
            // Prevent multiple concurrent loads
            if (isLoadingEmotionData) {
                console.log('â³ Already loading emotion data, skipping...');
                return;
            }
            
            // Rate limiting to prevent server overload
            const now = Date.now();
            if (now - lastRequestTime < MIN_REQUEST_INTERVAL) {
                console.log('ğŸš¦ Rate limiting: waiting before next request');
                await new Promise(resolve => setTimeout(resolve, MIN_REQUEST_INTERVAL - (now - lastRequestTime)));
            }
            lastRequestTime = Date.now();
            
            // Cancel any existing request
            if (currentEmotionController) {
                console.log('ğŸš« Canceling previous emotion data request');
                currentEmotionController.abort();
                currentEmotionController = null;
            }
            
            try {
                isLoadingEmotionData = true;
                showLoading('×˜×•×¢×Ÿ × ×ª×•× ×™ ×¨×’×©×•×ª...');
                const convData = conversationsData[folder];
                let emotionFile = convData.ai_file || convData.emotion_file || `emotions${convData.number}_ai_analyzed.json`;
                
                // Fix path - ensure we don't double the conversations/folder part
                if (!emotionFile.startsWith('conversations/')) {
                    emotionFile = `conversations/${folder}/${emotionFile}`;
                }
                
                // Create new controller for this request
                currentEmotionController = new AbortController();
                const timeoutId = setTimeout(() => {
                    if (currentEmotionController) {
                        console.log('â° Request timed out after 15 seconds');
                        currentEmotionController.abort();
                    }
                }, 45000); // Increased to 45 second timeout for large files
                
                console.log(`Loading emotion data from: ${apiBaseUrl}/${emotionFile}`);
                
                // Add cache-busting for fresh data after transcription
                const timestamp = new Date().getTime();
                const cacheBuster = Math.random().toString(36).substring(7);
                const fileUrl = `${apiBaseUrl}/${emotionFile}?t=${timestamp}&r=${cacheBuster}&v=3`;
                
                const response = await fetch(fileUrl, {
                    signal: currentEmotionController.signal,
                    cache: 'no-store', // Force fresh data to show transcription updates
                    headers: {
                        'Accept': 'application/json',
                        'Accept-Encoding': 'gzip, deflate'
                    }
                });
                console.log(`ğŸ”„ Loading with cache-busting: t=${timestamp}&r=${cacheBuster}`);
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`Failed to load emotion data: ${response.status} ${response.statusText}`);
                }
                
                // Store ETag for future requests
                const etag = response.headers.get('ETag');
                if (etag) {
                    emotionDataETag = etag;
                }
                
                const responseText = await response.text();
                if (!responseText || responseText.trim() === '') {
                    throw new Error('Empty emotion data response');
                }
                
                console.log(`Response text length: ${responseText.length} characters`);
                console.log(`Response preview: ${responseText.substring(0, 100)}...`);
                
                try {
                    emotionData = JSON.parse(responseText);
                } catch (parseError) {
                    console.error('JSON Parse Error Details:', {
                        error: parseError.message,
                        responseLength: responseText.length,
                        responseStart: responseText.substring(0, 200),
                        responseEnd: responseText.substring(Math.max(0, responseText.length - 200))
                    });
                    throw new Error(`Invalid emotion data JSON: ${parseError.message}. Response length: ${responseText.length}`);
                }
                console.log(`Successfully loaded ${Object.keys(emotionData).length} items`);
                
                // Load speaker info for this conversation
                await loadSpeakerInfo(folder);
                
                // Update current conversation tracker for speaker names
                if (currentConversation !== folder) {
                    currentConversation = folder;
                    console.log(`ğŸ”„ Updated current conversation to: ${folder}`);
                }
                
                displaySegments();
            } catch (error) {
                console.error('Error loading emotion data:', error);
                if (error.name === 'AbortError') {
                    // Check if this was a timeout or a manual cancellation
                    if (currentEmotionController === null) {
                        console.log('ğŸ“ Request was cancelled for new selection');
                        return; // Don't show error for cancelled requests
                    } else {
                        showStatus('×”×˜×¢×™× ×” ×œ×§×—×” ×™×•×ª×¨ ××“×™ ×–××Ÿ (15 ×©× ×™×•×ª). ×‘×“×•×§ ××ª ×”×—×™×‘×•×¨ ×œ××™× ×˜×¨× ×˜.', 'error');
                    }
                } else if (error.message.includes('JSON')) {
                    showStatus('×©×’×™××” ×‘×¤×•×¨××˜ ×”× ×ª×•× ×™×. ×”×§×•×‘×¥ ×¢×œ×•×œ ×œ×”×™×•×ª ×¤×’×•×. × ×¡×” ×œ×™×¦×•×¨ ××—×“×© ×¢× AI.', 'error');
                } else {
                    showStatus(`×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™ ×”×¨×’×©×•×ª: ${error.message}`, 'error');
                }
                
                // Clear the segments container on error
                const container = document.getElementById('segments-container');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #999;">
                            <p>âš ï¸ ×©×’×™××” ×‘×˜×¢×™× ×ª ×”× ×ª×•× ×™×</p>
                            <button class="btn btn-primary" onclick="loadEmotionData('${currentConversation}')">
                                ğŸ”„ × ×¡×” ×©×•×‘
                            </button>
                        </div>
                    `;
                }
            } finally {
                isLoadingEmotionData = false;
                currentEmotionController = null;
                hideLoading();
            }
        }

        // Load speaker info for current conversation
        async function loadSpeakerInfo(conversationId) {
            try {
                const response = await fetch(`${apiBaseUrl}/api/get-speaker-info/${conversationId}`);
                if (response.ok) {
                    const data = await response.json();
                    window.speakerInfo = data.speakers;
                    console.log('ğŸ­ Speaker info loaded:', window.speakerInfo);
                    
                    // Refresh any existing displays that might use speaker names
                    refreshSpeakerDisplays();
                } else {
                    console.warn('âš ï¸ Failed to load speaker info');
                    window.speakerInfo = {};
                }
            } catch (error) {
                console.warn('âš ï¸ Error loading speaker info:', error);
                window.speakerInfo = {};
            }
        }

        // Refresh speaker displays throughout the interface
        function refreshSpeakerDisplays() {
            // Update all speaker indicators and tooltips
            document.querySelectorAll('.speaker-indicator').forEach(indicator => {
                const mp3File = indicator.id.replace('speaker-indicator-', '');
                if (emotionData && emotionData[mp3File]) {
                    const speaker = emotionData[mp3File].speaker || 0;
                    indicator.title = getSpeakerName(speaker);
                }
            });
            
            // Update all speaker display elements
            document.querySelectorAll('[id^="speaker-display-"]').forEach(element => {
                const mp3File = element.id.replace('speaker-display-', '');
                if (emotionData && emotionData[mp3File]) {
                    const speaker = emotionData[mp3File].speaker || 0;
                    element.textContent = `ğŸ”Š ${getSpeakerName(speaker)}`;
                }
            });
        }

        // Get speaker name with fallback to default
        function getSpeakerName(speakerNumber) {
            // First try window.speakerInfo (from API)
            if (window.speakerInfo && window.speakerInfo[speakerNumber.toString()]) {
                return window.speakerInfo[speakerNumber.toString()].name;
            }
            
            // Then try conversation metadata (current conversation)
            if (!currentMetadataConversation || !conversationMetadata[currentMetadataConversation]) {
                return speakerNumber === 0 ? '×“×•×‘×¨ 1' : '×“×•×‘×¨ 2';
            }
            
            const metadata = conversationMetadata[currentMetadataConversation].metadata || {};
            const speakerName = speakerNumber === 0 ? metadata.speaker1Name : metadata.speaker2Name;
            
            if (speakerName && speakerName.trim()) {
                return speakerName.trim();
            }
            
            return speakerNumber === 0 ? '×“×•×‘×¨ 1' : '×“×•×‘×¨ 2';
        }

        function displaySegments() {
            const container = document.getElementById('segments-container');
            if (!container) {
                console.error('âŒ segments-container not found!');
                return;
            }
            
            container.innerHTML = '';

            // Filter out non-mp3 entries and sort them
            const mp3Files = Object.keys(emotionData || {})
                .filter(key => key.endsWith('.mp3'))
                .sort((a, b) => {
                    try {
                        return a.localeCompare(b, 'he', { numeric: true });
                    } catch(e) {
                        return a > b ? 1 : -1;
                    }
                });
            
            console.log(`ğŸ“Š Displaying ${mp3Files.length} MP3 segments:`, mp3Files.slice(0, 5));
            
            if (mp3Files.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #999;">
                        <div style="margin-bottom: 20px;">ğŸ“‚</div>
                        <div>××™×Ÿ ×§×˜×¢×™ MP3 ×–××™× ×™× ×‘×©×™×—×” ×–×•</div>
                        <div style="font-size: 0.9rem; margin-top: 10px; color: #666;">
                            ×™×™×ª×›×Ÿ ×©×”×©×™×—×” ×¢×“×™×™×Ÿ ×œ× ×¢×•×‘×“×” ××• ×©××™×Ÿ ×‘×” ×§×˜×¢×™ ××•×“×™×•
                        </div>
                    </div>
                `;
                return;
            }

            // Add header with segment count
            const headerDiv = document.createElement('div');
            headerDiv.innerHTML = `
                <div style="background: #f8f9fa; padding: 15px; margin-bottom: 15px; border-radius: 8px; border: 1px solid #e9ecef;">
                    <h4 style="margin: 0; color: #495057;">
                        ğŸµ ×§×˜×¢×™ ×”×©×™×—×” (${mp3Files.length})
                    </h4>
                    <div style="font-size: 0.9rem; color: #6c757d; margin-top: 5px;">
                        ×œ×—×¥ ×¢×œ ×§×˜×¢ ×›×“×™ ×œ×¢×¨×•×š ××ª ×”×¤×¨××˜×¨×™× ×©×œ×•
                    </div>
                </div>
            `;
            container.appendChild(headerDiv);

            // Create segment elements
            mp3Files.forEach((mp3File, index) => {
                const segment = emotionData[mp3File];
                if (!segment) {
                    console.warn(`âš ï¸ No segment data found for ${mp3File}`);
                    return;
                }
                
                const segmentDiv = createSegmentElement(segment, index);
                container.appendChild(segmentDiv);
            });
            
            console.log(`âœ… Successfully displayed ${mp3Files.length} segments in UI`);
            
            // Populate all emotion dropdowns after segments are displayed and sync all UI elements
            setTimeout(() => {
                populateAllEmotionDropdowns();
                
                // âœ… COMPREHENSIVE SYNC: Ensure all segments' UI elements are synchronized after display
                mp3Files.forEach(mp3File => {
                    if (emotionData[mp3File]) {
                        // Apply AI constraints before sync
                        applyAIConstraintsToSegment(mp3File);
                        syncAllSegmentElements(mp3File);
                    }
                });
                
                // âœ¨ Initialize enhanced sliders after segments are displayed
                initializeEnhancedSliders();
            }, 100);
        }

        function createSegmentElement(segment, index) {
            const mp3Files = Object.keys(emotionData || {}).filter(key => key.endsWith('.mp3')).sort((a, b) => {
                try {
                    return a.localeCompare(b, 'he', { numeric: true });
                } catch(e) {
                    return a > b ? 1 : -1;
                }
            });
            const mp3File = mp3Files[index];
            
            if (!mp3File) {
                console.error(`âŒ No MP3 file found at index ${index}`);
                return document.createElement('div');
            }
            
            const div = document.createElement('div');
            div.className = 'segment-item';
            div.id = `segment-${mp3File}`;
            
            const speakerClass = `speaker-${segment.speaker || 0}`;
            const emotions = segment.emotions || ['neutral'];
            const isAIAnalyzed = segment.ai_analyzed || false;
            const transcript = segment.transcript || segment.words || '';
            
            // Create emotion display with proper names from emotions config
            const emotionDisplay = emotions.map(e => {
                const config = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                const emoji = config.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                const hebrew = config.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                return emoji ? `${emoji} ${hebrew}` : hebrew;
            }).join(', ');
            
            // Create effects display
            const effects = [];
            if (segment.blur > 0) effects.push(`ğŸŒ«ï¸ ×˜×©×˜×•×©: ${segment.blur}`);
            if (segment.humor > 0) effects.push(`ğŸ˜„ ×”×•××•×¨: ${segment.humor}`);
            if (segment.shine > 0) effects.push(`âœ¨ ×‘×¨×§: ${segment.shine}`);
            
            // Get all available emotions for dropdown
            const allEmotions = emotionsConfig ? 
                Object.keys(emotionsConfig).filter(emotion => emotionsConfig[emotion].active) :
                ['happiness', 'sadness', 'anger', 'fear', 'surprise', 'disgust', 'neutral', 'curiosity', 'excitement'];
            
            const emotionOptions = allEmotions.map(emotion => {
                const config = (emotionsConfig && emotionsConfig[emotion]) || {};
                const displayName = config.hebrew ? `${config.emoji || ''} ${config.hebrew}` : emotion;
                return `<option value="${emotion}">${displayName}</option>`;
            }).join('');
            
            div.innerHTML = `
                <div class="enhanced-segment-card" style="background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%); border: 2px solid #e9ecef; border-radius: 12px; margin-bottom: 12px; overflow: hidden; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); position: relative; box-shadow: 0 2px 8px rgba(0,0,0,0.04);">
                    
                    <!-- Header Section -->
                    <div class="segment-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 1.1rem; font-weight: 600;">ğŸµ ${mp3File}</span>
                                <div class="speaker-selector" style="display: flex; align-items: center; gap: 6px;">
                                    <span style="font-size: 0.85rem; opacity: 0.9;">×“×•×‘×¨:</span>
                                    <select onchange="updateParam('${mp3File}', 'speaker', this.value); updateSpeakerIndicator('${mp3File}', this.value)" 
                                            onclick="event.stopPropagation()"
                                            style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; color: white; padding: 4px 8px; font-size: 0.85rem; cursor: pointer; outline: none; transition: all 0.2s ease;">
                                                                        <option value="0" ${segment.speaker === 0 ? 'selected' : ''} style="color: #333;">${getSpeakerName(0)}</option>
                                <option value="1" ${segment.speaker === 1 ? 'selected' : ''} style="color: #333;">${getSpeakerName(1)}</option>
                                    </select>
                                                                          <span class="speaker-indicator" id="speaker-indicator-${mp3File}" style="display: inline-block; width: 14px; height: 14px; border-radius: 50%; background: ${segment.speaker === 1 ? '#4ECDC4' : '#FF6B6B'}; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.2);" title="${getSpeakerName(segment.speaker || 0)}"></span>
                                </div>
                            </div>
                            ${isAIAnalyzed ? '<span title="× ×•×ª×— ×¢×œ ×™×“×™ AI" style="background: rgba(76, 175, 80, 0.2); padding: 4px 8px; border-radius: 8px; font-size: 0.8rem; display: flex; align-items: center; gap: 4px;"><span>ğŸ¤–</span> AI</span>' : '<span style="background: rgba(158, 158, 158, 0.2); padding: 4px 8px; border-radius: 8px; font-size: 0.8rem; display: flex; align-items: center; gap: 4px;"><span>âš™ï¸</span> Manual</span>'}
                        </div>
                        <div style="display: flex; gap: 6px; align-items: center;">
                            <button onclick="event.stopPropagation(); selectSegment('${mp3File}', emotionData['${mp3File}'])" 
                                    style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 6px 10px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;"
                                    onmouseover="this.style.background='rgba(255,255,255,0.3)'"
                                    onmouseout="this.style.background='rgba(255,255,255,0.2)'"
                                    title="×¢×¨×™×›×” ××ª×§×“××ª">
                                <span>ğŸ”§</span> ××ª×§×“×
                            </button>
                            <button onclick="event.stopPropagation(); playSegmentAudio('${mp3File}')" 
                                    style="background: rgba(23, 162, 184, 0.8); border: none; color: white; padding: 6px 10px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;"
                                    onmouseover="this.style.background='rgba(23, 162, 184, 1)'"
                                    onmouseout="this.style.background='rgba(23, 162, 184, 0.8)'"
                                    title="×”×©××¢ ×§×˜×¢ ×–×”">
                                <span>â–¶ï¸</span> × ×’×Ÿ
                            </button>
                        </div>
                    </div>
                    
                    <!-- Content Section -->
                    <div class="segment-content" style="padding: 16px;">
                        
                        <!-- Inline Editable Transcript -->
                        <div class="transcript-section" style="margin-bottom: 16px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <span style="font-weight: 600; color: #495057; font-size: 0.9rem;">ğŸ“ ×˜×§×¡×˜:</span>
                                <span style="font-size: 0.8rem; color: #6c757d; opacity: 0.8;">×œ×—×¥ ×œ×¢×¨×™×›×”</span>
                            </div>
                            <div class="editable-transcript" 
                                 contenteditable="true"
                                 data-mp3="${mp3File}"
                                 onblur="updateTranscript('${mp3File}', this.textContent.trim())"
                                 oninput="markTranscriptAsModified('${mp3File}', this)"
                                 onkeydown="handleTranscriptKeydown(event, '${mp3File}')"
                                 onclick="event.stopPropagation()"
                                 placeholder="×”×§×œ×“ ×›××Ÿ ××ª ×”×˜×¨× ×¡×§×¨×™×¤×˜..."
                                 style="background: #f8f9fa; border: 2px solid #e9ecef; border-radius: 8px; padding: 12px; min-height: 60px; font-size: 0.9rem; line-height: 1.4; direction: rtl; text-align: right; transition: all 0.2s ease; cursor: text; color: #495057;"
                                 onfocus="this.style.borderColor='#667eea'; this.style.background='#fff'; this.style.boxShadow='0 0 0 3px rgba(102, 126, 234, 0.1)'"
                                 onblur="this.style.borderColor='#e9ecef'; this.style.background='#f8f9fa'; this.style.boxShadow='none'">${transcript}</div>
                            <div class="transcript-status" id="transcript-status-${mp3File}" style="font-size: 0.75rem; color: #28a745; margin-top: 4px; opacity: 0; transition: opacity 0.2s ease;"></div>
                        </div>
                        
                        <!-- Emotions Display -->
                        ${emotions.length > 0 ? `
                        <div style="margin-bottom: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <span style="font-weight: 600; color: #495057; font-size: 0.9rem;">ğŸ­ ×¨×’×©×•×ª:</span>
                            </div>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                ${emotions.map(e => {
                                    const config = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                                    const color = config.color || DEFAULT_EMOTIONS[e]?.color || '#667eea';
                                    const emoji = config.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                                    const hebrew = config.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                                    return `<span style="background: linear-gradient(135deg, ${color}20, ${color}10); border: 1px solid ${color}40; color: ${color}; padding: 4px 8px; border-radius: 6px; font-size: 0.8rem; display: flex; align-items: center; gap: 4px;">${emoji} ${hebrew}</span>`;
                                }).join('')}
                            </div>
                        </div>` : ''}
                        
                        <!-- Effects Display -->
                        ${effects.length > 0 ? `
                        <div style="margin-bottom: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <span style="font-weight: 600; color: #495057; font-size: 0.9rem;">ğŸ¨ ××¤×§×˜×™×:</span>
                            </div>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                ${effects.map(effect => `<span style="background: linear-gradient(135deg, #17a2b820, #17a2b810); border: 1px solid #17a2b840; color: #17a2b8; padding: 4px 8px; border-radius: 6px; font-size: 0.8rem;">${effect}</span>`).join('')}
                            </div>
                        </div>` : ''}
                        
                        <!-- Inline Parameter Editor -->
                        <div style="margin-bottom: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <span style="font-weight: 600; color: #495057; font-size: 0.9rem;">âš™ï¸ ×¤×¨××˜×¨×™×:</span>
                                <span style="font-size: 0.75rem; color: #6c757d; opacity: 0.8;">×‘×—×™×¨×” ××”×™×¨×”</span>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                <!-- Blob Size -->
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">ğŸ”µ ×’×•×“×œ Blob:</span>
                                    <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                        <select id="blob-size-${mp3File}" 
                                                class="modern-select-compact"
                                                onchange="updateParam('${mp3File}', 'blobSizeScale', this.value); showDropdownFeedback('${mp3File}', '×’×•×“×œ Blob');"
                                                onclick="event.stopPropagation()"
                                                style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                            <option value="0.5" ${(segment.blobSizeScale || 3) == 0.5 ? 'selected' : ''}>0.5 - ×§×˜×Ÿ ×××•×“</option>
                                            <option value="1" ${(segment.blobSizeScale || 3) == 1 ? 'selected' : ''}>1.0 - ×§×˜×Ÿ</option>
                                            <option value="1.5" ${(segment.blobSizeScale || 3) == 1.5 ? 'selected' : ''}>1.5 - ×§×˜×Ÿ-×‘×™× ×•× ×™</option>
                                            <option value="2" ${(segment.blobSizeScale || 3) == 2 ? 'selected' : ''}>2.0 - ×‘×™× ×•× ×™ ×§×˜×Ÿ</option>
                                            <option value="3" ${(segment.blobSizeScale || 3) == 3 ? 'selected' : ''}>3.0 - ×‘×™× ×•× ×™</option>
                                            <option value="4" ${(segment.blobSizeScale || 3) == 4 ? 'selected' : ''}>4.0 - ×‘×™× ×•× ×™ ×’×“×•×œ</option>
                                            <option value="5" ${(segment.blobSizeScale || 3) == 5 ? 'selected' : ''}>5.0 - ×’×“×•×œ</option>
                                            <option value="6" ${(segment.blobSizeScale || 3) == 6 ? 'selected' : ''}>6.0 - ×’×“×•×œ ×××•×“</option>
                                            <option value="7" ${(segment.blobSizeScale || 3) == 7 ? 'selected' : ''}>7.0 - ×¢× ×§</option>
                                            <option value="8" ${(segment.blobSizeScale || 3) == 8 ? 'selected' : ''}>8.0 - ××§×¡×™××œ×™</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <!-- Emotion Char Size -->
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">ğŸ­ ×ª×• ×¨×’×©:</span>
                                    <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                        <select id="emotion-char-size-${mp3File}" 
                                                class="modern-select-compact"
                                                onchange="updateParam('${mp3File}', 'coloredCircleCharSize', this.value); showDropdownFeedback('${mp3File}', '×ª×• ×¨×’×©');"
                                                onclick="event.stopPropagation()"
                                                style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                            <option value="0.8" ${(segment.coloredCircleCharSize || 1.2) == 0.8 ? 'selected' : ''}>0.8 - ×–×¢×™×¨</option>
                                            <option value="1.0" ${(segment.coloredCircleCharSize || 1.2) == 1.0 ? 'selected' : ''}>1.0 - ×§×˜×Ÿ</option>
                                            <option value="1.2" ${(segment.coloredCircleCharSize || 1.2) == 1.2 ? 'selected' : ''}>1.2 - ×¨×’×™×œ</option>
                                            <option value="1.5" ${(segment.coloredCircleCharSize || 1.2) == 1.5 ? 'selected' : ''}>1.5 - ×‘×™× ×•× ×™</option>
                                            <option value="2.0" ${(segment.coloredCircleCharSize || 1.2) == 2.0 ? 'selected' : ''}>2.0 - ×’×“×•×œ</option>
                                            <option value="3.0" ${(segment.coloredCircleCharSize || 1.2) == 3.0 ? 'selected' : ''}>3.0 - ×’×“×•×œ ×××•×“</option>
                                            <option value="4.0" ${(segment.coloredCircleCharSize || 1.2) == 4.0 ? 'selected' : ''}>4.0 - ×¢× ×§</option>
                                            <option value="5.0" ${(segment.coloredCircleCharSize || 1.2) == 5.0 ? 'selected' : ''}>5.0 - ×¢× ×§×™</option>
                                            <option value="6.0" ${(segment.coloredCircleCharSize || 1.2) == 6.0 ? 'selected' : ''}>6.0 - ××¡×™×‘×™</option>
                                            <option value="8.0" ${(segment.coloredCircleCharSize || 1.2) == 8.0 ? 'selected' : ''}>8.0 - ××§×¡×™××œ×™</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <!-- Regular Char Size -->
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">ğŸ“ ×ª×• ×¨×’×™×œ:</span>
                                    <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                        <select id="regular-char-size-${mp3File}" 
                                                class="modern-select-compact"
                                                onchange="updateParam('${mp3File}', 'regularAsciiCharSize', this.value); showDropdownFeedback('${mp3File}', '×ª×• ×¨×’×™×œ');"
                                                onclick="event.stopPropagation()"
                                                style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                            <option value="0.5" ${(segment.regularAsciiCharSize || 1.0) == 0.5 ? 'selected' : ''}>0.5 - ×–×¢×™×¨</option>
                                            <option value="0.8" ${(segment.regularAsciiCharSize || 1.0) == 0.8 ? 'selected' : ''}>0.8 - ×§×˜×Ÿ ×××•×“</option>
                                            <option value="1.0" ${(segment.regularAsciiCharSize || 1.0) == 1.0 ? 'selected' : ''}>1.0 - ×¨×’×™×œ</option>
                                            <option value="1.2" ${(segment.regularAsciiCharSize || 1.0) == 1.2 ? 'selected' : ''}>1.2 - ×‘×™× ×•× ×™ ×§×˜×Ÿ</option>
                                            <option value="1.5" ${(segment.regularAsciiCharSize || 1.0) == 1.5 ? 'selected' : ''}>1.5 - ×‘×™× ×•× ×™</option>
                                            <option value="2.0" ${(segment.regularAsciiCharSize || 1.0) == 2.0 ? 'selected' : ''}>2.0 - ×’×“×•×œ</option>
                                            <option value="3.0" ${(segment.regularAsciiCharSize || 1.0) == 3.0 ? 'selected' : ''}>3.0 - ×’×“×•×œ ×××•×“</option>
                                            <option value="4.0" ${(segment.regularAsciiCharSize || 1.0) == 4.0 ? 'selected' : ''}>4.0 - ×¢× ×§</option>
                                            <option value="5.0" ${(segment.regularAsciiCharSize || 1.0) == 5.0 ? 'selected' : ''}>5.0 - ×¢× ×§×™</option>
                                            <option value="6.0" ${(segment.regularAsciiCharSize || 1.0) == 6.0 ? 'selected' : ''}>6.0 - ××§×¡×™××œ×™</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <!-- Emotion Amount -->
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">ğŸ¨ ×›××•×ª ×¨×’×©:</span>
                                    <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                        <select id="emotion-amount-${mp3File}" 
                                                class="modern-select-compact"
                                                onchange="updateParam('${mp3File}', 'emotionCharAmount', this.value); showDropdownFeedback('${mp3File}', '×›××•×ª ×¨×’×©');"
                                                onclick="event.stopPropagation()"
                                                style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                            <option value="10" ${(segment.emotionCharAmount || 50) == 10 ? 'selected' : ''}>10% - ××™× ×™××œ×™</option>
                                            <option value="25" ${(segment.emotionCharAmount || 50) == 25 ? 'selected' : ''}>25% - ×§×˜×Ÿ</option>
                                            <option value="40" ${(segment.emotionCharAmount || 50) == 40 ? 'selected' : ''}>40% - ×‘×™× ×•× ×™ × ××•×š</option>
                                            <option value="50" ${(segment.emotionCharAmount || 50) == 50 ? 'selected' : ''}>50% - ×‘×™× ×•× ×™</option>
                                            <option value="75" ${(segment.emotionCharAmount || 50) == 75 ? 'selected' : ''}>75% - ×’×‘×•×”</option>
                                            <option value="100" ${(segment.emotionCharAmount || 50) == 100 ? 'selected' : ''}>100% - ×’×‘×•×” ×××•×“</option>
                                            <option value="125" ${(segment.emotionCharAmount || 50) == 125 ? 'selected' : ''}>125% - ××™× ×˜× ×¡×™×‘×™</option>
                                            <option value="150" ${(segment.emotionCharAmount || 50) == 150 ? 'selected' : ''}>150% - ×§×™×¦×•× ×™</option>
                                            <option value="200" ${(segment.emotionCharAmount || 50) == 200 ? 'selected' : ''}>200% - ××¨×‘×™</option>
                                            <option value="300" ${(segment.emotionCharAmount || 50) == 300 ? 'selected' : ''}>300% - ××§×¡×™××œ×™</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Visual Effects Section -->
                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e9ecef;">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="font-weight: 600; color: #495057; font-size: 0.9rem;">ğŸ¨ ××¤×§×˜×™× ×•×™×–×•××œ×™×™×:</span>
                                    <span style="font-size: 0.75rem; color: #6c757d; opacity: 0.8;">×‘×§×¨×” ××ª×§×“××ª</span>
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                    <!-- Blobiness -->
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">ğŸ«§ Blobiness:</span>
                                        <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                            <select id="blobiness-${mp3File}" 
                                                    class="modern-select-compact"
                                                    onchange="updateParam('${mp3File}', 'blobiness', this.value); showDropdownFeedback('${mp3File}', 'Blobiness');"
                                                    onclick="event.stopPropagation()"
                                                    style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                                <option value="1.0" ${(segment.blobiness || 3.5) == 1.0 ? 'selected' : ''}>1.0 - ×—×“</option>
                                                <option value="1.5" ${(segment.blobiness || 3.5) == 1.5 ? 'selected' : ''}>1.5 - ×§×©×™×—</option>
                                                <option value="2.0" ${(segment.blobiness || 3.5) == 2.0 ? 'selected' : ''}>2.0 - ××•×¦×§</option>
                                                <option value="2.5" ${(segment.blobiness || 3.5) == 2.5 ? 'selected' : ''}>2.5 - ×§×œ ×¨×š</option>
                                                <option value="3.0" ${(segment.blobiness || 3.5) == 3.0 ? 'selected' : ''}>3.0 - ×¨×š</option>
                                                <option value="3.5" ${(segment.blobiness || 3.5) == 3.5 ? 'selected' : ''}>3.5 - ×¨×’×™×œ</option>
                                                <option value="4.0" ${(segment.blobiness || 3.5) == 4.0 ? 'selected' : ''}>4.0 - × ×•×–×œ×™</option>
                                                <option value="5.0" ${(segment.blobiness || 3.5) == 5.0 ? 'selected' : ''}>5.0 - × ×•×–×œ×™ ×××•×“</option>
                                                <option value="6.0" ${(segment.blobiness || 3.5) == 6.0 ? 'selected' : ''}>6.0 - ×–×•×¨×</option>
                                                <option value="8.0" ${(segment.blobiness || 3.5) == 8.0 ? 'selected' : ''}>8.0 - × ×•×–×œ ×§×™×¦×•× ×™</option>
                                                <option value="10.0" ${(segment.blobiness || 3.5) == 10.0 ? 'selected' : ''}>10.0 - ××§×¡×™××œ×™</option>
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <!-- Humor -->
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">ğŸ˜„ ×”×•××•×¨:</span>
                                        <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                            <select id="humor-${mp3File}" 
                                                    class="modern-select-compact"
                                                    onchange="updateParam('${mp3File}', 'humor', this.value); showDropdownFeedback('${mp3File}', '×”×•××•×¨');"
                                                    onclick="event.stopPropagation()"
                                                    style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                                <option value="0" ${(segment.humor || 0) == 0 ? 'selected' : ''}>0 - ×œ×œ×</option>
                                                <option value="1" ${(segment.humor || 0) == 1 ? 'selected' : ''}>1 - ××¢×˜</option>
                                                <option value="2" ${(segment.humor || 0) == 2 ? 'selected' : ''}>2 - ×§×œ</option>
                                                <option value="3" ${(segment.humor || 0) == 3 ? 'selected' : ''}>3 - ×‘×™× ×•× ×™</option>
                                                <option value="4" ${(segment.humor || 0) == 4 ? 'selected' : ''}>4 - ×˜×•×‘</option>
                                                <option value="5" ${(segment.humor || 0) == 5 ? 'selected' : ''}>5 - ×’×‘×•×”</option>
                                                <option value="6" ${(segment.humor || 0) == 6 ? 'selected' : ''}>6 - ××¦×—×™×§</option>
                                                <option value="7" ${(segment.humor || 0) == 7 ? 'selected' : ''}>7 - ×××•×“ ××¦×—×™×§</option>
                                                <option value="8" ${(segment.humor || 0) == 8 ? 'selected' : ''}>8 - ×”×™×œ×¨×™×˜×™</option>
                                                <option value="9" ${(segment.humor || 0) == 9 ? 'selected' : ''}>9 - ×§×•××“×™×”</option>
                                                <option value="10" ${(segment.humor || 0) == 10 ? 'selected' : ''}>10 - ××§×¡×™××œ×™</option>
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <!-- Blur (×˜×©×˜×•×©) -->
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">ğŸŒ«ï¸ ×˜×©×˜×•×©:</span>
                                        <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                            <select id="blur-${mp3File}" 
                                                    class="modern-select-compact"
                                                    onchange="updateParam('${mp3File}', 'blur', this.value); showDropdownFeedback('${mp3File}', '×˜×©×˜×•×©');"
                                                    onclick="event.stopPropagation()"
                                                    style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                                <option value="0" ${(segment.blur || 0) == 0 ? 'selected' : ''}>0 - ×œ×œ×</option>
                                                <option value="1" ${(segment.blur || 0) == 1 ? 'selected' : ''}>1 - ××¢×˜</option>
                                                <option value="2" ${(segment.blur || 0) == 2 ? 'selected' : ''}>2 - ×§×œ</option>
                                                <option value="3" ${(segment.blur || 0) == 3 ? 'selected' : ''}>3 - ×‘×™× ×•× ×™ × ××•×š</option>
                                                <option value="4" ${(segment.blur || 0) == 4 ? 'selected' : ''}>4 - ×‘×™× ×•× ×™</option>
                                                <option value="5" ${(segment.blur || 0) == 5 ? 'selected' : ''}>5 - ×‘×™× ×•× ×™ ×’×‘×•×”</option>
                                                <option value="6" ${(segment.blur || 0) == 6 ? 'selected' : ''}>6 - ××˜×•×©×˜×©</option>
                                                <option value="7" ${(segment.blur || 0) == 7 ? 'selected' : ''}>7 - ×××•×“ ××˜×•×©×˜×©</option>
                                                <option value="8" ${(segment.blur || 0) == 8 ? 'selected' : ''}>8 - ×—×œ×•××™</option>
                                                <option value="10" ${(segment.blur || 0) == 10 ? 'selected' : ''}>10 - ×§×™×¦×•× ×™</option>
                                                <option value="12" ${(segment.blur || 0) == 12 ? 'selected' : ''}>12 - ××§×¡×™××œ×™</option>
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <!-- Shine (×‘×¨×§) -->
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">âœ¨ ×‘×¨×§:</span>
                                        <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                            <select id="shine-${mp3File}" 
                                                    class="modern-select-compact"
                                                    onchange="updateParam('${mp3File}', 'shine', this.value); showDropdownFeedback('${mp3File}', '×‘×¨×§');"
                                                    onclick="event.stopPropagation()"
                                                    style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                                <option value="0" ${(segment.shine || 0) == 0 ? 'selected' : ''}>0 - ×œ×œ×</option>
                                                <option value="1" ${(segment.shine || 0) == 1 ? 'selected' : ''}>1 - × ×¦× ×•×¥</option>
                                                <option value="2" ${(segment.shine || 0) == 2 ? 'selected' : ''}>2 - ×§×œ</option>
                                                <option value="3" ${(segment.shine || 0) == 3 ? 'selected' : ''}>3 - ×‘×™× ×•× ×™</option>
                                                <option value="4" ${(segment.shine || 0) == 4 ? 'selected' : ''}>4 - ×‘×•×”×§</option>
                                                <option value="5" ${(segment.shine || 0) == 5 ? 'selected' : ''}>5 - ××‘×¨×™×§</option>
                                                <option value="6" ${(segment.shine || 0) == 6 ? 'selected' : ''}>6 - ×–×•×”×¨</option>
                                                <option value="7" ${(segment.shine || 0) == 7 ? 'selected' : ''}>7 - ××–×”×™×¨</option>
                                                <option value="8" ${(segment.shine || 0) == 8 ? 'selected' : ''}>8 - ××¡× ×•×•×¨</option>
                                                <option value="9" ${(segment.shine || 0) == 9 ? 'selected' : ''}>9 - ×§×™×¦×•× ×™</option>
                                                <option value="10" ${(segment.shine || 0) == 10 ? 'selected' : ''}>10 - ××§×¡×™××œ×™</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                <div id="visual-effects-status-${mp3File}" style="font-size: 0.7rem; color: #28a745; margin-top: 4px; opacity: 0; transition: opacity 0.2s ease;">âœ¨ ××¤×§×˜×™× ×¢×•×“×›× ×•</div>
                            </div>
                            <div id="param-status-${mp3File}" style="font-size: 0.7rem; color: #28a745; margin-top: 4px; opacity: 0; transition: opacity 0.2s ease;">âœ… ×¤×¨××˜×¨×™× ×¢×•×“×›× ×•</div>
                            <div style="font-size: 0.75rem; color: #6c757d; margin-top: 4px; padding: 4px 8px; background: #f8f9fa; border-radius: 4px;">
                                <i class="material-icons" style="font-size: 12px; vertical-align: text-bottom;">info</i>
                                ×‘×—×¨ ××”×¨×©×™××” ×œ×©×™× ×•×™ ××”×™×¨ ××• ×”×©×ª××© ×‘×¢×•×¨×š ×”××ª×§×“×
                            </div>
                        </div>
                        
                        <!-- Quick Actions -->
                        <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 12px; border-top: 1px solid #e9ecef;">
                            <div style="display: flex; gap: 8px;">
                                <button onclick="event.stopPropagation(); completeAIAnalysis('${mp3File}')" 
                                        style="background: linear-gradient(135deg, #28a745, #20c997); color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;"
                                        onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(40, 167, 69, 0.3)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'"
                                        title="× ×™×ª×•×— ××œ× ×¢× AI">
                                    <span>ğŸ¤–</span> × ×™×ª×•×— AI
                                </button>
                                <button onclick="event.stopPropagation(); transcribeAndAnalyzeSegment('${mp3File}')" 
                                        style="background: linear-gradient(135deg, #fd7e14, #ffc107); color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;"
                                        onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(253, 126, 20, 0.3)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'"
                                        title="×ª××œ×•×œ + × ×™×ª×•×— ××œ× ×¢× AI">
                                    <span>ğŸ¤ğŸ¤–</span> ×ª××œ×•×œ+AI
                                </button>
                                <button onclick="event.stopPropagation(); toggleSegmentLoop('${mp3File}')" 
                                        style="background: linear-gradient(135deg, #6f42c1, #e83e8c); color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;"
                                        onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(111, 66, 193, 0.3)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'"
                                        title="×œ×•×œ××” ×¨×¦×™×¤×”"
                                        id="loop-btn-${mp3File}">
                                    <span>ğŸ”</span> ×œ×•×œ××”
                                </button>
                            </div>
                            <div style="font-size: 0.75rem; color: #6c757d;">
                                <span id="save-indicator-${mp3File}" style="opacity: 0; transition: opacity 0.2s ease;">ğŸ’¾ × ×©××¨</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add enhanced hover effects
            div.addEventListener('mouseenter', () => {
                const card = div.querySelector('.enhanced-segment-card');
                card.style.transform = 'translateY(-4px)';
                card.style.boxShadow = '0 8px 25px rgba(102, 126, 234, 0.15)';
                card.style.borderColor = '#667eea';
            });
            
            div.addEventListener('mouseleave', () => {
                const card = div.querySelector('.enhanced-segment-card');
                card.style.transform = 'translateY(0)';
                card.style.boxShadow = '0 2px 8px rgba(0,0,0,0.04)';
                card.style.borderColor = '#e9ecef';
            });
            
            return div;
        }
        
        // Helper functions for enhanced segment functionality
        function updateSpeakerIndicator(mp3File, speakerValue) {
            const indicator = document.getElementById(`speaker-indicator-${mp3File}`);
            if (indicator) {
                indicator.style.background = speakerValue == 1 ? '#4ECDC4' : '#FF6B6B';
                indicator.title = `×“×•×‘×¨ ${parseInt(speakerValue) + 1}`;
            }
            
            // Show save indicator
            showSaveIndicator(mp3File);
        }
        
        function markTranscriptAsModified(mp3File, element) {
            // Add visual feedback for unsaved changes
            element.style.borderColor = '#ffc107';
            element.style.background = '#fff9e6';
            
            // Clear any existing timeout
            if (element.saveTimeout) {
                clearTimeout(element.saveTimeout);
            }
            
            // Set a timeout to auto-save after user stops typing
            element.saveTimeout = setTimeout(() => {
                updateTranscript(mp3File, element.textContent.trim());
                element.style.borderColor = '#28a745';
                element.style.background = '#f0f9f0';
                showSaveIndicator(mp3File);
                
                // Reset to normal after a moment
                setTimeout(() => {
                    element.style.borderColor = '#e9ecef';
                    element.style.background = '#f8f9fa';
                }, 1500);
            }, 1000);
        }
        
        function handleTranscriptKeydown(event, mp3File) {
            // Save on Ctrl+Enter or Cmd+Enter
            if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                event.preventDefault();
                const element = event.target;
                updateTranscript(mp3File, element.textContent.trim());
                element.blur();
                showSaveIndicator(mp3File);
            }
        }
        
        function showSaveIndicator(mp3File) {
            const indicator = document.getElementById(`save-indicator-${mp3File}`);
            if (indicator) {
                indicator.style.opacity = '1';
                setTimeout(() => {
                    indicator.style.opacity = '0';
                }, 2000);
            }
        }

        function createSegmentContent(segment, index) {
            const mp3File = Object.keys(emotionData).filter(key => key.endsWith('.mp3'))[index];
            const emotions = segment.emotions || [];
            
            // Create emotion tags with colors from emotions management
            const emotionTags = emotions.map((e, i) => {
                // Ensure we have emotions config loaded, fallback to DEFAULT_EMOTIONS
                const emotionConfig = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                const color = emotionConfig.color || DEFAULT_EMOTIONS[e]?.color || '#e3f2fd';
                const emoji = emotionConfig.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                const hebrew = emotionConfig.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                
                return `
                    <div class="emotion-tag" style="background-color: ${color}15; border: 1px solid ${color}; color: ${color};">
                        ${emoji} ${hebrew}
                        <button class="remove-btn" onclick="removeEmotion('${mp3File}', ${i})">Ã—</button>
                    </div>
                `;
            }).join('');
            
            // Get all available emotions from emotions config, with fallback
            const allEmotions = emotionsConfig ? 
                Object.keys(emotionsConfig).filter(emotion => emotionsConfig[emotion].active) :
                ['happiness', 'sadness', 'anger', 'fear', 'surprise', 'disgust', 'neutral', 'curiosity', 'excitement'];
            
            const emotionOptions = allEmotions.map(emotion => {
                const config = (emotionsConfig && emotionsConfig[emotion]) || {};
                const displayName = config.hebrew ? `${config.emoji} ${config.hebrew}` : emotion;
                return `<option value="${emotion}">${displayName}</option>`;
            }).join('');

            return `
                <!-- Enhanced Transcript Editor -->
                <div class="transcript-section">
                    <h4>ğŸ“ ×˜×¨× ×¡×§×¨×™×¤×˜</h4>
                    <div class="transcript-box" contenteditable="true" 
                         onblur="updateTranscript('${mp3File}', this.textContent)"
                         oninput="markTranscriptChanged('${mp3File}')"
                         placeholder="×”×§×œ×“ ×›××Ÿ ××ª ×”×˜×¨× ×¡×§×¨×™×¤×˜..."
                         style="direction: rtl;">${segment.transcript || segment.words || ''}</div>
                    <div class="transcript-actions">
                        <button class="btn btn-sm" onclick="clearTranscript('${mp3File}')">ğŸ—‘ï¸ × ×§×”</button>
                        <button class="btn btn-sm" onclick="capitalizeTranscript('${mp3File}')">ğŸ”¤ ××•×ª×™×•×ª ×’×“×•×œ×•×ª</button>
                        <span class="transcript-status" id="transcript-status-${mp3File}"></span>
                    </div>
                </div>
                
                <div style="margin-bottom: 1rem;">
                    <label>×¨×’×©×•×ª:</label>
                    <div class="emotion-tags">
                        ${emotionTags}
                    </div>
                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                        <select id="emotion-select-${mp3File}">
                            <option value="">×‘×—×¨ ×¨×’×©...</option>
                            <!-- Options will be populated by JavaScript -->
                        </select>
                        <button class="btn btn-secondary btn-sm" onclick="addEmotion('${mp3File}')">
                            <i class="material-icons">add</i>
                            ×”×•×¡×£
                        </button>
                    </div>
                </div>
                
                <!-- Character Size Controls -->
                <div style="background: #f0f8ff; border: 1px solid #b3d9ff; border-radius: 6px; padding: 15px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #0066cc; font-size: 14px;">ğŸ“ ×’×“×œ×™ ×ª×•×•×™×</h4>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                        <div>
                            <label>×’×•×“×œ ×ª×• ×¨×’×™×œ:</label>
                            <input type="number" 
                                   value="${segment.regularAsciiCharSize || 0.25}" 
                                   step="0.05" min="0.1" max="3"
                                   onchange="updateParam('${mp3File}', 'regularAsciiCharSize', this.value)">
                        </div>
                        <div>
                            <label>×’×•×“×œ ×ª×• ×¨×’×©:</label>
                            <input type="number" 
                                   value="${segment.coloredCircleCharSize || 0.25}" 
                                   step="0.05" min="0.1" max="3"
                                   onchange="updateParam('${mp3File}', 'coloredCircleCharSize', this.value)">
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <label>×›××•×ª ×ª×•×•×™ ×¨×’×© (0-200%):</label>
                        <input type="range" min="0" max="200" value="${segment.emotionCharAmount || 50}" 
                               onchange="updateParam('${mp3File}', 'emotionCharAmount', this.value); document.getElementById('emotion-amount-value-${mp3File}').textContent = this.value + '%';"
                               style="width: 100%; margin: 5px 0;">
                        <div style="text-align: center; font-size: 0.9rem; color: #666;">
                            <span id="emotion-amount-value-${mp3File}">${segment.emotionCharAmount || 50}%</span>
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <label>×¨×–×•×œ×•×¦×™×™×ª ×’×¨×™×“ (20-150):</label>
                        <input type="range" min="20" max="150" value="${segment.gridResolution || 50}" 
                               onchange="updateParam('${mp3File}', 'gridResolution', this.value); document.getElementById('grid-resolution-value-${mp3File}').textContent = this.value;"
                               style="width: 100%; margin: 5px 0;">
                        <div style="text-align: center; font-size: 0.9rem; color: #666;">
                            <span id="grid-resolution-value-${mp3File}">${segment.gridResolution || 50}</span> (× ××•×š=××”×™×¨, ×’×‘×•×”=××¤×•×¨×˜)
                        </div>
                    </div>
                </div>
                
                <!-- Main Parameters -->
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
                    <div>
                        <label>×“×•×‘×¨:</label>
                        <select onchange="updateParam('${mp3File}', 'speaker', this.value)">
                                                                        <option value="0" ${segment.speaker === 0 ? 'selected' : ''}>${getSpeakerName(0)}</option>
                                            <option value="1" ${segment.speaker === 1 ? 'selected' : ''}>${getSpeakerName(1)}</option>
                        </select>
                    </div>
                    
                    <div>
                        <label>×’×•×“×œ Blob:</label>
                        <input type="number" 
                               value="${segment.blobSizeScale || 4}" 
                               step="0.5" min="1" max="20"
                               onchange="updateParam('${mp3File}', 'blobSizeScale', this.value)">
                    </div>
                    
                    <div>
                        <label>×¢×•×¦××ª Blob:</label>
                        <input type="number" 
                               value="${segment.blobStrength || 450}" 
                               step="50" min="100" max="5000"
                               onchange="updateParam('${mp3File}', 'blobStrength', this.value)">
                    </div>
                    
                    <div>
                        <label>×”×©×¤×¢×ª ×¢×•×¦××”:</label>
                        <input type="number" 
                               value="${segment.volumeImpact || 3000}" 
                               step="50" min="3000" max="3000"
                               onchange="updateParam('${mp3File}', 'volumeImpact', this.value)">
                    </div>
                    
                    <div>
                        <label>×˜×©×˜×•×© (blur):</label>
                        <input type="number" 
                               value="${segment.blur || 0}" 
                               step="1" min="0" max="12"
                               onchange="updateParam('${mp3File}', 'blur', this.value)">
                    </div>
                    
                    <div>
                        <label>×”×•××•×¨:</label>
                        <input type="number" 
                               value="${segment.humor || 0}" 
                               step="1" min="0" max="10"
                               onchange="updateParam('${mp3File}', 'humor', this.value)">
                    </div>
                    
                    <div>
                        <label>×‘×¨×§ (shine):</label>
                        <input type="number" 
                               value="${segment.shine || 0}" 
                               step="1" min="0" max="10"
                               onchange="updateParam('${mp3File}', 'shine', this.value)">
                    </div>
                    
                    <div>
                        <label>Blobiness:</label>
                        <input type="number" 
                               value="${segment.blobiness || 3.5}" 
                               step="0.5" min="1" max="10"
                               onchange="updateParam('${mp3File}', 'blobiness', this.value)">
                    </div>
                    
                    <div>
                        <label>××–×•×¨ ×‘×™×ª:</label>
                        <select onchange="updateParam('${mp3File}', 'blobHomeRegion', this.value)">
                            <option value="center-left" ${segment.blobHomeRegion === 'center-left' ? 'selected' : ''}>××¨×›×– ×©×××œ</option>
                            <option value="center-right" ${segment.blobHomeRegion === 'center-right' ? 'selected' : ''}>××¨×›×– ×™××™×Ÿ</option>
                            <option value="center" ${segment.blobHomeRegion === 'center' ? 'selected' : ''}>××¨×›×–</option>
                            <option value="top-center" ${segment.blobHomeRegion === 'top-center' ? 'selected' : ''}>××¨×›×– ×¢×œ×™×•×Ÿ</option>
                            <option value="bottom-center" ${segment.blobHomeRegion === 'bottom-center' ? 'selected' : ''}>××¨×›×– ×ª×—×ª×•×Ÿ</option>
                            <option value="top-left" ${segment.blobHomeRegion === 'top-left' ? 'selected' : ''}>×©×××œ ×¢×œ×™×•×Ÿ</option>
                            <option value="top-right" ${segment.blobHomeRegion === 'top-right' ? 'selected' : ''}>×™××™×Ÿ ×¢×œ×™×•×Ÿ</option>
                            <option value="bottom-left" ${segment.blobHomeRegion === 'bottom-left' ? 'selected' : ''}>×©×××œ ×ª×—×ª×•×Ÿ</option>
                            <option value="bottom-right" ${segment.blobHomeRegion === 'bottom-right' ? 'selected' : ''}>×™××™×Ÿ ×ª×—×ª×•×Ÿ</option>
                        </select>
                    </div>
                    
                    <div>
                        <label>××¨×•×•×— Blob:</label>
                        <select onchange="updateParam('${mp3File}', 'minBlobSpacing', this.value)">
                            <option value="together" ${segment.minBlobSpacing === 'together' ? 'selected' : ''}>×™×—×“ (0px)</option>
                            <option value="close" ${segment.minBlobSpacing === 'close' ? 'selected' : ''}>×§×¨×•×‘ (300px)</option>
                            <option value="far away" ${segment.minBlobSpacing === 'far away' ? 'selected' : ''}>×¨×—×•×§ (900px)</option>
                        </select>
                    </div>
                    
                    <div>
                        <label>×“×¤×•×¡ ×¦××™×—×”:</label>
                        <select onchange="updateParam('${mp3File}', 'blobGrowthPattern', this.value)">
                            <option value="hesitant" ${segment.blobGrowthPattern === 'hesitant' ? 'selected' : ''}>××”×¡×¡</option>
                            <option value="steady" ${segment.blobGrowthPattern === 'steady' ? 'selected' : ''}>×™×¦×™×‘</option>
                            <option value="explosive" ${segment.blobGrowthPattern === 'explosive' ? 'selected' : ''}>××ª×¤×¨×¥</option>
                            <option value="building" ${segment.blobGrowthPattern === 'building' ? 'selected' : ''}>×‘×•× ×”</option>
                            <option value="curious" ${segment.blobGrowthPattern === 'curious' ? 'selected' : ''}>×¡×§×¨×Ÿ</option>
                            <option value="playful" ${segment.blobGrowthPattern === 'playful' ? 'selected' : ''}>×©×•×‘×‘</option>
                        </select>
                    </div>
                    
                    <div>
                        <label>×—×™×‘×•×¨×™×:</label>
                        <input type="checkbox" 
                               ${segment.connectBlobs ? 'checked' : ''}
                               onchange="updateParam('${mp3File}', 'connectBlobs', this.checked)">
                    </div>
                    
                    <div>
                        <label>× ×¨××•×ª Blobs:</label>
                        <input type="checkbox" 
                               ${segment.blobsVisible !== false ? 'checked' : ''}
                               onchange="updateParam('${mp3File}', 'blobsVisible', this.checked)">
                    </div>
                </div>
                
                <!-- Individual Segment Visualization -->
                <div class="segment-visualization">
                    <h4>ğŸ¨ ×•×™×–×•××œ×™×–×¦×™×” ×©×œ ×”×§×˜×¢</h4>
                    <div class="segment-viz-container">
                        <iframe id="segment-viz-${mp3File}" 
                                width="100%" 
                                height="150px" 
                                style="border: 2px solid #e0e0e0; border-radius: 8px; background: #f9f9f9; margin-bottom: 10px; display: none;"
                                onload="handleSegmentVizLoad('${mp3File}')"
                                onerror="handleSegmentVizError('${mp3File}')">
                        </iframe>
                        <button class="load-viz-btn" onclick="loadSegmentVisualization('${mp3File}')" 
                                style="width: 100%; height: 150px; border: 2px dashed #ccc; background: #f9f9f9; border-radius: 8px; cursor: pointer; color: #666;">
                            ğŸ¨ ×œ×—×¥ ×œ×˜×¢×™× ×ª ×•×™×–×•××œ×™×–×¦×™×”
                        </button>
                    </div>
                    <div class="segment-viz-status" id="segment-viz-status-${mp3File}" style="font-size: 12px; color: #666;">
                        ×¨×’×©×•×ª: ${emotions.join(', ')} | ×œ×—×¥ ×›×“×™ ×œ×¨××•×ª ×•×™×–×•××œ×™×–×¦×™×”
                    </div>
                </div>
                
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
                    <button class="btn btn-secondary btn-sm" onclick="playSegment('${mp3File}')">
                        <i class="material-icons">play_arrow</i>
                        ×”×©××¢
                    </button>
                    <button class="btn btn-secondary btn-sm loop-button" onclick="toggleLoop('${mp3File}')" id="loop-btn-${mp3File}" title="×œ×•×œ××”">
                        <i class="material-icons">loop</i>
                        ×œ×•×œ××”
                    </button>
                </div>
            `;
        }

        function selectSegment(mp3File, segment) {
            // Update selected state in UI
            document.querySelectorAll('.segment-item').forEach(item => {
                item.classList.remove('active');
            });
            document.getElementById(`segment-${mp3File}`).classList.add('active');
            
            currentSelectedSegment = mp3File;
            
            // Show the segment editor panel
            document.getElementById('no-segment-selected').style.display = 'none';
            document.getElementById('segment-editor-panel').style.display = 'flex';
            
            // Load the segment content in the editor
            loadSegmentEditor(mp3File, segment);
            
            // Load the visualization for this segment
            loadSegmentVisualization(mp3File);
        }
        
        function loadSegmentEditor(mp3File, segment) {
            const editorContainer = document.getElementById('active-segment-editor');
            editorContainer.innerHTML = createSegmentEditorContent(mp3File, segment);
            
            // âœ… COMPREHENSIVE SYNC: Ensure all UI elements are synchronized when segment is loaded
            setTimeout(() => {
                // Apply AI constraints when loading segment
                applyAIConstraintsToSegment(mp3File);
                
                syncAllSegmentElements(mp3File);
                
                // âœ¨ Initialize enhanced sliders for this segment
                initializeEnhancedSliders();
            }, 100); // Small delay to ensure DOM is updated
        }

        /**
         * Apply AI analysis constraints to a segment to ensure consistency
         */
        function applyAIConstraintsToSegment(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            let hasChanges = false;
            const updates = {};
            
            // âœ… Blob size constraint: max 5
            if (segment.blobSizeScale && segment.blobSizeScale > 5) {
                updates.blobSizeScale = 5;
                updates.blob_size = 5;
                hasChanges = true;
                console.log(`ğŸ¯ Applied blob size constraint to ${mp3File}: ${segment.blobSizeScale} â†’ 5`);
            }
            
            // âœ… Character size constraints: min 1.0
            if (segment.coloredCircleCharSize && segment.coloredCircleCharSize < 1.0) {
                updates.coloredCircleCharSize = 1.0;
                updates.godel_to_regesh = 1.0;
                hasChanges = true;
                console.log(`ğŸ¯ Applied emotion char size constraint to ${mp3File}: ${segment.coloredCircleCharSize} â†’ 1.0`);
            }
            
            if (segment.regularAsciiCharSize && segment.regularAsciiCharSize < 1.0) {
                updates.regularAsciiCharSize = 1.0;
                updates.godel_to_regular = 1.0;
                hasChanges = true;
                console.log(`ğŸ¯ Applied regular char size constraint to ${mp3File}: ${segment.regularAsciiCharSize} â†’ 1.0`);
            }
            
            // Apply updates if any constraints were violated
            if (hasChanges) {
                Object.assign(emotionData[mp3File], updates);
                console.log(`âœ… Applied AI constraints to segment ${mp3File}`);
            }
        }

        /**
         * Apply AI constraints to all segments in the current conversation
         */
        function applyAIConstraintsToAllSegments() {
            console.log('ğŸ¯ Applying AI constraints to all segments...');
            let totalConstraintsApplied = 0;
            
            Object.keys(emotionData).forEach(mp3File => {
                const segment = emotionData[mp3File];
                if (!segment || !mp3File.endsWith('.mp3')) return;
                
                let constraintsApplied = 0;
                
                // Check and fix blob size
                if (segment.blobSizeScale && segment.blobSizeScale > 5) {
                    segment.blobSizeScale = 5;
                    segment.blob_size = 5;
                    constraintsApplied++;
                }
                
                // Check and fix character sizes
                if (segment.coloredCircleCharSize && segment.coloredCircleCharSize < 1.0) {
                    segment.coloredCircleCharSize = 1.0;
                    segment.godel_to_regesh = 1.0;
                    constraintsApplied++;
                }
                
                if (segment.regularAsciiCharSize && segment.regularAsciiCharSize < 1.0) {
                    segment.regularAsciiCharSize = 1.0;
                    segment.godel_to_regular = 1.0;
                    constraintsApplied++;
                }
                
                totalConstraintsApplied += constraintsApplied;
            });
            
            if (totalConstraintsApplied > 0) {
                console.log(`âœ… Applied ${totalConstraintsApplied} AI constraints across all segments`);
                showStatus(`ğŸ¯ ×”×•×—×œ×• ${totalConstraintsApplied} ××™×œ×•×¦×™× ×—×›××™× ×¢×œ ×›×œ ×”×§×˜×¢×™×`, 'info');
            }
        }

        /**
         * Standardize AI analysis behavior across all conversations and segments
         * Ensures consistent parameter ranges and constraints are applied everywhere
         */
        function standardizeAIAnalysisBehavior() {
            console.log('ğŸ¯ Standardizing AI analysis behavior across conversation...');
            
            // Apply constraints to all current segments
            applyAIConstraintsToAllSegments();
            
            // Ensure all dropdowns are initialized with proper values
            initializeDropdownValues();
            
            // Log the standardization
            const segmentCount = Object.keys(emotionData).filter(key => key.endsWith('.mp3')).length;
            console.log(`âœ… Standardized AI behavior for ${segmentCount} segments with constraints: blobSizeâ‰¤5, charSizesâ‰¥1.0`);
        }
        
        function createSegmentEditorContent(mp3File, segment) {
            const emotions = segment.emotions || [];
            
            // Create emotion tags with colors from emotions management
            const emotionTags = emotions.map((e, i) => {
                // Ensure we have emotions config loaded, fallback to DEFAULT_EMOTIONS
                const emotionConfig = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                const color = emotionConfig.color || DEFAULT_EMOTIONS[e]?.color || '#e3f2fd';
                const emoji = emotionConfig.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                const hebrew = emotionConfig.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                
                return `
                    <div class="emotion-tag" style="background-color: ${color}15; border: 1px solid ${color}; color: ${color};">
                        ${emoji} ${hebrew}
                        <button class="remove-btn" onclick="removeEmotion('${mp3File}', ${i})">Ã—</button>
                    </div>
                `;
            }).join('');
            
            // Get all available emotions from emotions config, with fallback
            const allEmotions = emotionsConfig ? 
                Object.keys(emotionsConfig).filter(emotion => emotionsConfig[emotion].active) :
                ['happiness', 'sadness', 'anger', 'fear', 'surprise', 'disgust', 'neutral', 'curiosity', 'excitement'];
            
            const emotionOptions = allEmotions.map(emotion => {
                const config = (emotionsConfig && emotionsConfig[emotion]) || {};
                const displayName = config.hebrew ? `${config.emoji} ${config.hebrew}` : emotion;
                return `<option value="${emotion}">${displayName}</option>`;
            }).join('');

            return `
                <div class="modern-parameter-editor">
                    <div class="parameter-editor-header">
                        <h2 class="parameter-editor-title">
                            <i class="material-icons">edit</i>
                            ×¢×¨×™×›×ª ${mp3File}
                        </h2>
                        <p class="parameter-editor-subtitle">×¢×¨×•×š ×¤×¨××˜×¨×™×, ×¨×’×©×•×ª ×•××¤×§×˜×™× ×•×™×–×•××œ×™×™×</p>
                    </div>
                    
                    <div class="parameter-editor-body">
                        <!-- Transcript Section -->
                        <div class="parameter-section">
                            <div class="parameter-section-header" onclick="toggleParameterSection(this)">
                                <div class="parameter-section-title">
                                    <i class="material-icons">text_fields</i>
                                    ×˜×¨× ×¡×§×¨×™×¤×˜ ×•×ª×•×›×Ÿ
                                </div>
                                <i class="material-icons parameter-section-toggle">expand_more</i>
                            </div>
                            <div class="parameter-section-body">
                                <div class="transcript-editor" contenteditable="true" 
                                     onblur="updateTranscript('${mp3File}', this.textContent)"
                                     oninput="markTranscriptChanged('${mp3File}')"
                                     placeholder="×”×§×œ×“ ×›××Ÿ ××ª ×”×˜×¨× ×¡×§×¨×™×¤×˜...">${segment.transcript || segment.words || ''}</div>
                                <div class="transcript-actions">
                                    <button class="modern-btn modern-btn-secondary modern-btn-sm" onclick="clearTranscript('${mp3File}')">
                                        <i class="material-icons">clear</i> × ×§×”
                                    </button>
                                    <button class="modern-btn modern-btn-secondary modern-btn-sm" onclick="capitalizeTranscript('${mp3File}')">
                                        <i class="material-icons">format_size</i> ××•×ª×™×•×ª ×’×“×•×œ×•×ª
                                    </button>
                                    <button class="modern-btn modern-btn-success modern-btn-sm" onclick="completeAIAnalysis('${mp3File}')">
                                        <i class="material-icons">psychology</i> × ×™×ª×•×— ××œ× ×¢× AI
                                    </button>
                                    <span class="transcript-status" id="transcript-status-${mp3File}"></span>
                                </div>
                                <div style="font-size: 0.85rem; color: #6c757d; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 6px;">
                                    <i class="material-icons" style="font-size: 16px; vertical-align: text-bottom;">info</i>
                                    <strong>×˜×™×¤:</strong> ×¢×¨×•×š ××ª ×”×˜×§×¡×˜ ×•×œ×—×¥ "× ×™×ª×•×— ××œ× ×¢× AI" ×›×“×™ ×œ× ×ª×— ××ª ×”××•×“×™×• ×•×”×˜×§×¡×˜ ×•×œ×¢×“×›×Ÿ ××ª ×›×œ ×”×¤×¨××˜×¨×™×
                                </div>
                            </div>
                        </div>
                
                        <!-- Emotions Section -->
                        <div class="parameter-section">
                            <div class="parameter-section-header" onclick="toggleParameterSection(this)">
                                <div class="parameter-section-title">
                                    <i class="material-icons">sentiment_satisfied</i>
                                    ×¨×’×©×•×ª ×•××¦×‘ ×¨×•×—
                                </div>
                                <i class="material-icons parameter-section-toggle">expand_more</i>
                            </div>
                            <div class="parameter-section-body">
                                <div class="parameter-item">
                                    <div class="parameter-label">
                                        ×¨×’×©×•×ª × ×•×›×—×™×™×
                                        <span class="parameter-help" title="× ×™×ª×Ÿ ×œ×”×•×¡×™×£ ××¡×¤×¨ ×¨×’×©×•×ª">?</span>
                                    </div>
                                    <div class="emotion-tags" style="margin-bottom: 1rem;">
                                        ${emotionTags}
                                    </div>
                                    <div style="display: flex; gap: 0.5rem;">
                                        <select id="emotion-select-${mp3File}" class="modern-select" style="flex: 1;">
                                            <option value="">×‘×—×¨ ×¨×’×© ×œ×”×•×¡×¤×”...</option>
                                            <!-- Options will be populated by JavaScript -->
                                        </select>
                                        <button class="modern-btn modern-btn-secondary modern-btn-sm" onclick="addEmotion('${mp3File}')">
                                            <i class="material-icons">add</i>
                                            ×”×•×¡×£
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Visual Effects Section -->
                        <div class="parameter-section">
                            <div class="parameter-section-header" onclick="toggleParameterSection(this)">
                                <div class="parameter-section-title">
                                    <i class="material-icons">auto_fix_high</i>
                                    ××¤×§×˜×™× ×•×™×–×•××œ×™×™×
                                </div>
                                <i class="material-icons parameter-section-toggle">expand_more</i>
                            </div>
                            <div class="parameter-section-body">
                                <div class="visual-effects-grid">
                                    <div class="effect-control">
                                        <div class="effect-control-label">ğŸ«§ Blobiness</div>
                                        <input type="range" min="1" max="10" step="0.5" value="${segment.blobiness || 3.5}" 
                                               class="enhanced-slider"
                                               oninput="updateParam('${mp3File}', 'blobiness', this.value); document.getElementById('blobiness-value-${mp3File}').textContent = this.value; updateSliderBackground(this); syncCardVisualEffects('${mp3File}');"
                                               data-color="#3498db"
                                               data-unit="">
                                        <div class="effect-value-display" id="blobiness-value-${mp3File}">${segment.blobiness || 3.5}</div>
                                    </div>
                                    <div class="effect-control">
                                        <div class="effect-control-label">ğŸŒ«ï¸ ×˜×©×˜×•×©</div>
                                        <input type="range" min="0" max="15" value="${segment.blur || 0}" 
                                               class="enhanced-slider"
                                               oninput="updateParam('${mp3File}', 'blur', this.value); document.getElementById('blur-value-${mp3File}').textContent = this.value; updateSliderBackground(this); syncCardVisualEffects('${mp3File}');"
                                               data-color="#9b59b6"
                                               data-unit="">
                                        <div class="effect-value-display" id="blur-value-${mp3File}">${segment.blur || 0}</div>
                                    </div>
                                    <div class="effect-control">
                                        <div class="effect-control-label">ğŸ˜„ ×”×•××•×¨</div>
                                        <input type="range" min="0" max="15" value="${segment.humor || 0}" 
                                               class="enhanced-slider"
                                               oninput="updateParam('${mp3File}', 'humor', this.value); document.getElementById('humor-value-${mp3File}').textContent = this.value; updateSliderBackground(this); syncCardVisualEffects('${mp3File}');"
                                               data-color="#f39c12"
                                               data-unit="">
                                        <div class="effect-value-display" id="humor-value-${mp3File}">${segment.humor || 0}</div>
                                    </div>
                                    <div class="effect-control">
                                        <div class="effect-control-label">âœ¨ ×‘×¨×§</div>
                                        <input type="range" min="0" max="15" value="${segment.shine || 0}" 
                                               class="enhanced-slider"
                                               oninput="updateParam('${mp3File}', 'shine', this.value); document.getElementById('shine-value-${mp3File}').textContent = this.value; updateSliderBackground(this); syncCardVisualEffects('${mp3File}');"
                                               data-color="#f1c40f"
                                               data-unit="">
                                        <div class="effect-value-display" id="shine-value-${mp3File}">${segment.shine || 0}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                
                        <!-- Character Sizes Section -->
                        <div class="parameter-section">
                            <div class="parameter-section-header" onclick="toggleParameterSection(this)">
                                <div class="parameter-section-title">
                                    <i class="material-icons">format_size</i>
                                    ×’×“×œ×™ ×ª×•×•×™× ×•×¨×–×•×œ×•×¦×™×”
                                </div>
                                <i class="material-icons parameter-section-toggle">expand_more</i>
                            </div>
                            <div class="parameter-section-body">
                                <div class="parameter-grid parameter-grid-2">
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            ×’×•×“×œ ×ª×• ×¨×’×™×œ
                                            <span class="parameter-help" title="×’×•×“×œ ×ª×•×•×™ ASCII ×¨×’×™×œ×™×">?</span>
                                        </div>
                                        <input type="number" 
                                               class="modern-input"
                                               value="${segment.regularAsciiCharSize || 0.25}" 
                                               step="0.05" min="0.1" max="3"
                                               onchange="updateParam('${mp3File}', 'regularAsciiCharSize', this.value)">
                                    </div>
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            ×’×•×“×œ ×ª×• ×¨×’×©
                                            <span class="parameter-help" title="×’×•×“×œ ×ª×•×•×™ ×¨×’×© ×¦×‘×¢×•× ×™×™×">?</span>
                                        </div>
                                        <input type="number" 
                                               class="modern-input"
                                               value="${segment.coloredCircleCharSize || 0.25}" 
                                               step="0.05" min="0.1" max="3"
                                               onchange="updateParam('${mp3File}', 'coloredCircleCharSize', this.value)">
                                    </div>
                                </div>
                                <div class="parameter-item">
                                    <div class="parameter-label">
                                        ×›××•×ª ×ª×•×•×™ ×¨×’×©
                                        <span class="range-value" id="emotion-char-amount-${mp3File}">${segment.emotionCharAmount || 50}%</span>
                                    </div>
                                    <input type="range" min="10" max="300" value="${segment.emotionCharAmount || 50}" 
                                           class="enhanced-slider"
                                           oninput="updateParam('${mp3File}', 'emotionCharAmount', this.value); document.getElementById('emotion-char-amount-${mp3File}').textContent = this.value + '%'; updateSliderBackground(this);"
                                           data-color="#e83e8c"
                                           data-unit="%">
                                </div>
                                <div class="parameter-item">
                                    <div class="parameter-label">
                                        ×¨×–×•×œ×•×¦×™×™×ª ×’×¨×™×“
                                        <span class="range-value" id="grid-res-${mp3File}">${segment.gridResolution || 50}</span>
                                    </div>
                                    <input type="range" min="15" max="200" value="${segment.gridResolution || 50}" 
                                           class="enhanced-slider"
                                           oninput="updateParam('${mp3File}', 'gridResolution', this.value); document.getElementById('grid-res-${mp3File}').textContent = this.value; updateSliderBackground(this);"
                                           data-color="#17a2b8"
                                           data-unit="">
                                    <div style="text-align: center; font-size: 0.8rem; color: #6c757d; margin-top: 0.5rem;">
                                        × ××•×š=××”×™×¨, ×’×‘×•×”=××¤×•×¨×˜
                                    </div>
                                </div>
                            </div>
                        </div>
                
                        <!-- Blob Parameters Section -->
                        <div class="parameter-section">
                            <div class="parameter-section-header" onclick="toggleParameterSection(this)">
                                <div class="parameter-section-title">
                                    <i class="material-icons">bubble_chart</i>
                                    ×¤×¨××˜×¨×™ Blob ×•××•×“×™×•
                                </div>
                                <i class="material-icons parameter-section-toggle">expand_more</i>
                            </div>
                            <div class="parameter-section-body">
                                <div class="parameter-grid parameter-grid-3">
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            ×“×•×‘×¨
                                            <span class="parameter-help" title="×–×™×”×•×™ ×“×•×‘×¨ ×œ×¦×‘×¢ ×•××™×§×•×">?</span>
                                        </div>
                                        <select class="modern-select" onchange="updateParam('${mp3File}', 'speaker', this.value)">
                                            <option value="0" ${segment.speaker === 0 ? 'selected' : ''}>${getSpeakerName(0)} (××“×•×)</option>
                                            <option value="1" ${segment.speaker === 1 ? 'selected' : ''}>${getSpeakerName(1)} (×˜×•×¨×§×™×–)</option>
                                        </select>
                                    </div>
                                    
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            ×’×•×“×œ Blob
                                            <span class="range-value" id="blob-size-scale-${mp3File}">${segment.blobSizeScale || 4}</span>
                                        </div>
                                        <input type="range" 
                                               class="enhanced-slider"
                                               value="${segment.blobSizeScale || 4}" 
                                               step="0.1" min="0.5" max="15"
                                               oninput="updateParam('${mp3File}', 'blobSizeScale', this.value); document.getElementById('blob-size-scale-${mp3File}').textContent = this.value; updateSliderBackground(this);"
                                               data-color="#667eea"
                                               data-unit="">
                                    </div>
                                    
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            ×¢×•×¦××ª Blob
                                            <span class="range-value" id="blob-strength-${mp3File}">${segment.blobStrength || 450}</span>
                                        </div>
                                        <input type="range" 
                                               class="enhanced-slider"
                                               value="${segment.blobStrength || 450}" 
                                               step="25" min="50" max="2000"
                                               oninput="updateParam('${mp3File}', 'blobStrength', this.value); document.getElementById('blob-strength-${mp3File}').textContent = this.value; updateSliderBackground(this);"
                                               data-color="#e74c3c"
                                               data-unit="">
                                    </div>
                                    
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            ×”×©×¤×¢×ª ×¢×•×¦××”
                                            <span class="range-value" id="volume-impact-${mp3File}">${segment.volumeImpact || 3000}</span>
                                        </div>
                                        <input type="range" 
                                               class="enhanced-slider"
                                               value="${segment.volumeImpact || 3000}" 
                                               step="100" min="1000" max="6000"
                                               oninput="updateParam('${mp3File}', 'volumeImpact', this.value); document.getElementById('volume-impact-${mp3File}').textContent = this.value; updateSliderBackground(this);"
                                               data-color="#2ecc71"
                                               data-unit="">
                                    </div>
                                    
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            Blobiness
                                            <span class="parameter-help" title="×¨××ª ×”× ×–×™×œ×•×ª ×•×”×¢×™×•×•×ª">?</span>
                                        </div>
                                        <input type="number" 
                                               class="modern-input"
                                               value="${segment.blobiness || 3.5}" 
                                               step="0.5" min="1" max="10"
                                               onchange="updateParam('${mp3File}', 'blobiness', this.value)">
                                    </div>
                                    
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            ××–×•×¨ ×‘×™×ª
                                            <span class="parameter-help" title="××™×§×•× ×‘×¡×™×¡×™ ×©×œ ×”-Blob">?</span>
                                        </div>
                                        <select class="modern-select" onchange="updateParam('${mp3File}', 'blobHomeRegion', this.value)">
                                            <option value="center-left" ${segment.blobHomeRegion === 'center-left' ? 'selected' : ''}>××¨×›×– ×©×××œ</option>
                                            <option value="center-right" ${segment.blobHomeRegion === 'center-right' ? 'selected' : ''}>××¨×›×– ×™××™×Ÿ</option>
                                            <option value="center" ${segment.blobHomeRegion === 'center' ? 'selected' : ''}>××¨×›×–</option>
                                            <option value="top-center" ${segment.blobHomeRegion === 'top-center' ? 'selected' : ''}>××¨×›×– ×¢×œ×™×•×Ÿ</option>
                                            <option value="bottom-center" ${segment.blobHomeRegion === 'bottom-center' ? 'selected' : ''}>××¨×›×– ×ª×—×ª×•×Ÿ</option>
                                        </select>
                                    </div>
                        
                        <div>
                            <label>××¨×•×•×— Blob</label>
                            <select onchange="updateParam('${mp3File}', 'minBlobSpacing', this.value)">
                                <option value="together" ${segment.minBlobSpacing === 'together' ? 'selected' : ''}>×™×—×“ (0px)</option>
                                <option value="close" ${segment.minBlobSpacing === 'close' ? 'selected' : ''}>×§×¨×•×‘ (300px)</option>
                                <option value="far away" ${segment.minBlobSpacing === 'far away' ? 'selected' : ''}>×¨×—×•×§ (900px)</option>
                            </select>
                        </div>
                        
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            ×“×¤×•×¡ ×¦××™×—×”
                                            <span class="parameter-help" title="××•×¤×Ÿ ×”×ª×¤×ª×—×•×ª ×”-Blob ×œ××•×¨×š ×–××Ÿ">?</span>
                                        </div>
                                        <select class="modern-select" onchange="updateParam('${mp3File}', 'blobGrowthPattern', this.value)">
                                            <option value="hesitant" ${segment.blobGrowthPattern === 'hesitant' ? 'selected' : ''}>××”×¡×¡</option>
                                            <option value="steady" ${segment.blobGrowthPattern === 'steady' ? 'selected' : ''}>×™×¦×™×‘</option>
                                            <option value="explosive" ${segment.blobGrowthPattern === 'explosive' ? 'selected' : ''}>××ª×¤×¨×¥</option>
                                            <option value="building" ${segment.blobGrowthPattern === 'building' ? 'selected' : ''}>×‘×•× ×”</option>
                                            <option value="curious" ${segment.blobGrowthPattern === 'curious' ? 'selected' : ''}>×¡×§×¨×Ÿ</option>
                                            <option value="playful" ${segment.blobGrowthPattern === 'playful' ? 'selected' : ''}>×©×•×‘×‘</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <div class="parameter-grid parameter-grid-2" style="margin-top: 1rem;">
                                    <label class="modern-checkbox">
                                        <input type="checkbox" 
                                               ${segment.connectBlobs ? 'checked' : ''}
                                               onchange="updateParam('${mp3File}', 'connectBlobs', this.checked)">
                                        ×—×™×‘×•×¨×™× ×‘×™×Ÿ Blobs
                                    </label>
                                    
                                    <label class="modern-checkbox">
                                        <input type="checkbox" 
                                               ${segment.blobsVisible !== false ? 'checked' : ''}
                                               onchange="updateParam('${mp3File}', 'blobsVisible', this.checked)">
                                        ×”×¦×’ Blobs
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Advanced Analysis Results -->
                ${segment.ai_analyzed || segment.volume_analyzed || segment.advanced_params ? `
                <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin: 20px 0;">
                    <h4 style="margin: 0 0 15px 0; color: #495057; display: flex; align-items: center; gap: 0.5rem;">
                        <i class="material-icons">science</i>
                        ×ª×•×¦××•×ª × ×™×ª×•×— ××ª×§×“×
                    </h4>
                    
                    ${segment.ai_analyzed ? `
                    <div style="margin-bottom: 10px;">
                        <span style="background: #e8f5e8; color: #2e7d32; padding: 2px 8px; border-radius: 12px; font-size: 0.8rem;">
                            ğŸ¤– × ×•×ª×— ×¢×œ ×™×“×™ AI ${segment.ai_analysis_date ? new Date(segment.ai_analysis_date).toLocaleDateString('he-IL') : ''}
                        </span>
                    </div>
                    ` : ''}
                    
                    ${segment.volume_mean !== undefined ? `
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 15px; font-size: 0.9rem;">
                        <div style="background: white; padding: 8px; border-radius: 4px;">
                            <strong>ğŸ”Š ×¢×•×¦××ª ×§×•×œ ×××•×¦×¢×ª:</strong> ${(segment.volume_mean * 100).toFixed(1)}%
                        </div>
                        <div style="background: white; padding: 8px; border-radius: 4px;">
                            <strong>ğŸ“Š ×¢×•×¦××” ××§×¡×™××œ×™×ª:</strong> ${(segment.volume_max * 100).toFixed(1)}%
                        </div>
                        <div style="background: white; padding: 8px; border-radius: 4px;">
                            <strong>âš¡ ×× ×¨×’×™×”:</strong> ${(segment.volume_energy * 100).toFixed(1)}%
                        </div>
                        <div style="background: white; padding: 8px; border-radius: 4px;">
                            <strong>â±ï¸ ××©×š (×©× ×™×•×ª):</strong> ${segment.audio_duration ? segment.audio_duration.toFixed(2) : 'N/A'}
                        </div>
                    </div>
                    ` : ''}
                    
                    ${segment.tone || segment.intention || segment.godel_to_regesh ? `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 15px; font-size: 0.85rem;">
                        ${segment.tone ? `<div style="background: #fff3e0; padding: 6px; border-radius: 4px; text-align: center;"><strong>×˜×•×Ÿ:</strong> ${segment.tone}</div>` : ''}
                        ${segment.intention ? `<div style="background: #e3f2fd; padding: 6px; border-radius: 4px; text-align: center;"><strong>×›×•×•× ×”:</strong> ${segment.intention}</div>` : ''}
                        ${segment.godel_to_regesh ? `<div style="background: #f3e5f5; padding: 6px; border-radius: 4px; text-align: center;"><strong>×¢×•×¦××ª ×¨×’×©:</strong> ${segment.godel_to_regesh}</div>` : ''}
                        ${segment.proximity ? `<div style="background: #e8f5e8; padding: 6px; border-radius: 4px; text-align: center;"><strong>×§×¨×‘×”:</strong> ${segment.proximity}</div>` : ''}
                    </div>
                    ` : ''}
                    
                    ${segment.blob_size || segment.blob_intensity || segment.dominance ? `
                    <div style="font-size: 0.8rem; color: #6c757d; border-top: 1px solid #dee2e6; padding-top: 10px;">
                        <strong>×¤×¨××˜×¨×™× ×•×™×–×•××œ×™×™× ××ª×§×“××™×:</strong>
                        ${segment.blob_size ? ` ×’×•×“×œ Blob: ${segment.blob_size} |` : ''}
                        ${segment.blob_intensity ? ` ×¢×•×¦××ª Blob: ${segment.blob_intensity} |` : ''}
                        ${segment.dominance ? ` ×“×•××™× × ×˜×™×•×ª: ${segment.dominance} |` : ''}
                        ${segment.blobiness ? ` Blobiness: ${segment.blobiness}` : ''}
                    </div>
                    ` : ''}
                </div>
                ` : ''}
                
                <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.5rem;">
                        <button class="btn btn-secondary" onclick="analyzeSegmentAdvanced('${mp3File}')">
                            <i class="material-icons">science</i>
                            × ×™×ª×•×— ××ª×§×“× + ×§×•×œ
                        </button>
                        <button class="btn btn-info" onclick="analyzeVolumeOnly('${mp3File}')">
                            <i class="material-icons">volume_up</i>
                            × ×ª×— ×§×•×œ ×‘×œ×‘×“
                        </button>
                    </div>
                </div>
            `;
        }

        // Segment editing functions
        function updateTranscript(mp3File, value) {
            if (!emotionData[mp3File]) {
                console.error(`No emotion data found for ${mp3File}`);
                return;
            }
            
            // Check if transcript actually changed
            const currentTranscript = emotionData[mp3File].transcript || emotionData[mp3File].words || '';
            if (currentTranscript === value) {
                console.log(`No change in transcript for ${mp3File}`);
                return; // No change, don't add to pending
            }
            
            // Initialize pending changes for this file if not exists
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            
            pendingChanges[mp3File].transcript = value;
            pendingChanges[mp3File].words = value; // Update both fields
            emotionData[mp3File].transcript = value;
            emotionData[mp3File].words = value;
            hasUnsavedChanges = true;
            
            console.log(`Updated transcript for ${mp3File}:`, value.substring(0, 50) + (value.length > 50 ? '...' : ''));
            
            // Update save button state and schedule auto-save
            updateSaveButtonState();
            scheduleAutoSave();
            
            // âœ… COMPREHENSIVE SYNC: Sync with all editor types for complete synchronization
            syncInlineEditor(mp3File);
            syncSegmentEditor(mp3File);
            
            // Update the segment displays
            updateSegmentDisplays(mp3File);
            
            // âœ… SYNC TRANSCRIPT EDITORS: Update all transcript editor fields in all sections
            syncAllTranscriptEditors(mp3File, value);
            
            // âœ… AUTO AI ANALYSIS: Automatically trigger AI analysis when transcript changes
            // Check if auto-analysis is enabled (controlled by user setting)
            const shouldAutoAnalyze = window.autoAnalysisEnabled !== undefined ? window.autoAnalysisEnabled : true;
            if (shouldAutoAnalyze && value && value.trim().length > 0) {
                console.log(`ğŸ¤– Auto-triggering AI analysis for ${mp3File} due to transcript change`);
                // Delay slightly to allow UI to update, then trigger analysis
                setTimeout(async () => {
                    try {
                        await completeAIAnalysis(mp3File);
                        showStatus(`ğŸ¤– × ×™×ª×•×— ××•×˜×•××˜×™ ×”×•×©×œ× ×¢×‘×•×¨ ${mp3File}`, 'success');
                    } catch (error) {
                        console.error('Auto AI Analysis Error:', error);
                        showStatus(`âš ï¸ × ×™×ª×•×— ××•×˜×•××˜×™ × ×›×©×œ ×¢×‘×•×¨ ${mp3File} - ×œ×—×¥ ×¢×œ ×›×¤×ª×•×¨ AI ×œ× ×™×ª×•×— ×™×“× ×™`, 'warning');
                    }
                }, 1000); // 1 second delay
            }
            
            // Remove visual feedback
            const transcriptBox = document.querySelector('#active-segment-editor .transcript-box');
            if (transcriptBox) {
                transcriptBox.removeAttribute('data-changed');
            }
            
            // Update status
            const statusElement = document.getElementById(`transcript-status-${mp3File}`);
            if (statusElement) {
                statusElement.textContent = '×©××•×¨ âœ“';
                setTimeout(() => {
                    statusElement.textContent = '';
                }, 2000);
            }
            
            // Update individual segment visualization in real-time
            updateSegmentVisualization(mp3File);
            
            // If this segment is currently looping, update the main visualization in real-time
            if (currentLoopingSegment === mp3File) {
                updateLoopingVisualization(mp3File);
            }
        }
        
        function markTranscriptChanged(mp3File) {
            const statusEl = document.getElementById(`transcript-status-${mp3File}`);
            if (statusEl) {
                statusEl.textContent = 'âœï¸ ×¢×¨×™×›×”...';
                statusEl.style.color = '#ff9800';
            }
            
            // Add visual feedback to the transcript box
            const transcriptBox = document.querySelector('#active-segment-editor .transcript-box');
            if (transcriptBox) {
                transcriptBox.setAttribute('data-changed', 'true');
            }
        }
        
        function clearTranscript(mp3File) {
            const transcriptBox = document.querySelector('#active-segment-editor .transcript-box');
            if (transcriptBox) {
                transcriptBox.textContent = '';
                updateTranscript(mp3File, '');
                showStatus(`× ×•×§×” ×˜×¨× ×¡×§×¨×™×¤×˜ ×¢×‘×•×¨ ${mp3File}`, 'success');
            }
        }
        
        function capitalizeTranscript(mp3File) {
            const transcriptBox = document.querySelector('#active-segment-editor .transcript-box');
            if (transcriptBox) {
                const currentText = transcriptBox.textContent;
                const capitalizedText = currentText.charAt(0).toUpperCase() + currentText.slice(1);
                transcriptBox.textContent = capitalizedText;
                updateTranscript(mp3File, capitalizedText);
                showStatus(`×”×•×§×¤×˜×œ×• ××•×ª×™×•×ª ×¨××©×•× ×•×ª ×¢×‘×•×¨ ${mp3File}`, 'success');
            }
        }

        async function analyzeCurrentTranscript(mp3File) {
            if (!currentConversation || !emotionData[mp3File]) {
                showStatus('×©×’×™××”: × ×ª×•× ×™ ×”×§×˜×¢ ×œ× × ××¦××•', 'error');
                return;
            }

            // FIXED: Get transcript from the specific segment, not from active editor
            let currentTranscript = '';
            
            // First try to get from the inline editable transcript for this specific segment
            const segmentTranscriptEditor = document.querySelector(`[data-mp3="${mp3File}"].editable-transcript`);
            if (segmentTranscriptEditor) {
                currentTranscript = segmentTranscriptEditor.textContent.trim();
                console.log(`ğŸ“ Got transcript from inline editor for ${mp3File}: "${currentTranscript.substring(0, 50)}..."`);
            } else {
                // Fallback to existing transcript data for this specific segment
                currentTranscript = emotionData[mp3File].transcript || emotionData[mp3File].words || '';
                console.log(`ğŸ“ Got transcript from data for ${mp3File}: "${currentTranscript.substring(0, 50)}..."`);
            }

            if (!currentTranscript.trim()) {
                showStatus(`××™×Ÿ ×˜×§×¡×˜ ×œ× ×™×ª×•×— ×‘×§×˜×¢ ${mp3File} - ×× × ×”×•×¡×£ ×˜×¨× ×¡×§×¨×™×¤×˜ ×œ×§×˜×¢ ×–×”`, 'error');
                return;
            }

            const confirmMessage = `×œ× ×ª×— ××ª ×”×˜×§×¡×˜ ×¢×‘×•×¨ ×§×˜×¢ ${mp3File}?\n\nğŸ“ ×”×˜×§×¡×˜ ×©×™× ×•×ª×—:\n\"${currentTranscript.substring(0, 100)}${currentTranscript.length > 100 ? '...' : ''}\"\n\nğŸ¤– ×–×” ×™×¢×“×›×Ÿ ××ª ×›×œ ×”×¤×¨××˜×¨×™× (×¨×’×©×•×ª, ×˜×©×˜×•×©, ×‘×¨×§ ×•×›×•') ×‘×”×ª×× ×œ×˜×§×¡×˜.\n\nâš ï¸ ×•×•×“× ×©×–×” ×”×˜×§×¡×˜ ×”× ×›×•×Ÿ ×œ×§×˜×¢ ${mp3File}!`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            console.log(`âœ… User confirmed transcript analysis for ${mp3File} with transcript: "${currentTranscript.substring(0, 50)}..."`);
            console.log(`ğŸ¯ Analysis will be applied to segment: ${mp3File}`);

            try {
                const emotionCount = Object.keys(emotionsConfig || {}).length;
                showLoading(`ğŸ¤– ×× ×ª×— ×˜×§×¡×˜ ×¢×‘×•×¨ ${mp3File} ×¢× ${emotionCount} ×¨×’×©×•×ª ×–××™× ×™×...`);
                
                // First save the transcript update
                updateTranscript(mp3File, currentTranscript);
                
                // Prepare analysis payload with current transcript
                const analysisData = {
                    conversation: currentConversation,
                    mp3File: mp3File,
                    transcript: currentTranscript,
                    currentEmotions: emotionData[mp3File].emotions || ['neutral'],
                    speaker: emotionData[mp3File].speaker || 0,
                    includeVolumeAnalysis: true,
                    advancedParameters: true
                };
                
                console.log(`ğŸš€ Sending AI analysis request for ${mp3File}:`, {
                    segment: mp3File,
                    transcript_preview: currentTranscript.substring(0, 100) + '...',
                    transcript_length: currentTranscript.length,
                    speaker: analysisData.speaker,
                    emotions_available: Object.keys(emotionsConfig || {}).length
                });
                console.log(`ğŸ­ Analysis will use ${Object.keys(emotionsConfig || {}).length} available emotions from config`);
                
                const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.analysis) {
                        // Calculate enhanced visual effects from transcript and emotions
                        const enhancedEffects = calculateEnhancedVisualEffects(
                            currentTranscript, 
                            result.analysis.emotions || ['neutral'],
                            result.analysis
                        );
                        
                        // Update with AI analysis results including enhanced visual effects
                        const updates = {
                            transcript: currentTranscript, // Make sure we keep the new transcript
                            words: currentTranscript,
                            emotions: result.analysis.emotions || ['neutral'],
                            blur: enhancedEffects.blur,
                            shine: enhancedEffects.shine,
                            humor: enhancedEffects.humor,
                            ai_analyzed: true,
                            ai_analysis_date: new Date().toISOString(),
                            transcript_updated: true,
                            last_transcript_analysis: new Date().toISOString(),
                            enhanced_effects: true
                        };
                        
                        // If emotions were detected, ensure they're available in the emotions dropdown
                        if (result.analysis.available_emotions && result.analysis.emotions) {
                            updateEmotionsAvailability(result.analysis.available_emotions, result.analysis.emotion_mapping);
                            
                            // Auto-add detected emotions to the segment
                            result.analysis.emotions.forEach(detectedEmotion => {
                                autoAddDetectedEmotion(mp3File, detectedEmotion);
                            });
                        }
                        
                        // Add advanced parameters if available (with AI constraints)
                        if (result.analysis.advanced) {
                            Object.assign(updates, {
                                // âœ… CONSTRAINTS: Apply AI analysis limits
                                godel_to_regesh: Math.max(1.0, result.analysis.advanced.godel_to_regesh || 1.2),
                                coloredCircleCharSize: Math.max(1.0, result.analysis.advanced.godel_to_regesh || 1.2),
                                regularAsciiCharSize: Math.max(1.0, result.analysis.advanced.godel_to_regular || 1.0),
                                kamut_to_regesh: result.analysis.advanced.kamut_to_regesh,
                                emotionCharAmount: result.analysis.advanced.kamut_to_regesh,
                                blob_size: Math.min(5, result.analysis.advanced.blob_size || 3),
                                blobSizeScale: Math.min(5, result.analysis.advanced.blob_size || 3),
                                blob_intensity: result.analysis.advanced.blob_intensity,
                                blobStrength: result.analysis.advanced.blob_intensity,
                                dominance: result.analysis.advanced.dominance,
                                blobiness: result.analysis.advanced.blobiness,
                                proximity: result.analysis.advanced.proximity,
                                tone: result.analysis.advanced.tone,
                                intention: result.analysis.advanced.intention,
                                advanced_params: true
                            });
                        }
                        
                        // Add volume analysis if available
                        if (result.volume) {
                            Object.assign(updates, {
                                volume_mean: result.volume.mean,
                                volume_max: result.volume.max,
                                volume_energy: result.volume.energy,
                                audio_duration: result.volume.duration,
                                volume_analyzed: true
                            });
                        }
                        
                        // Check if backend auto-saved the segment
                        const emotionsText = updates.emotions.join(', ');
                        
                        if (result.segment_updated && result.analysis.auto_saved) {
                            // Backend auto-saved - update local data directly
                            const savedUpdates = result.segment_updated.updates;
                            emotionData[mp3File] = { ...emotionData[mp3File], ...savedUpdates };
                            
                            // Clear pending changes for this segment
                            if (pendingChanges[mp3File]) {
                                delete pendingChanges[mp3File];
                            }
                            hasUnsavedChanges = Object.keys(pendingChanges).length > 0;
                            
                            showStatus(`âœ… × ×™×ª×•×— ×”×•×©×œ× ×•× ×©××¨ ××•×˜×•××˜×™×ª ×¢×‘×•×¨ ${mp3File}! ×¨×’×©×•×ª: ${emotionsText}`, 'success');
                        } else {
                            // Fallback: manual save needed
                            emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                            pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                            hasUnsavedChanges = true;
                            
                            // Show analysis results summary
                            const effectsText = [];
                            if (updates.blur > 0) effectsText.push(`×˜×©×˜×•×©: ${updates.blur}`);
                            if (updates.shine > 0) effectsText.push(`×‘×¨×§: ${updates.shine}`);
                            if (updates.humor > 0) effectsText.push(`×”×•××•×¨: ${updates.humor}`);
                            
                            let summaryText = `âœ… × ×™×ª×•×— ×”×•×©×œ× ×¢×‘×•×¨ ${mp3File}!\n\nğŸ­ ×¨×’×©×•×ª: ${emotionsText}`;
                            if (effectsText.length > 0) {
                                summaryText += `\nğŸ¨ ××¤×§×˜×™×: ${effectsText.join(', ')}`;
                            }
                            if (updates.tone) {
                                summaryText += `\nğŸµ ×˜×•×Ÿ: ${updates.tone}`;
                            }
                            if (updates.intention) {
                                summaryText += `\nğŸ¯ ×›×•×•× ×”: ${updates.intention}`;
                            }
                            summaryText += `\nâš ï¸ × ×“×¨×©×ª ×©××™×¨×” ×™×“× ×™×ª`;
                            
                            showStatus(summaryText, 'warning');
                        }
                        
                        // Update UI displays in both cases with comprehensive sync
                        console.log(`âœ… AI analysis completed and applied to segment: ${mp3File}`);
                        console.log(`ğŸ“Š Updated emotions for ${mp3File}:`, updates.emotions);
                        console.log(`ğŸ¨ Enhanced visual effects: blur=${updates.blur}, shine=${updates.shine}, humor=${updates.humor}`);
                        console.log(`ğŸ­ Analysis used ${Object.keys(emotionsConfig || {}).length} available emotions from config`);
                        console.log(`ğŸ¯ Applied constraints: blobSizeâ‰¤5, charSizesâ‰¥1.0`);
                        
                        // âœ… COMPREHENSIVE SYNC: Ensure all UI elements are updated after AI analysis
                        syncAllSegmentElements(mp3File);
                        displaySegments(); // Refresh segments list
                        
                        // Force update dropdowns with constrained values
                        setTimeout(() => {
                            initializeEnhancedSliders();
                        }, 100);
                        selectSegment(mp3File, emotionData[mp3File]); // Refresh editor with new data
                        updateSaveButtonState();
                        
                    } else {
                        showStatus('× ×™×ª×•×— × ×›×©×œ - ×œ× ×”×ª×§×‘×œ×• ×ª×•×¦××•×ª ×-AI', 'error');
                    }
                } else {
                    const error = await response.text();
                    showStatus(`×©×’×™××” ×‘× ×™×ª×•×— AI: ${error}`, 'error');
                }
                
            } catch (error) {
                console.error('Error in transcript analysis:', error);
                showStatus('×©×’×™××” ×‘× ×™×ª×•×— ×”×˜×§×¡×˜ ×¢× AI', 'error');
            } finally {
                hideLoading();
            }
        }

        // ==================== COMPLETE AI ANALYSIS ====================
        // Inline editing functions
        function toggleInlineEditor(mp3File) {
            const editorPanel = document.getElementById(`inline-editor-${mp3File}`);
            const isVisible = editorPanel.style.display !== 'none';
            
            // Hide all other inline editors first
            document.querySelectorAll('[id^="inline-editor-"]').forEach(panel => {
                panel.style.display = 'none';
            });
            
            // Toggle current editor
            editorPanel.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                // Load current values from segment data when opening
                const segment = emotionData[mp3File];
                if (segment) {
                    const transcriptTextarea = document.getElementById(`inline-transcript-${mp3File}`);
                    const speakerSelect = document.getElementById(`inline-speaker-${mp3File}`);
                    
                    if (transcriptTextarea) {
                        transcriptTextarea.value = segment.transcript || segment.words || '';
                    }
                    if (speakerSelect) {
                        speakerSelect.value = segment.speaker || 0;
                    }
                }
                
                // Populate emotion dropdown options
                setTimeout(() => {
                    populateEmotionDropdown(mp3File);
                }, 100);
                
                // Focus on textarea when opening
                const textarea = document.getElementById(`inline-transcript-${mp3File}`);
                if (textarea) {
                    setTimeout(() => textarea.focus(), 150);
                }
            }
        }
        
        function saveInlineChanges(mp3File) {
            const transcriptTextarea = document.getElementById(`inline-transcript-${mp3File}`);
            const speakerSelect = document.getElementById(`inline-speaker-${mp3File}`);
            
            if (!emotionData[mp3File]) {
                showStatus('×©×’×™××”: × ×ª×•× ×™ ×”×§×˜×¢ ×œ× × ××¦××•', 'error');
                return;
            }
            
            // Update transcript using the existing function to maintain consistency
            const newTranscript = transcriptTextarea.value.trim();
            if (newTranscript !== (emotionData[mp3File].transcript || emotionData[mp3File].words || '')) {
                updateTranscript(mp3File, newTranscript);
            }
            
            // Update speaker using the existing function to maintain consistency
            const newSpeaker = parseInt(speakerSelect.value);
            if (newSpeaker !== (emotionData[mp3File].speaker || 0)) {
                updateParam(mp3File, 'speaker', newSpeaker);
            }
            
            // Update UI displays and sync with segment editor
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            // Hide editor
            document.getElementById(`inline-editor-${mp3File}`).style.display = 'none';
            
            // Save to backend (this will be handled by updateTranscript and updateParam)
            // saveEmotionData();
            
            // Refresh the segments display to ensure all changes are visible
            if (typeof displaySegments === 'function') {
                displaySegments();
            }
            
            showStatus(`âœ… ×”×©×™× ×•×™×™× × ×©××¨×• ×¢×‘×•×¨ ${mp3File}`, 'success');
        }
        
        function addInlineEmotion(mp3File) {
            const emotionSelect = document.getElementById(`inline-emotion-${mp3File}`);
            const selectedEmotion = emotionSelect.value;
            
            if (!selectedEmotion) {
                showStatus('×‘×—×¨ ×¨×’×© ×œ×”×•×¡×¤×”', 'warning');
                return;
            }
            
            if (!emotionData[mp3File]) {
                showStatus('×©×’×™××”: × ×ª×•× ×™ ×”×§×˜×¢ ×œ× × ××¦××•', 'error');
                return;
            }
            
            // Initialize emotions array if needed
            if (!emotionData[mp3File].emotions) {
                emotionData[mp3File].emotions = [];
            }
            
            // Check if emotion already exists
            if (emotionData[mp3File].emotions.includes(selectedEmotion)) {
                showStatus('×”×¨×’×© ×›×‘×¨ ×§×™×™× ×‘×¨×©×™××”', 'warning');
                return;
            }
            
            // Add emotion using the existing system to maintain consistency
            emotionData[mp3File].emotions.push(selectedEmotion);
            
            // Mark as having changes for the backend
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            pendingChanges[mp3File].emotions = emotionData[mp3File].emotions;
            hasUnsavedChanges = true;
            
            // Update UI and sync with segment editor
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            // Reset select
            emotionSelect.value = '';
            
            // Schedule auto-save
            updateSaveButtonState();
            scheduleAutoSave();
            
            showStatus(`âœ… ×”×¨×’×© ${selectedEmotion} × ×•×¡×£ ×œ×§×˜×¢ ${mp3File}`, 'success');
        }
        
        function cancelInlineEdit(mp3File) {
            // Reset form to original values
            const segment = emotionData[mp3File];
            if (segment) {
                document.getElementById(`inline-transcript-${mp3File}`).value = segment.transcript || segment.words || '';
                document.getElementById(`inline-speaker-${mp3File}`).value = segment.speaker || 0;
                document.getElementById(`inline-emotion-${mp3File}`).value = '';
            }
            
            // Hide editor
            document.getElementById(`inline-editor-${mp3File}`).style.display = 'none';
        }
        
        function updateSegmentDisplays(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            // Update emotion display
            const emotions = segment.emotions || ['neutral'];
            const emotionDisplay = emotions.map(e => {
                const config = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                const emoji = config.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                const hebrew = config.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                return emoji ? `${emoji} ${hebrew}` : hebrew;
            }).join(', ');
            
            const emotionDisplayElement = document.getElementById(`emotion-display-${mp3File}`);
            if (emotionDisplayElement) {
                emotionDisplayElement.textContent = emotionDisplay;
            }
            
            // Update transcript display
            const transcript = segment.transcript || segment.words || '';
            const transcriptDisplayElement = document.getElementById(`transcript-display-${mp3File}`);
            if (transcriptDisplayElement) {
                transcriptDisplayElement.textContent = transcript.length > 80 ? transcript.substring(0, 80) + '...' : transcript;
            }
            
            // Update speaker display
            const speakerDisplayElement = document.getElementById(`speaker-display-${mp3File}`);
            if (speakerDisplayElement) {
                                    speakerDisplayElement.textContent = `ğŸ”Š ${getSpeakerName(segment.speaker || 0)}`;
            }
            
            // Update speaker indicator color
            const speakerIndicator = document.querySelector(`#segment-${mp3File} .speaker-indicator`);
            if (speakerIndicator) {
                speakerIndicator.style.background = segment.speaker === 1 ? '#4ECDC4' : '#FF6B6B';
                speakerIndicator.title = `${getSpeakerName(segment.speaker || 0)}`;
            }
            
            // Sync with inline editor if it exists and is open
            syncInlineEditor(mp3File);
            
            // Populate emotion dropdowns with latest options
            populateEmotionDropdown(mp3File);
        }
        
        function syncInlineEditor(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            // Update inline editor fields if they exist
            const inlineTranscript = document.getElementById(`inline-transcript-${mp3File}`);
            if (inlineTranscript) {
                inlineTranscript.value = segment.transcript || segment.words || '';
            }
            
            const inlineSpeaker = document.getElementById(`inline-speaker-${mp3File}`);
            if (inlineSpeaker) {
                inlineSpeaker.value = segment.speaker || 0;
            }
            
            // Update enhanced emotion display
            refreshInlineEmotionsDisplay(mp3File);
        }
        
        function syncSegmentEditor(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            // Update segment editor panel fields if they exist
            const transcriptEditor = document.querySelector('.transcript-editor');
            if (transcriptEditor && currentSelectedSegment === mp3File) {
                transcriptEditor.textContent = segment.transcript || segment.words || '';
            }
            
            // Update speaker select in segment panel
            const speakerSelect = document.querySelector(`select[onchange*="updateParam('${mp3File}', 'speaker'"]`);
            if (speakerSelect) {
                speakerSelect.value = segment.speaker || 0;
            }
            
            // Update emotion tags in segment panel
            const emotionTags = document.querySelector('.emotion-tags');
            if (emotionTags && currentSelectedSegment === mp3File) {
                // Regenerate emotion tags
                const emotions = segment.emotions || [];
                emotionTags.innerHTML = emotions.map((e, i) => {
                    const emotionConfig = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                    const color = emotionConfig.color || DEFAULT_EMOTIONS[e]?.color || '#e3f2fd';
                    const emoji = emotionConfig.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                    const hebrew = emotionConfig.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                    
                    return `
                        <div class="emotion-tag" style="background-color: ${color}15; border: 1px solid ${color}; color: ${color};">
                            ${emoji} ${hebrew}
                            <button class="remove-btn" onclick="removeEmotion('${mp3File}', ${i})">Ã—</button>
                        </div>
                    `;
                }).join('');
            }
        }
        
        // âœ… COMPREHENSIVE PARAMETER SYNCHRONIZATION FUNCTIONS
        
        /**
         * Synchronizes a specific parameter value across all UI elements (sliders, inputs, selects)
         * This ensures that when a parameter is changed in one section, all other sections reflect the change
         */
        function syncAllParameterEditors(mp3File, param, value) {
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            // Find all parameter inputs for this mp3File and param (including dropdowns)
            const paramInputs = document.querySelectorAll(`
                input[onchange*="updateParam('${mp3File}', '${param}'"],
                select[onchange*="updateParam('${mp3File}', '${param}'"],
                input[oninput*="updateParam('${mp3File}', '${param}'"]
            `);
            
            paramInputs.forEach(input => {
                if (input.type === 'checkbox') {
                    input.checked = value === true || value === 'true';
                } else if (input.type === 'range' || input.type === 'number') {
                    input.value = parseFloat(value);
                } else if (input.tagName === 'SELECT') {
                    // Handle dropdown selects
                    input.value = value.toString();
                } else {
                    input.value = value;
                }
                
                // Update any associated display elements (for sliders with value displays)
                const paramDisplayId = `${param.replace(/([A-Z])/g, '-$1').toLowerCase()}-value-${mp3File}`;
                const displayElement = document.getElementById(paramDisplayId);
                if (displayElement) {
                    if (param === 'emotionCharAmount') {
                        displayElement.textContent = value + '%';
                    } else {
                        displayElement.textContent = value;
                    }
                }
            });
            
            console.log(`ğŸ”„ Synced parameter ${param} = ${value} across all editors for ${mp3File} (including dropdowns)`);
        }
        
        /**
         * Synchronizes transcript content across all transcript editor elements
         * This ensures that when transcript is changed in one place, all other places reflect the change
         */
        function syncAllTranscriptEditors(mp3File, transcriptValue) {
            // Update all transcript editor divs
            const transcriptEditors = document.querySelectorAll(`
                .transcript-editor[onblur*="updateTranscript('${mp3File}'"],
                .transcript-box[data-mp3="${mp3File}"]
            `);
            
            transcriptEditors.forEach(editor => {
                if (editor.textContent !== transcriptValue) {
                    editor.textContent = transcriptValue;
                }
            });
            
            // Update all transcript input fields
            const transcriptInputs = document.querySelectorAll(`
                input[id*="transcript"][id*="${mp3File}"],
                textarea[id*="transcript"][id*="${mp3File}"]
            `);
            
            transcriptInputs.forEach(input => {
                if (input.value !== transcriptValue) {
                    input.value = transcriptValue;
                }
            });
            
            // Update transcript display elements
            const transcriptDisplays = document.querySelectorAll(`[id*="transcript-display-${mp3File}"]`);
            transcriptDisplays.forEach(display => {
                const displayText = transcriptValue.length > 80 ? transcriptValue.substring(0, 80) + '...' : transcriptValue;
                if (display.textContent !== displayText) {
                    display.textContent = displayText;
                }
            });
            
            console.log(`ğŸ”„ Synced transcript across all editors for ${mp3File}: ${transcriptValue.substring(0, 50)}...`);
        }
        
        /**
         * Comprehensive synchronization function that ensures ALL UI elements are in sync for a segment
         * This is the master function that should be called when a segment is loaded or refreshed
         */
        function syncAllSegmentElements(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) {
                console.warn(`âš ï¸ No segment data found for ${mp3File}`);
                return;
            }
            
            console.log(`ğŸ”„ Full sync starting for segment: ${mp3File}`);
            
            // Sync all parameter values across all editors
            const paramKeys = ['speaker', 'blobSizeScale', 'blobStrength', 'volumeImpact', 'blur', 'humor', 
                'shine', 'blobiness', 'regularAsciiCharSize', 'coloredCircleCharSize', 'emotionCharAmount', 
                'gridResolution', 'blobHomeRegion', 'minBlobSpacing', 'blobGrowthPattern', 'connectBlobs', 'blobsVisible'];
                
            paramKeys.forEach(param => {
                if (segment[param] !== undefined && segment[param] !== null) {
                    syncAllParameterEditors(mp3File, param, segment[param]);
                }
            });
            
            // Sync transcript across all editors
            const transcript = segment.transcript || segment.words || '';
            if (transcript) {
                syncAllTranscriptEditors(mp3File, transcript);
            }
            
            // Sync standard editors
            syncInlineEditor(mp3File);
            syncSegmentEditor(mp3File);
            updateSegmentDisplays(mp3File);
            
            console.log(`âœ… Full sync completed for segment: ${mp3File}`);
        }
        
        /**
         * âœ¨ ENHANCED SLIDER FUNCTIONALITY
         * Updates slider background to show current progress and applies color theming
         */
        function updateSliderBackground(slider) {
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const value = parseFloat(slider.value);
            const percentage = ((value - min) / (max - min)) * 100;
            
            // Get color from data attribute or use default
            const color = slider.dataset.color || '#667eea';
            
            // Update CSS custom properties for dynamic styling
            slider.style.setProperty('--slider-color', color);
            slider.style.setProperty('--slider-percent', percentage + '%');
            
            // Add visual feedback
            slider.style.background = `linear-gradient(to right, ${color} 0%, ${color} ${percentage}%, #e9ecef ${percentage}%, #e9ecef 100%)`;
            
            // Optional: Add glow effect on interaction
            if (percentage > 80) {
                slider.style.filter = 'drop-shadow(0 0 8px rgba(255, 215, 0, 0.3))';
            } else {
                slider.style.filter = 'none';
            }
        }

        /**
         * Initialize all enhanced sliders with proper styling and event handlers
         */
        function initializeEnhancedSliders() {
            const sliders = document.querySelectorAll('.enhanced-slider');
            sliders.forEach(slider => {
                // Set initial background
                updateSliderBackground(slider);
                
                // Add event listeners for real-time updates
                slider.addEventListener('input', function() {
                    updateSliderBackground(this);
                });
                
                slider.addEventListener('change', function() {
                    updateSliderBackground(this);
                });
            });
            
            // Also ensure dropdowns are properly initialized with current values
            initializeDropdownValues();
        }

        /**
         * Initialize dropdown values to ensure they're not empty when going to segments
         */
        function initializeDropdownValues() {
            Object.keys(emotionData).forEach(mp3File => {
                const segment = emotionData[mp3File];
                if (!segment) return;
                
                // Update blob size dropdown
                const blobSizeDropdown = document.getElementById(`blob-size-${mp3File}`);
                if (blobSizeDropdown && segment.blobSizeScale !== undefined) {
                    blobSizeDropdown.value = Math.min(5, segment.blobSizeScale); // Apply constraint
                }
                
                // Update emotion char size dropdown
                const emotionCharDropdown = document.getElementById(`emotion-char-size-${mp3File}`);
                if (emotionCharDropdown && segment.coloredCircleCharSize !== undefined) {
                    emotionCharDropdown.value = Math.max(1.0, segment.coloredCircleCharSize); // Apply constraint
                }
                
                // Update regular char size dropdown
                const regularCharDropdown = document.getElementById(`regular-char-size-${mp3File}`);
                if (regularCharDropdown && segment.regularAsciiCharSize !== undefined) {
                    regularCharDropdown.value = Math.max(1.0, segment.regularAsciiCharSize); // Apply constraint
                }
                
                // Update emotion amount dropdown
                const emotionAmountDropdown = document.getElementById(`emotion-amount-${mp3File}`);
                if (emotionAmountDropdown && segment.emotionCharAmount !== undefined) {
                    emotionAmountDropdown.value = segment.emotionCharAmount;
                }
            });
        }

        /**
         * ğŸ¨ APPLY ENHANCED EFFECTS TO EXISTING SEGMENTS
         * Retroactively calculates and applies visual effects to segments that don't have them
         */
        function applyEnhancedEffectsToAllSegments() {
            console.log('ğŸ¨ Applying enhanced visual effects to all segments...');
            let enhancedCount = 0;
            
            Object.keys(emotionData).forEach(mp3File => {
                const segment = emotionData[mp3File];
                if (!segment || !mp3File.endsWith('.mp3')) return;
                
                const transcript = segment.transcript || segment.words || '';
                if (!transcript.trim()) return;
                
                // Only enhance if effects are minimal or missing
                if ((segment.blur || 0) <= 1 && (segment.shine || 0) <= 1 && (segment.humor || 0) <= 1) {
                    const enhancedEffects = calculateEnhancedVisualEffects(
                        transcript, 
                        segment.emotions || ['neutral'],
                        segment
                    );
                    
                    // Apply enhanced effects
                    Object.assign(segment, {
                        blur: enhancedEffects.blur,
                        shine: enhancedEffects.shine,
                        humor: enhancedEffects.humor,
                        enhanced_effects: true,
                        effects_enhanced_date: new Date().toISOString()
                    });
                    
                    enhancedCount++;
                    console.log(`ğŸ¨ Enhanced ${mp3File}: blur=${enhancedEffects.blur}, shine=${enhancedEffects.shine}, humor=${enhancedEffects.humor}`);
                }
            });
            
            if (enhancedCount > 0) {
                console.log(`âœ… Enhanced visual effects for ${enhancedCount} segments`);
                showStatus(`ğŸ¨ ×©×•×¤×¨×• ××¤×§×˜×™× ×•×™×–×•××œ×™×™× ×¢×‘×•×¨ ${enhancedCount} ×§×˜×¢×™×`, 'success');
                
                // Trigger UI refresh
                displaySegments();
            }
        }

        /**
         * ğŸ¨ ENHANCE VISUAL EFFECTS FOR INDIVIDUAL SEGMENT
         * Manually enhances visual effects for a specific segment
         */
        function enhanceVisualEffectsForSegment(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) {
                showStatus(`×©×’×™××”: ×œ× × ××¦× ×§×˜×¢ ${mp3File}`, 'error');
                return;
            }
            
            const transcript = segment.transcript || segment.words || '';
            if (!transcript.trim()) {
                showStatus(`×©×’×™××”: ××™×Ÿ ×˜×§×¡×˜ ×œ× ×™×ª×•×— ×‘×§×˜×¢ ${mp3File}`, 'error');
                return;
            }
            
            console.log(`ğŸ¨ Manually enhancing visual effects for ${mp3File}`);
            
            // Calculate enhanced effects
            const enhancedEffects = calculateEnhancedVisualEffects(
                transcript, 
                segment.emotions || ['neutral'],
                segment
            );
            
            // Apply enhanced effects
            Object.assign(segment, {
                blur: enhancedEffects.blur,
                shine: enhancedEffects.shine,
                humor: enhancedEffects.humor,
                enhanced_effects: true,
                effects_enhanced_date: new Date().toISOString()
            });
            
            // Mark as pending change for save
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            Object.assign(pendingChanges[mp3File], {
                blur: enhancedEffects.blur,
                shine: enhancedEffects.shine,
                humor: enhancedEffects.humor,
                enhanced_effects: true
            });
            hasUnsavedChanges = true;
            
            // Update UI
            updateSegmentDisplays(mp3File);
            displaySegments();
            updateSaveButtonState();
            
            showStatus(`ğŸ¨ ×©×•×¤×¨×• ××¤×§×˜×™× ×¢×‘×•×¨ ${mp3File}: ×˜×©×˜×•×©=${enhancedEffects.blur}, ×‘×¨×§=${enhancedEffects.shine}, ×”×•××•×¨=${enhancedEffects.humor}`, 'success');
            
            console.log(`âœ… Enhanced effects for ${mp3File}: blur=${enhancedEffects.blur}, shine=${enhancedEffects.shine}, humor=${enhancedEffects.humor}`);
        }

        /**
         * ğŸ¬ GENERATE ALL PREVIEW VIDEOS  
         * Generate 15-second preview videos for all conversations without side panel
         */
        async function generateAllPreviewVideos() {
            const confirmed = confirm(
                `ğŸ¬ ×™×™×¦×•×¨ ×•×™×“××• preview ×‘×Ÿ 15 ×©× ×™×•×ª ×¢×‘×•×¨ ×›×œ ×”×©×™×—×•×ª?\n\n` +
                `â€¢ 42 ×©×™×—×•×ª ×™×™×•×•×¦×¨×•\n` +
                `â€¢ 15 ×©× ×™×•×ª ×œ×›×œ ×•×™×“××•\n` +
                `â€¢ ×œ×œ× ×¤×× ×œ ×¦×“\n` +
                `â€¢ ××™×›×•×ª ×’×‘×•×”×” (1080p)\n\n` +
                `×–×” ×¢×œ×•×œ ×œ×§×—×ª 10-15 ×“×§×•×ª. ×œ×”××©×™×š?`
            );
            
            if (!confirmed) return;

            try {
                showLoading('ğŸ¬ ××ª×—×™×œ ×™×™×¦×•×¨ video previews ×¢×‘×•×¨ ×›×œ ×”×©×™×—×•×ª...');

                // Generate enhanced 15-second previews for all conversations
                const enhancedVideoSettings = {
                    duration: 15,           // 15 seconds as requested
                    quality: 1080,          // High quality
                    fps: 30,                // Smooth playback
                    backgroundColor: '#f7f9f3',
                    frameSize: {
                        width: 1920,
                        height: 1080
                    },
                    cropArea: {
                        enabled: false      // Full frame, no cropping
                    },
                    advancedOptions: {
                        noSidepanel: true,  // âœ… Hide side panel as requested
                        hideUI: true,       // Hide UI elements
                        noTimeline: true,   // Hide timeline
                        visualOnly: true,   // Only visualization
                        canvasOnly: true,   // Clean canvas only
                        cleanCapture: true, // Clean capture mode
                        optimize: true,     // Optimized rendering
                        fullscreen: true    // Full screen mode
                    }
                };

                console.log('ğŸ¬ Starting enhanced preview generation for all conversations with settings:', enhancedVideoSettings);

                const response = await fetch(`${apiBaseUrl}/api/generate-all-enhanced-videos`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(enhancedVideoSettings)
                });

                if (!response.ok) {
                    throw new Error(`Failed to generate videos: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();

                hideLoading();
                showStatus(
                    `âœ… ×”×•×©×œ× ×™×™×¦×•×¨ preview videos!\n\n` +
                    `ğŸ“Š ×¡×˜×˜×™×¡×˜×™×§×•×ª:\n` +
                    `â€¢ ×”×¦×œ×™×—×•: ${result.generated} ×©×™×—×•×ª\n` +
                    `â€¢ × ×›×©×œ×•: ${result.failed} ×©×™×—×•×ª\n` +
                    `â€¢ ×¡×”"×›: ${result.total} ×©×™×—×•×ª\n\n` +
                    `ğŸ¬ ×›×œ ×”×•×™×“××• previews ×‘× ×™ 15 ×©× ×™×•×ª ×œ×œ× ×¤×× ×œ ×¦×“ × ×•×¦×¨×• ×‘×”×¦×œ×—×”!`,
                    'success'
                );

                console.log('âœ… All preview videos generated successfully:', result);

            } catch (error) {
                hideLoading();
                console.error('Error generating preview videos:', error);
                showStatus(`âŒ ×©×’×™××” ×‘×™×™×¦×•×¨ preview videos: ${error.message}`, 'error');
            }
        }

        /**
         * Legacy function compatibility - redirect to updateParam for older slider calls
         */
        function updateSegmentParameter(mp3File, param, value) {
            console.warn(`âš ï¸ updateSegmentParameter is deprecated, using updateParam instead`);
            updateParam(mp3File, param, value);
        }

        /**
         * Show visual feedback when a dropdown parameter is changed
         */
        function showDropdownFeedback(mp3File, paramName) {
            // Check if this is a visual effect parameter
            const visualEffects = ['Blobiness', '×”×•××•×¨', '×˜×©×˜×•×©', '×‘×¨×§'];
            const isVisualEffect = visualEffects.includes(paramName);
            
            const statusId = isVisualEffect ? `visual-effects-status-${mp3File}` : `param-status-${mp3File}`;
            const statusEl = document.getElementById(statusId);
            
            if (statusEl) {
                statusEl.textContent = isVisualEffect ? `âœ¨ ${paramName} ×¢×•×“×›×Ÿ` : `âœ… ${paramName} ×¢×•×“×›×Ÿ`;
                statusEl.style.opacity = '1';
                statusEl.style.color = '#28a745';
                
                setTimeout(() => {
                    statusEl.style.opacity = '0';
                }, 2000);
            }
            
            // Update the effects display in real-time if it's a visual effect
            if (isVisualEffect) {
                updateEffectsDisplay(mp3File);
                // Also sync to advanced editor if it's open
                syncToAdvancedEditor(mp3File, paramName);
            }
            
            // Show save indicator
            showSaveIndicator(mp3File);
            
            // Refresh visualization if it's currently showing this segment
            refreshVisualizationIfActive(mp3File);
        }
        
        /**
         * Refresh the visualization if the current segment is being viewed
         */
        function refreshVisualizationIfActive(mp3File) {
            // Check if the visualization is showing this segment
            const iframe = document.getElementById('segment-visualization');
            if (iframe && iframe.src.includes(mp3File)) {
                // Small delay to ensure the data is saved before refreshing
                setTimeout(() => {
                    iframe.src = iframe.src; // Refresh the iframe
                }, 300);
            }
        }
        
        /**
         * Sync changes from segment card back to advanced editor if it's open
         */
        function syncToAdvancedEditor(mp3File, paramName) {
            // Only sync if this segment is currently selected in the advanced editor
            if (currentSelectedSegment !== mp3File) return;
            
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            // Map parameter names to advanced editor slider IDs
            const paramMapping = {
                'Blobiness': 'blobiness-value',
                '×”×•××•×¨': 'humor-value',
                '×˜×©×˜×•×©': 'blur-value',
                '×‘×¨×§': 'shine-value'
            };
            
            const paramKey = paramMapping[paramName];
            if (!paramKey) return;
            
            // Update the slider value and display in advanced editor
            const sliderElement = document.querySelector(`input[oninput*="${paramKey}-${mp3File}"]`);
            const valueDisplay = document.getElementById(`${paramKey}-${mp3File}`);
            
            if (sliderElement && valueDisplay) {
                const newValue = segment[getParamKey(paramName)];
                if (newValue !== undefined) {
                    sliderElement.value = newValue;
                    valueDisplay.textContent = newValue;
                    // Update slider background color
                    updateSliderBackground(sliderElement);
                }
            }
        }
        
        /**
         * Get the parameter key for a given parameter name
         */
        function getParamKey(paramName) {
            const keyMapping = {
                'Blobiness': 'blobiness',
                '×”×•××•×¨': 'humor',
                '×˜×©×˜×•×©': 'blur',
                '×‘×¨×§': 'shine'
            };
            return keyMapping[paramName];
        }
        
        /**
         * Update the effects display in the segment card in real-time
         */
        function updateEffectsDisplay(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            // Find the segment card and update its effects display
            const segmentCard = document.getElementById(`segment-${mp3File}`);
            if (!segmentCard) return;
            
            // Create new effects display
            const effects = [];
            if (segment.blur > 0) effects.push(`ğŸŒ«ï¸ ×˜×©×˜×•×©: ${segment.blur}`);
            if (segment.humor > 0) effects.push(`ğŸ˜„ ×”×•××•×¨: ${segment.humor}`);
            if (segment.shine > 0) effects.push(`âœ¨ ×‘×¨×§: ${segment.shine}`);
            if (segment.blobiness && segment.blobiness !== 3.5) effects.push(`ğŸ«§ Blobiness: ${segment.blobiness}`);
            
            // Find and update the effects section in the card
            const effectsSection = segmentCard.querySelector('.enhanced-segment-card').innerHTML;
            const parser = new DOMParser();
            const doc = parser.parseFromString(effectsSection, 'text/html');
            
            // Recreate the segment element to update effects display
            setTimeout(() => {
                loadSegments(); // Refresh the entire segment list to show updated effects
            }, 100);
        }
        
        /**
         * Sync visual effects changes from advanced editor back to segment cards
         */
        function syncCardVisualEffects(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            // Update the dropdowns in the enhanced segment card to match advanced editor values
            const cardBlobiness = document.getElementById(`blobiness-${mp3File}`);
            const cardHumor = document.getElementById(`humor-${mp3File}`);
            const cardBlur = document.getElementById(`blur-${mp3File}`);
            const cardShine = document.getElementById(`shine-${mp3File}`);
            
            if (cardBlobiness && segment.blobiness !== undefined) {
                cardBlobiness.value = segment.blobiness;
            }
            if (cardHumor && segment.humor !== undefined) {
                cardHumor.value = segment.humor;
            }
            if (cardBlur && segment.blur !== undefined) {
                cardBlur.value = segment.blur;
            }
            if (cardShine && segment.shine !== undefined) {
                cardShine.value = segment.shine;
            }
            
            // Update the effects display
            updateEffectsDisplay(mp3File);
            
            // Show visual effects status
            const statusEl = document.getElementById(`visual-effects-status-${mp3File}`);
            if (statusEl) {
                statusEl.textContent = 'âœ¨ ××¤×§×˜×™× ×¢×•×“×›× ×• ××”×¢×•×¨×š ×”××ª×§×“×';
                statusEl.style.opacity = '1';
                statusEl.style.color = '#28a745';
                
                setTimeout(() => {
                    statusEl.style.opacity = '0';
                }, 2000);
            }
            
            // Show save indicator
            showSaveIndicator(mp3File);
            
            // Refresh visualization for real-time preview
            refreshVisualizationIfActive(mp3File);
        }

        /**
         * ğŸ¨ ENHANCED VISUAL EFFECTS ANALYSIS
         * Intelligently calculates blur, shine, and humor based on transcript and emotions
         */
        function calculateEnhancedVisualEffects(transcript, emotions, aiResults = {}) {
            const text = transcript.toLowerCase();
            const emotionsList = emotions || ['neutral'];
            
            // Base values from AI or defaults
            let blur = aiResults.blur || 0;
            let shine = aiResults.shine || 0;
            let humor = aiResults.humor || 0;
            
            console.log(`ğŸ¨ Calculating visual effects for: "${transcript.substring(0, 50)}..." with emotions: ${emotionsList.join(', ')}`);
            
            // âœ¨ SHINE (×‘×¨×§) - Positive emotions, excitement, joy
            const shineKeywords = ['×©××—', '× ×”×“×¨', '××¢×•×œ×”', '×›×™×£', '××”×‘×”', '××•×”×‘', '× ×¤×œ×', '×™×¤×”', '×‘×¨×§', '×–×•×”×¨', '×××•×©×¨', '×©××—×”', '××©', '××“×œ×™×§', '×™××œ×œ×”', '×‘×•×'];
            const shineEmotions = ['happiness', 'joy', 'excitement', 'love', 'contentment', 'satisfaction', 'euphoria', 'elation'];
            
            let shineScore = 0;
            shineKeywords.forEach(keyword => {
                if (text.includes(keyword)) shineScore += 3; // Increased weight
            });
            shineEmotions.forEach(emotion => {
                if (emotionsList.includes(emotion)) shineScore += 4; // Increased weight
            });
            
            // Text length and intensity factor for shine
            if (text.includes('!!!') || text.includes('ğŸ˜') || text.includes('ğŸ¥°')) shineScore += 3;
            if (text.includes('!!')) shineScore += 2;
            if (text.includes('!')) shineScore += 1;
            
            // Hebrew positive expressions
            if (text.includes('×•×•××™') || text.includes('×•×•××•') || text.includes('××××œ×”')) shineScore += 2;
            
            shine = Math.max(shine, Math.min(12, Math.floor(shineScore * 1.2))); // Boosted max and multiplier
            
            // ğŸŒ«ï¸ BLUR (×˜×©×˜×•×©) - Confusion, sadness, uncertainty, tiredness
            const blurKeywords = ['×¢×™×™×£', '××‘×•×œ×‘×œ', '×œ× ×™×•×“×¢', '××•×œ×™', '×œ× ×‘×˜×•×—', '×¢×¦×•×‘', '×§×©×”', '××¡×•×‘×š', '×‘×œ×‘×•×œ', '×¢××•×', '×¨×š', '× ×¤×©', '×›×•××‘', '×“×•××’'];
            const blurEmotions = ['sadness', 'confusion', 'uncertainty', 'melancholy', 'fatigue', 'contemplation', 'worry', 'anxiety'];
            
            let blurScore = 0;
            blurKeywords.forEach(keyword => {
                if (text.includes(keyword)) blurScore += 3; // Increased weight
            });
            blurEmotions.forEach(emotion => {
                if (emotionsList.includes(emotion)) blurScore += 4; // Increased weight
            });
            
            // Uncertainty expressions
            if (text.includes('...') || text.includes('×××') || text.includes('××”×”')) blurScore += 2;
            if (text.includes('×œ× ×™×•×“×¢') || text.includes('××•×œ×™')) blurScore += 3;
            if (text.includes('?') && text.length < 20) blurScore += 1; // Short questioning
            
            blur = Math.max(blur, Math.min(15, Math.floor(blurScore * 1.3))); // Boosted max and multiplier
            
            // ğŸ˜„ HUMOR (×”×•××•×¨) - Funny words, laughter, jokes
            const humorKeywords = ['×—×—', '×”×”×”', '×œ×•×œ', '×¦×•×—×§', '××¦×—×™×§', '×©×˜×•×™×•×ª', '×›×™×£', '×‘×¦×—×•×§', '×¤×œ××¤×œ', '×”×•××•×¨', '×‘×“×™×—×”', '×—×—×—×—', '×‘×›×™×£', '××§×¡×™×'];
            const humorEmotions = ['amusement', 'playfulness', 'humor', 'sarcasm', 'irony', 'teasing'];
            const funnyChars = ['ğŸ˜‚', 'ğŸ˜„', 'ğŸ˜†', 'ğŸ¤£', 'ğŸ˜', 'ğŸ˜Š', 'ğŸ˜‰'];
            
            let humorScore = 0;
            humorKeywords.forEach(keyword => {
                if (text.includes(keyword)) humorScore += 4; // Higher weight for Hebrew humor
            });
            humorEmotions.forEach(emotion => {
                if (emotionsList.includes(emotion)) humorScore += 5; // Much higher weight
            });
            funnyChars.forEach(char => {
                if (text.includes(char)) humorScore += 3;
            });
            
            // Question marks often indicate playful tone in Hebrew
            if (text.includes('??') || text.includes('?!')) humorScore += 2;
            if (text.includes('×¨×•×¦×” ×¤×œ××¤×œ')) humorScore += 5; // Special case for the example
            
            // Informal Hebrew expressions
            if (text.includes('×‘× ×œ×š') || text.includes('××™×š ××ª×”') || text.includes('××” ×§×•×¨×”')) humorScore += 2;
            if (text.includes('×©×‘×ª ×©×œ×•×') || text.includes('×—×’ ×©××—')) humorScore += 1;
            
            humor = Math.max(humor, Math.min(15, Math.floor(humorScore * 1.5))); // Much higher max and multiplier
            
            console.log(`ğŸ¨ Enhanced effects calculated: blur=${blur}, shine=${shine}, humor=${humor}`);
            console.log(`   ğŸ“Š Scores - blur: ${blurScore}, shine: ${shineScore}, humor: ${humorScore}`);
            
            return { blur, shine, humor };
        }
        
        // ==================== ENHANCED AUDIO PLAYBACK FUNCTIONS ====================
        
        // Global audio management
        let currentPlayingAudio = null;
        let currentPlayingSegment = null;
        let audioLoopMode = {};
        let sequentialPlaylist = [];
        let sequentialPlayIndex = 0;
        let isPlayingSequentially = false;
        
        // Play a specific segment audio
        function playSegmentAudio(mp3File) {
            // Stop any currently playing audio
            stopAllAudio();
            
            try {
                const audioUrl = `${apiBaseUrl}/conversations/${currentConversation}/${mp3File}`;
                currentPlayingAudio = new Audio(audioUrl);
                currentPlayingSegment = mp3File;
                
                // Show visual indicator
                showAudioStatus(mp3File, '×× ×’×Ÿ...', 'ğŸ”Š');
                
                // Handle audio events
                currentPlayingAudio.onended = () => {
                    if (audioLoopMode[mp3File]) {
                        // Restart if loop mode is on
                        setTimeout(() => {
                            if (audioLoopMode[mp3File]) {
                                playSegmentAudio(mp3File);
                            }
                        }, 500);
                    } else {
                        hideAudioStatus(mp3File);
                        currentPlayingAudio = null;
                        currentPlayingSegment = null;
                        
                        // If playing sequentially, move to next
                        if (isPlayingSequentially) {
                            playNextInSequence();
                        }
                    }
                };
                
                currentPlayingAudio.onerror = (error) => {
                    console.error('Audio playback error:', error);
                    showStatus(`×©×’×™××” ×‘×”×©××¢×ª ${mp3File}`, 'error');
                    hideAudioStatus(mp3File);
                    currentPlayingAudio = null;
                    currentPlayingSegment = null;
                };
                
                currentPlayingAudio.onpause = () => {
                    hideAudioStatus(mp3File);
                };
                
                // Start playing
                currentPlayingAudio.play().then(() => {
                    showStatus(`ğŸ”Š ××©××™×¢ ${mp3File}`, 'info');
                }).catch(error => {
                    console.error('Play error:', error);
                    showStatus(`×©×’×™××” ×‘×”×¤×¢×œ×ª ${mp3File}`, 'error');
                    hideAudioStatus(mp3File);
                });
                
            } catch (error) {
                console.error('Error creating audio:', error);
                showStatus(`×©×’×™××” ×‘×˜×¢×™× ×ª ${mp3File}`, 'error');
            }
        }
        
        // Stop a specific segment audio
        function stopSegmentAudio(mp3File) {
            if (currentPlayingAudio && currentPlayingSegment === mp3File) {
                currentPlayingAudio.pause();
                currentPlayingAudio = null;
                currentPlayingSegment = null;
                
                hideAudioStatus(mp3File);
                showStatus(`â¹ï¸ ×”×•×¤×¡×§×” ×”×©××¢×ª ${mp3File}`, 'info');
            }
            
            // Turn off loop mode
            audioLoopMode[mp3File] = false;
            updateLoopButton(mp3File, false);
            
            // Stop sequential play if this segment was part of it
            if (isPlayingSequentially) {
                isPlayingSequentially = false;
                showStatus('×¨×¦×£ ×”×©××¢×” ×”×•×¤×¡×§', 'info');
            }
        }
        
        // Stop all audio playback
        function stopAllAudio() {
            if (currentPlayingAudio) {
                currentPlayingAudio.pause();
                if (currentPlayingSegment) {
                    hideAudioStatus(currentPlayingSegment);
                }
                currentPlayingAudio = null;
                currentPlayingSegment = null;
            }
            
            // Clear all loop modes
            Object.keys(audioLoopMode).forEach(mp3File => {
                audioLoopMode[mp3File] = false;
                updateLoopButton(mp3File, false);
            });
            
            isPlayingSequentially = false;
        }
        
        // Toggle loop mode for a segment
        function toggleSegmentLoop(mp3File) {
            const isCurrentlyLooping = audioLoopMode[mp3File] || false;
            audioLoopMode[mp3File] = !isCurrentlyLooping;
            
            updateLoopButton(mp3File, audioLoopMode[mp3File]);
            
            if (audioLoopMode[mp3File]) {
                showStatus(`ğŸ” ×œ×•×œ××” ×¤×¢×™×œ×” ×¢×‘×•×¨ ${mp3File}`, 'success');
                // Start playing if not already playing
                if (currentPlayingSegment !== mp3File) {
                    playSegmentAudio(mp3File);
                }
            } else {
                showStatus(`â¹ï¸ ×œ×•×œ××” ×”×•×¤×¡×§×” ×¢×‘×•×¨ ${mp3File}`, 'info');
            }
        }
        
        // Play all segments sequentially
        function playAllSegmentsSequentially() {
            if (!emotionData || Object.keys(emotionData).length === 0) {
                showStatus('××™×Ÿ ×§×˜×¢×™× ×œ×”×©××¢×”', 'error');
                return;
            }
            
            // Stop any current playback
            stopAllAudio();
            
            // Get all MP3 files sorted
            sequentialPlaylist = Object.keys(emotionData || {})
                .filter(key => key.endsWith('.mp3'))
                .sort((a, b) => {
                    try {
                        return a.localeCompare(b, 'he', { numeric: true });
                    } catch(e) {
                        return a > b ? 1 : -1;
                    }
                });
            
            if (sequentialPlaylist.length === 0) {
                showStatus('××™×Ÿ ×§×˜×¢×™ MP3 ×œ×”×©××¢×”', 'error');
                return;
            }
            
            sequentialPlayIndex = 0;
            isPlayingSequentially = true;
            
            showStatus(`ğŸµ ××ª×—×™×œ ×”×©××¢×” ×¨×¦×™×¤×” ×©×œ ${sequentialPlaylist.length} ×§×˜×¢×™×`, 'success');
            playNextInSequence();
        }
        
        // Play next segment in sequence
        function playNextInSequence() {
            if (!isPlayingSequentially || sequentialPlayIndex >= sequentialPlaylist.length) {
                showStatus('ğŸµ ×”×©××¢×” ×¨×¦×™×¤×” ×”×•×©×œ××”', 'success');
                isPlayingSequentially = false;
                return;
            }
            
            const mp3File = sequentialPlaylist[sequentialPlayIndex];
            sequentialPlayIndex++;
            
            showStatus(`ğŸµ ××©××™×¢ ×§×˜×¢ ${sequentialPlayIndex}/${sequentialPlaylist.length}: ${mp3File}`, 'info');
            playSegmentAudio(mp3File);
        }
        
        // Show audio status indicator
        function showAudioStatus(mp3File, text, icon) {
            const statusDiv = document.getElementById(`audio-status-${mp3File}`);
            const textSpan = document.getElementById(`audio-text-${mp3File}`);
            const iconSpan = document.getElementById(`audio-icon-${mp3File}`);
            
            if (statusDiv && textSpan && iconSpan) {
                textSpan.textContent = text;
                iconSpan.textContent = icon;
                statusDiv.style.display = 'block';
                
                // Add glow effect to the segment
                const segmentDiv = document.getElementById(`segment-${mp3File}`);
                if (segmentDiv) {
                    segmentDiv.style.boxShadow = '0 0 15px rgba(23, 162, 184, 0.5)';
                    segmentDiv.style.border = '2px solid #17a2b8';
                }
            }
        }
        
        // Hide audio status indicator
        function hideAudioStatus(mp3File) {
            const statusDiv = document.getElementById(`audio-status-${mp3File}`);
            if (statusDiv) {
                statusDiv.style.display = 'none';
                
                // Remove glow effect from the segment
                const segmentDiv = document.getElementById(`segment-${mp3File}`);
                if (segmentDiv) {
                    segmentDiv.style.boxShadow = '';
                    segmentDiv.style.border = '1px solid #e0e0e0';
                }
            }
        }
        
        // Update loop button appearance
        function updateLoopButton(mp3File, isLooping) {
            const loopBtn = document.getElementById(`loop-btn-${mp3File}`);
            if (loopBtn) {
                if (isLooping) {
                    loopBtn.style.background = '#dc3545';
                    loopBtn.style.boxShadow = '0 0 10px rgba(220, 53, 69, 0.5)';
                    loopBtn.title = '×¢×¦×•×¨ ×œ×•×œ××”';
                    loopBtn.innerHTML = 'ğŸ” ×¤×¢×™×œ';
                } else {
                    loopBtn.style.background = '#6f42c1';
                    loopBtn.style.boxShadow = '';
                    loopBtn.title = '×œ×•×œ××” ×¨×¦×™×¤×”';
                    loopBtn.innerHTML = 'ğŸ” ×œ×•×œ××”';
                }
            }
        }
        
        // Add keyboard shortcuts for audio control
        document.addEventListener('keydown', function(event) {
            // Only if not typing in an input field
            if (event.target.tagName.toLowerCase() === 'input' || 
                event.target.tagName.toLowerCase() === 'textarea' || 
                event.target.contentEditable === 'true') {
                return;
            }
            
            switch(event.key) {
                case ' ': // Spacebar - play/pause current segment
                    event.preventDefault();
                    if (currentPlayingAudio) {
                        if (currentPlayingAudio.paused) {
                            currentPlayingAudio.play();
                        } else {
                            currentPlayingAudio.pause();
                        }
                    }
                    break;
                case 'Escape': // Escape - stop all audio
                    event.preventDefault();
                    stopAllAudio();
                    showStatus('ğŸ”‡ ×›×œ ×”×©××¢×” ×”×•×¤×¡×§×”', 'info');
                    break;
                case 'p': // P - play all sequentially
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        playAllSegmentsSequentially();
                    }
                    break;
            }
        });
        
        // ==================== SEARCHABLE EMOTION DROPDOWN FUNCTIONS ====================
        
        // Hebrew alphabet order for sorting
        const HEBREW_ALPHABET_ORDER = '××‘×’×“×”×•×–×—×˜×™×›×œ×× ×¡×¢×¤×¦×§×¨×©×ª';
        
        // Get all available emotions sorted in Hebrew alphabetical order
        function getSortedEmotionsInHebrew() {
            const allEmotions = emotionsConfig ? 
                Object.keys(emotionsConfig).filter(emotion => emotionsConfig[emotion].active) :
                Object.keys(DEFAULT_EMOTIONS);
            
            return allEmotions.sort((a, b) => {
                const aConfig = (emotionsConfig && emotionsConfig[a]) || DEFAULT_EMOTIONS[a] || {};
                const bConfig = (emotionsConfig && emotionsConfig[b]) || DEFAULT_EMOTIONS[b] || {};
                const aHebrew = aConfig.hebrew || a;
                const bHebrew = bConfig.hebrew || b;
                
                // Sort by Hebrew alphabetical order
                return compareHebrewStrings(aHebrew, bHebrew);
            });
        }
        
        // Compare Hebrew strings for sorting
        function compareHebrewStrings(a, b) {
            const aFirst = a.charAt(0);
            const bFirst = b.charAt(0);
            const aIndex = HEBREW_ALPHABET_ORDER.indexOf(aFirst);
            const bIndex = HEBREW_ALPHABET_ORDER.indexOf(bFirst);
            
            if (aIndex !== -1 && bIndex !== -1) {
                if (aIndex !== bIndex) {
                    return aIndex - bIndex;
                }
            }
            
            // Fallback to standard comparison
            return a.localeCompare(b, 'he');
        }
        

        // Populate emotion dropdown with all available emotions
        function populateEmotionDropdown(mp3File) {
            // Find all emotion-select dropdowns for this mp3File
            const selects = document.querySelectorAll(`[id*="emotion-select-${mp3File}"]`);
            
            selects.forEach(select => {
                if (!select) return;
                
                // Get original placeholder text or use default
                const existingPlaceholder = select.querySelector('option[value=""]');
                const placeholderText = existingPlaceholder ? existingPlaceholder.textContent : '×‘×—×¨ ×¨×’×©...';
                
                // Clear all options
                select.innerHTML = '';
                
                // Add placeholder
                const newPlaceholder = document.createElement('option');
                newPlaceholder.value = '';
                newPlaceholder.textContent = placeholderText;
                select.appendChild(newPlaceholder);
                
                // Add all available emotions
                const availableEmotions = getAvailableEmotions();
                availableEmotions.forEach(emotion => {
                    const config = (emotionsConfig && emotionsConfig[emotion]) || DEFAULT_EMOTIONS[emotion] || {};
                    const hebrew = config.hebrew || emotion;
                    const emoji = config.emoji || '';
                    
                    const option = document.createElement('option');
                    option.value = emotion;
                    option.textContent = `${emoji} ${hebrew}`;
                    select.appendChild(option);
                });
            });
        }
        
        // Populate all emotion dropdowns in the interface
        function populateAllEmotionDropdowns() {
            // Find all emotion-select dropdowns and populate them
            const allSelects = document.querySelectorAll('[id^="emotion-select-"]');
            const processedFiles = new Set();
            
            allSelects.forEach(select => {
                const id = select.id;
                const match = id.match(/emotion-select-(.+)/);
                if (match && match[1]) {
                    const mp3File = match[1];
                    if (!processedFiles.has(mp3File)) {
                        populateEmotionDropdown(mp3File);
                        processedFiles.add(mp3File);
                    }
                }
            });
        }
        
        // Add emotion from simple dropdown
        function addEmotion(mp3File) {
            const select = document.getElementById(`emotion-select-${mp3File}`);
            if (!select || !select.value) {
                showStatus('×‘×—×¨ ×¨×’×© ×œ×”×•×¡×¤×”', 'warning');
                return;
            }
            
            const selectedEmotion = select.value;
            
            // Add the emotion using existing function
            if (!emotionData[mp3File]) {
                showStatus('×©×’×™××”: × ×ª×•× ×™ ×”×§×˜×¢ ×œ× × ××¦××•', 'error');
                return;
            }
            
            // Initialize emotions array if needed
            if (!emotionData[mp3File].emotions) {
                emotionData[mp3File].emotions = [];
            }
            
            // Check if emotion already exists
            if (emotionData[mp3File].emotions.includes(selectedEmotion)) {
                showStatus('×”×¨×’×© ×›×‘×¨ ×§×™×™× ×‘×¨×©×™××”', 'warning');
                return;
            }
            
            // Add emotion
            emotionData[mp3File].emotions.push(selectedEmotion);
            
            // Mark as having changes
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            pendingChanges[mp3File].emotions = emotionData[mp3File].emotions;
            hasUnsavedChanges = true;
            
            // Update displays
            refreshInlineEmotionsDisplay(mp3File);
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            // Reset select
            select.value = '';
            
            // Schedule auto-save
            updateSaveButtonState();
            scheduleAutoSave();
            
            const emotionConfig = (emotionsConfig && emotionsConfig[selectedEmotion]) || DEFAULT_EMOTIONS[selectedEmotion] || {};
            const emotionDisplay = emotionConfig.hebrew ? `${emotionConfig.emoji} ${emotionConfig.hebrew}` : selectedEmotion;
            showStatus(`âœ… ×”×¨×’×© ${emotionDisplay} × ×•×¡×£ ×œ×§×˜×¢ ${mp3File}`, 'success');
        }
        

        
        // ==================== ENHANCED INLINE EMOTION MANAGEMENT FUNCTIONS ====================
        
        // Add emotion from dropdown selector (Legacy - keeping for compatibility)
        function addInlineEmotionEnhanced(mp3File) {
            // Redirect to simple emotion system
            addEmotion(mp3File);
            return;
            
            const emotionSelect = document.getElementById(`inline-emotion-selector-${mp3File}`);
            const selectedEmotion = emotionSelect.value;
            
            if (!selectedEmotion) {
                showStatus('×‘×—×¨ ×¨×’×© ×œ×”×•×¡×¤×”', 'warning');
                return;
            }
            
            if (!emotionData[mp3File]) {
                showStatus('×©×’×™××”: × ×ª×•× ×™ ×”×§×˜×¢ ×œ× × ××¦××•', 'error');
                return;
            }
            
            // Initialize emotions array if needed
            if (!emotionData[mp3File].emotions) {
                emotionData[mp3File].emotions = [];
            }
            
            // Check if emotion already exists
            if (emotionData[mp3File].emotions.includes(selectedEmotion)) {
                showStatus('×”×¨×’×© ×›×‘×¨ ×§×™×™× ×‘×¨×©×™××”', 'warning');
                return;
            }
            
            // Add emotion
            emotionData[mp3File].emotions.push(selectedEmotion);
            
            // Mark as having changes
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            pendingChanges[mp3File].emotions = emotionData[mp3File].emotions;
            hasUnsavedChanges = true;
            
            // Update displays
            refreshInlineEmotionsDisplay(mp3File);
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            // Reset select
            emotionSelect.value = '';
            
            // Schedule auto-save
            updateSaveButtonState();
            scheduleAutoSave();
            
            const emotionConfig = (emotionsConfig && emotionsConfig[selectedEmotion]) || DEFAULT_EMOTIONS[selectedEmotion] || {};
            const emotionDisplay = emotionConfig.hebrew ? `${emotionConfig.emoji} ${emotionConfig.hebrew}` : selectedEmotion;
            showStatus(`âœ… ×”×¨×’×© ${emotionDisplay} × ×•×¡×£ ×œ×§×˜×¢ ${mp3File}`, 'success');
        }
        
        // Quick add emotion from quick buttons
        function addQuickInlineEmotion(mp3File, emotion) {
            if (!emotionData[mp3File]) {
                showStatus('×©×’×™××”: × ×ª×•× ×™ ×”×§×˜×¢ ×œ× × ××¦××•', 'error');
                return;
            }
            
            // Initialize emotions array if needed
            if (!emotionData[mp3File].emotions) {
                emotionData[mp3File].emotions = [];
            }
            
            // Check if emotion already exists
            if (emotionData[mp3File].emotions.includes(emotion)) {
                showStatus('×”×¨×’×© ×›×‘×¨ ×§×™×™× ×‘×¨×©×™××”', 'warning');
                return;
            }
            
            // Add emotion
            emotionData[mp3File].emotions.push(emotion);
            
            // Mark as having changes
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            pendingChanges[mp3File].emotions = emotionData[mp3File].emotions;
            hasUnsavedChanges = true;
            
            // Update displays
            refreshInlineEmotionsDisplay(mp3File);
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            // Schedule auto-save
            updateSaveButtonState();
            scheduleAutoSave();
            
            const emotionConfig = (emotionsConfig && emotionsConfig[emotion]) || DEFAULT_EMOTIONS[emotion] || {};
            const emotionDisplay = emotionConfig.hebrew ? `${emotionConfig.emoji} ${emotionConfig.hebrew}` : emotion;
            showStatus(`ğŸš€ ×”×¨×’×© ${emotionDisplay} × ×•×¡×£ ×‘××”×™×¨×•×ª ×œ×§×˜×¢ ${mp3File}`, 'success');
        }
        
        // Remove specific emotion by index
        function removeInlineEmotion(mp3File, emotionIndex) {
            if (!emotionData[mp3File] || !emotionData[mp3File].emotions) return;
            
            const currentEmotions = emotionData[mp3File].emotions || [];
            
            if (currentEmotions.length <= 1) {
                showStatus('×—×™×™×‘ ×œ×”×™×•×ª ×œ×¤×—×•×ª ×¨×’×© ××—×“ ×‘×§×˜×¢', 'error');
                return;
            }
            
            const emotionToRemove = currentEmotions[emotionIndex];
            const newEmotions = currentEmotions.filter((_, index) => index !== emotionIndex);
            
            // Update data
            emotionData[mp3File].emotions = newEmotions;
            
            // Mark as having changes
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            pendingChanges[mp3File].emotions = newEmotions;
            hasUnsavedChanges = true;
            
            // Update displays
            refreshInlineEmotionsDisplay(mp3File);
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            // Schedule auto-save
            updateSaveButtonState();
            scheduleAutoSave();
            
            const emotionConfig = (emotionsConfig && emotionsConfig[emotionToRemove]) || DEFAULT_EMOTIONS[emotionToRemove] || {};
            const emotionDisplay = emotionConfig.hebrew ? `${emotionConfig.emoji} ${emotionConfig.hebrew}` : emotionToRemove;
            showStatus(`ğŸ—‘ï¸ ×”×•×¡×¨ ×¨×’×© ${emotionDisplay} ××”×§×˜×¢ ${mp3File}`, 'success');
        }
        
        // Clear all emotions from segment
        function clearAllInlineEmotions(mp3File) {
            if (!emotionData[mp3File]) return;
            
            const confirmMessage = `×œ× ×§×•×ª ××ª ×›×œ ×”×¨×’×©×•×ª ××”×§×˜×¢ ${mp3File}?\n\n×–×” ×™×•×¡×™×£ ×¨×’×© "× ×™×˜×¨×œ×™" ×›×‘×¨×™×¨×ª ××—×“×œ.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Set to neutral emotion only
            emotionData[mp3File].emotions = ['neutral'];
            
            // Mark as having changes
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            pendingChanges[mp3File].emotions = ['neutral'];
            hasUnsavedChanges = true;
            
            // Update displays
            refreshInlineEmotionsDisplay(mp3File);
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            // Schedule auto-save
            updateSaveButtonState();
            scheduleAutoSave();
            
            showStatus(`ğŸ—‘ï¸ × ×•×§×• ×›×œ ×”×¨×’×©×•×ª ××”×§×˜×¢ ${mp3File}, ×”×•×’×“×¨ ×›"× ×™×˜×¨×œ×™"`, 'info');
        }
        
        // Refresh the inline emotions display
        function refreshInlineEmotionsDisplay(mp3File) {
            const emotionsContainer = document.getElementById(`inline-emotions-tags-${mp3File}`);
            if (!emotionsContainer) return;
            
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            const emotions = segment.emotions || ['neutral'];
            
            // Update emotion count in label
            const label = emotionsContainer.parentElement.querySelector('label');
            if (label) {
                label.innerHTML = `ğŸ­ ×¨×’×©×•×ª × ×•×›×—×™×™×: <span style="font-size: 0.8rem; color: #6c757d; font-weight: normal;">(${emotions.length} ×¨×’×©×•×ª)</span>`;
            }
            
            // Generate emotion tags HTML
            const emotionTagsHTML = emotions.map((e, i) => {
                const emotionConfig = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                const color = emotionConfig.color || DEFAULT_EMOTIONS[e]?.color || '#6c757d';
                const emoji = emotionConfig.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                const hebrew = emotionConfig.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                
                return `
                    <div class="inline-emotion-tag" data-emotion="${e}" style="
                        background: ${color}25; 
                        border: 1.5px solid ${color}; 
                        color: ${color}; 
                        padding: 0.3rem 0.6rem; 
                        border-radius: 15px; 
                        font-size: 0.8rem; 
                        font-weight: 600;
                        display: flex;
                        align-items: center;
                        gap: 0.3rem;
                        transition: all 0.2s ease;
                        cursor: pointer;
                        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                    " 
                    onmouseover="this.style.background='${color}35'; this.style.transform='scale(1.05)'; this.style.boxShadow='0 2px 6px rgba(0,0,0,0.15)'"
                    onmouseout="this.style.background='${color}25'; this.style.transform='scale(1)'; this.style.boxShadow='0 1px 3px rgba(0,0,0,0.1)'"
                    title="×œ×—×¥ ×›×“×™ ×œ×”×¡×™×¨ ××ª ${hebrew}">
                        <span>${emoji} ${hebrew}</span>
                        <button onclick="event.stopPropagation(); removeInlineEmotion('${mp3File}', ${i})" 
                                style="background: none; border: none; color: ${color}; cursor: pointer; padding: 0; margin-left: 0.2rem; font-size: 1rem; font-weight: bold; opacity: 0.7; transition: opacity 0.2s;"
                                onmouseover="this.style.opacity='1'"
                                onmouseout="this.style.opacity='0.7'"
                                title="×”×¡×¨ ×¨×’×© ${hebrew}">Ã—</button>
                    </div>
                `;
            }).join('');
            
            // Update container content
            if (emotions.length === 0) {
                emotionsContainer.innerHTML = '<div style="color: #6c757d; font-style: italic; display: flex; align-items: center; justify-content: center; width: 100%; padding: 0.5rem;">ğŸ“ ××™×Ÿ ×¨×’×©×•×ª - ×”×•×¡×£ ×¨×’×© ×¨××©×•×Ÿ</div>';
            } else {
                emotionsContainer.innerHTML = emotionTagsHTML;
            }
        }
        
        // Auto-analysis toggle functionality
        function toggleAutoAnalysis() {
            window.autoAnalysisEnabled = !window.autoAnalysisEnabled;
            const button = document.getElementById('auto-analysis-toggle');
            const icon = button.querySelector('.material-icons');
            
            if (window.autoAnalysisEnabled) {
                button.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
                button.innerHTML = '<i class="material-icons">smart_toy</i>× ×™×ª×•×— ××•×˜×•××˜×™: ×¤×¢×™×œ';
                button.title = '× ×™×ª×•×— ××•×˜×•××˜×™ ×›×©××¢×“×›× ×™× ×˜×¨× ×¡×§×¨×™×¤×˜ - ×¤×¢×™×œ';
                showStatus('ğŸ¤– × ×™×ª×•×— ××•×˜×•××˜×™ ×”×•×¤×¢×œ - ×¨×’×©×•×ª ×™×ª×¢×“×›× ×• ××•×˜×•××˜×™×•×ª ×›×©××¢×“×›× ×™× ×˜×¨× ×¡×§×¨×™×¤×˜', 'success');
            } else {
                button.style.background = 'linear-gradient(135deg, #6c757d, #495057)';
                button.innerHTML = '<i class="material-icons">smart_toy_disabled</i>× ×™×ª×•×— ××•×˜×•××˜×™: ×›×‘×•×™';
                button.title = '× ×™×ª×•×— ××•×˜×•××˜×™ ×›×©××¢×“×›× ×™× ×˜×¨× ×¡×§×¨×™×¤×˜ - ×›×‘×•×™ (×œ×—×¥ ×œ×”×¤×¢×œ×”)';
                showStatus('â¸ï¸ × ×™×ª×•×— ××•×˜×•××˜×™ ×”×•×©×‘×ª - ×”×©×ª××© ×‘×›×¤×ª×•×¨ AI ×œ× ×™×ª×•×— ×™×“× ×™', 'info');
            }
            
            // Save the setting to localStorage
            localStorage.setItem('autoAnalysisEnabled', window.autoAnalysisEnabled);
        }
        
        // Initialize auto-analysis setting on page load
        function initializeAutoAnalysis() {
            // Load setting from localStorage, default to true
            const saved = localStorage.getItem('autoAnalysisEnabled');
            window.autoAnalysisEnabled = saved !== null ? JSON.parse(saved) : true;
            
            // Update button appearance
            const button = document.getElementById('auto-analysis-toggle');
            if (button) {
                if (window.autoAnalysisEnabled) {
                    button.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
                    button.innerHTML = '<i class="material-icons">smart_toy</i>× ×™×ª×•×— ××•×˜×•××˜×™: ×¤×¢×™×œ';
                    button.title = '× ×™×ª×•×— ××•×˜×•××˜×™ ×›×©××¢×“×›× ×™× ×˜×¨× ×¡×§×¨×™×¤×˜ - ×¤×¢×™×œ';
                } else {
                    button.style.background = 'linear-gradient(135deg, #6c757d, #495057)';
                    button.innerHTML = '<i class="material-icons">smart_toy_disabled</i>× ×™×ª×•×— ××•×˜×•××˜×™: ×›×‘×•×™';
                    button.title = '× ×™×ª×•×— ××•×˜×•××˜×™ ×›×©××¢×“×›× ×™× ×˜×¨× ×¡×§×¨×™×¤×˜ - ×›×‘×•×™ (×œ×—×¥ ×œ×”×¤×¢×œ×”)';
                }
            }
        }
        
        async function startInlineAIAnalysis(mp3File) {
            // FIXED: Get current transcript from the correct source for this specific segment
            let currentTranscript = '';
            
            // First try to get from the inline editable transcript for this specific segment
            const segmentTranscriptEditor = document.querySelector(`[data-mp3="${mp3File}"].editable-transcript`);
            if (segmentTranscriptEditor) {
                currentTranscript = segmentTranscriptEditor.textContent.trim();
                console.log(`ğŸ“ Got transcript from inline editor for ${mp3File}: "${currentTranscript.substring(0, 50)}..."`);
            } else {
                // Fallback to old inline editor if it exists
                const transcriptTextarea = document.getElementById(`inline-transcript-${mp3File}`);
                if (transcriptTextarea) {
                    currentTranscript = transcriptTextarea.value.trim();
                } else {
                    // Final fallback to existing transcript data
                    currentTranscript = emotionData[mp3File]?.transcript || emotionData[mp3File]?.words || '';
                }
            }
            
            if (!currentTranscript) {
                showStatus(`××™×Ÿ ×˜×§×¡×˜ ×œ× ×™×ª×•×— ×‘×§×˜×¢ ${mp3File} - ×× × ×”×•×¡×£ ×˜×¨× ×¡×§×¨×™×¤×˜ ×§×•×“×`, 'error');
                return;
            }
            
            // Update the transcript in data before analysis
            if (emotionData[mp3File]) {
                emotionData[mp3File].transcript = currentTranscript;
                emotionData[mp3File].words = currentTranscript;
            }
            
            // Hide old inline editor if it exists
            const inlineEditor = document.getElementById(`inline-editor-${mp3File}`);
            if (inlineEditor) {
                inlineEditor.style.display = 'none';
            }
            
            try {
                console.log(`ğŸ¤– Starting AI analysis for ${mp3File} with transcript: "${currentTranscript.substring(0, 100)}..."`);
                
                // Call the main AI analysis function
                await completeAIAnalysis(mp3File);
                
                // Refresh the entire segments display to show all updates
                if (typeof displaySegments === 'function') {
                    displaySegments();
                }
                
                showStatus(`ğŸ¤– × ×™×ª×•×— AI ×”×•×©×œ× ×¢×‘×•×¨ ${mp3File}`, 'success');
            } catch (error) {
                console.error('AI Analysis Error:', error);
                showStatus('×©×’×™××” ×‘× ×™×ª×•×— AI - × ×¡×” ×©×•×‘', 'error');
            }
        }

        // Single comprehensive function that analyzes both MP3 audio and transcript
        async function completeAIAnalysis(mp3File) {
            if (!currentConversation || !emotionData[mp3File]) {
                showStatus('×©×’×™××”: × ×ª×•× ×™ ×”×§×˜×¢ ×œ× × ××¦××•', 'error');
                return;
            }

            // FIXED: Get transcript from the specific segment, not from active editor
            let currentTranscript = '';
            
            // First try to get from the inline editable transcript for this specific segment
            const segmentTranscriptEditor = document.querySelector(`[data-mp3="${mp3File}"].editable-transcript`);
            if (segmentTranscriptEditor) {
                currentTranscript = segmentTranscriptEditor.textContent.trim();
                console.log(`ğŸ“ Got transcript from inline editor for ${mp3File}: "${currentTranscript.substring(0, 50)}..."`);
            } else {
                // Fallback to existing transcript data for this specific segment
                currentTranscript = emotionData[mp3File].transcript || emotionData[mp3File].words || '';
                console.log(`ğŸ“ Got transcript from data for ${mp3File}: "${currentTranscript.substring(0, 50)}..."`);
            }

            if (!currentTranscript.trim()) {
                showStatus(`××™×Ÿ ×˜×§×¡×˜ ×œ× ×™×ª×•×— ×‘×§×˜×¢ ${mp3File} - ×× × ×”×•×¡×£ ×˜×¨× ×¡×§×¨×™×¤×˜ ×œ×§×˜×¢ ×–×”`, 'error');
                return;
            }

            const confirmMessage = `ğŸ¯ × ×™×ª×•×— ××œ× ×¢×‘×•×¨ ×§×˜×¢ ${mp3File}?\n\nğŸ“ ×”×˜×§×¡×˜ ×©×™× ×•×ª×—:\n\"${currentTranscript.substring(0, 100)}${currentTranscript.length > 100 ? '...' : ''}\"\n\nğŸ” ×”× ×™×ª×•×— ×™×›×œ×•×œ:\nâ€¢ × ×™×ª×•×— ×”××•×“×™×• (×¢×•×¦××ª ×§×•×œ, ×× ×¨×’×™×”)\nâ€¢ × ×™×ª×•×— ×”×˜×§×¡×˜ ×¢× ChatGPT\nâ€¢ ×¢×“×›×•×Ÿ ×›×œ ×”×¤×¨××˜×¨×™× (×¨×’×©×•×ª, ×˜×©×˜×•×©, ×‘×¨×§, ×”×•××•×¨)\nâ€¢ ×¤×¨××˜×¨×™× ××ª×§×“××™× (×˜×•×Ÿ, ×›×•×•× ×”, ×’×•×“×œ blob)\n\nâš ï¸ ×•×•×“× ×©×–×” ×”×˜×§×¡×˜ ×”× ×›×•×Ÿ ×œ×§×˜×¢ ${mp3File}!`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            console.log(`âœ… User confirmed AI analysis for ${mp3File} with transcript: "${currentTranscript.substring(0, 50)}..."`);
            console.log(`ğŸ¯ Analysis will be applied to segment: ${mp3File}`);

            try {
                const emotionCount = Object.keys(emotionsConfig || {}).length;
                showLoading(`ğŸ¯ × ×™×ª×•×— ××œ× ×¢×‘×•×¨ ${mp3File}...\nğŸ”Š ××•×“×™×• + ğŸ¤– ×˜×§×¡×˜ + ğŸ­ ${emotionCount} ×¨×’×©×•×ª ×-ChatGPT`);
                
                // First save the transcript update
                updateTranscript(mp3File, currentTranscript);
                
                // Prepare comprehensive analysis payload
                const analysisData = {
                    conversation: currentConversation,
                    mp3File: mp3File,
                    transcript: currentTranscript,
                    currentEmotions: emotionData[mp3File].emotions || ['neutral'],
                    speaker: emotionData[mp3File].speaker || 0,
                    includeVolumeAnalysis: true,  // Audio analysis
                    advancedParameters: true,     // Advanced parameters
                    analyzeAudio: true,           // Full audio processing
                    comprehensiveAnalysis: true   // Complete analysis mode
                };
                
                console.log(`ğŸš€ Sending comprehensive AI analysis request for ${mp3File}:`, {
                    segment: mp3File,
                    transcript_preview: currentTranscript.substring(0, 100) + '...',
                    transcript_length: currentTranscript.length,
                    speaker: analysisData.speaker,
                    mode: 'comprehensive'
                });
                
                const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.analysis) {
                        // Calculate enhanced visual effects from transcript and emotions
                        const enhancedEffects = calculateEnhancedVisualEffects(
                            currentTranscript, 
                            result.analysis.emotions || ['neutral'],
                            result.analysis
                        );
                        
                        // Update with complete AI analysis results including enhanced visual effects
                        const updates = {
                            transcript: currentTranscript,
                            words: currentTranscript,
                            emotions: result.analysis.emotions || ['neutral'],
                            blur: enhancedEffects.blur,
                            shine: enhancedEffects.shine,
                            humor: enhancedEffects.humor,
                            ai_analyzed: true,
                            ai_analysis_date: new Date().toISOString(),
                            transcript_updated: true,
                            last_complete_analysis: new Date().toISOString(),
                            complete_analysis: true,
                            enhanced_effects: true
                        };
                        
                        // Add advanced parameters if available (with AI constraints)
                        if (result.analysis.advanced) {
                            Object.assign(updates, {
                                // âœ… CONSTRAINTS: Apply AI analysis limits
                                godel_to_regesh: Math.max(1.0, result.analysis.advanced.godel_to_regesh || 1.2),
                                coloredCircleCharSize: Math.max(1.0, result.analysis.advanced.godel_to_regesh || 1.2),
                                regularAsciiCharSize: Math.max(1.0, result.analysis.advanced.godel_to_regular || 1.0),
                                kamut_to_regesh: result.analysis.advanced.kamut_to_regesh,
                                emotionCharAmount: result.analysis.advanced.kamut_to_regesh,
                                blob_size: Math.min(5, result.analysis.advanced.blob_size || 3),
                                blobSizeScale: Math.min(5, result.analysis.advanced.blob_size || 3),
                                blob_intensity: result.analysis.advanced.blob_intensity,
                                blobStrength: result.analysis.advanced.blob_intensity,
                                dominance: result.analysis.advanced.dominance,
                                blobiness: result.analysis.advanced.blobiness,
                                proximity: result.analysis.advanced.proximity,
                                tone: result.analysis.advanced.tone,
                                intention: result.analysis.advanced.intention,
                                advanced_params: true
                            });
                        }
                        
                        // Add comprehensive volume analysis if available
                        if (result.volume) {
                            Object.assign(updates, {
                                volume_mean: result.volume.mean,
                                volume_max: result.volume.max,
                                volume_energy: result.volume.energy,
                                volume_std: result.volume.std,
                                audio_duration: result.volume.duration,
                                volume_analyzed: true,
                                audio_analyzed: true
                            });
                        }
                        
                        // Update emotions availability in dropdowns
                        if (result.analysis && result.analysis.available_emotions && result.analysis.emotions) {
                            updateEmotionsAvailability(result.analysis.available_emotions, result.analysis.emotion_mapping);
                            
                            // Auto-add detected emotions to the segment
                            result.analysis.emotions.forEach(detectedEmotion => {
                                autoAddDetectedEmotion(mp3File, detectedEmotion);
                            });
                        }
                        
                        // Check if backend auto-saved the segment
                        const emotionsText = updates.emotions.join(', ');
                        
                        if (result.segment_updated && result.analysis.auto_saved) {
                            // Backend auto-saved - update local data directly
                            const savedUpdates = result.segment_updated.updates;
                            emotionData[mp3File] = { ...emotionData[mp3File], ...savedUpdates };
                            
                            // Clear pending changes for this segment
                            if (pendingChanges[mp3File]) {
                                delete pendingChanges[mp3File];
                            }
                            hasUnsavedChanges = Object.keys(pendingChanges).length > 0;
                            
                            showStatus(`ğŸ¯ × ×™×ª×•×— ××œ× ×”×•×©×œ× ×•× ×©××¨ ××•×˜×•××˜×™×ª ×¢×‘×•×¨ ${mp3File}!\n\nğŸ­ ×¨×’×©×•×ª: ${emotionsText}\n\nâœ… ×”×˜×§×¡×˜ ×•×”××•×“×™×• × ×•×ª×—×• ×‘×”×¦×œ×—×” ×¢× ChatGPT!`, 'success');
                        } else {
                            // Fallback: manual save needed
                            emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                            pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                            hasUnsavedChanges = true;
                            
                            // Show comprehensive analysis results summary
                            const effectsText = [];
                            if (updates.blur > 0) effectsText.push(`×˜×©×˜×•×©: ${updates.blur}`);
                            if (updates.shine > 0) effectsText.push(`×‘×¨×§: ${updates.shine}`);
                            if (updates.humor > 0) effectsText.push(`×”×•××•×¨: ${updates.humor}`);
                            
                            let summaryText = `ğŸ¯ × ×™×ª×•×— ××œ× ×”×•×©×œ× ×¢×‘×•×¨ ${mp3File}!\n\nğŸ­ ×¨×’×©×•×ª: ${emotionsText}`;
                            
                            if (effectsText.length > 0) {
                                summaryText += `\nğŸ¨ ××¤×§×˜×™×: ${effectsText.join(', ')}`;
                            }
                            
                            if (updates.tone) {
                                summaryText += `\nğŸµ ×˜×•×Ÿ: ${updates.tone}`;
                            }
                            
                            if (updates.intention) {
                                summaryText += `\nğŸ¯ ×›×•×•× ×”: ${updates.intention}`;
                            }
                            
                            if (updates.volume_mean) {
                                summaryText += `\nğŸ”Š ×¢×•×¦××ª ×§×•×œ: ${Math.round(updates.volume_mean * 100)}%`;
                            }
                            
                            if (updates.blob_size) {
                                summaryText += `\nâšª ×’×•×“×œ Blob: ${updates.blob_size}`;
                            }
                            
                            summaryText += `\n\nâœ… ×”×˜×§×¡×˜ ×•×”××•×“×™×• × ×•×ª×—×• ×‘×”×¦×œ×—×” ×¢× ChatGPT!\nâš ï¸ × ×“×¨×©×ª ×©××™×¨×” ×™×“× ×™×ª`;
                            
                            showStatus(summaryText, 'warning');
                        }
                        
                        // Update UI displays in both cases
                        console.log(`âœ… Comprehensive AI analysis completed and applied to segment: ${mp3File}`);
                        console.log(`ğŸ“Š Updated emotions for ${mp3File}:`, updates.emotions);
                        console.log(`ğŸ¨ Updated effects for ${mp3File}: blur=${updates.blur}, shine=${updates.shine}, humor=${updates.humor}`);
                        console.log(`ğŸ­ Comprehensive analysis used ${Object.keys(emotionsConfig || {}).length} available emotions + audio analysis`);
                        displaySegments(); // Refresh segments list
                        selectSegment(mp3File, emotionData[mp3File]); // Refresh editor with new data
                        updateSaveButtonState();
                        
                    } else {
                        showStatus('× ×™×ª×•×— × ×›×©×œ - ×œ× ×”×ª×§×‘×œ×• ×ª×•×¦××•×ª ×-ChatGPT', 'error');
                    }
                } else {
                    const error = await response.text();
                    showStatus(`×©×’×™××” ×‘× ×™×ª×•×— ××œ×: ${error}`, 'error');
                }
                
            } catch (error) {
                console.error('Error in complete AI analysis:', error);
                showStatus('×©×’×™××” ×‘× ×™×ª×•×— ×”××œ× ×¢× ChatGPT', 'error');
            } finally {
                hideLoading();
            }
        }

        // New comprehensive transcription + analysis for single segment
        async function transcribeAndAnalyzeSegment(mp3File) {
            console.log(`ğŸ¤ Transcription request for segment: ${mp3File}`);
            
            if (!currentConversation || !emotionData[mp3File]) {
                console.error('Missing conversation or emotion data:', { currentConversation, hasEmotionData: !!emotionData[mp3File] });
                showStatus('×©×’×™××”: × ×ª×•× ×™ ×”×§×˜×¢ ×œ× × ××¦××•', 'error');
                return;
            }

            // Show transcription method selection dialog
            const transcriptionMethod = await showTranscriptionMethodDialog();
            if (!transcriptionMethod) {
                return; // User cancelled
            }

            try {
                const emotionCount = Object.keys(emotionsConfig || {}).length;
                showLoading(`ğŸ¤ğŸ¤– ×ª××œ×•×œ + × ×™×ª×•×— ××œ× ×¢×‘×•×¨ ${mp3File}...\nğŸ”Š ×ª××œ×•×œ ××•×“×™×• + ğŸ­ ${emotionCount} ×¨×’×©×•×ª ×-ChatGPT`);
                
                const analysisData = {
                    conversation: currentConversation,
                    mp3File: mp3File,
                    speaker: emotionData[mp3File].speaker || 0,
                    transcription_method: transcriptionMethod,
                    auto_save: true
                };

                console.log(`ğŸš€ Sending transcription + analysis request for ${mp3File}:`, {
                    segment: mp3File,
                    speaker: analysisData.speaker,
                    transcription_method: transcriptionMethod,
                    emotions_available: Object.keys(emotionsConfig || {}).length
                });
                console.log(`ğŸ­ğŸ¤ Transcription + Analysis will use ${Object.keys(emotionsConfig || {}).length} available emotions + transcription`);
                
                const response = await fetch(`${apiBaseUrl}/api/transcribe-and-analyze-segment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisData)
                });

                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.analysis && result.transcript) {
                        // Update with comprehensive analysis results including transcript
                        const updates = {
                            transcript: result.transcript,
                            words: result.transcript,
                            emotions: result.analysis.emotions || ['neutral'],
                            blur: result.analysis.blur || 0,
                            shine: result.analysis.shine || 0,
                            humor: result.analysis.humor || 0,
                            ai_analyzed: true,
                            transcribed: true,
                            transcription_method: result.transcription_method,
                            ai_analysis_date: new Date().toISOString(),
                            transcription_date: new Date().toISOString(),
                            transcript_updated: true,
                            last_transcript_analysis: new Date().toISOString()
                        };
                        
                        // Update emotion data
                        Object.assign(emotionData[mp3File], updates);
                        
                        // Update inline transcript editor if it exists
                        const segmentTranscriptEditor = document.querySelector(`[data-mp3="${mp3File}"].editable-transcript`);
                        if (segmentTranscriptEditor) {
                            segmentTranscriptEditor.textContent = result.transcript;
                            // Add visual feedback for successful transcription
                            segmentTranscriptEditor.style.background = 'rgba(40, 167, 69, 0.1)';
                            setTimeout(() => {
                                segmentTranscriptEditor.style.background = '';
                            }, 2000);
                        }
                        
                        console.log(`âœ… Complete transcription + analysis completed for segment: ${mp3File}`);
                        console.log(`ğŸ“ New transcript: "${result.transcript.substring(0, 100)}..."`);
                        console.log(`ğŸ“Š Updated emotions for ${mp3File}:`, updates.emotions);
                        console.log(`ğŸ­ğŸ¤ Complete analysis used ${Object.keys(emotionsConfig || {}).length} available emotions + transcription`);
                        
                        // Force reload emotion data to ensure fresh data
                        await loadEmotionData(currentConversation);
                        
                        displaySegments(); // Refresh segments list
                        selectSegment(mp3File, emotionData[mp3File]); // Refresh editor with new data
                        
                        // Show success with detailed results and force UI refresh
                        showStatus(`ğŸ¤ğŸ¤– ×ª××œ×•×œ + × ×™×ª×•×— ×”×•×©×œ× ×‘×”×¦×œ×—×” ×¢×‘×•×¨ ${mp3File}!\n\nğŸ“ ×ª××œ×•×œ: "${result.transcript.substring(0, 80)}${result.transcript.length > 80 ? '...' : ''}"\nğŸ­ ×¨×’×©×•×ª: ${updates.emotions.join(', ')}\nğŸ¤ ×©×™×˜×ª ×ª××œ×•×œ: ${result.transcription_method}\n\nğŸ”„ ×”×××©×§ ×¢×•×“×›×Ÿ ×¢× ×”×ª××œ×•×œ ×”×—×“×©!`, 'success');
                    } else {
                        showStatus(`×©×’×™××” ×‘×ª××œ×•×œ ××• × ×™×ª×•×— ×”×§×˜×¢ ${mp3File}`, 'error');
                    }
                } else {
                    const errorResult = await response.json();
                    showStatus(`×©×’×™××” ×‘×ª××œ×•×œ + × ×™×ª×•×—: ${errorResult.error}`, 'error');
                }
            } catch (error) {
                showStatus(`×©×’×™××” ×‘×ª××œ×•×œ + × ×™×ª×•×—: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        // New comprehensive transcription + analysis for entire conversation
        async function transcribeAndAnalyzeEntireConversation() {
            console.log(`ğŸ¤ğŸ¯ Full conversation transcription request for: ${currentConversation}`);
            
            if (!currentConversation) {
                console.error('No conversation selected');
                showStatus('×©×’×™××”: ×œ× × ×‘×—×¨×” ×©×™×—×”', 'error');
                return;
            }

            // Show transcription method selection dialog
            const transcriptionMethod = await showTranscriptionMethodDialog();
            if (!transcriptionMethod) {
                return; // User cancelled
            }

            const maxSegments = await showMaxSegmentsDialog();
            if (!maxSegments) {
                return; // User cancelled
            }

            if (!confirm(`ğŸ¤ğŸ¤– ×ª××œ×•×œ + × ×™×ª×•×— ××œ× ×¢×‘×•×¨ ×›×œ ×”×©×™×—×” ${currentConversation}?\n\nğŸ“ ×”×©×œ×‘×™×:\nâ€¢ ×ª××œ×•×œ ××•×˜×•××˜×™ ×œ×›×œ ×”×§×˜×¢×™×\nâ€¢ × ×™×ª×•×— ×¨×’×©×•×ª ×¢× ChatGPT\nâ€¢ ×¢×“×›×•×Ÿ ×›×œ ×”×¤×¨××˜×¨×™×\n\nâš ï¸ ×–×” ×¢×œ×•×œ ×œ×§×—×ª ×–××Ÿ ×¨×‘!\n\nğŸ”¢ ××§×¡×™××•× ×§×˜×¢×™×: ${maxSegments}\nğŸ¤ ×©×™×˜×ª ×ª××œ×•×œ: ${transcriptionMethod === 'openai_fast' ? 'OpenAI + GPT-4' : 
                                      transcriptionMethod === 'azure_hebrew' ? 'Azure Speech ×¢×‘×¨×™×ª' :
                                      transcriptionMethod === 'google_hebrew' ? 'Google Speech ×¢×‘×¨×™×ª' :
                                      '×©×¨×©×¨×ª ××ª×§×“××ª'}`)) {
                return;
            }

            try {
                const emotionCount = Object.keys(emotionsConfig || {}).length;
                showLoading(`ğŸ¤ğŸ¤– ××ª×—×™×œ ×ª××œ×•×œ + × ×™×ª×•×— ××œ× ×¢×‘×•×¨ ${currentConversation}...\nğŸ”Š ×ª××œ×•×œ ××•×“×™×• + ğŸ­ ${emotionCount} ×¨×’×©×•×ª ×-ChatGPT\nğŸ“Š ××§×¡×™××•× ${maxSegments} ×§×˜×¢×™×`);
                
                // Show progress tracking
                setTimeout(() => {
                    showAnalysisProgress(0, maxSegments, '××ª×›×•× ×Ÿ...', '×ª××œ×•×œ + × ×™×ª×•×— ××œ×');
                }, 500);
                
                const analysisData = {
                    conversationFolder: currentConversation,
                    transcription_method: transcriptionMethod,
                    max_segments: parseInt(maxSegments),
                    skip_existing_transcripts: true // Skip segments that already have transcripts
                };

                console.log(`ğŸš€ Starting complete transcription + analysis for conversation ${currentConversation}:`, analysisData);
                
                const response = await fetch(`${apiBaseUrl}/api/transcribe-and-analyze-conversation`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisData)
                });

                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.success) {
                        const stats = result.stats;
                        
                        console.log(`âœ… Complete conversation transcription + analysis finished for ${currentConversation}`);
                        console.log(`ğŸ“Š Stats:`, stats);
                        
                        // Force reload emotion data to show all updates
                        await loadEmotionData(currentConversation);
                        
                        // Refresh the UI display
                        displaySegments();
                        
                        let summaryMessage = `ğŸ¤ğŸ¤– ×ª××œ×•×œ + × ×™×ª×•×— ××œ× ×”×•×©×œ× ×¢×‘×•×¨ ${currentConversation}!\n\nğŸ“Š ×¡×˜×˜×™×¡×˜×™×§×•×ª:\n`;
                        summaryMessage += `â€¢ âœ… ${stats.transcribed} ×§×˜×¢×™× ×ª×•××œ×œ×•\n`;
                        summaryMessage += `â€¢ ğŸ­ ${stats.analyzed} ×§×˜×¢×™× × ×•×ª×—×•\n`;
                        if (stats.skipped > 0) summaryMessage += `â€¢ â­ï¸ ${stats.skipped} ×§×˜×¢×™× ×“×•×œ×’×• (×™×© ×›×‘×¨ ×ª××œ×•×œ)\n`;
                        if (stats.errors > 0) summaryMessage += `â€¢ âŒ ${stats.errors} ×©×’×™××•×ª\n`;
                        summaryMessage += `\nğŸ¤ ×©×™×˜×ª ×ª××œ×•×œ: ${transcriptionMethod}\nğŸ­ ×”×©×ª××© ×‘-${emotionCount} ×¨×’×©×•×ª ×–××™× ×™× + ×ª××œ×•×œ ××•×˜×•××˜×™\n\nğŸ”„ ×”×˜×§×¡×˜×™× ×•×”×”×¨×’×©×•×ª ×¢×•×“×›× ×• ×‘×××©×§!`;
                        
                        showStatus(summaryMessage, stats.errors > 0 ? 'warning' : 'success');
                    } else {
                        showStatus(`×©×’×™××” ×‘×ª××œ×•×œ + × ×™×ª×•×— ×”×©×™×—×”: ${result.error}`, 'error');
                    }
                } else {
                    const errorResult = await response.json();
                    showStatus(`×©×’×™××” ×‘×ª××œ×•×œ + × ×™×ª×•×— ×”×©×™×—×”: ${errorResult.error}`, 'error');
                }
            } catch (error) {
                showStatus(`×©×’×™××” ×‘×ª××œ×•×œ + × ×™×ª×•×— ×”×©×™×—×”: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        // Helper function to show transcription method selection dialog
        async function showTranscriptionMethodDialog() {
            return new Promise((resolve) => {
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                dialog.innerHTML = `
                    <div style="background: white; padding: 2rem; border-radius: 12px; max-width: 500px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
                        <h3 style="margin-bottom: 1.5rem; color: #333;">ğŸ¤ ×‘×—×¨ ×©×™×˜×ª ×ª××œ×•×œ</h3>
                        <div style="margin-bottom: 2rem;">
                            <label style="display: block; margin-bottom: 1rem; padding: 1rem; border: 2px solid #e9ecef; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;">
                                <input type="radio" name="transcription" value="openai_fast" checked style="margin-left: 10px;">
                                <strong>ğŸ“ OpenAI + GPT-4 - ××”×™×¨ ×•××©×•×¤×¨</strong><br>
                                <small style="color: #666;">Whisper + GPT-4 ×œ×ª×™×§×•×Ÿ ×•× ×™×§×•×™ ×”×˜×§×¡×˜ ×”×¢×‘×¨×™</small>
                            </label>
                            <label style="display: block; margin-bottom: 1rem; padding: 1rem; border: 2px solid #e9ecef; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;">
                                <input type="radio" name="transcription" value="whisper_accurate" style="margin-left: 10px;">
                                <strong>ğŸ¯ ×©×¨×©×¨×ª ××ª×§×“××ª - ×”×›×™ ××“×•×™×§</strong><br>
                                <small style="color: #666;">Azure â†’ Google â†’ WhisperX â†’ OpenAI (×¢× ×—×–×¨×” ××•×˜×•××˜×™×ª)</small>
                            </label>
                            <label style="display: block; margin-bottom: 1rem; padding: 1rem; border: 2px solid #e9ecef; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;">
                                <input type="radio" name="transcription" value="azure_hebrew" style="margin-left: 10px;">
                                <strong>ğŸ‡®ğŸ‡± Azure Speech - ××•×ª×× ×œ×¢×‘×¨×™×ª</strong><br>
                                <small style="color: #666;">×©×™×¨×•×ª Microsoft ××•×ª×× ×‘××™×•×—×“ ×œ×¢×‘×¨×™×ª</small>
                            </label>
                            <label style="display: block; padding: 1rem; border: 2px solid #e9ecef; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;">
                                <input type="radio" name="transcription" value="google_hebrew" style="margin-left: 10px;">
                                <strong>ğŸŒ Google Speech - ××•×ª×× ×œ×¢×‘×¨×™×ª</strong><br>
                                <small style="color: #666;">×©×™×¨×•×ª Google ××•×ª×× ×‘××™×•×—×“ ×œ×¢×‘×¨×™×ª</small>
                            </label>
                        </div>
                        <div style="display: flex; gap: 1rem; justify-content: center;">
                            <button class="transcription-continue-btn" style="background: #28a745; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer;">
                                ğŸ“ ×”×ª×—×œ ×ª××œ×•×œ
                            </button>
                            <button class="transcription-cancel-btn" style="background: #6c757d; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer;">
                                ×‘×™×˜×•×œ
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(dialog);

                // Set up button handlers
                const continueBtn = dialog.querySelector('.transcription-continue-btn');
                const cancelBtn = dialog.querySelector('.transcription-cancel-btn');
                
                // Default to openai_fast
                let selectedMethod = 'openai_fast';
                
                continueBtn.onclick = () => {
                    resolve(selectedMethod);
                    document.body.removeChild(dialog);
                };
                
                cancelBtn.onclick = () => {
                    resolve(null);
                    document.body.removeChild(dialog);
                };

                // Handle radio button selection
                dialog.addEventListener('change', (e) => {
                    if (e.target.type === 'radio') {
                        selectedMethod = e.target.value;
                    }
                });

                // Handle escape key
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        resolve(null);
                        document.body.removeChild(dialog);
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
            });
        }

        // Helper function to show max segments dialog  
        async function showMaxSegmentsDialog() {
            return new Promise((resolve) => {
                const segments = Object.keys(emotionData || {}).length;
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                dialog.innerHTML = `
                    <div style="background: white; padding: 2rem; border-radius: 12px; max-width: 400px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
                        <h3 style="margin-bottom: 1.5rem; color: #333;">ğŸ“Š ××¡×¤×¨ ×§×˜×¢×™× ×œ×¢×™×‘×•×“</h3>
                        <p style="margin-bottom: 1rem; color: #666;">×”×©×™×—×” ××›×™×œ×” ${segments} ×§×˜×¢×™×</p>
                        <input type="number" id="maxSegments" value="50" min="1" max="${segments}" style="width: 100%; padding: 0.75rem; border: 2px solid #e9ecef; border-radius: 6px; text-align: center; font-size: 1.1rem; margin-bottom: 1.5rem;">
                        <div style="display: flex; gap: 1rem; justify-content: center;">
                            <button class="segments-continue-btn" style="background: #28a745; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer;">
                                ğŸ“ ×”××©×š
                            </button>
                            <button class="segments-cancel-btn" style="background: #6c757d; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer;">
                                ×‘×™×˜×•×œ
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(dialog);

                // Set up button handlers
                const continueBtn = dialog.querySelector('.segments-continue-btn');
                const cancelBtn = dialog.querySelector('.segments-cancel-btn');
                const input = dialog.querySelector('#maxSegments');
                
                continueBtn.onclick = () => {
                    const value = parseInt(input.value) || 50;
                    resolve(value);
                    document.body.removeChild(dialog);
                };
                
                cancelBtn.onclick = () => {
                    resolve(null);
                    document.body.removeChild(dialog);
                };

                // Handle escape key
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        resolve(null);
                        document.body.removeChild(dialog);
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
            });
        }

        // Make transcription functions globally accessible
        window.transcribeAndAnalyzeSegment = transcribeAndAnalyzeSegment;
        window.transcribeAndAnalyzeEntireConversation = transcribeAndAnalyzeEntireConversation;

        function markTranscriptChanged(mp3File) {
            // Visual feedback for transcript changes
            const transcriptBox = document.querySelector('#active-segment-editor .transcript-box');
            if (transcriptBox) {
                transcriptBox.setAttribute('data-changed', 'true');
                transcriptBox.style.border = '2px solid #ffc107';
                
                // Update status
                const statusElement = document.getElementById(`transcript-status-${mp3File}`);
                if (statusElement) {
                    statusElement.innerHTML = '<span style="color: #ffc107;">âš ï¸ ×©×•× ×” - ×œ×—×¥ ××—×•×¥ ×œ×ª×™×‘×” ×œ×©××™×¨×”</span>';
                }
            }
        }

        function removeEmotion(mp3File, emotionIndex) {
            if (!emotionData[mp3File] || !emotionData[mp3File].emotions) return;
            
            const currentEmotions = emotionData[mp3File].emotions || ['neutral'];
            
            if (currentEmotions.length <= 1) {
                showStatus('×—×™×™×‘ ×œ×”×™×•×ª ×œ×¤×—×•×ª ×¨×’×© ××—×“', 'error');
                return;
            }
            
            const emotionToRemove = currentEmotions[emotionIndex];
            const newEmotions = currentEmotions.filter((_, index) => index !== emotionIndex);
            
            updateParam(mp3File, 'emotions', newEmotions);
            refreshEmotionDisplay(mp3File);
            
            showStatus(`×”×•×¡×¨ ×¨×’×© "${emotionToRemove}"`, 'success');
        }

        function addEmotion(mp3File) {
            const select = document.getElementById(`emotion-select-${mp3File}`);
            const emotion = select.value;
            
            if (!emotion) {
                showStatus('×‘×—×¨ ×¨×’×© ××”×¨×©×™××”', 'error');
                return;
            }
            
            if (!emotionData[mp3File]) return;
            
            // Get current emotions
            const currentEmotions = emotionData[mp3File].emotions || ['neutral'];
            
            // Check if emotion already exists
            if (currentEmotions.includes(emotion)) {
                showStatus(`×”×¨×’×© "${emotion}" ×›×‘×¨ ×§×™×™×`, 'error');
                return;
            }
            
            // Debug: Check emotions config
            console.log('ğŸ¨ Adding emotion:', emotion);
            console.log('ğŸ¨ Current emotions config:', emotionsConfig);
            console.log('ğŸ¨ Emotion config for', emotion, ':', emotionsConfig[emotion]);
            
            // Add the new emotion
            const newEmotions = [...currentEmotions, emotion];
            updateParam(mp3File, 'emotions', newEmotions);
            
            // Refresh the emotion display
            refreshEmotionDisplay(mp3File);
            
            // Reset dropdown
            select.value = '';
            
            const emotionConfig = (emotionsConfig && emotionsConfig[emotion]) || {};
            const emotionDisplay = emotionConfig.hebrew ? `${emotionConfig.emoji} ${emotionConfig.hebrew}` : emotion;
            showStatus(`×”×•×¡×£ ×¨×’×© "${emotionDisplay}"`, 'success');
        }
        
        function refreshEmotionDisplay(mp3File) {
            const emotions = emotionData[mp3File].emotions || ['neutral'];
            
            // Create emotion display with colors and names
            const emotionDisplayText = emotions.map(e => {
                const config = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                const emoji = config.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                const hebrew = config.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                return hebrew ? `${emoji} ${hebrew}` : e;
            }).join(', ');
            
            // Update the segment list
            const segmentDiv = document.getElementById(`segment-${mp3File}`);
            if (segmentDiv) {
                const emotionSpan = segmentDiv.querySelector('span[style*="background: #e3f2fd"]');
                if (emotionSpan) {
                    emotionSpan.textContent = emotionDisplayText;
                }
            }
            
            // Update the editor if this is the current segment
            if (currentSelectedSegment === mp3File) {
                const emotionTags = emotions.map((e, i) => {
                    // Ensure we have emotions config loaded, fallback to DEFAULT_EMOTIONS
                    const emotionConfig = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                    const color = emotionConfig.color || DEFAULT_EMOTIONS[e]?.color || '#e3f2fd';
                    const emoji = emotionConfig.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                    const hebrew = emotionConfig.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                    
                    return `
                        <div class="emotion-tag" style="background-color: ${color}15; border: 1px solid ${color}; color: ${color};">
                            ${emoji} ${hebrew}
                            <button class="remove-btn" onclick="removeEmotion('${mp3File}', ${i})">Ã—</button>
                        </div>
                    `;
                }).join('');
                
                const emotionsContainer = document.querySelector('#active-segment-editor .emotion-tags');
                if (emotionsContainer) {
                    emotionsContainer.innerHTML = emotionTags;
                }
                
                // Update visualization
                updateSegmentVisualization(mp3File);
            }
            
            // If this segment is currently looping, update the main visualization in real-time
            if (currentLoopingSegment === mp3File) {
                updateLoopingVisualization(mp3File);
            }
        }

        function updateParam(mp3File, param, value) {
            if (!emotionData[mp3File]) {
                console.error(`No emotion data found for ${mp3File}`);
                return;
            }
            
            // Convert numeric values
            if (['speaker', 'blobSizeScale', 'blobStrength', 'volumeImpact', 'blur', 'humor', 
                'shine', 'regularAsciiCharSize', 'coloredCircleCharSize', 'blobiness', 'emotionCharAmount', 'gridResolution'].includes(param)) {
                value = parseFloat(value);
                if (isNaN(value)) {
                    console.error(`Invalid numeric value for ${param}:`, value);
                    return;
                }
            }
            
            // Convert boolean values
            if (param === 'connectBlobs' || param === 'blobsVisible') {
                value = value === true || value === 'true';
            }
            
            // Check if value actually changed
            const currentValue = emotionData[mp3File][param];
            if (currentValue === value) {
                console.log(`No change for ${param}: ${currentValue} === ${value}`);
                return; // No change, don't add to pending
            }
            
            // Initialize pending changes for this file if not exists
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            
            pendingChanges[mp3File][param] = value;
            emotionData[mp3File][param] = value; // Update local copy immediately
            hasUnsavedChanges = true;
            
            console.log(`Updated ${mp3File}.${param}: ${currentValue} -> ${value}`);
            
            // Special handling for spacing changes - add visual feedback
            if (param === 'minBlobSpacing') {
                console.log(`ğŸ¯ SPACING UPDATE: ${mp3File} spacing changed from "${currentValue}" to "${value}"`);
                showStatus(`×¢×•×“×›×Ÿ ××¨×•×•×— Blob: ${value}`, 'success');
            }
            
            // Update save button state and schedule auto-save (with smart debouncing)
            updateSaveButtonState();
            scheduleAutoSave();
            
            // âœ… OPTIMIZED REAL-TIME UPDATES: Only update what's necessary
            // Batch visualization updates to prevent excessive refreshing
            
            // Critical visual parameters that need immediate update
            const visualParameters = ['blur', 'humor', 'shine', 'blobSizeScale', 'blobStrength', 'emotions', 'blobiness'];
            const needsVisualizationUpdate = visualParameters.includes(param);
            
            if (needsVisualizationUpdate) {
                // Use requestAnimationFrame to batch updates and prevent excessive calls
                if (!window.pendingVisualizationUpdate) {
                    window.pendingVisualizationUpdate = true;
                    requestAnimationFrame(() => {
                        updateSegmentVisualization(mp3File);
                        updateLoopingVisualization(mp3File);
                        window.pendingVisualizationUpdate = false;
                    });
                }
            }
            
            // âœ… OPTIMIZED SYNC: Reduce sync frequency for UI elements
            // Only sync editors if it's a parameter that affects the UI directly
            const uiParameters = ['emotions', 'speaker', 'minBlobSpacing', 'gridResolution'];
            if (uiParameters.includes(param)) {
                syncInlineEditor(mp3File);
                syncSegmentEditor(mp3File);
                syncAllParameterEditors(mp3File, param, value);
            }
            
            // Special handling for speaker parameter
            if (param === 'speaker') {
                // Update speaker indicator tooltip with custom name
                const speakerIndicator = document.getElementById(`speaker-indicator-${mp3File}`);
                if (speakerIndicator) {
                    speakerIndicator.title = getSpeakerName(parseInt(value));
                    speakerIndicator.style.background = value == 1 ? '#4ECDC4' : '#FF6B6B';
                }
                
                // Update speaker display text
                const speakerDisplayElement = document.getElementById(`speaker-display-${mp3File}`);
                if (speakerDisplayElement) {
                    speakerDisplayElement.textContent = `ğŸ”Š ${getSpeakerName(parseInt(value))}`;
                }
            }
            
            // âœ… OPTIMIZED SEGMENT DISPLAYS: Only update when necessary
            if (['emotions', 'speaker'].includes(param)) {
                updateSegmentDisplays(mp3File);
            }
            
            // Update the segment list UI to reflect changes
            const segmentDiv = document.getElementById(`segment-${mp3File}`);
            if (segmentDiv) {
                const segment = emotionData[mp3File];
                const emotions = segment.emotions || ['neutral'];
                const emotionSpan = segmentDiv.querySelector('span[style*="background: #e3f2fd"]');
                if (emotionSpan && param === 'emotions') {
                    emotionSpan.textContent = emotions.join(', ');
                }
            }
            
            // Update the editor if this is the current segment
            if (currentSelectedSegment === mp3File) {
                updateSegmentVisualization(mp3File);
            }
            
            // If this segment is currently looping, update the main visualization in real-time
            if (currentLoopingSegment === mp3File) {
                updateLoopingVisualization(mp3File);
            }
        }
        
        function playSegment(mp3File) {
            const audio = new Audio(`conversations/${currentConversation}/${mp3File}`);
            audio.play().catch(error => {
                console.error('Error playing audio:', error);
                showStatus('×©×’×™××” ×‘× ×™×’×•×Ÿ ×”×§×˜×¢', 'error');
            });
        }
        
        function toggleLoop(mp3File) {
            const loopBtn = document.getElementById(`loop-btn-${mp3File}`);
            const headerLoopBtn = document.getElementById(`header-loop-btn-${mp3File}`);
            
            if (currentLoopingSegment === mp3File) {
                // Stop current loop
                stopLoop();
                if (loopBtn) {
                    loopBtn.classList.remove('active');
                    loopBtn.title = '×œ×•×œ××”';
                }
                if (headerLoopBtn) {
                    headerLoopBtn.classList.remove('active');
                    headerLoopBtn.title = '×œ×•×œ××”';
                }
                showStatus(`ğŸ”„ ×”×•×¤×¡×§×” ×œ×•×œ××” ×¢×‘×•×¨ ${mp3File}`, 'info');
            } else {
                // Start new loop
                if (currentLoopingSegment) {
                    stopLoop();
                    const oldBtn = document.getElementById(`loop-btn-${currentLoopingSegment}`);
                    const oldHeaderBtn = document.getElementById(`header-loop-btn-${currentLoopingSegment}`);
                    if (oldBtn) {
                        oldBtn.classList.remove('active');
                        oldBtn.title = '×œ×•×œ××”';
                    }
                    if (oldHeaderBtn) {
                        oldHeaderBtn.classList.remove('active');
                        oldHeaderBtn.title = '×œ×•×œ××”';
                    }
                }
                
                startLoop(mp3File);
                if (loopBtn) {
                    loopBtn.classList.add('active');
                    loopBtn.title = 'â¹ï¸ ×¢×¦×•×¨ ×œ×•×œ××”';
                }
                if (headerLoopBtn) {
                    headerLoopBtn.classList.add('active');
                    headerLoopBtn.title = 'â¹ï¸ ×¢×¦×•×¨ ×œ×•×œ××”';
                }
                showStatus(`ğŸ” ×œ×•×œ××” ×¨×¦×™×¤×” ×¤×¢×™×œ×” ×¢×‘×•×¨ ${mp3File} - ×›×œ ×©×™× ×•×™ ×™×•×—×œ ××™×“ ×¢×œ ×”×•×™×–×•××œ×™×–×¦×™×”!`, 'success');
            }
        }
        
        function startLoop(mp3File) {
            currentLoopingSegment = mp3File;
            
            // Tell visualization to loop this specific segment with current data
            const iframe = document.getElementById('segment-preview-iframe');
            if (iframe && iframe.contentWindow) {
                const segmentData = emotionData[mp3File] || {};
                iframe.contentWindow.postMessage({
                    action: 'startSegmentLoop',
                    segment: mp3File,
                    conversation: currentConversation,
                    segmentData: segmentData
                }, '*');
            }
            
            function playLoop() {
                currentLoopingAudio = new Audio(`conversations/${currentConversation}/${mp3File}`);
                currentLoopingAudio.onended = () => {
                    if (currentLoopingSegment === mp3File) {
                        // Restart after a short delay
                        setTimeout(playLoop, 500);
                    }
                };
                currentLoopingAudio.play().catch(error => {
                    console.error('Error in loop playback:', error);
                });
            }
            
            playLoop();
        }
        
        function stopLoop() {
            if (currentLoopingAudio) {
                currentLoopingAudio.pause();
                currentLoopingAudio = null;
            }
            
            // Tell visualization to stop segment loop and return to normal mode
            const iframe = document.getElementById('segment-preview-iframe');
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage({
                    action: 'stopSegmentLoop'
                }, '*');
            }
            
            currentLoopingSegment = null;
        }
        
        async function analyzeSegmentWithAI(mp3File) {
            if (!currentConversation || !emotionData[mp3File]) return;
            
            const confirmMessage = `×œ× ×ª×— ××ª ${mp3File} ×¢× AI?\n\n×–×” ×™×—×œ×™×£ ××ª ×”×¨×’×©×•×ª ×”×§×™×™××™× ×©×œ ×”×§×˜×¢ ×”×–×”.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                showLoading(`×× ×ª×— ${mp3File} ×¢× AI...`);
                
                const segment = emotionData[mp3File];
                const transcript = segment.transcript || segment.words || '';
                
                if (!transcript.trim()) {
                    showStatus('××™×Ÿ ×˜×¨× ×¡×§×¨×™×¤×˜ ×œ× ×™×ª×•×—', 'error');
                    return;
                }
                
                const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversation: currentConversation,
                        mp3File: mp3File,
                        transcript: transcript,
                        currentEmotions: segment.emotions || [],
                        speaker: segment.speaker || 0
                    })
                });

                if (!response.ok) throw new Error('Analysis failed');
                
                const result = await response.json();
                
                if (result.success && result.analysis) {
                    // Check if the backend auto-saved the segment
                    if (result.segment_updated && result.analysis.auto_saved) {
                        // Backend auto-saved - update local data directly from saved values
                        const savedUpdates = result.segment_updated.updates;
                        
                        // Update local emotion data with the auto-saved values
                        emotionData[mp3File] = { ...emotionData[mp3File], ...savedUpdates };
                        
                        // Clear any pending changes for this segment since it's already saved
                        if (pendingChanges[mp3File]) {
                            delete pendingChanges[mp3File];
                        }
                        
                        // Check if there are any other pending changes
                        hasUnsavedChanges = Object.keys(pendingChanges).length > 0;
                        
                        showStatus(`âœ… × ×™×ª×•×— AI ×”×•×©×œ× ×•× ×©××¨ ××•×˜×•××˜×™×ª! ×¨×’×©×•×ª: ${savedUpdates.emotions.join(', ')}`, 'success');
                        
                        console.log(`ğŸ¯ Auto-saved AI analysis for ${mp3File}:`, savedUpdates);
                    } else {
                        // Fallback: manual save needed (shouldn't happen with auto-save enabled)
                        const updates = {
                            emotions: result.analysis.emotions || ['neutral'],
                            blur: result.analysis.blur || 0,
                            shine: result.analysis.shine || 0,
                            humor: result.analysis.humor || 0,
                            ai_analyzed: true,
                            ai_analysis_date: new Date().toISOString()
                        };
                        
                        // Update local data
                        emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                        
                        // Mark as pending change
                        pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                        hasUnsavedChanges = true;
                        
                        showStatus(`× ×™×ª×•×— AI ×”×•×©×œ×! ×¨×’×©×•×ª: ${updates.emotions.join(', ')} - × ×“×¨×©×ª ×©××™×¨×” ×™×“× ×™×ª`, 'warning');
                        
                        // Auto-save the changes if auto-save failed
                        await saveAllChanges();
                    }
                    
                    // Update emotions availability in dropdowns
                    if (result.analysis && result.analysis.available_emotions && result.analysis.emotions) {
                        updateEmotionsAvailability(result.analysis.available_emotions, result.analysis.emotion_mapping);
                        
                        // Auto-add detected emotions to the segment
                        result.analysis.emotions.forEach(detectedEmotion => {
                            autoAddDetectedEmotion(mp3File, detectedEmotion);
                        });
                    }
                    
                    // Update the UI in both cases
                    displaySegments();
                    
                    // If this is the currently selected segment, reload its editor
                    if (currentSelectedSegment === mp3File) {
                        loadSegmentEditor(mp3File, emotionData[mp3File]);
                        updateSegmentVisualization(mp3File);
                    }
                    
                    // Update save button state
                    updateSaveButtonState();
                    
                    // Auto-sync to production after AI analysis (non-blocking)
                    setTimeout(async () => {
                        try {
                            await syncToProduction(currentConversation, 'incremental');
                        } catch (error) {
                            console.warn('âš ï¸ Sync to production failed after AI analysis:', error);
                        }
                    }, 1000); // Small delay to ensure changes are processed
                    
                } else {
                    showStatus('×©×’×™××” ×‘× ×™×ª×•×— AI - ×œ× ×”×ª×§×‘×œ×• ×ª×•×¦××•×ª', 'error');
                }
            } catch (error) {
                console.error('Error analyzing segment:', error);
                showStatus(`×©×’×™××” ×‘× ×™×ª×•×— AI: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        // Save changes
        async function saveAllChanges() {
            const changeCount = Object.keys(pendingChanges).length;
            if (changeCount === 0) {
                showStatus('××™×Ÿ ×©×™× ×•×™×™× ×œ×©××™×¨×”', 'error');
                return;
            }

            try {
                showLoading('×©×•××¨ ×©×™× ×•×™×™×...');
                
                console.log('=== SAVE DEBUG INFO ===');
                console.log('Pending changes count:', changeCount);
                console.log('Pending changes:', pendingChanges);
                console.log('Current conversation:', currentConversation);
                
                // Save each changed segment
                for (const [filename, data] of Object.entries(pendingChanges)) {
                    console.log(`\n--- Saving ${filename} ---`);
                    console.log('Data being sent:', data);
                    console.log('Data type:', typeof data);
                    console.log('Data keys:', data ? Object.keys(data) : 'data is null/undefined');
                    
                    // Make sure data is valid
                    if (!data || typeof data !== 'object') {
                        console.error(`Invalid data for ${filename}:`, data);
                        continue;
                    }
                    
                    // Check if there are any actual changes
                    const changeKeys = Object.keys(data);
                    if (changeKeys.length === 0) {
                        console.warn(`No changes found for ${filename}, skipping`);
                        continue;
                    }
                    
                    // Validate required fields
                    if (!currentConversation) {
                        console.error('Missing currentConversation');
                        throw new Error('No conversation selected');
                    }
                    
                    if (!filename) {
                        console.error('Missing filename');
                        continue;
                    }
                    
                    const requestPayload = {
                        conversation: currentConversation,
                        filename: filename,
                        updates: data
                    };
                    
                    console.log('Full request payload:', JSON.stringify(requestPayload, null, 2));
                    console.log('Payload validation:');
                    console.log('- conversation:', requestPayload.conversation);
                    console.log('- filename:', requestPayload.filename);
                    console.log('- updates:', requestPayload.updates);
                    console.log('- updates is object:', typeof requestPayload.updates === 'object');
                    console.log('- updates is not null:', requestPayload.updates !== null);
                    console.log('- updates keys:', requestPayload.updates ? Object.keys(requestPayload.updates) : 'no updates');
                    
                    const response = await fetch(`${apiBaseUrl}/api/update-segment`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestPayload)
                    });
                    
                    console.log('Response status:', response.status);
                    console.log('Response OK:', response.ok);
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('Error response body:', errorText);
                        throw new Error(`Failed to save ${filename}: ${response.status} - ${errorText}`);
                    }
                    
                    const result = await response.json();
                    console.log('Save result:', result);
                }
                
                // Clear pending changes
                pendingChanges = {};
                hasUnsavedChanges = false;
                
                // Update save button state
                updateSaveButtonState();
                
                // DISABLED: Auto-sync to production after saving changes (causes slowness)
                // Users can manually sync when needed to prevent admin panel lag
                console.log('âš ï¸ Auto-sync disabled after analysis to prevent slowness - sync manually if needed');
                
                showStatus(`× ×©××¨×• ${changeCount} ×©×™× ×•×™×™× ×‘×”×¦×œ×—×”!`, 'success');
                
            } catch (error) {
                console.error('Error saving changes:', error);
                showStatus(`×©×’×™××” ×‘×©××™×¨×ª ×”×©×™× ×•×™×™×: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }



        // ==================== COMPREHENSIVE CONVERSATION ANALYSIS ====================
        // Analyzes entire conversation with ChatGPT using transcripts + audio for each segment
        async function analyzeEntireConversationComprehensive() {
            if (!currentConversation) {
                showStatus('×× × ×‘×—×¨ ×©×™×—×” ×œ× ×™×ª×•×—', 'error');
                return;
            }

            // Get all mp3 files from the conversation (with or without transcripts)
            const mp3Files = Object.keys(emotionData).filter(key => key.endsWith('.mp3'));
            
            if (mp3Files.length === 0) {
                showStatus('×œ× × ××¦××• ×§×˜×¢×™ MP3 ×œ× ×™×ª×•×—', 'error');
                return;
            }
            
            // Count how many have transcripts vs audio-only
            const withTranscripts = mp3Files.filter(key => {
                const segment = emotionData[key];
                const transcript = segment.transcript || segment.words || '';
                return transcript.trim().length > 0;
            });
            
            const audioOnly = mp3Files.length - withTranscripts.length;

            let confirmMessage = `ğŸ¯ × ×™×ª×•×— ××œ× ×¢×‘×•×¨ ×›×œ ×”×©×™×—×”?\n\nğŸ“Š ×™×•×ª×—×• ${mp3Files.length} ×§×˜×¢×™×:`;
            if (withTranscripts.length > 0) {
                confirmMessage += `\nâ€¢ ${withTranscripts.length} ×§×˜×¢×™× ×¢× ×˜×§×¡×˜ (×¨×’×©×•×ª ××¨×•×‘×™× + ××•×“×™×•)`;
            }
            if (audioOnly > 0) {
                confirmMessage += `\nâ€¢ ${audioOnly} ×§×˜×¢×™× ×œ×œ× ×˜×§×¡×˜ (× ×™×ª×•×— ××•×“×™×• ×‘×œ×‘×“)`;
            }
            confirmMessage += `\n\nğŸ­ ×—×“×©: ×–×™×”×•×™ ×¨×’×©×•×ª ××¨×•×‘×™× ×‘×›×œ ×§×˜×¢!\nğŸ¤– ×›×œ ×§×˜×¢ ×™×•×ª×— ×¢× ChatGPT + ×›×œ 92 ×”×¨×’×©×•×ª\nğŸ”Š × ×™×ª×•×— ××•×“×™×• ××ª×§×“× ×¢× ×¤×¨××˜×¨×™× ×•×™×–×•××œ×™×™×\nâš ï¸ ×–×” ×™×¢×“×›×Ÿ ××ª ×›×œ ×”×¤×¨××˜×¨×™× (×¨×’×©×•×ª, ×˜×©×˜×•×©, ×‘×¨×§, ×”×•××•×¨)!`;
            
            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                showLoading(`ğŸ­ ×× ×ª×— ${mp3Files.length} ×§×˜×¢×™× ×¢× ×¨×’×©×•×ª ××¨×•×‘×™×...\n\nğŸ¤– ChatGPT + ×›×œ 92 ×”×¨×’×©×•×ª + × ×™×ª×•×— ××•×“×™×•`);
                
                // Show progress indicator
                const analysisProgressIndicator = document.getElementById('analysis-progress');
                if (analysisProgressIndicator) {
                    analysisProgressIndicator.style.display = 'block';
                }
                
                let successCount = 0;
                let errorCount = 0;
                let processedSegments = [];
                
                // Analyze each segment
                for (let i = 0; i < mp3Files.length; i++) {
                    const mp3File = mp3Files[i];
                    try {
                        const segment = emotionData[mp3File];
                        const transcript = segment.transcript || segment.words || '';
                        const hasTranscript = transcript.trim().length > 0;
                        
                        // Determine analysis type
                        const analysisType = hasTranscript ? '×¨×’×©×•×ª ××¨×•×‘×™× + ××•×“×™×•' : '× ×™×ª×•×— ××•×“×™×• ×‘×œ×‘×“';
                        
                        // Show detailed progress
                        showAnalysisProgress(i + 1, mp3Files.length, mp3File, analysisType);
                        
                        // Log what type of analysis we're doing
                        if (hasTranscript) {
                            console.log(`ğŸ¯ Analyzing ${mp3File} with transcript + audio (${i + 1}/${mp3Files.length})`);
                        } else {
                            console.log(`ğŸµ Analyzing ${mp3File} with audio only (${i + 1}/${mp3Files.length})`);
                        }
                        
                        // Use optimal settings for comprehensive analysis
                        const includeVolumeAnalysis = true;     // Always include audio analysis
                        const advancedParameters = true;       // Always use advanced parameters  
                        const preserveExisting = false;        // Always overwrite for fresh analysis
                        
                        const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                conversation: currentConversation,
                                mp3File: mp3File,
                                transcript: transcript,
                                currentEmotions: segment.emotions || ['neutral'],
                                speaker: segment.speaker || 0,
                                includeVolumeAnalysis: includeVolumeAnalysis,
                                advancedParameters: advancedParameters,
                                preserveExisting: preserveExisting
                            })
                        });

                        if (response.ok) {
                            const result = await response.json();
                            if (result.success && result.analysis) {
                                // Build comprehensive updates object
                                const updates = {
                                    emotions: result.analysis.emotions || ['neutral'],
                                    blur: result.analysis.blur || 0,
                                    shine: result.analysis.shine || 0,
                                    humor: result.analysis.humor || 0,
                                    ai_analyzed: true,
                                    ai_analysis_date: new Date().toISOString()
                                };
                                
                                // Add advanced parameters if available
                                if (result.analysis.advanced) {
                                    Object.assign(updates, {
                                        godel_to_regesh: result.analysis.advanced.godel_to_regesh,
                                        kamut_to_regesh: result.analysis.advanced.kamut_to_regesh,
                                        blob_size: result.analysis.advanced.blob_size,
                                        blob_intensity: result.analysis.advanced.blob_intensity,
                                        dominance: result.analysis.advanced.dominance,
                                        blobiness: result.analysis.advanced.blobiness,
                                        proximity: result.analysis.advanced.proximity,
                                        tone: result.analysis.advanced.tone,
                                        intention: result.analysis.advanced.intention,
                                        advanced_params: true
                                    });
                                }
                                
                                // Add volume analysis if available
                                if (result.volume) {
                                    Object.assign(updates, {
                                        volume_mean: result.volume.mean,
                                        volume_max: result.volume.max,
                                        volume_energy: result.volume.energy,
                                        audio_duration: result.volume.duration,
                                        volume_analyzed: true
                                    });
                                }
                                
                                // Update local data
                                emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                                
                                // IMPORTANT: Save to server immediately
                                try {
                                    const updateResponse = await fetch(`${apiBaseUrl}/api/update-segment`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            conversation: currentConversation,
                                            filename: mp3File,
                                            updates: updates
                                        })
                                    });
                                    
                                    if (updateResponse.ok) {
                                        console.log(`âœ… Successfully saved ${mp3File} analysis`);
                                    } else {
                                        console.error(`âŒ Failed to save ${mp3File} analysis`);
                                    }
                                } catch (saveError) {
                                    console.error(`âŒ Error saving ${mp3File}:`, saveError);
                                }
                                
                                successCount++;
                                processedSegments.push(mp3File);
                                
                                // Update UI less frequently to prevent slowness
                                if (processedSegments.length % 5 === 0) { // Update every 5 segments instead of every segment
                                    displaySegments();
                                }
                            }
                        } else {
                            errorCount++;
                            console.error(`Failed to analyze ${mp3File}: ${response.status}`);
                        }
                    } catch (error) {
                        errorCount++;
                        console.error(`Error analyzing ${mp3File}:`, error);
                    }
                }
                
                // Show completion status
                if (successCount > 0) {
                    const progressElement = document.getElementById('analysis-progress-text');
                    if (progressElement) {
                        progressElement.textContent = '××¡×™×™× × ×™×ª×•×—...';
                    }
                }
                
                // Hide progress indicator
                const analysisProgressEnd = document.getElementById('analysis-progress');
                if (analysisProgressEnd) {
                    analysisProgressEnd.style.display = 'none';
                }
                
                // Reload emotion data to get fresh data and update UI
                if (successCount > 0) {
                    await loadEmotionData(currentConversation);
                    displaySegments(); // Refresh the segments display
                }
                
                // DISABLED: Auto-sync to production after bulk analysis (causes slowness)
                // Manual sync recommended after bulk operations
                if (false && successCount > 0) { // Disabled
                    setTimeout(async () => {
                        try {
                            await syncToProduction(currentConversation, 'incremental');
                        } catch (error) {
                            console.warn('âš ï¸ Sync to production failed after bulk analysis:', error);
                        }
                    }, 1000); // Small delay to ensure reload is complete
                }
                
                // Show detailed completion message
                let completionMessage = `ğŸ­ × ×™×ª×•×— ×¨×’×©×•×ª ××¨×•×‘×™× ×”×•×©×œ×!\n\nâœ… ${successCount} ×§×˜×¢×™× × ×•×ª×—×• ×‘×”×¦×œ×—×”`;
                if (errorCount > 0) {
                    completionMessage += `\nâŒ ${errorCount} ×©×’×™××•×ª`;
                }
                completionMessage += `\n\nğŸ¯ ×ª×›×•× ×•×ª ××ª×§×“××•×ª ×©×¤×•×¢×œ×•×ª:\nâ€¢ ×–×™×”×•×™ ××¢×“ 3 ×¨×’×©×•×ª ×‘×›×œ ×§×˜×¢\nâ€¢ ×’×™×©×” ×œ×›×œ 92 ×”×¨×’×©×•×ª ×‘××¢×¨×›×ª\nâ€¢ × ×™×ª×•×— ××•×“×™×• ××ª×§×“×\nâ€¢ ×¤×¨××˜×¨×™× ×•×™×–×•××œ×™×™× ××•×ª×××™×`;
                if (processedSegments.length > 0) {
                    completionMessage += `\n\nğŸ“‹ ×§×˜×¢×™× ×©×¢×•×“×›× ×•:\n${processedSegments.slice(0, 10).join(', ')}`;
                    if (processedSegments.length > 10) {
                        completionMessage += `\n...×•×¢×•×“ ${processedSegments.length - 10}`;
                    }
                }
                completionMessage += '\n\nğŸ”„ ×”× ×ª×•× ×™× × ×©××¨×• ×•×¢×•×“×›× ×• ×‘×××©×§';
                
                showStatus(completionMessage, 'success');
                
            } catch (error) {
                console.error('Error analyzing conversation:', error);
                showStatus('×©×’×™××” ×‘× ×™×ª×•×— AI', 'error');
                const analysisProgressError = document.getElementById('analysis-progress');
                if (analysisProgressError) {
                    analysisProgressError.style.display = 'none';
                }
            } finally {
                hideLoading();
            }
        }

        // ==================== INDIVIDUAL SEGMENT ADVANCED ANALYSIS ====================
        
        async function analyzeSegmentAdvanced(mp3File) {
            if (!currentConversation || !emotionData[mp3File]) {
                showStatus('×©×’×™××”: × ×ª×•× ×™ ×”×§×˜×¢ ×œ× × ××¦××•', 'error');
                return;
            }

            const segment = emotionData[mp3File];
            const confirmMessage = `×œ×‘×¦×¢ × ×™×ª×•×— ××ª×§×“× ×¢×‘×•×¨ ${mp3File}?\n\nğŸ”¬ × ×™×ª×•×— ×›×•×œ×œ:\nâ€¢ GPT-4 ×¢× ×¤×¨××˜×¨×™× ××ª×§×“××™×\nâ€¢ × ×™×ª×•×— ×¢×•×¦××ª ×§×•×œ\nâ€¢ ×¤×¨××˜×¨×™× ×•×™×–×•××œ×™×™× ××¤×•×¨×˜×™×`;
            
            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                showLoading(`××‘×¦×¢ × ×™×ª×•×— ××ª×§×“× ×¢×‘×•×¨ ${mp3File}...`);
                
                const analysisData = {
                    conversation: currentConversation,
                    mp3File: mp3File,
                    transcript: segment.transcript || segment.words || '',
                    currentEmotions: segment.emotions || ['neutral'],
                    speaker: segment.speaker || 0,
                    includeVolumeAnalysis: true,
                    advancedParameters: true
                };
                
                const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.analysis) {
                        const updates = {
                            emotions: result.analysis.emotions || ['neutral'],
                            blur: result.analysis.blur || 0,
                            shine: result.analysis.shine || 0,
                            humor: result.analysis.humor || 0,
                            ai_analyzed: true,
                            ai_analysis_date: new Date().toISOString()
                        };
                        
                        // Add advanced parameters
                        if (result.analysis.advanced) {
                            Object.assign(updates, {
                                godel_to_regesh: result.analysis.advanced.godel_to_regesh,
                                kamut_to_regesh: result.analysis.advanced.kamut_to_regesh,
                                blob_size: result.analysis.advanced.blob_size,
                                blob_intensity: result.analysis.advanced.blob_intensity,
                                dominance: result.analysis.advanced.dominance,
                                blobiness: result.analysis.advanced.blobiness,
                                proximity: result.analysis.advanced.proximity,
                                tone: result.analysis.advanced.tone,
                                intention: result.analysis.advanced.intention,
                                advanced_params: true
                            });
                        }
                        
                        // Add volume analysis
                        if (result.volume) {
                            Object.assign(updates, {
                                volume_mean: result.volume.mean,
                                volume_max: result.volume.max,
                                volume_energy: result.volume.energy,
                                audio_duration: result.volume.duration,
                                volume_analyzed: true,
                                volume_analysis_date: new Date().toISOString()
                            });
                        }
                        
                        // Update data
                        emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                        pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                        hasUnsavedChanges = true;
                        
                        // Refresh displays
                        displaySegments();
                        if (document.getElementById('active-segment-editor')) {
                            selectSegment(mp3File, emotionData[mp3File]);
                        }
                        
                        showStatus(`× ×™×ª×•×— ××ª×§×“× ×”×•×©×œ× ×¢×‘×•×¨ ${mp3File}`, 'success');
                    } else {
                        showStatus('× ×™×ª×•×— × ×›×©×œ - ×œ× ×”×ª×§×‘×œ×• ×ª×•×¦××•×ª', 'error');
                    }
                } else {
                    const error = await response.text();
                    showStatus(`×©×’×™××” ×‘× ×™×ª×•×—: ${error}`, 'error');
                }
                
            } catch (error) {
                console.error('Error in advanced segment analysis:', error);
                showStatus('×©×’×™××” ×‘× ×™×ª×•×— ××ª×§×“×', 'error');
            } finally {
                hideLoading();
            }
        }

        async function analyzeVolumeOnly(mp3File) {
            if (!currentConversation || !emotionData[mp3File]) {
                showStatus('×©×’×™××”: × ×ª×•× ×™ ×”×§×˜×¢ ×œ× × ××¦××•', 'error');
                return;
            }

            try {
                showLoading(`×× ×ª×— ×¢×•×¦××ª ×§×•×œ ×¢×‘×•×¨ ${mp3File}...`);
                
                const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversation: currentConversation,
                        mp3File: mp3File,
                        transcript: emotionData[mp3File].transcript || '',
                        volumeOnly: true
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.volume) {
                        const updates = {
                            volume_mean: result.volume.mean,
                            volume_max: result.volume.max,
                            volume_energy: result.volume.energy,
                            audio_duration: result.volume.duration,
                            volume_analyzed: true,
                            volume_analysis_date: new Date().toISOString()
                        };
                        
                        emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                        pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                        hasUnsavedChanges = true;
                        
                        // Refresh displays
                        displaySegments();
                        if (document.getElementById('active-segment-editor')) {
                            selectSegment(mp3File, emotionData[mp3File]);
                        }
                        
                        showStatus(`× ×™×ª×•×— ×§×•×œ ×”×•×©×œ× ×¢×‘×•×¨ ${mp3File}`, 'success');
                    } else {
                        showStatus('× ×™×ª×•×— ×§×•×œ × ×›×©×œ - ×œ× ×”×ª×§×‘×œ×• × ×ª×•× ×™×', 'error');
                    }
                } else {
                    const error = await response.text();
                    showStatus(`×©×’×™××” ×‘× ×™×ª×•×— ×§×•×œ: ${error}`, 'error');
                }
                
            } catch (error) {
                console.error('Error in volume analysis:', error);
                showStatus('×©×’×™××” ×‘× ×™×ª×•×— ×§×•×œ', 'error');
            } finally {
                hideLoading();
            }
        }

        // ==================== ADVANCED AI ANALYSIS FUNCTIONS ====================
        
        async function analyzeConversationAdvanced() {
            if (!currentConversation || !emotionData) {
                showStatus('×™×© ×œ×‘×—×•×¨ ×©×™×—×” ×§×•×“×', 'error');
                return;
            }

            const confirmMessage = '×œ×‘×¦×¢ × ×™×ª×•×— ××ª×§×“× ×¢× AI + × ×™×ª×•×— ×§×•×œ?\n\nğŸ”¬ ×–×” ×›×•×œ×œ:\nâ€¢ × ×™×ª×•×— ×˜×§×¡×˜ ××ª×§×“× ×¢× GPT-4\nâ€¢ × ×™×ª×•×— ×¢×•×¦××ª ×§×•×œ ×•×× ×¨×’×™×”\nâ€¢ ×¤×¨××˜×¨×™× ×•×™×–×•××œ×™×™× ××¤×•×¨×˜×™×\nâ€¢ × ×™×ª×•×— ×¨×’×©×™ ××¢××™×§\n\nâš ï¸ ×”×ª×”×œ×™×š ×¢×œ×•×œ ×œ×§×—×ª ×–××Ÿ ×¨×‘!';
            
            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                showLoading('××‘×¦×¢ × ×™×ª×•×— ××ª×§×“×...');
                
                const includeVolume = document.getElementById('includeVolumeAnalysis').checked;
                const advancedParams = document.getElementById('advancedParameters').checked;
                
                let successCount = 0;
                let errorCount = 0;
                const mp3Files = Object.keys(emotionData);
                
                for (let i = 0; i < mp3Files.length; i++) {
                    const mp3File = mp3Files[i];
                    const segment = emotionData[mp3File];
                    
                    // Don't skip segments without transcripts - process all segments equally
                    if (!segment.transcript || segment.transcript.trim() === '') {
                        console.log(`âš ï¸ ${mp3File} has no transcript - will process with placeholder text`);
                        // Use a placeholder transcript to ensure the segment is still analyzed
                        segment.transcript = `[Audio segment ${mp3File}]`;
                    }
                    
                    try {
                        showLoading(`×× ×ª×— ${mp3File} (${i + 1}/${mp3Files.length})...`);
                        
                        // Prepare analysis payload
                        const analysisData = {
                            conversation: currentConversation,
                            mp3File: mp3File,
                            transcript: segment.transcript,
                            currentEmotions: segment.emotions || ['neutral'],
                            speaker: segment.speaker || 0,
                            includeVolumeAnalysis: includeVolume,
                            advancedParameters: advancedParams
                        };
                        
                        const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(analysisData)
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            
                            if (result.analysis) {
                                // Advanced parameter updates
                                const updates = {
                                    emotions: result.analysis.emotions || ['neutral'],
                                    blur: result.analysis.blur || 0,
                                    shine: result.analysis.shine || 0,
                                    humor: result.analysis.humor || 0,
                                    ai_analyzed: true,
                                    ai_analysis_date: new Date().toISOString()
                                };
                                
                                // Add advanced parameters if available
                                if (advancedParams && result.analysis.advanced) {
                                    Object.assign(updates, {
                                        godel_to_regesh: result.analysis.advanced.godel_to_regesh,
                                        kamut_to_regesh: result.analysis.advanced.kamut_to_regesh,
                                        blob_size: result.analysis.advanced.blob_size,
                                        blob_intensity: result.analysis.advanced.blob_intensity,
                                        dominance: result.analysis.advanced.dominance,
                                        blobiness: result.analysis.advanced.blobiness,
                                        proximity: result.analysis.advanced.proximity,
                                        tone: result.analysis.advanced.tone,
                                        intention: result.analysis.advanced.intention
                                    });
                                }
                                
                                // Add volume analysis if available  
                                if (includeVolume && result.volume) {
                                    Object.assign(updates, {
                                        volume_mean: result.volume.mean,
                                        volume_max: result.volume.max,
                                        volume_energy: result.volume.energy,
                                        audio_duration: result.volume.duration
                                    });
                                }
                                
                                // Update local data
                                emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                                pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                                hasUnsavedChanges = true;
                                
                                successCount++;
                                displaySegments(); // Update UI in real-time
                            }
                        } else {
                            errorCount++;
                            console.error(`Failed advanced analysis for ${mp3File}`);
                        }
                    } catch (error) {
                        errorCount++;
                        console.error(`Error in advanced analysis for ${mp3File}:`, error);
                    }
                }
                
                // Save changes
                if (successCount > 0) {
                    showLoading('×©×•××¨ ×ª×•×¦××•×ª × ×™×ª×•×— ××ª×§×“×...');
                    await saveAllChanges();
                }
                
                await loadEmotionData(currentConversation);
                showStatus(`× ×™×ª×•×— ××ª×§×“× ×”×•×©×œ×! ${successCount} ×§×˜×¢×™× × ×•×ª×—×•${errorCount > 0 ? `, ${errorCount} ×©×’×™××•×ª` : ''}`, 'success');
                
            } catch (error) {
                console.error('Error in advanced conversation analysis:', error);
                showStatus('×©×’×™××” ×‘× ×™×ª×•×— ××ª×§×“×', 'error');
            } finally {
                hideLoading();
            }
        }

        async function analyzeVolumeForAll() {
            if (!currentConversation || !emotionData) {
                showStatus('×™×© ×œ×‘×—×•×¨ ×©×™×—×” ×§×•×“×', 'error');
                return;
            }

            const confirmMessage = '×œ× ×ª×— ×¢×•×¦××ª ×§×•×œ ×œ×›×œ ×”×§×˜×¢×™×?\n\nğŸ”Š ×–×” ×™×•×¡×™×£ × ×ª×•× ×™ ×¢×•×¦××ª ×§×•×œ ×•×× ×¨×’×™×” ×œ×›×œ ×”××§×˜×¢×™×.';
            
            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                showLoading('×× ×ª×— ×¢×•×¦××ª ×§×•×œ...');
                
                let successCount = 0;
                let errorCount = 0;
                const mp3Files = Object.keys(emotionData);
                
                for (let i = 0; i < mp3Files.length; i++) {
                    const mp3File = mp3Files[i];
                    
                    try {
                        showLoading(`×× ×ª×— ×§×•×œ ${mp3File} (${i + 1}/${mp3Files.length})...`);
                        
                        const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                conversation: currentConversation,
                                mp3File: mp3File,
                                transcript: emotionData[mp3File].transcript || '',
                                volumeOnly: true
                            })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            
                            if (result.volume) {
                                const updates = {
                                    volume_mean: result.volume.mean,
                                    volume_max: result.volume.max,
                                    volume_energy: result.volume.energy,
                                    audio_duration: result.volume.duration,
                                    volume_analyzed: true,
                                    volume_analysis_date: new Date().toISOString()
                                };
                                
                                emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                                pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                                hasUnsavedChanges = true;
                                
                                successCount++;
                            }
                        } else {
                            errorCount++;
                        }
                    } catch (error) {
                        errorCount++;
                        console.error(`Error analyzing volume for ${mp3File}:`, error);
                    }
                }
                
                if (successCount > 0) {
                    await saveAllChanges();
                    displaySegments();
                }
                
                showStatus(`× ×™×ª×•×— ×§×•×œ ×”×•×©×œ×! ${successCount} ×§×˜×¢×™× × ×•×ª×—×•${errorCount > 0 ? `, ${errorCount} ×©×’×™××•×ª` : ''}`, 'success');
                
            } catch (error) {
                console.error('Error in volume analysis:', error);
                showStatus('×©×’×™××” ×‘× ×™×ª×•×— ×§×•×œ', 'error');
            } finally {
                hideLoading();
            }
        }

        async function reanalyzeTranscripts() {
            if (!currentConversation || !emotionData) {
                showStatus('×™×© ×œ×‘×—×•×¨ ×©×™×—×” ×§×•×“×', 'error');
                return;
            }

            const confirmMessage = '×œ× ×ª×— ××—×“×© ××ª ×”×ª××œ×•×œ×™× ×¢× AI?\n\nğŸ“ ×–×” ×™× ×ª×— ××ª ×”×ª××œ×•×œ×™× ×”×§×™×™××™× ×•×™×¢×“×›×Ÿ ×¨×’×©×•×ª ×‘×”×ª××.';
            
            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                showLoading('×× ×ª×— ×ª××œ×•×œ×™× ××—×“×©...');
                
                const preserveExisting = document.getElementById('preserveExisting').checked;
                let successCount = 0;
                let errorCount = 0;
                const mp3Files = Object.keys(emotionData);
                
                for (let i = 0; i < mp3Files.length; i++) {
                    const mp3File = mp3Files[i];
                    const segment = emotionData[mp3File];
                    
                    if (!segment.transcript) {
                        console.log(`Skipping ${mp3File} - no transcript`);
                        continue;
                    }
                    
                    try {
                        showLoading(`×× ×ª×— ×ª××œ×•×œ ${mp3File} (${i + 1}/${mp3Files.length})...`);
                        
                        const response = await fetch(`${apiBaseUrl}/api/update-conversation-transcript`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                conversation: currentConversation,
                                mp3File: mp3File,
                                newTranscript: segment.transcript,
                                preserveExisting: preserveExisting
                            })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            
                            if (result.updated_segment) {
                                const updates = {
                                    ...result.updated_segment,
                                    transcript_reanalyzed: true,
                                    transcript_analysis_date: new Date().toISOString()
                                };
                                
                                emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                                pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                                hasUnsavedChanges = true;
                                
                                successCount++;
                            }
                        } else {
                            errorCount++;
                        }
                    } catch (error) {
                        errorCount++;
                        console.error(`Error reanalyzing transcript for ${mp3File}:`, error);
                    }
                }
                
                if (successCount > 0) {
                    await saveAllChanges();
                    displaySegments();
                }
                
                showStatus(`× ×™×ª×•×— ×ª××œ×•×œ×™× ×”×•×©×œ×! ${successCount} ×§×˜×¢×™× × ×•×ª×—×•${errorCount > 0 ? `, ${errorCount} ×©×’×™××•×ª` : ''}`, 'success');
                
            } catch (error) {
                console.error('Error in transcript reanalysis:', error);
                showStatus('×©×’×™××” ×‘× ×™×ª×•×— ×ª××œ×•×œ×™×', 'error');
            } finally {
                hideLoading();
            }
        }

        async function exportConversationData() {
            if (!currentConversation || !emotionData) {
                showStatus('×™×© ×œ×‘×—×•×¨ ×©×™×—×” ×§×•×“×', 'error');
                return;
            }

            try {
                showLoading('××›×™×Ÿ × ×ª×•× ×™× ×œ×™×™×¦×•×...');
                
                // Prepare export data
                const exportData = {
                    conversation: currentConversation,
                    exportDate: new Date().toISOString(),
                    segments: {},
                    metadata: {
                        totalSegments: Object.keys(emotionData).length,
                        analyzedSegments: Object.values(emotionData).filter(s => s.ai_analyzed).length,
                        hasVolumeData: Object.values(emotionData).some(s => s.volume_mean !== undefined),
                        conversationData: conversationsData[currentConversation]
                    }
                };
                
                // Add segment data
                for (const [mp3File, segment] of Object.entries(emotionData)) {
                    exportData.segments[mp3File] = {
                        ...segment,
                        exportTimestamp: new Date().toISOString()
                    };
                }
                
                // Create downloadable file
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentConversation}_export_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus('× ×ª×•× ×™× ×™×•×¦××• ×‘×”×¦×œ×—×”', 'success');
                
            } catch (error) {
                console.error('Error exporting conversation data:', error);
                showStatus('×©×’×™××” ×‘×™×™×¦×•× × ×ª×•× ×™×', 'error');
            } finally {
                hideLoading();
            }
        }

        // Upload & Process Functions
        function setupEventListeners() {
            // File input - only set up if elements exist (upload tab)
            const fileInput = document.getElementById('fileInput');
            const uploadArea = document.getElementById('upload-area');
            const processBtn = document.getElementById('processBtn');

            if (fileInput && uploadArea && processBtn) {
                fileInput.addEventListener('change', handleFileSelect);
                
                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        fileInput.files = files;
                        handleFileSelect({ target: fileInput });
                    }
                });

                uploadArea.addEventListener('click', () => fileInput.click());
                processBtn.addEventListener('click', processUploadedFile);
            }

            // Sensitivity slider - only set up if elements exist (experiments tab)
            const slider = document.getElementById('sensitivity-slider');
            const value = document.getElementById('sensitivity-value');
            if (slider && value) {
                slider.addEventListener('input', () => {
                    value.textContent = slider.value;
                });
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            // Check if file has supported audio extension
            const supportedExtensions = ['.mp3', '.m4a', '.wav', '.flac', '.aac', '.ogg'];
            const fileName = file.name.toLowerCase();
            const isSupported = supportedExtensions.some(ext => fileName.endsWith(ext));
            
            if (!isSupported) {
                showStatus('× × ×œ×‘×—×•×¨ ×§×•×‘×¥ ××•×“×™×• × ×ª××š: MP3, M4A, WAV, FLAC, AAC, OGG', 'error');
                return;
            }

            uploadedFile = file;
            document.querySelector('.upload-area h3').textContent = file.name;
            document.getElementById('processBtn').disabled = false;
            
            // Populate target folders
            const select = document.getElementById('target-folder');
            select.innerHTML = '<option value="">×‘×—×¨ ×ª×™×§×™×™×”...</option>';
            
            Object.entries(conversationsData).forEach(([folder, data]) => {
                const option = document.createElement('option');
                option.value = folder;
                option.textContent = `×©×™×—×” ${data.number} - ${folder}`;
                select.appendChild(option);
            });
        }

        async function processUploadedFile() {
            if (!uploadedFile) return;

            const targetFolder = document.getElementById('target-folder').value;
            if (!targetFolder) {
                showStatus('× × ×œ×‘×—×•×¨ ×ª×™×§×™×™×ª ×™×¢×“', 'error');
                return;
            }

            try {
                showLoading('××¢×œ×” ×•××¢×‘×“ ×§×•×‘×¥...');
                
                const formData = new FormData();
                formData.append('file', uploadedFile);
                formData.append('folder', targetFolder);
                
                const response = await fetch(`${apiBaseUrl}/api/upload-process`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) throw new Error('Upload failed');

                showStatus('×”×§×•×‘×¥ ×”×•×¢×œ×” ×•××¢×•×‘×“ ×‘×”×¦×œ×—×”!', 'success');
                
                // Auto-sync to production after file upload and processing (non-blocking)
                setTimeout(async () => {
                    try {
                        await syncToProduction(targetFolder, 'incremental');
                    } catch (error) {
                        console.warn('âš ï¸ Sync to production failed after file upload:', error);
                    }
                }, 2000); // Longer delay to ensure processing is complete
                
                // Reset form
                uploadedFile = null;
                document.getElementById('fileInput').value = '';
                document.querySelector('.upload-area h3').textContent = '×’×¨×•×¨ ×§×•×‘×¥ ×œ×›××Ÿ ××• ×œ×—×¥ ×œ×‘×—×™×¨×”';
                document.getElementById('processBtn').disabled = true;
                
            } catch (error) {
                console.error('Error uploading:', error);
                showStatus('×©×’×™××” ×‘×”×¢×œ××ª ×”×§×•×‘×¥', 'error');
            } finally {
                hideLoading();
            }
        }

        // Retranscription options
        async function populateRetranscriptionOptions() {
            const quickContainer = document.getElementById('quick-analysis-options');
            const fullContainer = document.getElementById('full-reprocess-options');
            
            if (!quickContainer || !fullContainer) return;
            
            quickContainer.innerHTML = '';
            fullContainer.innerHTML = '';

            // Make sure conversationsData is loaded
            if (!conversationsData || Object.keys(conversationsData).length === 0) {
                await loadConversations();
            }

            const sortedConvos = Object.entries(conversationsData)
                .sort(([,a], [,b]) => a.number - b.number);

            sortedConvos.forEach(([folder, data]) => {
                // Quick analysis button
                const quickBtn = document.createElement('button');
                quickBtn.className = 'process-option';
                quickBtn.textContent = `×©×™×—×” ${data.number}`;
                quickBtn.onclick = () => retranscribeConversation(folder, false);
                quickContainer.appendChild(quickBtn);

                // Full reprocess button
                const fullBtn = document.createElement('button');
                fullBtn.className = 'process-option';
                fullBtn.textContent = `×©×™×—×” ${data.number}`;
                fullBtn.onclick = () => retranscribeConversation(folder, true);
                fullContainer.appendChild(fullBtn);
            });
        }

        async function retranscribeConversation(folder, useWhisper) {
            const action = useWhisper ? '×ª××œ×•×œ ×•× ×™×ª×•×— ××œ×' : '× ×™×ª×•×— ××”×™×¨';
            
            if (!confirm(`×”×× ×œ×‘×¦×¢ ${action} ×¢×‘×•×¨ ${folder}?`)) {
                return;
            }

            try {
                showLoading(`××‘×¦×¢ ${action}...`);
                
                const response = await fetch(`${apiBaseUrl}/api/retranscribe`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder, useWhisper })
                });

                if (!response.ok) throw new Error('Retranscription failed');

                showStatus(`${action} ×”×•×©×œ× ×‘×”×¦×œ×—×”!`, 'success');
            } catch (error) {
                console.error('Error retranscribing:', error);
                showStatus(`×©×’×™××” ×‘${action}`, 'error');
            } finally {
                hideLoading();
            }
        }

        // Experiments
        function initializeExperiments() {
            const textInput = document.getElementById('test-text-input');
            const output = document.getElementById('analysis-output');
            
            if (!textInput || !output) return;

            let timeout;
            textInput.addEventListener('input', () => {
                clearTimeout(timeout);
                timeout = setTimeout(() => analyzeText(), 300);
            });

            // Initial analysis
            analyzeText();
        }

        async function analyzeText() {
            const text = document.getElementById('test-text-input').value;
            const output = document.getElementById('analysis-output');
            
            if (!text.trim()) {
                output.textContent = '×”×§×œ×“ ×˜×§×¡×˜ ×œ× ×™×ª×•×—...';
                return;
            }

            try {
                const response = await fetch(`${apiBaseUrl}/api/test-analysis`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        text,
                        sensitivity: parseFloat(document.getElementById('sensitivity-slider')?.value || 0.5),
                        mode: document.getElementById('analysis-mode')?.value || 'standard'
                    })
                });

                if (!response.ok) throw new Error(`Analysis failed: ${response.status} ${response.statusText}`);

                const responseText = await response.text();
                if (!responseText) {
                    throw new Error('Empty analysis response');
                }
                
                let result;
                try {
                    result = JSON.parse(responseText);
                } catch (parseError) {
                    throw new Error(`Invalid response JSON: ${parseError.message}`);
                }
                
                output.textContent = JSON.stringify(result, null, 2);
            } catch (error) {
                output.textContent = `×©×’×™××”: ${error.message}`;
            }
        }

        // Settings
        function saveSettings() {
            const settings = {
                apiServer: document.getElementById('api-server').value,
                apiKey: document.getElementById('api-key').value,
                autoRefresh: document.getElementById('auto-refresh').checked,
                showDebug: document.getElementById('show-debug').checked
            };

            localStorage.setItem('adminSettings', JSON.stringify(settings));
            showStatus('×”×”×’×“×¨×•×ª × ×©××¨×• ×‘×”×¦×œ×—×”!', 'success');
        }



        // Removed duplicate function - using main definition above
        
        // Store ETags for efficient polling
        let emotionDataETag = null;
        
        // Smart refresh emotion data using ETags
        async function refreshEmotionData() {
            if (!currentConversation || isLoadingEmotionData) {
                console.log(`â­ï¸ Skipping refresh: currentConversation=${currentConversation}, isLoadingEmotionData=${isLoadingEmotionData}`);
                return;
            }
            console.log(`ğŸ”„ Refreshing emotion data for: ${currentConversation}`);
            
            try {
                if (!conversationsData) {
                    console.warn(`âš ï¸ Conversations data not loaded yet, skipping refresh`);
                    return;
                }
                
                const convData = conversationsData[currentConversation];
                if (!convData) {
                    console.warn(`âš ï¸ Conversation ${currentConversation} not found in conversations data, skipping refresh`);
                    console.log(`ğŸ“‹ Available conversations:`, Object.keys(conversationsData));
                    return;
                }
                let emotionFile = convData.ai_file || convData.emotion_file || `emotions${convData.number}_ai_analyzed.json`;
                
                // Fix path - ensure we don't double the conversations/folder part
                if (!emotionFile.startsWith('conversations/')) {
                    emotionFile = `conversations/${currentConversation}/${emotionFile}`;
                }
                
                const emotionUrl = `${apiBaseUrl}/${emotionFile}`;
                
                // Use If-None-Match header for efficient caching
                const headers = {};
                if (emotionDataETag) {
                    headers['If-None-Match'] = emotionDataETag;
                }
                
                // Add timeout for refresh requests
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout for refresh
                
                const response = await fetch(emotionUrl, { 
                    headers,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (response.status === 304) {
                    // Data hasn't changed
                    console.log('âœ… Emotion data unchanged (304)');
                    return;
                }
                
                if (response.ok) {
                    // Store new ETag
                    const newETag = response.headers.get('ETag');
                    if (newETag) {
                        emotionDataETag = newETag;
                    }
                    
                    const freshData = await response.json();
                    
                    // Check if data has changed
                    const hasChanges = JSON.stringify(freshData) !== JSON.stringify(emotionData);
                    
                    if (hasChanges && !hasUnsavedChanges) {
                        console.log('ğŸ”„ Emotion data changed, updating UI...');
                        emotionData = freshData;
                        displaySegments();
                    }
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.warn('âš ï¸ Failed to refresh emotion data:', error);
                }
                // Don't show error messages for background refresh failures
            }
        }

        // Individual segment visualization handlers
        function handleSegmentVizLoad(mp3File) {
            console.log(`âœ… Segment visualization loaded for ${mp3File}`);
            const statusDiv = document.getElementById(`segment-viz-status-${mp3File}`);
            if (statusDiv && emotionData[mp3File]) {
                const emotions = emotionData[mp3File].emotions || ['neutral'];
                const speaker = emotionData[mp3File].speaker || 0;
                statusDiv.innerHTML = `âœ… <strong>×•×™×–×•××œ×™×–×¦×™×” ×¤×¢×™×œ×”</strong> | ×“×•×‘×¨ ${speaker} | ×¨×’×©×•×ª: <span style="font-weight: bold; color: #2196F3;">${emotions.join(', ')}</span>`;
                statusDiv.style.color = '#4CAF50';
            }
        }
        
        // Debug function to help troubleshoot segment display issues
        function debugSegmentDisplay() {
            console.log('ğŸ” DEBUG: Segment Display Status');
            console.log('=' .repeat(50));
            
            // Check if conversation is selected
            console.log('ğŸ“ Current conversation:', currentConversation);
            console.log('ğŸ“Š Emotion data loaded:', !!(emotionData && Object.keys(emotionData).length > 0));
            
            if (emotionData) {
                const mp3Files = Object.keys(emotionData).filter(key => key.endsWith('.mp3'));
                console.log('ğŸµ MP3 files found:', mp3Files.length);
                console.log('ğŸµ First 5 files:', mp3Files.slice(0, 5));
            }
            
            // Check DOM elements
            const container = document.getElementById('segments-container');
            console.log('ğŸ“¦ Segments container found:', !!container);
            console.log('ğŸ“¦ Container content length:', container ? container.innerHTML.length : 'N/A');
            
            const editor = document.getElementById('conversation-editor');
            console.log('ğŸ“ Editor visible:', editor ? editor.style.display !== 'none' : false);
            
            // Try to force display segments
            if (emotionData && Object.keys(emotionData).length > 0) {
                console.log('ğŸ”„ Attempting to force display segments...');
                displaySegments();
            }
            
            console.log('ğŸ” Debug complete');
        }
        
        // Add global debug function for easy access in console
        window.debugSegments = debugSegmentDisplay;
        
        function handleSegmentVizError(mp3File) {
            console.error(`âŒ Segment visualization failed to load for ${mp3File}`);
            const statusDiv = document.getElementById(`segment-viz-status-${mp3File}`);
            if (statusDiv) {
                statusDiv.innerHTML = 'âŒ <strong>×©×’×™××” ×‘×˜×¢×™× ×ª ×•×™×–×•××œ×™×–×¦×™×”</strong> - × ×¡×” ×©×•×‘';
                statusDiv.style.color = '#f44336';
            }
        }
        
        function loadSegmentVisualization(mp3File) {
            const iframe = document.getElementById('segment-preview-iframe');
            
            if (iframe) {
                // Load the visualization for this specific segment
                const timestamp = new Date().getTime();
                iframe.src = `${apiBaseUrl}/visualization.html?folder=${currentConversation}&segment=${mp3File}&viewMode=segment&t=${timestamp}`;
                
                // Auto-start loop if the loop button is active
                const loopBtn = document.getElementById('main-loop-btn');
                if (loopBtn && loopBtn.classList.contains('active')) {
                    setTimeout(() => {
                        startSegmentLoop();
                    }, 1000);
                }
            }
        }
        
        function toggleSegmentLoop() {
            const loopBtn = document.getElementById('main-loop-btn');
            
            if (loopBtn.classList.contains('active')) {
                // Stop loop
                stopSegmentLoop();
                loopBtn.classList.remove('active');
                loopBtn.innerHTML = '<i class="material-icons">loop</i> ×œ×•×œ××” ×¨×¦×™×¤×”';
            } else {
                // Start loop
                startSegmentLoop();
                loopBtn.classList.add('active');
                loopBtn.innerHTML = '<i class="material-icons">stop</i> ×¢×¦×•×¨ ×œ×•×œ××”';
            }
        }
        
        function startSegmentLoop() {
            if (!currentSelectedSegment) return;
            
            const iframe = document.getElementById('segment-preview-iframe');
            if (iframe && iframe.contentWindow) {
                const segmentData = emotionData[currentSelectedSegment] || {};
                iframe.contentWindow.postMessage({
                    action: 'startSegmentLoop',
                    segment: currentSelectedSegment,
                    conversation: currentConversation,
                    segmentData: segmentData
                }, '*');
            }
            
            // Start audio loop
            currentLoopingSegment = currentSelectedSegment;
            startLoop(currentSelectedSegment);
        }
        
        function stopSegmentLoop() {
            stopLoop();
            
            const iframe = document.getElementById('segment-preview-iframe');
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage({
                    action: 'stopSegmentLoop'
                }, '*');
            }
        }
        
        function playCurrentSegment() {
            if (currentSelectedSegment) {
                playSegment(currentSelectedSegment);
            }
        }
        
        function updateSegmentVisualization(mp3File) {
            const iframe = document.getElementById('segment-preview-iframe');
            if (iframe && iframe.contentWindow) {
                const segmentData = emotionData[mp3File] || {};
                iframe.contentWindow.postMessage({
                    action: 'updateSegmentData',
                    segment: mp3File,
                    conversation: currentConversation,
                    segmentData: segmentData
                }, '*');
                
                console.log(`ğŸ”„ Updated visualization for ${mp3File}:`, segmentData);
            }
        }
        
        // Update visualization in real-time when looping
        function updateLoopingVisualization(mp3File) {
            if (currentLoopingSegment !== mp3File) return;
            
            const iframe = document.getElementById('segment-preview-iframe');
            if (iframe && iframe.contentWindow) {
                const segmentData = emotionData[mp3File] || {};
                iframe.contentWindow.postMessage({
                    action: 'updateLoopingSegment',
                    segment: mp3File,
                    conversation: currentConversation,
                    segmentData: segmentData
                }, '*');
                
                console.log(`ğŸ”„ Updated looping visualization for ${mp3File}:`, segmentData);
            }
        }

        // Warn before leaving with unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        // ==================== AI SUMMARY AND INSIGHTS GENERATION FUNCTIONS ====================
        
        // Function to refresh AI content in visualization windows
        function refreshVisualizationAIContent(conversationKey) {
            try {
                // First, try to refresh content in the same window (most common case)
                if (window.refreshAIContent && typeof window.refreshAIContent === 'function') {
                    console.log(`ğŸ”„ Refreshing AI content in same window for ${conversationKey}`);
                    window.refreshAIContent();
                }
                
                // Try to refresh content in any open visualization windows
                // This will work if the visualization page is open in the same browser
                if (window.opener && window.opener.refreshAIContent) {
                    console.log(`ğŸ”„ Refreshing AI content in opener window for ${conversationKey}`);
                    window.opener.refreshAIContent();
                }
                
                // Also try to refresh content in child windows (if any)
                if (window.childWindows) {
                    window.childWindows.forEach(childWindow => {
                        if (childWindow && childWindow.refreshAIContent) {
                            console.log(`ğŸ”„ Refreshing AI content in child window for ${conversationKey}`);
                            childWindow.refreshAIContent();
                        }
                    });
                }
                
                // Post message to all windows (as a fallback)
                try {
                    if (window.parent !== window) {
                        window.parent.postMessage({
                            type: 'refreshAIContent',
                            conversationKey: conversationKey
                        }, '*');
                    }
                } catch (e) {
                    // Ignore cross-origin errors
                }
                
                // Try to refresh insights directly if functions exist on this window
                if (typeof window.refreshAIContent === 'function') {
                    console.log(`ğŸ”„ Direct refresh: calling refreshAIContent`);
                    window.refreshAIContent();
                }
                
                // Try to refresh insights in any open visualization tabs
                if (typeof window.displayAIInsights === 'function') {
                    console.log(`ğŸ”„ Direct refresh: calling displayAIInsights`);
                    window.displayAIInsights();
                }
                
                console.log(`ğŸ“¨ AI content refresh triggered for ${conversationKey}`);
            } catch (error) {
                console.log(`âš ï¸ Could not refresh visualization content:`, error);
            }
        }
        
        // Functions for current conversation in editor
        async function generateCurrentConversationSummary() {
            if (!currentConversation) {
                showStatus('âŒ ××™×Ÿ ×©×™×—×” × ×‘×—×¨×ª ×œ×¢×¨×™×›×”', 'error');
                return;
            }
            await generateConversationSummary(currentConversation);
        }
        
        async function generateCurrentConversationInsights() {
            if (!currentConversation) {
                showStatus('âŒ ××™×Ÿ ×©×™×—×” × ×‘×—×¨×ª ×œ×¢×¨×™×›×”', 'error');
                return;
            }
            await generateConversationInsights(currentConversation);
        }
        
        async function generateCurrentConversationBoth() {
            if (!currentConversation) {
                showStatus('âŒ ××™×Ÿ ×©×™×—×” × ×‘×—×¨×ª ×œ×¢×¨×™×›×”', 'error');
                return;
            }
            await generateBothForConversation(currentConversation);
        }
        
        // Individual conversation AI generation functions
        async function generateConversationSummary(conversationKey) {
            if (!confirm(`ğŸ¤– ×œ×¦×•×¨ ×¡×™×›×•× ××‘×•×¡×¡ AI ×¢×‘×•×¨ ×©×™×—×” ${conversationKey}?`)) {
                return;
            }

            try {
                showLoading(`ğŸ“ ×™×•×¦×¨ ×¡×™×›×•× AI ×¢×‘×•×¨ ${conversationKey}...`);
                
                // Get specific conversation from config
                const response = await fetch('config/conversations_config.json');
                const config = await response.json();
                const conversationData = config.conversations[conversationKey];
                
                if (!conversationData) {
                    throw new Error(`Conversation ${conversationKey} not found`);
                }
                
                // Generate AI summary for this conversation
                const summaryResult = await generateConversationSummaryAI(conversationKey, conversationData);
                
                if (summaryResult.success) {
                    showStatus(`âœ… ×¡×™×›×•× AI × ×•×¦×¨ ×‘×”×¦×œ×—×” ×¢×‘×•×¨ ${conversationKey}!\n\nğŸ¯ ×”×¡×™×›×•× ×™×•×¦×’ ×‘×œ×©×•× ×™×ª "×¡×™×›×•×" ×‘×¤×× ×œ ×”×¦×“`, 'success');
                    // Refresh the conversations list to show updated indicators
                    await loadConversations();
                    // Refresh AI content in visualization windows
                    refreshVisualizationAIContent(conversationKey);
                } else {
                    showStatus(`âŒ ×©×’×™××” ×‘×™×¦×™×¨×ª ×¡×™×›×•× ×¢×‘×•×¨ ${conversationKey}: ${summaryResult.error}`, 'error');
                }
                
            } catch (error) {
                console.error(`Error generating summary for ${conversationKey}:`, error);
                showStatus(`×©×’×™××” ×‘×™×¦×™×¨×ª ×¡×™×›×•×: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }
        
        async function generateConversationInsights(conversationKey) {
            if (!confirm(`ğŸ” ×œ×¦×•×¨ ×ª×•×‘× ×•×ª ××‘×•×¡×¡×•×ª AI ×¢×‘×•×¨ ×©×™×—×” ${conversationKey}?`)) {
                return;
            }

            try {
                showLoading(`ğŸ’¡ ×™×•×¦×¨ ×ª×•×‘× ×•×ª AI ×¢×‘×•×¨ ${conversationKey}...`);
                
                // Get specific conversation from config
                const response = await fetch('config/conversations_config.json');
                const config = await response.json();
                const conversationData = config.conversations[conversationKey];
                
                if (!conversationData) {
                    throw new Error(`Conversation ${conversationKey} not found`);
                }
                
                // Generate AI insights for this conversation
                const insightsResult = await generateConversationInsightsAI(conversationKey, conversationData);
                
                if (insightsResult.success) {
                    showStatus(`âœ… ×ª×•×‘× ×•×ª AI × ×•×¦×¨×• ×‘×”×¦×œ×—×” ×¢×‘×•×¨ ${conversationKey}!\n\nğŸ’¡ ×”×ª×•×‘× ×•×ª ×™×•×¦×’×• ×‘×œ×©×•× ×™×ª "×ª×•×‘× ×•×ª" ×‘×¤×× ×œ ×”×¦×“`, 'success');
                    // Refresh the conversations list to show updated indicators
                    await loadConversations();
                    // Refresh AI content in visualization windows
                    refreshVisualizationAIContent(conversationKey);
                    
                    // Store insights in localStorage for offline access
                    setTimeout(async () => {
                        try {
                            console.log('ğŸ”„ Storing insights locally and triggering refresh...');
                            
                            // Store insights in localStorage
                            if (insightsResult.insights) {
                                const insightKey = `insights_${conversationKey}`;
                                localStorage.setItem(insightKey, JSON.stringify(insightsResult.insights));
                                console.log(`ğŸ’¾ Insights stored locally for ${conversationKey}`);
                            }
                            
                            // Reset conversations config cache in all possible windows
                            if (typeof window.conversationsConfig !== 'undefined') {
                                window.conversationsConfig = null;
                            }
                            if (window.opener && typeof window.opener.conversationsConfig !== 'undefined') {
                                window.opener.conversationsConfig = null;
                            }
                            
                            // Trigger insights display in current window
                            if (typeof window.displayAIInsights === 'function') {
                                await window.displayAIInsights();
                                console.log('âœ… Direct insights refresh completed');
                            }
                            
                            // Trigger insights display in opener window using new UI function
                            if (window.opener && typeof window.opener.displayInsightsUI === 'function') {
                                const container = window.opener.document.getElementById('insight-content-dynamic');
                                if (container && insightsResult.insights) {
                                    window.opener.displayInsightsUI(insightsResult.insights, conversationKey, container);
                                    console.log('âœ… Opener insights UI refresh completed');
                                }
                            }
                            
                            // Try to trigger simple refresh in opener window
                            if (window.opener && typeof window.opener.simpleInsightsRefresh === 'function') {
                                window.opener.simpleInsightsRefresh();
                                console.log('âœ… Opener simple refresh completed');
                            }
                        } catch (e) {
                            console.log('â„¹ï¸ Additional refresh attempt completed');
                        }
                    }, 1500);
                } else {
                    showStatus(`âŒ ×©×’×™××” ×‘×™×¦×™×¨×ª ×ª×•×‘× ×•×ª ×¢×‘×•×¨ ${conversationKey}: ${insightsResult.error}`, 'error');
                }
                
            } catch (error) {
                console.error(`Error generating insights for ${conversationKey}:`, error);
                showStatus(`×©×’×™××” ×‘×™×¦×™×¨×ª ×ª×•×‘× ×•×ª: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }
        
        async function generateBothForConversation(conversationKey) {
            if (!confirm(`ğŸš€ ×œ×¦×•×¨ ×¡×™×›×•× ×•×ª×•×‘× ×•×ª ××‘×•×¡×¡×™ AI ×¢×‘×•×¨ ×©×™×—×” ${conversationKey}?`)) {
                return;
            }

            try {
                showLoading(`ğŸš€ ×™×•×¦×¨ ×¡×™×›×•× ×•×ª×•×‘× ×•×ª AI ×¢×‘×•×¨ ${conversationKey}...`);
                
                // Get specific conversation from config
                const response = await fetch('config/conversations_config.json');
                const config = await response.json();
                const conversationData = config.conversations[conversationKey];
                
                if (!conversationData) {
                    throw new Error(`Conversation ${conversationKey} not found`);
                }
                
                // Generate both summary and insights
                const summaryResult = await generateConversationSummaryAI(conversationKey, conversationData);
                const insightsResult = await generateConversationInsightsAI(conversationKey, conversationData);
                
                const summarySuccess = summaryResult.success;
                const insightsSuccess = insightsResult.success;
                
                if (summarySuccess && insightsSuccess) {
                    showStatus(`âœ… ×¡×™×›×•× ×•×ª×•×‘× ×•×ª AI × ×•×¦×¨×• ×‘×”×¦×œ×—×” ×¢×‘×•×¨ ${conversationKey}!\n\nğŸ¯ ×”×ª×•×›×Ÿ ×™×•×¦×’ ×‘×œ×©×•× ×™×•×ª "×¡×™×›×•×" ×•"×ª×•×‘× ×•×ª" ×‘×¤×× ×œ ×”×¦×“`, 'success');
                } else if (summarySuccess || insightsSuccess) {
                    const successPart = summarySuccess ? '×¡×™×›×•×' : '×ª×•×‘× ×•×ª';
                    const failPart = !summarySuccess ? '×¡×™×›×•×' : '×ª×•×‘× ×•×ª';
                    showStatus(`âš ï¸ ${successPart} × ×•×¦×¨ ×‘×”×¦×œ×—×” ××š ${failPart} × ×›×©×œ ×¢×‘×•×¨ ${conversationKey}`, 'warning');
                } else {
                    showStatus(`âŒ ×©×’×™××” ×‘×™×¦×™×¨×ª ×¡×™×›×•× ×•×ª×•×‘× ×•×ª ×¢×‘×•×¨ ${conversationKey}`, 'error');
                }
                
                // Refresh the conversations list to show updated indicators
                await loadConversations();
                
                // Refresh AI content in visualization windows
                if (summarySuccess || insightsSuccess) {
                    refreshVisualizationAIContent(conversationKey);
                }
                
            } catch (error) {
                console.error(`Error generating content for ${conversationKey}:`, error);
                showStatus(`×©×’×™××” ×‘×™×¦×™×¨×ª ×ª×•×›×Ÿ: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }
        
        async function generateConversationSummaryAI(conversationKey, conversationData) {
            try {
                // Load conversation emotion data
                const emotionFilePath = conversationData.ai_file || conversationData.emotion_file;
                if (!emotionFilePath) {
                    console.warn(`No emotion file found for ${conversationKey}`);
                    return { success: false, error: 'No emotion file' };
                }
                
                const emotionResponse = await fetch(emotionFilePath);
                const emotionData = await emotionResponse.json();
                
                // Prepare conversation data for AI analysis
                const segments = Object.keys(emotionData)
                    .filter(key => key.endsWith('.mp3'))
                    .map(key => ({
                        file: key,
                        transcript: emotionData[key].transcript || emotionData[key].words || '',
                        emotions: emotionData[key].emotions || ['neutral'],
                        speaker: emotionData[key].speaker || 0
                    }))
                    .filter(segment => segment.transcript.trim().length > 0);
                
                if (segments.length === 0) {
                    console.warn(`No transcript segments found for ${conversationKey}`);
                    return { success: false, error: 'No transcript segments' };
                }
                
                // Call AI to generate summary
                const summaryRequest = {
                    conversation_key: conversationKey,
                    conversation_number: conversationData.number,
                    segments: segments,
                    metadata: conversationData.metadata || {},
                    type: 'summary'
                };
                
                const response = await fetch(`${apiBaseUrl}/api/generate-conversation-summary`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(summaryRequest)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log(`âœ… Generated summary for ${conversationKey}:`, result);
                    return { success: true, data: result };
                } else {
                    console.error(`Failed to generate summary for ${conversationKey}:`, response.statusText);
                    return { success: false, error: response.statusText };
                }
                
            } catch (error) {
                console.error(`Error generating summary for ${conversationKey}:`, error);
                return { success: false, error: error.message };
            }
        }
        
        async function generateConversationInsightsAI(conversationKey, conversationData) {
            try {
                // Load conversation emotion data
                const emotionFilePath = conversationData.ai_file || conversationData.emotion_file;
                if (!emotionFilePath) {
                    console.warn(`No emotion file found for ${conversationKey}`);
                    return { success: false, error: 'No emotion file' };
                }
                
                const emotionResponse = await fetch(emotionFilePath);
                const emotionData = await emotionResponse.json();
                
                // Prepare conversation data for AI analysis
                const segments = Object.keys(emotionData)
                    .filter(key => key.endsWith('.mp3'))
                    .map(key => ({
                        file: key,
                        transcript: emotionData[key].transcript || emotionData[key].words || '',
                        emotions: emotionData[key].emotions || ['neutral'],
                        speaker: emotionData[key].speaker || 0,
                        humor: emotionData[key].humor || 0,
                        blur: emotionData[key].blur || 0,
                        spark: emotionData[key].spark || 0
                    }))
                    .filter(segment => segment.transcript.trim().length > 0);
                
                if (segments.length === 0) {
                    console.warn(`No transcript segments found for ${conversationKey}`);
                    return { success: false, error: 'No transcript segments' };
                }
                
                // Call AI to generate insights
                const insightsRequest = {
                    conversation_key: conversationKey,
                    conversation_number: conversationData.number,
                    segments: segments,
                    metadata: conversationData.metadata || {},
                    type: 'insights'
                };
                
                const response = await fetch(`${apiBaseUrl}/api/generate-conversation-insights`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(insightsRequest)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log(`âœ… Generated insights for ${conversationKey}:`, result);
                    return { success: true, data: result };
                } else {
                    console.error(`Failed to generate insights for ${conversationKey}:`, response.statusText);
                    return { success: false, error: response.statusText };
                }
                
            } catch (error) {
                console.error(`Error generating insights for ${conversationKey}:`, error);
                return { success: false, error: error.message };
            }
        }

        // ==================== METADATA MANAGEMENT FUNCTIONS ====================
        let currentMetadataConversation = null;
        let conversationMetadata = {};
        let metadataCache = {};
        
        // Populate main emotions selector with all 92 emotions from config
        async function populateMainEmotionsSelector() {
            try {
                console.log('ğŸ­ Starting to populate emotions selector...');
                const container = document.getElementById('main-emotions-selector');
                if (!container) {
                    console.error('âŒ Emotions container not found');
                    return;
                }
                
                // Ensure emotions config is loaded - try multiple times
                if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                    console.log('â³ Loading emotions config...');
                    await loadEmotionsConfig();
                    
                    // If still empty, wait and try again
                    if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                        console.log('â³ Retrying emotions config load...');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        await loadEmotionsConfig();
                    }
                }
                
                console.log('ğŸ“‹ Emotions config status:', emotionsConfig ? Object.keys(emotionsConfig).length : 0, 'emotions');
                
                if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                    console.error('âŒ Failed to load emotions config');
                    container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #ff6b6b; padding: 1rem;">×©×’×™××” ×‘×˜×¢×™× ×ª ×¨×’×©×•×ª - ×œ× × ×™×ª×Ÿ ×œ×˜×¢×•×Ÿ ××ª ×§×•×‘×¥ ×”×§×•× ×¤×™×’×•×¨×¦×™×”</div>';
                    return;
                }
                
                // Clear loading message
                container.innerHTML = '';
                
                // Get all emotions and sort alphabetically in Hebrew
                const allEmotions = Object.entries(emotionsConfig);
                allEmotions.sort((a, b) => {
                    try {
                        // Hebrew keys are the emotion names themselves
                        return a[0].localeCompare(b[0], 'he');
                    } catch(e) {
                        return a[0] > b[0] ? 1 : -1;
                    }
                });
                
                console.log('ğŸ”¤ Sorted emotions:', allEmotions.slice(0, 5).map(([name]) => name));
                
                // Create checkboxes for all emotions
                allEmotions.forEach(([emotion, config]) => {
                    const label = document.createElement('label');
                    label.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; cursor: pointer; padding: 0.25rem; border-radius: 4px; transition: background-color 0.2s ease;';
                    
                    // Add hover effect
                    label.addEventListener('mouseenter', () => {
                        label.style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
                    });
                    label.addEventListener('mouseleave', () => {
                        label.style.backgroundColor = 'transparent';
                    });
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    // Use Hebrew name as the value since our emotion data now uses Hebrew
                    checkbox.value = emotion;
                    // Add English name as data attribute for compatibility
                    checkbox.setAttribute('data-english', config.english || emotion);
                    
                    const text = document.createElement('span');
                    text.textContent = `${config.emoji || 'ğŸ˜'} ${emotion}`;
                    
                    label.appendChild(checkbox);
                    label.appendChild(text);
                    container.appendChild(label);
                });
                
                console.log(`âœ… Successfully populated ${allEmotions.length} emotions in metadata selector`);
                
                // Set up search functionality
                setupEmotionsSearch();
                
            } catch (error) {
                console.error('âŒ Error populating emotions selector:', error);
                const container = document.getElementById('main-emotions-selector');
                if (container) {
                    container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #ff6b6b; padding: 1rem;">×©×’×™××” ×‘×˜×¢×™× ×ª ×¨×’×©×•×ª: ' + error.message + '</div>';
                }
            }
        }

        // Set up emotions search functionality
        function setupEmotionsSearch() {
            const searchInput = document.getElementById('emotions-search');
            if (!searchInput) return;
            
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                const emotionLabels = document.querySelectorAll('#main-emotions-selector label');
                
                emotionLabels.forEach(label => {
                    const emotionText = label.textContent.toLowerCase();
                    const shouldShow = emotionText.includes(searchTerm);
                    label.style.display = shouldShow ? 'flex' : 'none';
                });
            });
        }

        // Select all visible emotions
        function selectAllEmotions() {
            const checkboxes = document.querySelectorAll('#main-emotions-selector input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                const label = checkbox.closest('label');
                if (label && label.style.display !== 'none') {
                    checkbox.checked = true;
                }
            });
        }

        // Clear all emotion selections
        function clearAllEmotions() {
            const checkboxes = document.querySelectorAll('#main-emotions-selector input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
        }
        
        // Force load emotions with extra debugging and retry logic
        async function forceLoadEmotions() {
            try {
                console.log('ğŸ”„ Force loading emotions...');
                showLoading('×˜×•×¢×Ÿ ×¨×’×©×•×ª...');
                
                // Clear any existing emotions
                const container = document.getElementById('main-emotions-selector');
                if (container) {
                    container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #666; padding: 1rem;">ğŸ”„ ×˜×•×¢×Ÿ ×¨×’×©×•×ª...</div>';
                }
                
                // Force reload emotions config
                emotionsConfig = null;
                await loadEmotionsConfig();
                
                // Wait a bit then populate
                await new Promise(resolve => setTimeout(resolve, 500));
                await populateMainEmotionsSelector();
                
                hideLoading();
                showStatus('×¨×’×©×•×ª × ×˜×¢× ×• ×‘×”×¦×œ×—×”!', 'success');
                
            } catch (error) {
                console.error('âŒ Error force loading emotions:', error);
                hideLoading();
                showStatus('×©×’×™××” ×‘×˜×¢×™× ×ª ×¨×’×©×•×ª', 'error');
                
                // Show fallback message
                const container = document.getElementById('main-emotions-selector');
                if (container) {
                    container.innerHTML = `
                        <div style="grid-column: 1/-1; text-align: center; color: #ff6b6b; padding: 1rem;">
                            ×©×’×™××” ×‘×˜×¢×™× ×ª ×¨×’×©×•×ª<br>
                            <button onclick="window.location.reload()" class="btn btn-primary btn-sm" style="margin-top: 0.5rem;">
                                ×¨×¢× ×Ÿ ×“×£
                            </button>
                        </div>
                    `;
                }
            }
        }

        // Initialize metadata functionality
        async function initializeMetadata() {
            try {
                console.log('ğŸš€ Initializing metadata with forced refresh...');
                await loadConversationMetadata(true); // Force refresh on initialization
                setupMetadataEventListeners();
                displayMetadataConversations();
                
                // Populate emotions selector with all 92 emotions
                await populateMainEmotionsSelector();
                
                // Ensure emotions are visible after metadata loads
                setTimeout(async () => {
                    const emotionsContainer = document.getElementById('main-emotions-selector');
                    if (emotionsContainer && emotionsContainer.innerHTML.includes('×˜×•×¢×Ÿ ×¨×’×©×•×ª...')) {
                        console.log('ğŸ”„ Emotions still loading, retrying...');
                        await populateMainEmotionsSelector();
                    }
                }, 2000);
            } catch (error) {
                console.error('Error initializing metadata:', error);
                showStatus('×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™ ×”×©×™×—×•×ª', 'error');
            }
        }
        
        // Load conversation metadata from config
        async function loadConversationMetadata(forceRefresh = false) {
            try {
                // ğŸ” ENHANCED CACHE-BUSTING: Always prevent stale config after refresh
                const cacheBuster = forceRefresh ? `?v=${Date.now()}&refresh=true` : `?v=${Date.now()}`;
                const configUrl = `${apiBaseUrl}/config/conversations_config.json${cacheBuster}`;
                
                console.log(`ğŸ“¡ Loading conversation metadata from: ${configUrl}`);
                
                const response = await fetch(configUrl, {
                    cache: 'no-cache',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to load conversations config: ${response.status} ${response.statusText}`);
                }
                
                const config = await response.json();
                console.log('ğŸ“„ Raw config loaded:', config);
                
                conversationMetadata = config.conversations || {};
                console.log(`ğŸ“Š Found ${Object.keys(conversationMetadata).length} conversations`);
                
                // Enhance with metadata if available
                for (const [folder, data] of Object.entries(conversationMetadata)) {
                    // Add default metadata if not present
                    if (!data.metadata) {
                        data.metadata = {
                            date: '',
                            name: `×©×™×—×” ${data.number}`,
                            participants: [],
                            mainEmotions: [],
                            emotionalIntensity: 5,
                            duration: '',
                            totalWords: 0,
                            notes: '',
                            tags: [],
                            isImportant: false,
                            isPrivate: false,
                            needsReview: false
                        };
                    }
                    console.log(`ğŸ“ Processed conversation ${folder}:`, data);
                }
                
                console.log('âœ… Loaded conversation metadata:', conversationMetadata);
            } catch (error) {
                console.error('âŒ Error loading conversation metadata:', error);
                throw error;
            }
        }
        
        // Display conversations list with metadata preview
        function displayMetadataConversations() {
            console.log('ğŸ¨ Displaying metadata conversations...');
            const container = document.getElementById('metadata-conversations-list');
            if (!container) {
                console.error('âŒ Container #metadata-conversations-list not found!');
                return;
            }
            
            container.innerHTML = '';
            
            console.log('ğŸ“Š Current conversationMetadata:', conversationMetadata);
            console.log('ğŸ“Š Metadata keys count:', Object.keys(conversationMetadata || {}).length);
            
            if (!conversationMetadata || Object.keys(conversationMetadata).length === 0) {
                console.log('âš ï¸ No conversation metadata available, showing empty state');
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: #999;">
                        <i class="material-icons" style="font-size: 48px; display: block; margin-bottom: 1rem;">chat_bubble_outline</i>
                        <p>××™×Ÿ ×©×™×—×•×ª ×–××™× ×•×ª</p>
                        <button onclick="refreshMetadataList()" class="btn btn-primary btn-sm" style="margin-top: 1rem;">
                            <i class="material-icons">refresh</i>
                            ×˜×¢×Ÿ ××—×“×©
                        </button>
                    </div>
                `;
                return;
            }
            
            const sortedConvos = Object.entries(conversationMetadata)
                .sort(([,a], [,b]) => a.number - b.number);
            
            console.log(`ğŸ¯ Displaying ${sortedConvos.length} conversations`);
            
            sortedConvos.forEach(([folder, data]) => {
                console.log(`ğŸ“ Processing conversation ${folder}:`, data);
                const metadata = data.metadata || {};
                const item = document.createElement('div');
                item.className = 'conversation-item';
                item.onclick = () => selectMetadataConversation(folder);
                
                // Calculate duration preview
                const durationText = metadata.duration || '×œ× ××—×•×©×‘';
                const emotionsText = metadata.mainEmotions?.length ? 
                    metadata.mainEmotions.map(e => getEmotionEmoji(e)).join('') : 
                    'ğŸ˜';
                
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                        <div style="flex: 1;">
                            <h4 style="margin: 0 0 0.5rem 0; display: flex; align-items: center; gap: 0.5rem;">
                                ${metadata.name || `×©×™×—×” ${data.number}`}
                                ${metadata.isImportant ? '<span style="color: #f44336;">â­</span>' : ''}
                                ${metadata.isPrivate ? '<span style="color: #9c27b0;">ğŸ”’</span>' : ''}
                                ${metadata.needsReview ? '<span style="color: #ff9800;">âš ï¸</span>' : ''}
                            </h4>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
                                ğŸ“… ${metadata.date || '×œ×œ× ×ª××¨×™×š'} | â±ï¸ ${durationText}
                            </div>
                            <div style="font-size: 0.9rem; margin-bottom: 0.5rem;">
                                ${emotionsText} ${metadata.mainEmotions?.join(', ') || '×œ×œ× ×¨×’×©×•×ª ××•×’×“×¨×™×'}
                            </div>
                        </div>
                        <div style="text-align: right; font-size: 0.8rem; color: #999; margin-left: 1rem;">
                            <div>ğŸ“ ${folder}</div>
                            <div>ğŸµ ${data.mp3_count || 0} ×§×˜×¢×™×</div>
                            <div>ğŸ“ ${metadata.totalWords || 0} ××™×œ×™×</div>
                            <button onclick="deleteConversation('${folder}'); event.stopPropagation();" 
                                    class="btn btn-danger" 
                                    style="margin-top: 0.5rem; padding: 0.25rem 0.5rem; font-size: 0.8rem;" 
                                    title="××—×§ ×©×™×—×” ×–×• ×œ×¦××™×ª×•×ª">
                                <i class="material-icons" style="font-size: 16px;">delete</i>
                                ××—×§
                            </button>
                        </div>
                    </div>
                    <div class="conversation-stats">
                        <span>××©×ª×ª×¤×™×: ${metadata.participants?.join(', ') || '×œ× ×”×•×’×“×¨'}</span>
                        <span>×¢×•×¦××”: ${metadata.emotionalIntensity || 5}/10</span>
                    </div>
                `;
                
                container.appendChild(item);
            });
        }
        
        // Select conversation for metadata editing
        async function selectMetadataConversation(folder) {
            try {
                console.log(`ğŸ“ Selecting conversation for metadata: ${folder}`);
                
                // Update UI
                document.querySelectorAll('#metadata-conversations-list .conversation-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                event.target.closest('.conversation-item').classList.add('active');
                
                currentMetadataConversation = folder;
                const data = conversationMetadata[folder];
                
                if (!data) {
                    showStatus(`×œ× × ××¦××• × ×ª×•× ×™× ×¢×‘×•×¨ ${folder}`, 'error');
                    return;
                }
                
                // Clear previous main emotion analysis result when switching conversations
                const emotionAnalysisResult = document.getElementById('main-emotion-analysis-result');
                if (emotionAnalysisResult) {
                    emotionAnalysisResult.style.display = 'none';
                    // Clear the content as well
                    document.getElementById('detected-main-emotion').textContent = '';
                    document.getElementById('emotion-explanation').textContent = '';
                    document.getElementById('segments-count').textContent = '';
                    document.getElementById('confidence-score').textContent = '';
                }
                
                // Show editor
                document.getElementById('no-metadata-selection').style.display = 'none';
                document.getElementById('metadata-editor-panel').style.display = 'flex';
                const titleEl = document.getElementById('metadata-conversation-title');
            if (titleEl) titleEl.textContent = `× ×ª×•× ×™ ${data.metadata?.name || `×©×™×—×” ${data.number}`}`;
                
                // Load conversation data and calculate statistics
                await loadMetadataForm(folder, data);
                await calculateMetadataStatistics(folder);
                
            } catch (error) {
                console.error('Error selecting conversation for metadata:', error);
                showStatus('×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™ ×”×©×™×—×”', 'error');
            }
        }
        
        // Load metadata form with conversation data
        function loadMetadataForm(folder, data) {
            const metadata = data.metadata || {};
            
            // Basic info
            document.getElementById('conversation-date').value = metadata.date || '';
            document.getElementById('conversation-name').value = metadata.name || `×©×™×—×” ${data.number}`;
            document.getElementById('main-participant').value = metadata.mainParticipant || '';
            document.getElementById('custom-participant-name').value = metadata.customParticipantName || '';
            
            // Speaker names
            document.getElementById('speaker-1-name').value = metadata.speaker1Name || '';
            document.getElementById('speaker-2-name').value = metadata.speaker2Name || '';
            
            // Refresh speaker displays if this is the current conversation
            if (currentConversation === folder && emotionData) {
                refreshSpeakerDisplays();
            }
            
            // Show/hide custom participant input
            const showCustom = document.getElementById('main-participant').value === 'custom';
            document.getElementById('custom-participant-input').style.display = showCustom ? 'block' : 'none';
            
            // Conversation Topics - load both predefined and custom topics
            const savedTopics = metadata.conversationTopics || [];
            const predefinedTopics = ['family', 'work', 'relationships', 'health', 'personal', 'therapy', 'memories', 'future', 'emotions', 'decisions'];
            
            // Clear and set predefined topic checkboxes
            const topicCheckboxes = document.querySelectorAll('#conversation-topics input[type="checkbox"]');
            topicCheckboxes.forEach(checkbox => {
                checkbox.checked = savedTopics.includes(checkbox.value);
            });
            
            // Set custom topics (topics not in predefined list)
            const customTopics = savedTopics.filter(topic => !predefinedTopics.includes(topic));
            document.getElementById('custom-topics').value = customTopics.join(', ');
            
            // Main emotions checkboxes
            const emotionCheckboxes = document.querySelectorAll('#main-emotions-selector input[type="checkbox"]');
            emotionCheckboxes.forEach(checkbox => {
                checkbox.checked = metadata.mainEmotions?.includes(checkbox.value) || false;
            });
            
            // Emotional intensity
            const intensitySlider = document.getElementById('emotional-intensity');
            intensitySlider.value = metadata.emotionalIntensity || 5;
            const intensityDisplayEl = document.getElementById('intensity-display');
            if (intensityDisplayEl) intensityDisplayEl.textContent = intensitySlider.value;
            
            // Basic statistics (elements may not exist)
            const segmentsCountEl = document.getElementById('segments-count');
            if (segmentsCountEl) segmentsCountEl.textContent = data.mp3_count || 0;
            
            const totalDurationEl = document.getElementById('total-duration');
            if (totalDurationEl) totalDurationEl.textContent = metadata.duration || '××—×©×‘...';
            
            const totalWordsEl = document.getElementById('total-words');
            if (totalWordsEl) totalWordsEl.textContent = metadata.totalWords || '××—×©×‘...';
            
            // Notes and tags (elements removed)
            const notesEl = document.getElementById('conversation-notes');
            if (notesEl) notesEl.value = metadata.notes || '';
            
            const tagsEl = document.getElementById('conversation-tags');
            if (tagsEl) tagsEl.value = metadata.tags?.join(', ') || '';
            
            // Flags (elements removed)
            const importantEl = document.getElementById('is-important');
            if (importantEl) importantEl.checked = metadata.isImportant || false;
            
            const privateEl = document.getElementById('is-private');
            if (privateEl) privateEl.checked = metadata.isPrivate || false;
            
            const reviewEl = document.getElementById('needs-review');
            if (reviewEl) reviewEl.checked = metadata.needsReview || false;
        }
        
        // Calculate conversation statistics (duration, words, emotions)
        async function calculateMetadataStatistics(folder) {
            try {
                showLoading('××—×©×‘ ×¡×˜×˜×™×¡×˜×™×§×•×ª...');
                
                const convData = conversationMetadata[folder];
                let emotionFile = convData.ai_file || convData.emotion_file || `emotions${convData.number}_ai_analyzed.json`;
                
                if (!emotionFile.startsWith('conversations/')) {
                    emotionFile = `conversations/${folder}/${emotionFile}`;
                }
                
                // Load emotion data
                const response = await fetch(`${apiBaseUrl}/${emotionFile}`);
                if (!response.ok) throw new Error('Failed to load emotion data');
                
                const emotionData = await response.json();
                
                // Calculate statistics
                let totalWords = 0;
                let totalDurationMs = 0;
                const emotionCounts = {};
                
                for (const [filename, data] of Object.entries(emotionData)) {
                    if (filename === 'conversation_details') continue;
                    
                    // Count words
                    if (data.word_count) {
                        totalWords += data.word_count;
                    } else if (data.words) {
                        totalWords += data.words.split(' ').length;
                    }
                    
                    // Estimate duration (roughly 1-2 seconds per MP3 segment)
                    totalDurationMs += 1500; // Approximate 1.5 seconds per segment
                    
                    // Count emotions
                    if (data.emotions && Array.isArray(data.emotions)) {
                        data.emotions.forEach(emotion => {
                            emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                        });
                    }
                }
                
                // Convert duration to readable format
                const totalSeconds = Math.round(totalDurationMs / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const durationText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Calculate average segment duration
                const segmentCount = Object.keys(emotionData).filter(k => k !== 'conversation_details').length;
                const avgSegmentDuration = segmentCount > 0 ? (totalSeconds / segmentCount).toFixed(1) : 0;
                
                // Update UI with null checks
                const totalDurationEl = document.getElementById('total-duration');
                if (totalDurationEl) totalDurationEl.textContent = durationText;
                
                const totalWordsEl = document.getElementById('total-words');
                if (totalWordsEl) totalWordsEl.textContent = totalWords.toLocaleString();
                
                const avgSegmentDurationEl = document.getElementById('avg-segment-duration');
                if (avgSegmentDurationEl) avgSegmentDurationEl.textContent = `${avgSegmentDuration}s`;
                
                // Store in metadata cache
                metadataCache[folder] = {
                    duration: durationText,
                    totalWords: totalWords,
                    avgSegmentDuration: avgSegmentDuration,
                    emotionCounts: emotionCounts,
                    totalSegments: segmentCount
                };
                
                console.log(`ğŸ“Š Calculated statistics for ${folder}:`, metadataCache[folder]);
                
            } catch (error) {
                console.error('Error calculating statistics:', error);
                showStatus('×©×’×™××” ×‘×—×™×©×•×‘ ×”×¡×˜×˜×™×¡×˜×™×§×•×ª', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // Analyze emotional profile from conversation data
        async function analyzeEmotionalProfile() {
            if (!currentMetadataConversation) return;
            
            try {
                showLoading('×× ×ª×— ×¤×¨×•×¤×™×œ ×¨×’×©×™...');
                
                const cached = metadataCache[currentMetadataConversation];
                if (!cached || !cached.emotionCounts) {
                    await calculateMetadataStatistics(currentMetadataConversation);
                }
                
                const emotionCounts = metadataCache[currentMetadataConversation]?.emotionCounts || {};
                
                // Find top emotions
                const sortedEmotions = Object.entries(emotionCounts)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 5);
                
                // Update emotion checkboxes based on analysis
                const emotionCheckboxes = document.querySelectorAll('#main-emotions-selector input[type="checkbox"]');
                emotionCheckboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // Check top 3 emotions
                sortedEmotions.slice(0, 3).forEach(([emotion, count]) => {
                    // Try multiple ways to find the emotion checkbox
                    let checkbox = 
                        // 1. Try by exact value match (Hebrew)
                        document.querySelector(`#main-emotions-selector input[value="${emotion}"]`) ||
                        // 2. Try by English data attribute  
                        document.querySelector(`#main-emotions-selector input[data-english="${emotion}"]`) ||
                        // 3. Try by English equivalent lookup if emotion is English
                        (function() {
                            // Search for Hebrew key that has this English value
                            for (const [hebrewKey, config] of Object.entries(emotionsConfig || {})) {
                                if (config.english === emotion || config.english === emotion.toLowerCase()) {
                                    return document.querySelector(`#main-emotions-selector input[value="${hebrewKey}"]`);
                                }
                            }
                            return null;
                        })();
                    
                    if (checkbox) {
                        checkbox.checked = true;
                    } else {
                        console.warn(`Could not find checkbox for emotion: ${emotion}`);
                    }
                });
                
                // Calculate intensity based on emotion variety and counts
                const totalSegments = metadataCache[currentMetadataConversation]?.totalSegments || 1;
                const emotionVariety = Object.keys(emotionCounts).length;
                const maxEmotionCount = Math.max(...Object.values(emotionCounts));
                const intensity = Math.min(10, Math.max(1, Math.round((emotionVariety * 2) + (maxEmotionCount / totalSegments * 5))));
                
                const emotionalIntensityEl = document.getElementById('emotional-intensity');
                if (emotionalIntensityEl) emotionalIntensityEl.value = intensity;
                
                const intensityDisplayEl = document.getElementById('intensity-display');
                if (intensityDisplayEl) intensityDisplayEl.textContent = intensity;
                
                showStatus(`× ××¦××• ${emotionVariety} ×¨×’×©×•×ª ×©×•× ×™×. ×¢×•×¦××” ××•×¢×¨×›×ª: ${intensity}/10`, 'success');
                
            } catch (error) {
                console.error('Error analyzing emotional profile:', error);
                showStatus('×©×’×™××” ×‘× ×™×ª×•×— ×”×¤×¨×•×¤×™×œ ×”×¨×’×©×™', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // Calculate duration for current conversation
        async function calculateCurrentDuration() {
            if (!currentMetadataConversation) return;
            
            await calculateMetadataStatistics(currentMetadataConversation);
            showStatus('×”××©×š ×—×•×©×‘ ××—×“×© ×‘×”×¦×œ×—×”', 'success');
        }
        
        // Calculate durations for all conversations
        async function calculateAllDurations() {
            try {
                showLoading('××—×©×‘ ××©×›×™ ×–××Ÿ ×œ×›×œ ×”×©×™×—×•×ª...');
                
                let processed = 0;
                const total = Object.keys(conversationMetadata).length;
                
                for (const folder of Object.keys(conversationMetadata)) {
                    await calculateMetadataStatistics(folder);
                    processed++;
                    
                    // Update loading text
                    document.getElementById('loading-text').textContent = 
                        `××—×©×‘ ××©×›×™ ×–××Ÿ... (${processed}/${total})`;
                }
                
                // Refresh display
                displayMetadataConversations();
                showStatus(`×—×•×©×‘×• ××©×›×™ ×–××Ÿ ×¢×‘×•×¨ ${total} ×©×™×—×•×ª`, 'success');
                
            } catch (error) {
                console.error('Error calculating all durations:', error);
                showStatus('×©×’×™××” ×‘×—×™×©×•×‘ ××©×›×™ ×”×–××Ÿ', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // Save conversation metadata
        async function saveMetadata() {
            if (!currentMetadataConversation) {
                console.error('âŒ No conversation selected for metadata save');
                showStatus('××™×Ÿ ×©×™×—×” × ×‘×—×¨×ª ×œ×©××™×¨×”', 'error');
                return;
            }
            
            console.log('ğŸ’¾ Starting metadata save for:', currentMetadataConversation);
            
            try {
                showLoading('×©×•××¨ × ×ª×•× ×™ ×©×™×—×”...');
                
                // Collect form data
                const metadata = {
                    date: document.getElementById('conversation-date').value,
                    name: document.getElementById('conversation-name').value,
                    mainParticipant: document.getElementById('main-participant').value,
                    customParticipantName: document.getElementById('custom-participant-name').value,
                    
                    // Speaker names
                    speaker1Name: document.getElementById('speaker-1-name').value,
                    speaker2Name: document.getElementById('speaker-2-name').value,
                    
                    // Conversation Topics - collect both predefined and custom
                    conversationTopics: [
                        ...Array.from(document.querySelectorAll('#conversation-topics input[type="checkbox"]:checked'))
                            .map(checkbox => checkbox.value),
                        ...document.getElementById('custom-topics').value
                            .split(',')
                            .map(topic => topic.trim())
                            .filter(topic => topic.length > 0)
                    ],
                    
                    // Main Emotions
                    mainEmotions: Array.from(document.querySelectorAll('#main-emotions-selector input[type="checkbox"]:checked'))
                        .map(checkbox => checkbox.value),
                    emotionalIntensity: parseInt(document.getElementById('emotional-intensity').value),
                    
                    // Notes and Tags (elements may not exist)
                    notes: document.getElementById('conversation-notes')?.value || '',
                    tags: (document.getElementById('conversation-tags')?.value || '')
                        .split(',')
                        .map(tag => tag.trim())
                        .filter(tag => tag.length > 0),
                    
                    // Status Flags (elements may not exist)
                    isImportant: document.getElementById('is-important')?.checked || false,
                    isPrivate: document.getElementById('is-private')?.checked || false,
                    needsReview: document.getElementById('needs-review')?.checked || false,
                    lastModified: new Date().toISOString()
                };
                
                // Add calculated statistics
                const cached = metadataCache[currentMetadataConversation];
                if (cached) {
                    metadata.duration = cached.duration;
                    metadata.totalWords = cached.totalWords;
                    metadata.avgSegmentDuration = cached.avgSegmentDuration;
                }
                
                // Determine participants list
                metadata.participants = [];
                if (metadata.mainParticipant === 'custom' && metadata.customParticipantName) {
                    metadata.participants.push(metadata.customParticipantName);
                } else if (metadata.mainParticipant) {
                    metadata.participants.push(metadata.mainParticipant);
                }
                
                // ğŸ” ENHANCED DEBUGGING: Log the collected metadata  
                console.log('ğŸ“ Collected metadata for save:', {
                    conversation: currentMetadataConversation,
                    name: metadata.name,
                    metadata: metadata
                });
                
                // ğŸ” ENHANCED DEBUGGING: Verify we have the conversation data
                if (!conversationMetadata[currentMetadataConversation]) {
                    console.error('âŒ No conversation data found for:', currentMetadataConversation);
                    throw new Error(`No conversation data found for ${currentMetadataConversation}`);
                }
                
                // Update local data
                conversationMetadata[currentMetadataConversation].metadata = metadata;
                console.log('âœ… Updated local metadata for:', currentMetadataConversation);
                
                // Save to server
                const updatedConfig = {
                    conversations: conversationMetadata,
                    total_conversations: Object.keys(conversationMetadata).length,
                    file_mappings: Object.fromEntries(
                        Object.entries(conversationMetadata).map(([folder, data]) => [
                            folder,
                            data.emotion_file || `conversations/${folder}/emotions${data.number}.json`
                        ])
                    ),
                    last_metadata_update: new Date().toISOString()
                };
                
                // ğŸ” ENHANCED DEBUGGING: Log the config before saving
                console.log('ğŸŒ Config to be saved:', {
                    conversation: currentMetadataConversation,
                    conversationName: updatedConfig.conversations[currentMetadataConversation]?.metadata?.name,
                    totalConversations: updatedConfig.total_conversations,
                    lastUpdate: updatedConfig.last_metadata_update
                });
                
                console.log('ğŸŒ Sending save request to server...');
                
                // ğŸ” ENHANCED DEBUGGING: Add timeout and better error handling
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    console.error('âŒ Save request timed out after 30 seconds');
                }, 30000);
                
                const response = await fetch(`${apiBaseUrl}/api/save-config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: 'config/conversations_config.json',
                        content: updatedConfig
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                console.log('ğŸ“¡ Server response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('âŒ Server error:', {
                        status: response.status,
                        statusText: response.statusText,
                        error: errorText
                    });
                    throw new Error(`Failed to save metadata: ${response.status} - ${errorText}`);
                }
                
                const responseData = await response.json();
                console.log('âœ… Server response:', responseData);
                
                // ğŸ” ENHANCED DEBUGGING: Verify the save was successful
                if (responseData.success) {
                    console.log('âœ… Server confirmed successful save');
                } else {
                    console.warn('âš ï¸ Server response indicates save may have failed:', responseData);
                }
                
                // ğŸ”„ FORCE METADATA RELOAD: Essential for ensuring fresh data after save
                console.log('ğŸ”„ Forcing metadata reload after save...');
                await loadConversationMetadata(true); // Force refresh with cache-busting
                
                // ğŸ”„ FORCE CONVERSATIONS RELOAD: Essential for edit parameters tab
                console.log('ğŸ”„ Forcing conversations reload for edit parameters tab...');
                await loadConversations(true); // Force refresh with cache-busting
                
                // Refresh displays everywhere
                displayMetadataConversations();
                
                // Also refresh the main conversations list (in editor tab)
                conversationsData = conversationMetadata;
                displayConversations();
                
                // ğŸ”„ NOTIFY MAIN INTERFACE: Essential for syncing conversation name changes
                notifyMainVisualizationOfChanges();
                
                // ğŸ”„ FORCE GLOBAL CONFIG REFRESH: Ensure all components reload fresh config
                window.lastConfigUpdate = Date.now();
                
                // ğŸ”„ Force reload conversation config in all interfaces
                try {
                    // Notify visualization iframe directly
                    const iframe = document.querySelector('iframe[src*="visualization.html"]');
                    if (iframe && iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'force-config-reload',
                            conversation: currentMetadataConversation,
                            metadata: metadata
                        }, '*');
                        
                        // Also send a specific conversation title update message
                        iframe.contentWindow.postMessage({
                            type: 'update-conversation-title',
                            conversation: currentMetadataConversation,
                            name: metadata.name,
                            metadata: metadata
                        }, '*');
                    }
                    
                    // Find and notify index.html window if it exists
                    if (window.parent !== window) {
                        window.parent.postMessage({
                            type: 'force-config-reload',
                            conversation: currentMetadataConversation,
                            metadata: metadata
                        }, '*');
                        
                        window.parent.postMessage({
                            type: 'update-conversation-title',
                            conversation: currentMetadataConversation,
                            name: metadata.name,
                            metadata: metadata
                        }, '*');
                    }
                    
                    // Also broadcast via BroadcastChannel for other tabs/components
                    if (typeof BroadcastChannel !== 'undefined') {
                        const configChannel = new BroadcastChannel('conversation-sync');
                        configChannel.postMessage({
                            type: 'force-config-reload',
                            conversation: currentMetadataConversation,
                            metadata: metadata,
                            timestamp: Date.now()
                        });
                        
                        // Send specific title update broadcast
                        configChannel.postMessage({
                            type: 'update-conversation-title',
                            conversation: currentMetadataConversation,
                            name: metadata.name,
                            metadata: metadata,
                            timestamp: Date.now()
                        });
                        
                        configChannel.close();
                        console.log('ğŸ“» Broadcasted force config reload and title update to all components');
                    }
                } catch (error) {
                    console.warn('âš ï¸ Could not notify all interfaces:', error);
                }
                
                // Refresh the segments display to show updated speaker names
                if (currentConversation === currentMetadataConversation && emotionData) {
                    console.log('ğŸ”„ Refreshing segments display with new speaker names...');
                    displaySegments();
                }
                
                // Sync to production after metadata changes (optional - don't block on failure)
                setTimeout(async () => {
                    try {
                        await syncToProduction(currentMetadataConversation, 'incremental');
                    } catch (error) {
                        console.warn('âš ï¸ Sync to production failed, but metadata was saved successfully:', error);
                        // Don't show error to user - metadata save was successful
                    }
                }, 500);
                
                console.log('ğŸ‰ METADATA SAVE COMPLETED SUCCESSFULLY!');
                
                // Show success notification with fallback
                try {
                    showStatus('× ×ª×•× ×™ ×”×©×™×—×” × ×©××¨×• ×‘×”×¦×œ×—×”!', 'success');
                } catch (statusError) {
                    console.warn('Status function failed, using alert fallback:', statusError);
                    alert('âœ… × ×ª×•× ×™ ×”×©×™×—×” × ×©××¨×• ×‘×”×¦×œ×—×”!');
                }
                
            } catch (error) {
                console.error('âŒ ERROR SAVING METADATA:', error);
                
                // Show error notification with fallback
                try {
                    showStatus(`×©×’×™××” ×‘×©××™×¨×ª × ×ª×•× ×™ ×”×©×™×—×”: ${error.message}`, 'error');
                } catch (statusError) {
                    console.warn('Status function failed, using alert fallback:', statusError);
                    alert(`âŒ ×©×’×™××” ×‘×©××™×¨×ª × ×ª×•× ×™ ×”×©×™×—×”: ${error.message}`);
                }
            } finally {
                hideLoading();
            }
        }
        
        // Preview metadata (show what will be displayed on hover)
        function previewMetadata() {
            if (!currentMetadataConversation) return;
            
            const metadata = conversationMetadata[currentMetadataConversation]?.metadata || {};
            const cached = metadataCache[currentMetadataConversation] || {};
            
            const preview = `
ğŸ“ ${metadata.name || '×©×™×—×” ×œ×œ× ×©×'}
ğŸ“… ×ª××¨×™×š: ${metadata.date || '×œ× ×”×•×’×“×¨'}
ğŸ‘¥ ××©×ª×ª×¤×™×: ${metadata.participants?.join(', ') || '×œ× ×”×•×’×“×¨'}
ğŸ’¬ × ×•×©××™×: ${metadata.conversationTopics?.length ? metadata.conversationTopics.join(', ') : '×œ× ×”×•×’×“×¨'}
â±ï¸  ××©×š: ${cached.duration || '×œ× ××—×•×©×‘'}
ğŸ˜Š ×¨×’×©×•×ª ×¢×™×§×¨×™×™×: ${metadata.mainEmotions?.map(e => getEmotionEmoji(e) + ' ' + e).join(', ') || '×œ× ×”×•×’×“×¨'}
ğŸ“Š ×¢×•×¦××” ×¨×’×©×™×ª: ${metadata.emotionalIntensity || 5}/10
ğŸ“ ${cached.totalWords || 0} ××™×œ×™× | ğŸµ ${cached.totalSegments || 0} ×§×˜×¢×™×
ğŸ·ï¸  ×ª×’×™×•×ª: ${metadata.tags?.join(', ') || '×œ×œ× ×ª×’×™×•×ª'}
${metadata.notes ? 'ğŸ“‹ ×”×¢×¨×•×ª: ' + metadata.notes : ''}
${metadata.isImportant ? 'â­ ×©×™×—×” ×—×©×•×‘×”' : ''}
${metadata.isPrivate ? 'ğŸ”’ ×©×™×—×” ×¤×¨×˜×™×ª' : ''}
${metadata.needsReview ? 'âš ï¸ ×“×•×¨×© ×‘×“×™×§×”' : ''}
            `.trim();
            
            alert(`×ª×¦×•×’×” ××§×“×™××” ×©×œ ××™×“×¢ ×‘×¢×ª ×¨×™×—×•×£:\n\n${preview}`);
        }
        
        // Refresh metadata list
        async function refreshMetadataList() {
            try {
                await loadConversationMetadata();
                displayMetadataConversations();
                showStatus('×¨×©×™××ª ×”×©×™×—×•×ª ×¢×•×“×›× ×”', 'success');
            } catch (error) {
                console.error('Error refreshing metadata list:', error);
                showStatus('×©×’×™××” ×‘×¨×¢× ×•×Ÿ ×”×¨×©×™××”', 'error');
            }
        }
        
        // Setup event listeners for metadata form
        function setupMetadataEventListeners() {
            // Main participant selector
            const participantSelect = document.getElementById('main-participant');
            if (participantSelect) {
                participantSelect.addEventListener('change', function() {
                    const showCustom = this.value === 'custom';
                    document.getElementById('custom-participant-input').style.display = 
                        showCustom ? 'block' : 'none';
                });
            }
            
            // Emotional intensity slider
            const intensitySlider = document.getElementById('emotional-intensity');
            if (intensitySlider) {
                intensitySlider.addEventListener('input', function() {
                    document.getElementById('intensity-display').textContent = this.value;
                });
            }
            
            // Add topic selection helpers
            const topicCheckboxes = document.querySelectorAll('#conversation-topics input[type="checkbox"]');
            topicCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    // Optional: Add visual feedback when topics are selected
                    const selectedCount = document.querySelectorAll('#conversation-topics input[type="checkbox"]:checked').length;
                    console.log(`ğŸ“‹ Selected ${selectedCount} conversation topics`);
                });
            });
        }
        
        // Initialize metadata tab when it's loaded
        function initializeMetadata() {
            console.log('ğŸ›ï¸ Initializing metadata tab...');
            
            // Clear any previous main emotion analysis result on tab initialization
            const emotionAnalysisResult = document.getElementById('main-emotion-analysis-result');
            if (emotionAnalysisResult) {
                emotionAnalysisResult.style.display = 'none';
            }
            
            // Set up event listeners
            setupMetadataEventListeners();
            
            // Load conversation metadata if not already loaded
            if (Object.keys(conversationMetadata).length === 0) {
                loadConversationMetadata().then(() => {
                    displayMetadataConversations();
                });
            } else {
                displayMetadataConversations();
            }
            
            console.log('âœ… Metadata tab initialized');
        }
        
        // Analyze main emotion of the conversation using ChatGPT
        async function analyzeMainEmotionWithChatGPT() {
            if (!currentMetadataConversation) {
                showStatus('××™×Ÿ ×©×™×—×” × ×‘×—×¨×ª ×œ× ×™×ª×•×—', 'error');
                return;
            }
            
            try {
                showLoading('×× ×ª×— ×¨×’×© ×¢×™×§×¨×™ ×¢× ChatGPT...');
                
                console.log('ğŸ¤– Starting main emotion analysis for:', currentMetadataConversation);
                
                const response = await fetch('/api/analyze-main-emotion', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        conversationFolder: currentMetadataConversation
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.error) {
                    throw new Error(result.error);
                }
                
                // Display the result
                const resultDiv = document.getElementById('main-emotion-analysis-result');
                const emotionDiv = document.getElementById('detected-main-emotion');
                
                if (result.mainEmotion) {
                    emotionDiv.textContent = result.mainEmotion;
                    resultDiv.style.display = 'block';
                    
                    // Show explanation if available
                    const explanationDiv = document.getElementById('emotion-explanation');
                    if (result.explanation && explanationDiv) {
                        explanationDiv.textContent = `ğŸ’¡ ${result.explanation}`;
                        explanationDiv.style.display = 'block';
                    }
                    
                    // Show analysis statistics
                    const statsDiv = document.getElementById('analysis-stats');
                    if (statsDiv) {
                        document.getElementById('segments-count').textContent = `ğŸ“Š ${result.segmentsAnalyzed || 0} ×§×˜×¢×™×`;
                        document.getElementById('confidence-score').textContent = `ğŸ¯ ×‘×™×˜×—×•×Ÿ: ${Math.round((result.confidence || 0) * 100)}%`;
                        statsDiv.style.display = 'flex';
                    }
                    
                    // Clear all emotion checkboxes first, then select only the detected main emotion
                    const emotionCheckboxes = document.querySelectorAll('#main-emotions-selector input[type="checkbox"]');
                    emotionCheckboxes.forEach(checkbox => {
                        checkbox.checked = false; // Clear all first
                    });
                    
                    // Now find and check only the detected main emotion
                    emotionCheckboxes.forEach(checkbox => {
                        if (checkbox.value === result.mainEmotion || checkbox.nextElementSibling?.textContent?.trim() === result.mainEmotion) {
                            checkbox.checked = true;
                            console.log(`âœ… Selected main emotion checkbox: ${result.mainEmotion}`);
                        }
                    });
                    
                    // Update intensity if provided
                    if (result.intensity) {
                        document.getElementById('emotional-intensity').value = result.intensity;
                        document.getElementById('intensity-display').textContent = result.intensity;
                    }
                    
                    showStatus(`×”×¨×’×© ×”×¢×™×§×¨×™ ×–×•×”×”: ${result.mainEmotion} (${Math.round((result.confidence || 0) * 100)}% ×‘×™×˜×—×•×Ÿ)`, 'success');
                    console.log('âœ… Main emotion analysis completed:', result);
                } else {
                    throw new Error('×œ× × ××¦× ×¨×’×© ×¢×™×§×¨×™ ×‘×ª×•×¦××•×ª');
                }
                
            } catch (error) {
                console.error('âŒ Main emotion analysis error:', error);
                showStatus(`×©×’×™××” ×‘× ×™×ª×•×—: ${error.message}`, 'error');
                
                // Hide result div on error
                document.getElementById('main-emotion-analysis-result').style.display = 'none';
            } finally {
                hideLoading();
            }
        }
        
        // ==================== PEOPLE MANAGEMENT FUNCTIONS ====================
        
        // Global variables for people management
        let peopleData = {};
        let currentPersonId = null;
        
        // Load people data from server
        async function loadPeopleData() {
            try {
                const response = await fetch('/api/get-people-data');
                if (response.ok) {
                    peopleData = await response.json();
                    console.log('ğŸ‘¥ Loaded people data:', peopleData);
                } else {
                    console.warn('âš ï¸ Failed to load people data, creating empty structure');
                    peopleData = { people: {} };
                }
            } catch (error) {
                console.error('âŒ Error loading people data:', error);
                peopleData = { people: {} };
            }
        }
        
        // Save people data to server
        async function savePeopleData() {
            try {
                const response = await fetch('/api/save-people-data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(peopleData)
                });
                
                if (!response.ok) throw new Error('Failed to save people data');
                
                console.log('âœ… People data saved successfully');
                return true;
            } catch (error) {
                console.error('âŒ Error saving people data:', error);
                return false;
            }
        }
        
        // Display people list
        function displayPeopleList() {
            const peopleList = document.getElementById('people-list');
            if (!peopleList) return;
            
            peopleList.innerHTML = '';
            
            if (Object.keys(peopleData.people || {}).length === 0) {
                peopleList.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: #999;">
                        <i class="material-icons" style="font-size: 48px; display: block; margin-bottom: 1rem;">people</i>
                        <p>××™×Ÿ ×× ×©×™× ××•×’×“×¨×™×</p>
                        <button onclick="addNewPerson()" class="btn btn-primary">
                            <i class="material-icons">person_add</i>
                            ×”×•×¡×£ ××“× ×¨××©×•×Ÿ
                        </button>
                    </div>
                `;
                return;
            }
            
            Object.entries(peopleData.people).forEach(([personId, person]) => {
                const personCard = document.createElement('div');
                personCard.className = 'modern-conversation-card';
                personCard.onclick = () => selectPerson(personId);
                
                const conversationsCount = person.conversations?.length || 0;
                const totalSegments = person.totalSegments || 0;
                
                personCard.innerHTML = `
                    <div class="conversation-card-header">
                        <div class="conversation-card-title">
                            <div style="width: 12px; height: 12px; border-radius: 50%; background: ${person.color || '#667eea'}; margin-left: 0.5rem;"></div>
                            ${person.name}
                        </div>
                        <div class="conversation-card-meta">
                            <span>${conversationsCount} ×©×™×—×•×ª</span>
                            <span>${totalSegments} ×§×˜×¢×™×</span>
                        </div>
                    </div>
                    <div class="conversation-card-body">
                        <div class="conversation-stats">
                            <div class="stat-item">
                                <i class="material-icons" style="font-size: 16px;">person</i>
                                ${person.status || 'active'}
                            </div>
                            ${person.description ? `<div class="stat-item">${person.description}</div>` : ''}
                        </div>
                    </div>
                `;
                
                peopleList.appendChild(personCard);
            });
        }
        
        // Select a person for editing
        function selectPerson(personId) {
            currentPersonId = personId;
            const person = peopleData.people[personId];
            if (!person) return;
            
            // Show editor panel
            document.getElementById('no-person-selection').style.display = 'none';
            document.getElementById('person-editor-panel').style.display = 'block';
            
            // Update title
            document.getElementById('person-editor-title').textContent = `×¢×¨×™×›×ª ××“×: ${person.name}`;
            
            // Fill form fields
            document.getElementById('person-name').value = person.name || '';
            document.getElementById('person-description').value = person.description || '';
            document.getElementById('person-color').value = person.color || '#667eea';
            document.getElementById('person-status').value = person.status || 'active';
            document.getElementById('person-default-speaker').value = person.defaultSpeaker || '0';
            
            // Load available conversations
            loadAvailableConversations();
            
            // Update statistics
            updatePersonStatistics(personId);
            
            // Highlight selected card
            document.querySelectorAll('#people-list .modern-conversation-card').forEach(card => {
                card.classList.remove('active');
            });
            event.target.closest('.modern-conversation-card')?.classList.add('active');
        }
        
        // Load available conversations for assignment
        function loadAvailableConversations() {
            const availableContainer = document.getElementById('available-conversations');
            const assignedContainer = document.getElementById('assigned-conversations');
            
            if (!availableContainer || !assignedContainer) return;
            
            availableContainer.innerHTML = '';
            assignedContainer.innerHTML = '';
            
            const currentPerson = peopleData.people[currentPersonId];
            const assignedConversations = currentPerson?.conversations || [];
            
            // Get all conversations from metadata
            const allConversations = Object.entries(conversationMetadata || {});
            
            allConversations.forEach(([conversationId, conversation]) => {
                const conversationName = conversation.metadata?.name || conversationId;
                const isAssigned = assignedConversations.includes(conversationId);
                
                const conversationItem = document.createElement('div');
                conversationItem.style.cssText = `
                    padding: 0.5rem; margin: 0.25rem 0; border-radius: 4px; 
                    background: ${isAssigned ? '#e8f5e8' : '#f8f9fa'}; 
                    border: 1px solid ${isAssigned ? '#28a745' : '#dee2e6'};
                `;
                
                if (isAssigned) {
                    // For assigned conversations, show speaker selection
                    const speakerMapping = peopleData.speakerMappings?.[conversationId] || {};
                    const currentSpeaker = Object.keys(speakerMapping).find(speaker => 
                        speakerMapping[speaker] === currentPersonId) || currentPerson.defaultSpeaker || '0';
                    
                    conversationItem.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <strong>${conversationName}</strong>
                                <div style="font-size: 0.8rem; color: #666; margin-top: 0.25rem;">
                                    ID: ${conversationId}
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <select onchange="updateSpeakerMapping('${conversationId}', this.value)" 
                                        style="padding: 0.25rem; font-size: 0.8rem; min-width: 90px;">
                                    <option value="0" ${currentSpeaker === '0' ? 'selected' : ''}>×“×•×‘×¨ 0</option>
                                    <option value="1" ${currentSpeaker === '1' ? 'selected' : ''}>×“×•×‘×¨ 1</option>
                                    <option value="2" ${currentSpeaker === '2' ? 'selected' : ''}>×“×•×‘×¨ 2</option>
                                    <option value="3" ${currentSpeaker === '3' ? 'selected' : ''}>×“×•×‘×¨ 3</option>
                                </select>
                                <button onclick="toggleConversationAssignment('${conversationId}')" 
                                        class="btn btn-sm btn-danger" 
                                        style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">
                                    ×”×¡×¨
                                </button>
                            </div>
                        </div>
                    `;
                    assignedContainer.appendChild(conversationItem);
                } else {
                    conversationItem.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>${conversationName}</span>
                            <button onclick="toggleConversationAssignment('${conversationId}')" 
                                    class="btn btn-sm btn-success" 
                                    style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">
                                ×”×•×¡×£
                            </button>
                        </div>
                    `;
                    availableContainer.appendChild(conversationItem);
                }
            });
        }
        
        // Toggle conversation assignment to person
        function toggleConversationAssignment(conversationId) {
            if (!currentPersonId || !peopleData.people[currentPersonId]) return;
            
            const person = peopleData.people[currentPersonId];
            const assignedConversations = person.conversations || [];
            
            const isAssigned = assignedConversations.includes(conversationId);
            
            if (isAssigned) {
                // Remove conversation
                person.conversations = assignedConversations.filter(id => id !== conversationId);
                
                // Remove from conversation assignments
                if (!peopleData.conversationAssignments) peopleData.conversationAssignments = {};
                if (peopleData.conversationAssignments[conversationId]) {
                    peopleData.conversationAssignments[conversationId] = 
                        peopleData.conversationAssignments[conversationId].filter(p => p !== currentPersonId);
                    if (peopleData.conversationAssignments[conversationId].length === 0) {
                        delete peopleData.conversationAssignments[conversationId];
                    }
                }
                
                // Remove speaker mapping
                if (!peopleData.speakerMappings) peopleData.speakerMappings = {};
                if (peopleData.speakerMappings[conversationId]) {
                    Object.keys(peopleData.speakerMappings[conversationId]).forEach(speaker => {
                        if (peopleData.speakerMappings[conversationId][speaker] === currentPersonId) {
                            delete peopleData.speakerMappings[conversationId][speaker];
                        }
                    });
                    if (Object.keys(peopleData.speakerMappings[conversationId]).length === 0) {
                        delete peopleData.speakerMappings[conversationId];
                    }
                }
            } else {
                // Add conversation
                person.conversations = [...assignedConversations, conversationId];
                
                // Add to conversation assignments
                if (!peopleData.conversationAssignments) peopleData.conversationAssignments = {};
                if (!peopleData.conversationAssignments[conversationId]) {
                    peopleData.conversationAssignments[conversationId] = [];
                }
                if (!peopleData.conversationAssignments[conversationId].includes(currentPersonId)) {
                    peopleData.conversationAssignments[conversationId].push(currentPersonId);
                }
                
                // Add speaker mapping (use default speaker)
                if (!peopleData.speakerMappings) peopleData.speakerMappings = {};
                if (!peopleData.speakerMappings[conversationId]) {
                    peopleData.speakerMappings[conversationId] = {};
                }
                const defaultSpeaker = person.defaultSpeaker || '0';
                peopleData.speakerMappings[conversationId][defaultSpeaker] = currentPersonId;
            }
            
            // Reload conversation lists
            loadAvailableConversations();
            
            // Update statistics
            updatePersonStatistics(currentPersonId);
        }
        
        // Update speaker mapping for a conversation
        function updateSpeakerMapping(conversationId, newSpeaker) {
            if (!currentPersonId || !peopleData.people[currentPersonId]) return;
            
            if (!peopleData.speakerMappings) peopleData.speakerMappings = {};
            if (!peopleData.speakerMappings[conversationId]) {
                peopleData.speakerMappings[conversationId] = {};
            }
            
            // Remove current person from all speakers in this conversation
            Object.keys(peopleData.speakerMappings[conversationId]).forEach(speaker => {
                if (peopleData.speakerMappings[conversationId][speaker] === currentPersonId) {
                    delete peopleData.speakerMappings[conversationId][speaker];
                }
            });
            
            // Add person to new speaker
            peopleData.speakerMappings[conversationId][newSpeaker] = currentPersonId;
            
            console.log(`ğŸ™ï¸ Updated speaker mapping: ${conversationId} speaker ${newSpeaker} = ${currentPersonId}`);
            
            // Show temporary status
            showStatus(`×¢×•×“×›×Ÿ: ${peopleData.people[currentPersonId].name} ×”×•× ×›×¢×ª ×“×•×‘×¨ ${newSpeaker} ×‘×©×™×—×” ${conversationId}`, 'info');
        }
        
        // Update person statistics
        function updatePersonStatistics(personId) {
            const person = peopleData.people[personId];
            if (!person) return;
            
            const conversations = person.conversations || [];
            let totalSegments = 0;
            let totalDuration = 0;
            
            // Calculate statistics from assigned conversations
            conversations.forEach(conversationId => {
                const conversation = conversationMetadata[conversationId];
                if (conversation) {
                    totalSegments += conversation.mp3_count || 0;
                    // Add duration calculation if available
                }
            });
            
            // Update display
            document.getElementById('person-conversations-count').textContent = conversations.length;
            document.getElementById('person-segments-count').textContent = totalSegments;
            document.getElementById('person-total-duration').textContent = formatDuration(totalDuration);
            document.getElementById('person-status-display').textContent = person.status || 'active';
            
            // Update person data
            person.totalSegments = totalSegments;
            person.totalDuration = totalDuration;
        }
        
        // Add new person
        function addNewPerson() {
            currentPersonId = 'person_' + Date.now();
            
            // Create new person
            peopleData.people[currentPersonId] = {
                name: '××“× ×—×“×©',
                description: '',
                color: '#667eea',
                status: 'active',
                conversations: [],
                totalSegments: 0,
                totalDuration: 0,
                defaultSpeaker: '0',
                createdAt: new Date().toISOString(),
                lastModified: new Date().toISOString()
            };
            
            // Show editor
            selectPerson(currentPersonId);
            
            // Focus on name field
            setTimeout(() => {
                document.getElementById('person-name').focus();
            }, 100);
        }
        
        // Save person
        async function savePerson() {
            if (!currentPersonId || !peopleData.people[currentPersonId]) return;
            
            const person = peopleData.people[currentPersonId];
            
            // Update person data from form
            person.name = document.getElementById('person-name').value.trim();
            person.description = document.getElementById('person-description').value.trim();
            person.color = document.getElementById('person-color').value;
            person.status = document.getElementById('person-status').value;
            person.defaultSpeaker = document.getElementById('person-default-speaker').value;
            person.lastModified = new Date().toISOString();
            
            if (!person.name) {
                showStatus('×©× ×”××“× ×”×•× ×©×“×” ×—×•×‘×”', 'error');
                return;
            }
            
            try {
                showLoading();
                
                // Save to server
                const success = await savePeopleData();
                if (success) {
                    // Synchronize speaker names with conversation metadata
                    await synchronizeSpeakerNames();
                    
                    // Refresh display
                    displayPeopleList();
                    showStatus('×”××“× × ×©××¨ ×‘×”×¦×œ×—×”!', 'success');
                } else {
                    showStatus('×©×’×™××” ×‘×©××™×¨×ª ×”××“×', 'error');
                }
            } catch (error) {
                console.error('Error saving person:', error);
                showStatus('×©×’×™××” ×‘×©××™×¨×ª ×”××“×', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // Delete person
        async function deletePerson() {
            if (!currentPersonId || !peopleData.people[currentPersonId]) return;
            
            const person = peopleData.people[currentPersonId];
            
            if (!confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª "${person.name}"?`)) {
                return;
            }
            
            try {
                showLoading();
                
                // Remove person
                delete peopleData.people[currentPersonId];
                
                // Save to server
                const success = await savePeopleData();
                if (success) {
                    // Reset selection
                    currentPersonId = null;
                    document.getElementById('no-person-selection').style.display = 'block';
                    document.getElementById('person-editor-panel').style.display = 'none';
                    
                    // Refresh display
                    displayPeopleList();
                    showStatus('×”××“× × ××—×§ ×‘×”×¦×œ×—×”!', 'success');
                } else {
                    showStatus('×©×’×™××” ×‘××—×™×§×ª ×”××“×', 'error');
                }
            } catch (error) {
                console.error('Error deleting person:', error);
                showStatus('×©×’×™××” ×‘××—×™×§×ª ×”××“×', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // Refresh people list
        async function refreshPeopleList() {
            try {
                await loadPeopleData();
                displayPeopleList();
                showStatus('×¨×©×™××ª ×”×× ×©×™× ×¢×•×“×›× ×”', 'success');
            } catch (error) {
                console.error('Error refreshing people list:', error);
                showStatus('×©×’×™××” ×‘×¨×¢× ×•×Ÿ ×”×¨×©×™××”', 'error');
            }
        }
        
        // Initialize people management tab
        function initializePeople() {
            console.log('ğŸ‘¥ Initializing people management tab...');
            
            // Load people data
            loadPeopleData().then(() => {
                displayPeopleList();
            });
            
            console.log('âœ… People management tab initialized');
        }
        
        // Helper function to get emotion emoji
        function getEmotionEmoji(emotion) {
            const emojiMap = {
                'happiness': 'ğŸ˜Š',
                'sadness': 'ğŸ˜¢',
                'anger': 'ğŸ˜ ',
                'fear': 'ğŸ˜¨',
                'surprise': 'ğŸ˜²',
                'disgust': 'ğŸ¤¢',
                'curiosity': 'ğŸ¤”',
                'confusion': 'ğŸ˜µ',
                'excitement': 'ğŸ¤©',
                'neutral': 'ğŸ˜',
                'annoyance': 'ğŸ˜¤',
                'frustration': 'ğŸ˜«',
                'caring': 'ğŸ¤—',
                'love': 'â¤ï¸'
            };
            return emojiMap[emotion] || 'ğŸ˜';
        }
        
        // ==================== CONVERSATION DELETION FUNCTIONS ====================
        
        // Delete a single conversation
        async function deleteConversation(folder) {
            if (!folder) return;
            
            const conversationData = conversationMetadata[folder];
            const conversationName = conversationData?.metadata?.name || `×©×™×—×” ${conversationData?.number}`;
            
            // Show confirmation dialog
            const confirmMessage = `×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª "${conversationName}" (${folder})?\n\n×¤×¢×•×œ×” ×–×• ×ª××—×§:\nâ€¢ ××ª ×›×œ ×§×‘×¦×™ ×”-MP3 ×‘×ª×™×§×™×™×”\nâ€¢ ××ª ×§×‘×¦×™ ×”× ×ª×•× ×™× ×”×¨×’×©×™×™×\nâ€¢ ××ª ×”××˜××“××˜×” ×©×œ ×”×©×™×—×”\n\n×œ× × ×™×ª×Ÿ ×œ×‘×˜×œ ×¤×¢×•×œ×” ×–×•!`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                showLoading(`××•×—×§ ××ª ${conversationName}...`);
                
                // Call backend to delete the conversation
                const response = await fetch(`${apiBaseUrl}/api/delete-conversation`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folder,
                        conversationName: conversationName
                    })
                });
                
                const result = await response.json();
                
                if (!response.ok) {
                    throw new Error(result.error || 'Failed to delete conversation');
                }
                
                // Remove from local data
                delete conversationMetadata[folder];
                
                // Clear current selection if this conversation was selected
                if (currentMetadataConversation === folder) {
                    currentMetadataConversation = null;
                    document.getElementById('no-metadata-selection').style.display = 'block';
                    document.getElementById('metadata-editor-panel').style.display = 'none';
                }
                
                // Refresh the conversations list
                displayMetadataConversations();
                
                // Notify main visualization about the deletion
                notifyMainVisualizationOfDeletion(folder);
                
                showStatus(`×”×©×™×—×” "${conversationName}" × ××—×§×” ×‘×”×¦×œ×—×”`, 'success');
                console.log(`ğŸ—‘ï¸ Deleted conversation: ${folder}`);
                
            } catch (error) {
                console.error('Error deleting conversation:', error);
                showStatus(`×©×’×™××” ×‘××—×™×§×ª ×”×©×™×—×”: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }
        
        // Show multiple deletion confirmation dialog
        function showDeleteAllConfirm() {
            const conversationList = Object.keys(conversationMetadata);
            if (conversationList.length === 0) {
                alert('××™×Ÿ ×©×™×—×•×ª ×œ××—×™×§×”');
                return;
            }
            
            // Create a selection dialog
            const dialogHtml = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; justify-content: center; align-items: center;">
                    <div style="background: white; padding: 2rem; border-radius: 12px; max-width: 600px; max-height: 80vh; overflow-y: auto; direction: rtl;">
                        <h3 style="margin: 0 0 1rem 0; color: #d32f2f;">××—×™×§×” ××¨×•×‘×” ×©×œ ×©×™×—×•×ª</h3>
                        <p style="color: #666; margin-bottom: 1.5rem;">×‘×—×¨ ××ª ×”×©×™×—×•×ª ×©×‘×¨×¦×•× ×š ×œ××—×•×§. <strong>×¤×¢×•×œ×” ×–×• ×‘×œ×ª×™ ×”×¤×™×›×”!</strong></p>
                        
                        <div style="max-height: 300px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 8px; padding: 1rem;">
                            ${conversationList.map(folder => {
                                const data = conversationMetadata[folder];
                                const metadata = data.metadata || {};
                                const name = metadata.name || `×©×™×—×” ${data.number}`;
                                return `
                                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; cursor: pointer;">
                                        <input type="checkbox" value="${folder}" class="delete-conversation-checkbox">
                                        <span>${name} (${folder}) - ${data.mp3_count || 0} ×§×˜×¢×™×</span>
                                    </label>
                                `;
                            }).join('')}
                        </div>
                        
                        <div style="margin-top: 1.5rem; display: flex; gap: 1rem; justify-content: flex-end;">
                            <button onclick="closeDeleteDialog()" class="btn btn-secondary">×‘×™×˜×•×œ</button>
                            <button onclick="selectAllConversations()" class="btn btn-secondary">×‘×—×¨ ×”×›×œ</button>
                            <button onclick="executeMultipleDelete()" class="btn btn-danger">××—×§ × ×‘×—×¨×™×</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add dialog to page
            const dialogDiv = document.createElement('div');
            dialogDiv.id = 'delete-dialog';
            dialogDiv.innerHTML = dialogHtml;
            document.body.appendChild(dialogDiv);
        }
        
        // Close delete dialog
        function closeDeleteDialog() {
            const dialog = document.getElementById('delete-dialog');
            if (dialog) {
                dialog.remove();
            }
        }
        
        // Select all conversations in delete dialog
        function selectAllConversations() {
            const checkboxes = document.querySelectorAll('.delete-conversation-checkbox');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = !allChecked;
            });
        }
        
        // Execute multiple conversation deletion
        async function executeMultipleDelete() {
            const selectedCheckboxes = document.querySelectorAll('.delete-conversation-checkbox:checked');
            const selectedFolders = Array.from(selectedCheckboxes).map(cb => cb.value);
            
            if (selectedFolders.length === 0) {
                alert('×œ× × ×‘×—×¨×• ×©×™×—×•×ª ×œ××—×™×§×”');
                return;
            }
            
            const confirmMessage = `×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ${selectedFolders.length} ×©×™×—×•×ª?\n\n×©×™×—×•×ª ×©× ×‘×—×¨×•:\n${selectedFolders.map(folder => `â€¢ ${conversationMetadata[folder]?.metadata?.name || folder}`).join('\n')}\n\n×¤×¢×•×œ×” ×–×• ×‘×œ×ª×™ ×”×¤×™×›×”!`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            closeDeleteDialog();
            
            try {
                showLoading(`××•×—×§ ${selectedFolders.length} ×©×™×—×•×ª...`);
                
                let successCount = 0;
                let errorCount = 0;
                
                for (const folder of selectedFolders) {
                    try {
                        document.getElementById('loading-text').textContent = 
                            `××•×—×§ ×©×™×—×•×ª... (${successCount + errorCount + 1}/${selectedFolders.length})`;
                        
                        const response = await fetch(`${apiBaseUrl}/api/delete-conversation`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folder,
                                conversationName: conversationMetadata[folder]?.metadata?.name || folder
                            })
                        });
                        
                        if (response.ok) {
                            delete conversationMetadata[folder];
                            successCount++;
                            console.log(`ğŸ—‘ï¸ Deleted conversation: ${folder}`);
                        } else {
                            errorCount++;
                            console.error(`âŒ Failed to delete: ${folder}`);
                        }
                        
                    } catch (error) {
                        errorCount++;
                        console.error(`âŒ Error deleting ${folder}:`, error);
                    }
                }
                
                // Clear current selection if it was deleted
                if (currentMetadataConversation && selectedFolders.includes(currentMetadataConversation)) {
                    currentMetadataConversation = null;
                    document.getElementById('no-metadata-selection').style.display = 'block';
                    document.getElementById('metadata-editor-panel').style.display = 'none';
                }
                
                // Refresh the conversations list
                displayMetadataConversations();
                
                // Notify main visualization about the multiple deletions
                if (successCount > 0) {
                    notifyMainVisualizationOfChanges();
                }
                
                // Show results
                let message = `×”×•×©×œ××” ××—×™×§×” ××¨×•×‘×”:\nâ€¢ ${successCount} ×©×™×—×•×ª × ××—×§×• ×‘×”×¦×œ×—×”`;
                if (errorCount > 0) {
                    message += `\nâ€¢ ${errorCount} ×©×™×—×•×ª × ×›×©×œ×• ×‘××—×™×§×”`;
                }
                
                showStatus(message.replace('\n', ' | '), successCount > 0 ? 'success' : 'error');
                
            } catch (error) {
                console.error('Error in multiple deletion:', error);
                showStatus('×©×’×™××” ×‘××—×™×§×” ××¨×•×‘×”', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // ==================== MAIN VISUALIZATION NOTIFICATION ====================
        
        // Notify main visualization about conversation deletion
        function notifyMainVisualizationOfDeletion(folder) {
            try {
                // Check if main visualization is open in another tab/window
                if (window.opener) {
                    // If admin panel was opened from main visualization
                    window.opener.postMessage({
                        type: 'conversation-deleted',
                        folder: folder,
                        timestamp: Date.now()
                    }, '*');
                    console.log(`ğŸ“¡ Notified main visualization about deletion of ${folder}`);
                }
                
                // Also try to send message to any iframe that might contain main visualization
                const iframes = document.getElementsByTagName('iframe');
                for (let iframe of iframes) {
                    try {
                        iframe.contentWindow.postMessage({
                            type: 'conversation-deleted',
                            folder: folder,
                            timestamp: Date.now()
                        }, '*');
                    } catch (e) {
                        // Ignore cross-origin errors
                    }
                }
                
                // Try using BroadcastChannel for same-origin communication
                if (typeof BroadcastChannel !== 'undefined') {
                    const channel = new BroadcastChannel('conversation-sync');
                    channel.postMessage({
                        type: 'conversation-deleted',
                        folder: folder,
                        timestamp: Date.now()
                    });
                    channel.close();
                    console.log(`ğŸ“» Broadcast deletion notification for ${folder}`);
                }
                
            } catch (error) {
                console.warn('âš ï¸ Failed to notify main visualization:', error);
            }
        }
        
        // Notify main visualization about general changes
        function notifyMainVisualizationOfChanges() {
            try {
                // Check if main visualization is open in another tab/window
                if (window.opener) {
                    window.opener.postMessage({
                        type: 'refresh-conversations',
                        timestamp: Date.now()
                    }, '*');
                    console.log(`ğŸ“¡ Notified main visualization about conversation changes`);
                }
                
                // Also try to send message to any iframe
                const iframes = document.getElementsByTagName('iframe');
                for (let iframe of iframes) {
                    try {
                        iframe.contentWindow.postMessage({
                            type: 'refresh-conversations',
                            timestamp: Date.now()
                        }, '*');
                    } catch (e) {
                        // Ignore cross-origin errors
                    }
                }
                
                // Try using BroadcastChannel
                if (typeof BroadcastChannel !== 'undefined') {
                    const channel = new BroadcastChannel('conversation-sync');
                    channel.postMessage({
                        type: 'refresh-conversations',
                        timestamp: Date.now()
                    });
                    channel.close();
                    console.log(`ğŸ“» Broadcast conversation refresh notification`);
                }
                
            } catch (error) {
                console.warn('âš ï¸ Failed to notify main visualization:', error);
            }
        }
        
        // ==================== END MAIN VISUALIZATION NOTIFICATION ====================
        
        // ==================== EMOTION COLOR REQUEST HANDLER ====================
        
        // Listen for emotion color requests from editor visualizations
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'requestEmotionColors') {
                console.log('ğŸ”„ Received emotion colors request from:', event.data.source, 'sketchId:', event.data.sketchId);
                console.log('ğŸ“Š Current emotions config status:', {
                    loaded: !!(emotionsConfig && Object.keys(emotionsConfig).length > 0),
                    count: emotionsConfig ? Object.keys(emotionsConfig).length : 0
                });
                
                // Check if we have emotions config loaded
                if (emotionsConfig && Object.keys(emotionsConfig).length > 0) {
                    // Prepare emotion colors for visualization
                    const emotionColorsForViz = {};
                    let activeCount = 0;
                    Object.entries(emotionsConfig).forEach(([emotion, config]) => {
                        if (config.active && config.color) {
                            // Convert hex to RGB array for visualization
                            const rgbColor = hexToRgb(config.color);
                            
                            // Store with Hebrew name (original key)
                            emotionColorsForViz[emotion] = rgbColor;
                            
                            // Also store with English equivalent if available for better compatibility
                            if (config.english) {
                                emotionColorsForViz[config.english] = rgbColor;
                            }
                            
                            activeCount++;
                        }
                    });
                    
                    console.log(`ğŸ¨ Sending current emotion colors to ${event.data.sketchId || 'unknown'}:`, {
                        totalEmotions: Object.keys(emotionColorsForViz).length,
                        activeEmotions: activeCount,
                        sampleColors: Object.keys(emotionColorsForViz).slice(0, 5)
                    });
                    
                    // Send response back to the requesting window
                    const responseMessage = {
                        type: 'emotionColorsResponse',
                        emotionColorMap: emotionColorsForViz,
                        emotions: emotionsConfig,
                        targetSketch: event.data.sketchId,
                        timestamp: Date.now()
                    };
                    
                    // Send to the source that requested it
                    if (event.source && event.source !== window) {
                        try {
                            event.source.postMessage(responseMessage, '*');
                            console.log(`âœ… Sent emotion colors response to ${event.data.sketchId || 'unknown'} (${Object.keys(emotionColorsForViz).length} emotions)`);
                        } catch (error) {
                            console.warn('Could not send response to requesting window:', error);
                        }
                    }
                    
                    // Also send to all iframes as backup
                    const iframes = document.querySelectorAll('iframe');
                    iframes.forEach((iframe, index) => {
                        try {
                            iframe.contentWindow.postMessage(responseMessage, '*');
                            console.log(`ğŸ”„ Backup: Sent colors to iframe ${index}`);
                        } catch (e) {
                            // Ignore cross-origin errors
                        }
                    });
                    
                    // Also broadcast to all targets to make sure everyone gets it
                    setTimeout(() => {
                        updateVisualizationColors();
                    }, 100);
                    
                } else {
                    console.log('âš ï¸ No emotions config available to send - will load default config');
                    
                    // Try to load emotions config if not loaded
                    if (!emotionsConfig) {
                        loadEmotionsConfig().then(() => {
                            // Retry sending colors after loading
                            if (emotionsConfig && Object.keys(emotionsConfig).length > 0) {
                                console.log('âœ… Emotions config loaded, retrying color send...');
                                // Re-trigger the same request
                                window.dispatchEvent(new MessageEvent('message', { data: event.data, source: event.source }));
                            }
                        }).catch(err => {
                            console.error('Failed to load emotions config:', err);
                        });
                    }
                    
                    // Send empty response
                    const emptyResponse = {
                        type: 'emotionColorsResponse',
                        emotionColorMap: {},
                        emotions: {},
                        targetSketch: event.data.sketchId,
                        timestamp: Date.now()
                    };
                    
                    if (event.source && event.source !== window) {
                        try {
                            event.source.postMessage(emptyResponse, '*');
                            console.log('ğŸ“¤ Sent empty emotion colors response');
            } catch (error) {
                            console.warn('Could not send empty response:', error);
                        }
                    }
                }
            }
        });
        
        // Also listen for BroadcastChannel requests
        if (typeof BroadcastChannel !== 'undefined') {
            const emotionColorsRequestChannel = new BroadcastChannel('emotion-colors-sync');
            emotionColorsRequestChannel.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'requestEmotionColors') {
                    console.log('ğŸ“» Received BroadcastChannel emotion colors request from:', event.data.source);
                    
                    // Send current colors via broadcast
                    if (emotionsConfig && Object.keys(emotionsConfig).length > 0) {
                        const emotionColorsForViz = {};
                        Object.entries(emotionsConfig).forEach(([emotion, config]) => {
                            if (config.active && config.color) {
                                emotionColorsForViz[emotion] = hexToRgb(config.color);
                            }
                        });
                        
                        emotionColorsRequestChannel.postMessage({
                            type: 'emotionColorsResponse',
                            emotionColorMap: emotionColorsForViz,
                            emotions: emotionsConfig,
                            timestamp: Date.now()
                        });
                        
                        console.log('ğŸ“» Broadcast emotion colors response via BroadcastChannel');
                    }
                }
            });
            
            console.log('ğŸ¨ BroadcastChannel listener for emotion color requests initialized');
        }
        
        // ==================== END EMOTION COLOR REQUEST HANDLER ====================
        
        // Setup emotion color synchronization system
        function setupEmotionColorSync() {
            console.log('ğŸ¨ Setting up emotion color synchronization system...');
            
            // Send colors immediately when emotions tab is opened
            const originalSwitchTab = window.switchTab;
            window.switchTab = function(tabName) {
                // Call original function
                const result = originalSwitchTab.apply(this, arguments);
                
                // If switching to emotions tab, ensure colors are synchronized
                if (tabName === 'emotions') {
                    console.log('ğŸ­ Emotions tab opened - synchronizing colors with visualizations...');
                    setTimeout(() => {
                        updateVisualizationColors();
                    }, 500); // Small delay to ensure tab is fully loaded
                }
                
                return result;
            };
            
            // Send colors when page is focused (user returns to admin panel)
            window.addEventListener('focus', () => {
                console.log('ğŸ¨ Admin panel focused - checking emotion color sync...');
                if (emotionsConfig && Object.keys(emotionsConfig).length > 0) {
                    updateVisualizationColors();
                }
            });
            
            // Send colors when page becomes visible
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    console.log('ğŸ¨ Admin panel visible - ensuring emotion color sync...');
                    if (emotionsConfig && Object.keys(emotionsConfig).length > 0) {
                        updateVisualizationColors();
                    }
                }
            });
            
            console.log('âœ… Emotion color synchronization system initialized');
        }
        
        // ==================== END CONVERSATION DELETION ====================
        
        // Tab switching is now handled in the main switchTab function above
        
        // Initialize the admin panel when DOM is loaded
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('ğŸ›ï¸ Admin Panel initializing...');
            
            // Only set API base URL if not already set by the main initialization
            if (!apiBaseUrl) {
                apiBaseUrl = window.location.origin;
                console.log(`ğŸ”§ Set default API base URL: ${apiBaseUrl}`);
            }
            
            // Initialize on load
            await detectApiServer();
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            
            await loadConversations();
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            
            // Load emotion configuration early to ensure colors are available
            await loadEmotionsConfig();
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            
            populateRetranscriptionOptions();
            setupEventListeners();
            initializeExperiments();
            
            // Initialize auto-sync functionality
            addManualSyncButton();
            createSyncStatusIndicator();
            console.log('ğŸ”„ Auto-sync functionality initialized');
            
            // Smart auto-refresh with focus detection
            let isPageVisible = true;
            let lastRefreshTime = Date.now();
            
            // Detect page visibility
            document.addEventListener('visibilitychange', () => {
                isPageVisible = !document.hidden;
                if (isPageVisible && Date.now() - lastRefreshTime > 60000 && !isLoadingEmotionData) {
                    // Refresh if page becomes visible and hasn't refreshed in 60s
                    refreshEmotionData();
                }
            });
            
            // Smart refresh interval - only when page is visible and no loading in progress
            refreshInterval = setInterval(async () => {
                if (currentConversation && !hasUnsavedChanges && isPageVisible && !isLoadingEmotionData) {
                    await refreshEmotionData();
                    lastRefreshTime = Date.now();
                }
            }, 120000); // Refresh every 2 minutes to reduce server load
            
            // Initialize the first tab (editor) as active
            const firstTab = document.querySelector('.tab-button.active');
            if (firstTab) {
                const tabName = firstTab.getAttribute('onclick').match(/switchTab\('(.*)'\)/)?.[1];
                if (tabName) {
                    // Don't call switchTab directly since it might interfere with the default state
                    // Just ensure the correct tab content is visible
                    console.log(`ğŸ¯ Default tab: ${tabName}`);
                    
                    // Initialize the default tab's functionality
                    if (tabName === 'editor') {
                        setTimeout(() => {
                            if (typeof loadConversations === 'function') {
                                loadConversations();
                            }
                        }, 500);
                    }
                }
            }
            
            console.log('âœ… Admin Panel initialized');
        });

        // Modern Parameter Editor Functions
        function toggleParameterSection(header) {
            const section = header.parentElement;
            const body = section.querySelector('.parameter-section-body');
            const toggle = header.querySelector('.parameter-section-toggle');
            
            section.classList.toggle('collapsed');
            
            if (section.classList.contains('collapsed')) {
                body.style.maxHeight = '0';
                body.style.paddingTop = '0';
                body.style.paddingBottom = '0';
            } else {
                body.style.maxHeight = body.scrollHeight + 'px';
                body.style.paddingTop = '1.5rem';
                body.style.paddingBottom = '1.5rem';
            }
        }
        
        // ==================== ENHANCED UPLOAD SYSTEM ====================
        let processingInProgress = false;
        
        // Quality selection function
        function selectQuality(quality) {
            console.log('ğŸ¯ Selected quality:', quality);
            
            // Remove active class from all options
            document.querySelectorAll('.quality-option').forEach(option => {
                option.style.borderColor = '#e0e0e0';
                option.style.background = 'white';
                option.style.transform = 'scale(1)';
            });
            
            // Add active class to selected option
            const selectedOption = event.target.closest('.quality-option');
            if (selectedOption) {
                selectedOption.style.borderColor = '#4caf50';
                selectedOption.style.background = '#f0f8f0';
                selectedOption.style.transform = 'scale(1.02)';
            }
            
            // Update hidden input
            document.getElementById('selected-quality').value = quality;
            
            // Show quality description
            const qualityDescriptions = {
                'chatgpt4_best': 'ğŸ¯ ×ª××œ×•×œ ××ª×§×“× ×¢× GPT-4 ×œ×¢×‘×¨×™×ª ××•×©×œ××ª - ×”××™×›×•×ª ×”×’×‘×•×”×” ×‘×™×•×ª×¨',
                'whisper_accurate': 'ğŸ¯ Whisper ×¢× ×©×™×¤×•×¨ GPT-4 ×œ×¢×‘×¨×™×ª ××“×•×™×§×ª',
                'openai_fast': 'âš¡ ×ª××œ×•×œ ××”×™×¨ ×¢× ×©×™×¤×•×¨ ×‘×¡×™×¡×™'
            };
            
            showStatus(qualityDescriptions[quality] || '××™×›×•×ª × ×‘×—×¨×”', 'info');
        }
        
        function initializeUpload() {
            const uploadArea = document.getElementById('upload-area');
            const fileInput = document.getElementById('fileInput');
            const startBtn = document.getElementById('start-processing-btn');
            const cancelBtn = document.getElementById('cancel-upload-btn');
            
            if (!uploadArea || !fileInput) return;

            // Drag and drop handling
            uploadArea.addEventListener('click', () => fileInput.click());
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });

            if (startBtn) startBtn.addEventListener('click', startProcessingNewConversation);
            if (cancelBtn) cancelBtn.addEventListener('click', cancelUpload);
        }

        function handleDragOver(e) {
            e.preventDefault();
            const uploadArea = document.getElementById('upload-area');
            uploadArea.style.borderColor = '#4CAF50';
            uploadArea.style.background = '#f0f8f0';
            uploadArea.style.transform = 'scale(1.02)';
        }

        function handleDragLeave() {
            const uploadArea = document.getElementById('upload-area');
            uploadArea.style.borderColor = '#667eea';
            uploadArea.style.background = '#f8f9ff';
            uploadArea.style.transform = 'scale(1)';
        }

        function handleDrop(e) {
            e.preventDefault();
            handleDragLeave();
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileUpload(files[0]);
            }
        }

        async function handleFileUpload(file) {
            console.log('ğŸ“ File upload initiated:', file.name, file.size, file.type);
            
            // Validate file type - check for audio MIME type or supported extensions
            const supportedExtensions = ['.mp3', '.m4a', '.wav', '.flac', '.aac', '.ogg'];
            const fileName = file.name.toLowerCase();
            const isSupported = file.type.includes('audio') || supportedExtensions.some(ext => fileName.endsWith(ext));
            
            if (!isSupported) {
                showStatus('âŒ × × ×œ×”×¢×œ×•×ª ×§×•×‘×¥ ××•×“×™×• × ×ª××š: MP3, M4A, WAV, FLAC, AAC, OGG', 'error');
                return;
            }

            // Validate file size (100MB limit)
            const maxSize = 100 * 1024 * 1024; // 100MB
            if (file.size > maxSize) {
                showStatus('âŒ ×”×§×•×‘×¥ ×’×“×•×œ ××“×™. ××§×¡×™××•× 100MB', 'error');
                return;
            }

            uploadedFile = file;
            
            // Update upload status
            document.getElementById('upload-status').innerHTML = `
                <div style="padding: 1rem; background: #e8f5e8; border-radius: 8px; color: #2e7d32;">
                    <i class="material-icons" style="vertical-align: middle;">check_circle</i>
                    <strong>×§×•×‘×¥ ×”×•×¢×œ×” ×‘×”×¦×œ×—×”!</strong><br>
                    ğŸ“ <strong>${file.name}</strong><br>
                    ğŸ“Š ×’×•×“×œ: ${(file.size / 1024 / 1024).toFixed(2)} MB<br>
                    â±ï¸ ××©×š ××©×•×¢×¨: ${Math.round(file.size / (1024 * 10))} ×©× ×™×•×ª
                </div>
            `;
            
            // Show processing options
            document.getElementById('processing-options').style.display = 'block';
            
            // Update file info
            updateFileInfo(file);
            
            // Suggest conversation name based on file name (remove any audio extension)
            const audioExtensions = ['.mp3', '.m4a', '.wav', '.flac', '.aac', '.ogg'];
            let suggestedName = file.name;
            audioExtensions.forEach(ext => {
                if (suggestedName.toLowerCase().endsWith(ext)) {
                    suggestedName = suggestedName.slice(0, -ext.length);
                }
            });
            suggestedName = suggestedName.replace(/[_-]/g, ' ');
            document.getElementById('new-conversation-name').value = suggestedName;
        }

        function updateFileInfo(file) {
            const fileInfoDiv = document.getElementById('file-info');
            const duration = Math.round(file.size / (1024 * 10)); // Rough estimate
            const estimatedSegments = Math.ceil(duration / 20); // 20 second segments
            
            fileInfoDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; text-align: center;">
                    <div style="background: white; padding: 1rem; border-radius: 6px;">
                        <div style="font-size: 1.5rem; color: #2196f3;">ğŸ“</div>
                        <div style="font-size: 0.9rem; color: #666;">×§×•×‘×¥</div>
                        <div style="font-weight: bold;">${uploadedFile.name}</div>
                    </div>
                    <div style="background: white; padding: 1rem; border-radius: 6px;">
                        <div style="font-size: 1.5rem; color: #4caf50;">ğŸ“Š</div>
                        <div style="font-size: 0.9rem; color: #666;">×’×•×“×œ</div>
                        <div style="font-weight: bold;">${(uploadedFile.size / 1024 / 1024).toFixed(1)} MB</div>
                    </div>
                    <div style="background: white; padding: 1rem; border-radius: 6px;">
                        <div style="font-size: 1.5rem; color: #ff9800;">â±ï¸</div>
                        <div style="font-size: 0.9rem; color: #666;">××©×š ××©×•×¢×¨</div>
                        <div style="font-weight: bold;">${Math.floor(duration / 60)}:${(duration % 60).toString().padStart(2, '0')}</div>
                    </div>
                    <div style="background: white; padding: 1rem; border-radius: 6px;">
                        <div style="font-size: 1.5rem; color: #9c27b0;">ğŸµ</div>
                        <div style="font-size: 0.9rem; color: #666;">×§×˜×¢×™× ××©×•×¢×¨×™×</div>
                        <div style="font-weight: bold;">${estimatedSegments}</div>
                    </div>
                </div>
            `;
        }

        async function startProcessingNewConversation() {
            if (!uploadedFile || processingInProgress) {
                return;
            }

            const conversationName = document.getElementById('new-conversation-name').value.trim();
            const conversationType = document.getElementById('conversation-type').value;
            const segmentLength = parseInt(document.getElementById('segment-length').value);
            const transcriptionQuality = document.getElementById('selected-quality').value;
            const emotionAnalysisLevel = document.getElementById('emotion-analysis-level').value;

            if (!conversationName) {
                showStatus('âŒ × × ×œ×”×–×™×Ÿ ×©× ×œ×©×™×—×”', 'error');
                return;
            }

            processingInProgress = true;
            
            try {
                // Show processing progress and reset tracking
                document.getElementById('processing-progress').style.display = 'block';
                resetProgress();
                updateProgress(0, '××›×™×Ÿ ×œ×¢×™×‘×•×“...');

                console.log('ğŸš€ Starting new conversation processing:', {
                    name: conversationName,
                    type: conversationType,
                    segmentLength,
                    transcriptionQuality,
                    fileSize: uploadedFile.size
                });

                // Step 1: Upload and create conversation folder
                updateProgress(10, '×™×•×¦×¨ ×ª×™×§×™×™×ª ×©×™×—×” ×—×“×©×”...');
                const formData = new FormData();
                formData.append('mp3File', uploadedFile);
                formData.append('conversationName', conversationName);
                formData.append('conversationType', conversationType);
                formData.append('segmentLength', segmentLength);
                formData.append('transcriptionQuality', transcriptionQuality);
                formData.append('emotionAnalysisLevel', emotionAnalysisLevel);

                const uploadResponse = await fetch(`${apiBaseUrl}/api/upload-and-process`, {
                    method: 'POST',
                    body: formData
                });

                if (!uploadResponse.ok) {
                    throw new Error(`Upload failed: ${uploadResponse.status} ${uploadResponse.statusText}`);
                }

                const uploadResult = await uploadResponse.json();
                const conversationFolder = uploadResult.conversationFolder;
                
                updateProgress(25, `× ×•×¦×¨×” ×ª×™×§×™×™×”: ${conversationFolder}`);
                
                // Step 2: Segment the audio
                updateProgress(30, '××—×œ×§ ××ª ×”××•×“×™×• ×œ×§×˜×¢×™×...');
                await new Promise(resolve => setTimeout(resolve, 1000)); // Allow UI update
                
                const segmentResponse = await fetch(`${apiBaseUrl}/api/segment-audio`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversationFolder,
                        segmentLength,
                        originalFile: uploadResult.uploadedPath
                    })
                });

                if (!segmentResponse.ok) {
                    throw new Error('Audio segmentation failed');
                }

                const segmentResult = await segmentResponse.json();
                updateProgress(60, `× ×•×¦×¨×• ${segmentResult.segmentCount} ×§×˜×¢×™ ××•×“×™×•`);

                // Step 3: Auto-transcribe and analyze all segments  
                updateProgress(70, '××ª××œ×œ ×•×× ×ª×— ×¨×’×©×•×ª ×‘××•×¤×Ÿ ××•×˜×•××˜×™...');
                await generateEmotionAnalysis(conversationFolder, transcriptionQuality);

                // Step 4: Update configurations and integrate
                updateProgress(95, '××©×œ×‘ ×‘××¢×¨×›×ª...');
                await updateSystemConfiguration(conversationFolder, {
                    name: conversationName,
                    type: conversationType,
                    segmentCount: segmentResult.segmentCount,
                    duration: segmentResult.totalDuration
                });

                // Final success update with celebration
                hideSubProgress();
                updateProgress(100, 'ğŸ‰ ×”×©×™×—×” × ×•×¦×¨×” ×‘×”×¦×œ×—×” ×•××•×›× ×” ×œ×©×™××•×©!');

                // Success feedback
                setTimeout(() => {
                    showStatus(`ğŸ‰ ×”×©×™×—×” "${conversationName}" × ×•×¦×¨×” ×‘×”×¦×œ×—×” ×•××•×›× ×” ×œ×©×™××•×©! ×”×©×™×—×” × ×•×¡×¤×” ××•×˜×•××˜×™×ª ×œ××¢×¨×›×ª ×”×¨××©×™×ª.`, 'success');
                    resetUploadForm();
                    refreshAfterUpload();
                    
                    // Hide progress after a delay to let user see the completion
                    setTimeout(() => {
                        const progressContainer = document.getElementById('processing-progress');
                        if (progressContainer) {
                            progressContainer.style.display = 'none';
                        }
                    }, 3000);
                }, 1000);

            } catch (error) {
                console.error('âŒ Processing error:', error);
                hideSubProgress();
                updateProgress(0, `âŒ ×©×’×™××”: ${error.message}`);
                showStatus(`×©×’×™××” ×‘×¢×™×‘×•×“: ${error.message}`, 'error');
                
                // Hide progress display after error
                setTimeout(() => {
                    const progressContainer = document.getElementById('processing-progress');
                    if (progressContainer) {
                        progressContainer.style.display = 'none';
                    }
                }, 5000); // Show error longer than success
            } finally {
                processingInProgress = false;
            }
        }

        async function processTranscription(conversationFolder, quality) {
            try {
                const response = await fetch(`${apiBaseUrl}/api/transcribe`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversationFolder,
                        quality
                    })
                });

                if (!response.ok) {
                    throw new Error('Transcription failed');
                }

                return await response.json();
            } catch (error) {
                console.warn('âš ï¸ Transcription failed, continuing with basic analysis:', error);
                return { status: 'skipped', reason: 'transcription_failed' };
            }
        }

        async function generateEmotionAnalysis(conversationFolder, transcriptionQuality = 'openai_fast') {
            console.log(`ğŸ¤ Starting transcription and analysis for ${conversationFolder} with quality: ${transcriptionQuality}`);
            
            try {
                // First, get the number of segments to set up progress tracking
                const segmentCountResponse = await fetch(`${apiBaseUrl}/conversations/${conversationFolder}/`);
                let totalSegments = 0;
                
                if (segmentCountResponse.ok) {
                    const folderListing = await segmentCountResponse.text();
                    const mp3Matches = folderListing.match(/\.mp3/g);
                    totalSegments = mp3Matches ? mp3Matches.length - 1 : 0; // Subtract 1 for original file
                }

                console.log(`ğŸ“Š Found ${totalSegments} segments to process`);
                
                // Set up initial progress
                updateProgress(75, '××ª×—×™×œ ×ª××œ×•×œ ×•× ×™×ª×•×—...', {
                    title: '××›×™×Ÿ ×œ×ª××œ×•×œ',
                    current: 0,
                    total: totalSegments,
                    currentItem: null
                });

                // Start the processing with a promise that tracks progress
                const result = await processWithDetailedProgress(conversationFolder, transcriptionQuality, totalSegments);
                
                console.log('âœ… Transcription and analysis completed:', result);
                
                // Final progress update
                hideSubProgress();
                if (result.success) {
                    updateProgress(90, `âœ… ×ª××œ×•×œ ×”×•×©×œ×: ${result.transcribedCount} ×§×˜×¢×™×, × ×™×ª×•×—: ${result.analyzedCount} ×§×˜×¢×™×`);
                }
                
                return result;
                
            } catch (error) {
                console.error('âŒ Error in generateEmotionAnalysis:', error);
                hideSubProgress();
                throw error;
            }
        }

        async function processWithDetailedProgress(conversationFolder, transcriptionQuality, totalSegments) {
            // Start the actual processing
            const processingPromise = fetch(`${apiBaseUrl}/api/auto-transcribe-and-analyze`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    conversationFolder,
                    quality: transcriptionQuality === 'whisper' ? 'whisper_accurate' : 'openai_fast'
                })
            });

            // Simulate detailed progress tracking based on estimated timing
            let currentSegment = 0;
            const progressInterval = setInterval(async () => {
                if (currentSegment < totalSegments) {
                    currentSegment++;
                    
                    // Update sub-progress
                    const subTaskData = {
                        title: '××ª××œ×œ ×•×× ×ª×—',
                        current: currentSegment,
                        total: totalSegments,
                        currentItem: `×§×˜×¢ ${currentSegment.toString().padStart(3, '0')}.mp3`
                    };
                    
                    // Calculate overall progress (75% to 90% range for this step)
                    const stepProgress = (currentSegment / totalSegments) * 15; // 15% of total progress
                    updateProgress(75 + stepProgress, `××¢×‘×“ ×§×˜×¢ ${currentSegment} ××ª×•×š ${totalSegments}`, subTaskData);
                }
            }, 2000); // Update every 2 seconds (estimate ~2 seconds per segment)

            try {
                const response = await processingPromise;
                clearInterval(progressInterval);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('âŒ Auto-transcription failed:', errorText);
                    throw new Error(`Auto-transcription failed: ${response.status} - ${errorText}`);
                }

                const result = await response.json();
                
                // Final sub-progress update
                if (result.success) {
                    updateSubProgress('×”×•×©×œ×!', totalSegments, totalSegments, 'âœ… ×›×œ ×”×§×˜×¢×™× ×¢×•×‘×“×•');
                    setTimeout(hideSubProgress, 1500); // Hide after 1.5 seconds
                }
                
                return result;
            } catch (error) {
                clearInterval(progressInterval);
                throw error;
            }
        }

        async function updateSystemConfiguration(conversationFolder, metadata) {
            console.log('ğŸ”„ Updating system configuration for:', conversationFolder, metadata);
            
            const response = await fetch(`${apiBaseUrl}/api/update-system-config`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    conversationFolder,
                    metadata
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('âŒ System configuration update failed:', errorText);
                throw new Error(`System configuration update failed: ${response.status} ${response.statusText}`);
            }

            const result = await response.json();
            console.log('âœ… System configuration updated successfully:', result);
            
            // Force refresh the main visualization page to show the new conversation
            if (window.opener) {
                window.opener.postMessage({
                    type: 'conversation-added',
                    conversationFolder: conversationFolder,
                    timestamp: Date.now()
                }, '*');
            }
            
            // Broadcast to other tabs
            if (typeof BroadcastChannel !== 'undefined') {
                const channel = new BroadcastChannel('conversation-sync');
                channel.postMessage({
                    type: 'conversation-added',
                    conversationFolder: conversationFolder,
                    timestamp: Date.now()
                });
                channel.close();
            }
            
            return result;
        }

        // Enhanced progress tracking
        let processStartTime = null;
        let lastProgressUpdate = null;
        let progressHistory = [];

        function updateProgress(percentage, message, subTaskData = null) {
            const now = Date.now();
            if (!processStartTime) processStartTime = now;
            
            // Update main progress
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const progressPercentageEl = document.getElementById('progress-percentage');
            const timeElapsedEl = document.getElementById('time-elapsed');
            const timeRemainingEl = document.getElementById('time-remaining');
            const progressSteps = document.getElementById('progress-steps');

            if (progressBar) progressBar.style.width = `${percentage}%`;
            if (progressText) progressText.textContent = message;
            if (progressPercentageEl) progressPercentageEl.textContent = `${Math.round(percentage)}%`;

            // Calculate and update time tracking
            const elapsedMs = now - processStartTime;
            const elapsedMinutes = Math.floor(elapsedMs / 60000);
            const elapsedSeconds = Math.floor((elapsedMs % 60000) / 1000);
            
            if (timeElapsedEl) {
                timeElapsedEl.textContent = `${elapsedMinutes.toString().padStart(2, '0')}:${elapsedSeconds.toString().padStart(2, '0')}`;
            }

            // Estimate remaining time based on progress
            if (percentage > 5 && timeRemainingEl) {
                const estimatedTotalMs = (elapsedMs / percentage) * 100;
                const remainingMs = estimatedTotalMs - elapsedMs;
                const remainingMinutes = Math.floor(remainingMs / 60000);
                const remainingSeconds = Math.floor((remainingMs % 60000) / 1000);
                
                if (remainingMs > 0) {
                    timeRemainingEl.textContent = `${remainingMinutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
                } else {
                    timeRemainingEl.textContent = '00:00';
                }
            }

            // Update sub-task progress if provided
            if (subTaskData) {
                updateSubProgress(subTaskData.title, subTaskData.current, subTaskData.total, subTaskData.currentItem);
            }

            // Add step to progress log with timestamp
            if (progressSteps && message) {
                const timeStr = `${elapsedMinutes.toString().padStart(2, '0')}:${elapsedSeconds.toString().padStart(2, '0')}`;
                const step = document.createElement('div');
                step.style.cssText = 'margin-bottom: 0.4rem; padding: 0.25rem; border-left: 3px solid #4caf50; padding-left: 0.5rem; background: rgba(76, 175, 80, 0.1);';
                step.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span><span style="color: #4caf50; font-weight: bold;">âœ“</span> ${message}</span>
                        <span style="color: #666; font-size: 0.75rem;">${timeStr}</span>
                    </div>
                `;
                progressSteps.appendChild(step);
                progressSteps.scrollTop = progressSteps.scrollHeight;
            }

            // Store progress history for better time estimation
            progressHistory.push({ time: now, percentage });
            if (progressHistory.length > 10) progressHistory.shift(); // Keep last 10 points

            lastProgressUpdate = now;
        }

        function updateSubProgress(title, current, total, currentItem = null) {
            const subContainer = document.getElementById('sub-progress-container');
            const subTitle = document.getElementById('sub-progress-title');
            const subCounter = document.getElementById('sub-progress-counter');
            const subBar = document.getElementById('sub-progress-bar');

            if (!subContainer || !subTitle || !subCounter || !subBar) return;

            // Show sub-progress container
            subContainer.style.display = 'block';

            // Update title and counter
            if (currentItem) {
                subTitle.textContent = `${title} - ${currentItem}`;
            } else {
                subTitle.textContent = title;
            }
            subCounter.textContent = `${current}/${total}`;

            // Update progress bar
            const percentage = total > 0 ? (current / total) * 100 : 0;
            subBar.style.width = `${percentage}%`;

            // Change color based on completion
            if (current === total) {
                subBar.style.background = '#28a745'; // Green when complete
            } else {
                subBar.style.background = '#17a2b8'; // Blue during progress
            }
        }

        function hideSubProgress() {
            const subContainer = document.getElementById('sub-progress-container');
            if (subContainer) {
                subContainer.style.display = 'none';
            }
        }

        function resetProgress() {
            processStartTime = null;
            lastProgressUpdate = null;
            progressHistory = [];
            
            const progressSteps = document.getElementById('progress-steps');
            if (progressSteps) {
                progressSteps.innerHTML = '';
            }
            
            hideSubProgress();
            updateProgress(0, '××›×™×Ÿ ×œ×¢×™×‘×•×“...');
        }

        function cancelUpload() {
            uploadedFile = null;
            processingInProgress = false;
            resetUploadForm();
            showStatus('×”×¢×œ××” ×‘×•×˜×œ×”', 'info');
        }

        function resetUploadForm() {
            document.getElementById('upload-status').innerHTML = '';
            document.getElementById('processing-options').style.display = 'none';
            document.getElementById('processing-progress').style.display = 'none';
            document.getElementById('new-conversation-name').value = '';
            document.getElementById('conversation-type').value = 'general';
            document.getElementById('segment-length').value = '20';
            document.getElementById('transcription-quality').value = 'basic';
            document.getElementById('fileInput').value = '';
            document.getElementById('progress-steps').innerHTML = '';
        }

        async function refreshAfterUpload() {
            console.log('ğŸ”„ Refreshing after upload...');
            
            // Refresh conversations list
            await loadConversations();
            await loadConversationMetadata();
            displayMetadataConversations();
            
            // Notify main visualization about new conversation
            if (window.opener) {
                window.opener.postMessage({
                    type: 'conversation-added',
                    timestamp: Date.now()
                }, '*');
            }
            
            // Broadcast to other tabs
            if (typeof BroadcastChannel !== 'undefined') {
                const channel = new BroadcastChannel('conversation-sync');
                channel.postMessage({
                    type: 'conversation-added',
                    timestamp: Date.now()
                });
                channel.close();
            }
            
            // Force reload the main page to show new conversation
            try {
                const mainPage = window.opener || window.parent;
                if (mainPage && mainPage.location.href.includes('index.html')) {
                    console.log('ğŸ”„ Reloading main page to show new conversation...');
                    mainPage.location.reload();
                }
            } catch (e) {
                console.log('âš ï¸ Could not reload main page:', e.message);
            }
        }

        // ==================== END ENHANCED UPLOAD SYSTEM ====================

        // ==================== END METADATA MANAGEMENT ====================

        // ==================== VIDEO GENERATION FUNCTIONS ====================
        
        let videoGenerationInProgress = false;
        
        // Update duration value display
        document.addEventListener('DOMContentLoaded', () => {
            const durationSlider = document.getElementById('video-duration');
            const durationValue = document.getElementById('duration-value');
            
            if (durationSlider && durationValue) {
                durationSlider.addEventListener('input', (e) => {
                    durationValue.textContent = e.target.value;
                });
            }
        });

        async function generateAllVideos() {
            if (videoGenerationInProgress) {
                showStatus('×™×™×¦×•×¨ ×•×™×“××• ×›×‘×¨ ×‘×ª×”×œ×™×š', 'info');
                return;
            }

            // Get enhanced video settings
            const videoSettings = getEnhancedVideoSettings();
            
            // Check conversation selection
            const selectedConversation = document.getElementById('generation-conversation-select').value;
            
            let conversationsToProcess = [];
            
            if (selectedConversation === 'all' || !selectedConversation) {
                // Process all conversations
                if (!conversationsData || Object.keys(conversationsData).length === 0) {
                    await loadConversations();
                }

                if (!conversationsData || Object.keys(conversationsData).length === 0) {
                    showStatus('××™×Ÿ ×©×™×—×•×ª ×–××™× ×•×ª ×œ×™×™×¦×•×¨ ×•×™×“××•', 'error');
                    return;
                }
                
                conversationsToProcess = Object.keys(conversationsData);
            } else {
                // Process only selected conversation
                conversationsToProcess = [selectedConversation];
                
                // Make sure we have conversation data
                if (!conversationsData || Object.keys(conversationsData).length === 0) {
                    await loadConversations();
                }
            }

            videoGenerationInProgress = true;
            showVideoProgress();

            try {
                const totalConversations = conversationsToProcess.length;
                let completedCount = 0;

                const modeText = selectedConversation === 'all' || !selectedConversation ? '×›×œ ×”×©×™×—×•×ª' : '×©×™×—×” × ×‘×—×¨×ª';
                updateVideoProgress(0, `××ª×—×™×œ ×™×™×¦×•×¨ ×•×™×“××• ××ª×§×“× ×¢×‘×•×¨ ${modeText}...`);

                for (const conversationFolder of conversationsToProcess) {
                    const conversationData = conversationsData[conversationFolder];
                    const displayName = conversationData?.metadata?.name || `×©×™×—×” ${conversationFolder.replace('convo', '')}`;
                    
                    updateVideoProgress(
                        (completedCount / totalConversations) * 100,
                        `××™×™×¦×¨ ×•×™×“××• ××ª×§×“× ×¢×‘×•×¨ ${displayName} (${completedCount + 1}/${totalConversations})`
                    );

                    try {
                        await generateEnhancedVideoForConversation(conversationFolder, videoSettings);
                        
                        completedCount++;
                        
                        // Add step to progress log
                        addVideoProgressStep(`âœ… ×”×•×©×œ×: ${displayName}`);
                        
                    } catch (error) {
                        console.error(`Error generating enhanced video for ${conversationFolder}:`, error);
                        addVideoProgressStep(`âŒ × ×›×©×œ: ${displayName} - ${error.message}`);
                    }
                }

                updateVideoProgress(100, 'âœ… ×™×™×¦×•×¨ ×”×•×™×“××• ×”××ª×§×“× ×”×•×©×œ×!');
                showStatus(`×”×•×©×œ× ×™×™×¦×•×¨ ×•×™×“××• ××ª×§×“× ×¢×‘×•×¨ ${completedCount} ××ª×•×š ${totalConversations} ×©×™×—×•×ª`, 'success');
                
                // Refresh video list
                await loadEnhancedVideoList();

            } catch (error) {
                console.error('Error in enhanced video generation:', error);
                showStatus(`×©×’×™××” ×‘×™×™×¦×•×¨ ×•×™×“××• ××ª×§×“×: ${error.message}`, 'error');
            } finally {
                videoGenerationInProgress = false;
                setTimeout(() => {
                    hideVideoProgress();
                }, 3000);
            }
        }

        async function generateVideoForConversation(conversationFolder, options) {
            const response = await fetch(`${apiBaseUrl}/api/generate-video`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    conversationFolder,
                    options
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Video generation failed: ${response.status} - ${errorText}`);
            }

            return await response.json();
        }
        
        async function generateEnhancedVideoForConversation(conversationFolder, enhancedSettings) {
            const response = await fetch(`${apiBaseUrl}/api/generate-enhanced-video`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    conversation: conversationFolder,
                    ...enhancedSettings
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Enhanced video generation failed: ${response.status} - ${errorText}`);
            }

            return await response.json();
        }

        async function deleteAllVideos() {
            if (!confirm('âš ï¸ ×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª ×›×œ ×§×‘×¦×™ ×”×•×™×“××•?\n\n×¤×¢×•×œ×” ×–×• ×œ× × ×™×ª× ×ª ×œ×‘×™×˜×•×œ!')) {
                return;
            }

            try {
                showLoading('××•×—×§ ×§×‘×¦×™ ×•×™×“××•...');
                
                const response = await fetch(`${apiBaseUrl}/api/delete-all-videos`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error(`Delete failed: ${response.status}`);
                }

                const result = await response.json();
                showStatus(`× ××—×§×• ${result.deletedCount} ×§×‘×¦×™ ×•×™×“××•`, 'success');
                
                // Refresh video list
                await loadVideoList();
                
            } catch (error) {
                console.error('Error deleting videos:', error);
                showStatus(`×©×’×™××” ×‘××—×™×§×ª ×•×™×“××•: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        async function loadVideoList() {
            try {
                const response = await fetch(`${apiBaseUrl}/api/list-videos`);
                if (!response.ok) {
                    throw new Error(`Failed to load videos: ${response.status}`);
                }

                const videos = await response.json();
                displayVideoList(videos);
                
            } catch (error) {
                console.error('Error loading video list:', error);
                document.getElementById('video-files-container').innerHTML = 
                    '<p style="color: #999; text-align: center;">×©×’×™××” ×‘×˜×¢×™× ×ª ×¨×©×™××ª ×”×•×™×“××•</p>';
            }
        }

        function displayVideoList(videos) {
            const container = document.getElementById('video-files-container');
            
            if (!videos || videos.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center;">××™×Ÿ ×§×‘×¦×™ ×•×™×“××• ×–××™× ×™×</p>';
                return;
            }

            container.innerHTML = videos.map(video => `
                <div style="background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 8px; padding: 1rem; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h4 style="margin: 0 0 0.5rem 0;">${video.conversationName}</h4>
                        <div style="font-size: 0.9rem; color: #666;">
                            ğŸ“ ${video.filename} | 
                            ğŸ“Š ${video.fileSize} | 
                            ğŸ¬ ${video.quality}p ${video.fps}fps | 
                            â±ï¸ ${video.duration}s
                        </div>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="previewVideo('${video.conversationFolder}')" class="btn btn-sm btn-primary">
                            <i class="material-icons">play_circle</i>
                            ×ª×¦×•×’×” ××§×“×™××”
                        </button>
                        <button onclick="downloadVideo('${video.conversationFolder}')" class="btn btn-sm btn-secondary">
                            <i class="material-icons">download</i>
                            ×”×•×¨×“
                        </button>
                        <button onclick="deleteVideo('${video.conversationFolder}')" class="btn btn-sm btn-danger">
                            <i class="material-icons">delete</i>
                            ××—×§
                        </button>
                    </div>
                </div>
            `).join('');
        }

        async function previewVideo(conversationFolder) {
            try {
                const videoUrl = `${apiBaseUrl}/videos/${conversationFolder}.mp4`;
                
                // Create modal preview
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;
                
                modal.innerHTML = `
                    <div style="background: white; border-radius: 12px; padding: 2rem; max-width: 80vw; max-height: 80vh; position: relative;">
                        <button onclick="this.parentElement.parentElement.remove()" style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 24px; cursor: pointer;">Ã—</button>
                        <h3 style="margin: 0 0 1rem 0;">×ª×¦×•×’×” ××§×“×™××” - ${conversationFolder}</h3>
                        <video controls autoplay loop muted style="width: 100%; max-width: 600px; height: auto; border-radius: 8px;">
                            <source src="${videoUrl}" type="video/mp4">
                            ×”×“×¤×“×¤×Ÿ ×©×œ×š ×œ× ×ª×•××š ×‘×ª×¦×•×’×ª ×•×™×“××•
                        </video>
                    </div>
                `;
                
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                document.body.appendChild(modal);
                
            } catch (error) {
                console.error('Error previewing video:', error);
                showStatus(`×©×’×™××” ×‘×ª×¦×•×’×” ××§×“×™××”: ${error.message}`, 'error');
            }
        }

        function downloadVideo(conversationFolder) {
            const videoUrl = `${apiBaseUrl}/videos/${conversationFolder}.mp4`;
            const link = document.createElement('a');
            link.href = videoUrl;
            link.download = `${conversationFolder}_visualization.mp4`;
            link.click();
        }

        async function deleteVideo(conversationFolder) {
            if (!confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª ×”×•×™×“××• ×©×œ ${conversationFolder}?`)) {
                return;
            }

            try {
                const response = await fetch(`${apiBaseUrl}/api/delete-video/${conversationFolder}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error(`Delete failed: ${response.status}`);
                }

                showStatus(`×•×™×“××• ×©×œ ${conversationFolder} × ××—×§ ×‘×”×¦×œ×—×”`, 'success');
                await loadVideoList();
                
            } catch (error) {
                console.error('Error deleting video:', error);
                showStatus(`×©×’×™××” ×‘××—×™×§×ª ×•×™×“××•: ${error.message}`, 'error');
            }
        }

        function showVideoProgress() {
            const progressDiv = document.getElementById('video-generation-progress');
            if (progressDiv) {
                progressDiv.style.display = 'block';
                document.getElementById('video-progress-steps').innerHTML = '';
            }
        }

        function hideVideoProgress() {
            const progressDiv = document.getElementById('video-generation-progress');
            if (progressDiv) {
                progressDiv.style.display = 'none';
            }
        }

        function updateVideoProgress(percentage, message) {
            const progressBar = document.getElementById('video-progress-bar');
            const progressText = document.getElementById('video-progress-text');

            if (progressBar) progressBar.style.width = `${percentage}%`;
            if (progressText) progressText.textContent = message;
        }

        function addVideoProgressStep(message) {
            const stepsContainer = document.getElementById('video-progress-steps');
            if (stepsContainer) {
                const step = document.createElement('div');
                step.style.cssText = 'font-size: 0.9rem; color: #666; margin-bottom: 0.25rem;';
                step.textContent = message;
                stepsContainer.appendChild(step);
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
            }
        }

        // Load video list when videos tab is activated
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'tab-switched' && event.data.tab === 'videos') {
                loadVideoList();
                checkVideoStatus();
            }
        });

        async function checkVideoStatus() {
            try {
                const response = await fetch(`${apiBaseUrl}/api/video-status`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const status = await response.json();
                displayVideoStatus(status);

            } catch (error) {
                console.error('Error checking video status:', error);
                document.getElementById('video-status-details').innerHTML = 
                    '<span style="color: #f44336;">âŒ ×©×’×™××” ×‘×‘×“×™×§×ª ×¡×˜×˜×•×¡</span>';
            }
        }

        // ==================== ENHANCED VIDEO MANAGEMENT FUNCTIONS ====================
        
        let videoManagementData = {
            conversations: [],
            videos: [],
            selectedVideos: []
        };
        
        function updateDurationDisplay(value) {
            document.getElementById('duration-display').textContent = `${value} ×©× ×™×•×ª`;
        }
        
        // ==================== FRAME SIZE & CROP AREA FUNCTIONS ====================
        
        const frameSizePresets = {
            'full': { width: 1920, height: 1080, aspectRatio: '16:9' },
            '16:9': { width: 1920, height: 1080, aspectRatio: '16:9' },
            '4:3': { width: 1440, height: 1080, aspectRatio: '4:3' },
            '1:1': { width: 1080, height: 1080, aspectRatio: '1:1' },
            '9:16': { width: 1080, height: 1920, aspectRatio: '9:16' },
            '21:9': { width: 2560, height: 1080, aspectRatio: '21:9' }
        };
        
        function updateFrameSizeFields() {
            const preset = document.getElementById('frame-size-preset').value;
            const customDiv = document.getElementById('custom-dimensions');
            
            if (preset === 'custom') {
                customDiv.style.display = 'block';
            } else {
                customDiv.style.display = 'none';
                
                if (frameSizePresets[preset]) {
                    const { width, height } = frameSizePresets[preset];
                    document.getElementById('custom-width').value = width;
                    document.getElementById('custom-height').value = height;
                    
                    // Update crop area max values
                    updateCropLimits(width, height);
                }
            }
            
            // Show frame size info
            updateFrameSizeDisplay();
        }
        
        function updateCropLimits(maxWidth, maxHeight) {
            document.getElementById('crop-x').max = maxWidth;
            document.getElementById('crop-y').max = maxHeight;
            document.getElementById('crop-width').max = maxWidth;
            document.getElementById('crop-height').max = maxHeight;
            
            // Reset crop values if they exceed new limits
            const cropX = parseInt(document.getElementById('crop-x').value);
            const cropY = parseInt(document.getElementById('crop-y').value);
            const cropWidth = parseInt(document.getElementById('crop-width').value);
            const cropHeight = parseInt(document.getElementById('crop-height').value);
            
            if (cropX >= maxWidth) document.getElementById('crop-x').value = 0;
            if (cropY >= maxHeight) document.getElementById('crop-y').value = 0;
            if (cropWidth > maxWidth) document.getElementById('crop-width').value = maxWidth;
            if (cropHeight > maxHeight) document.getElementById('crop-height').value = maxHeight;
        }
        
        function updateFrameSizeDisplay() {
            const preset = document.getElementById('frame-size-preset').value;
            let displayText = '';
            
            if (preset === 'custom') {
                const width = document.getElementById('custom-width').value;
                const height = document.getElementById('custom-height').value;
                displayText = `${width}x${height} (××•×ª×× ××™×©×™×ª)`;
            } else if (frameSizePresets[preset]) {
                const { width, height, aspectRatio } = frameSizePresets[preset];
                displayText = `${width}x${height} (${aspectRatio})`;
            }
            
            // Update any display elements (can be added later)
            console.log(`Frame size: ${displayText}`);
        }
        
        function toggleCropControls() {
            const isEnabled = document.getElementById('enable-crop').checked;
            const controls = document.getElementById('crop-controls');
            controls.style.display = isEnabled ? 'block' : 'none';
            
            if (isEnabled) {
                resetCropArea();
            }
        }
        
        function previewCropArea() {
            const cropData = getCropAreaData();
            
            // Create preview modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10000; display: flex;
                align-items: center; justify-content: center; flex-direction: column;
            `;
            
            const preview = document.createElement('div');
            preview.style.cssText = `
                background: white; padding: 2rem; border-radius: 12px;
                max-width: 80%; max-height: 80%; overflow: auto;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            `;
            
            preview.innerHTML = `
                <h3 style="margin: 0 0 1rem 0; text-align: center;">×ª×¦×•×’×” ××§×“×™××” - ××–×•×¨ ×”×§×œ×˜×”</h3>
                <div style="background: #f0f0f0; border: 2px solid #ddd; position: relative; margin: 1rem 0;">
                    <div style="
                        position: absolute; 
                        left: ${(cropData.x / cropData.frameWidth) * 100}%; 
                        top: ${(cropData.y / cropData.frameHeight) * 100}%;
                        width: ${(cropData.width / cropData.frameWidth) * 100}%; 
                        height: ${(cropData.height / cropData.frameHeight) * 100}%;
                        background: rgba(0, 123, 255, 0.3); 
                        border: 2px solid #007bff;
                        box-sizing: border-box;
                    "></div>
                    <div style="
                        width: 400px; height: ${400 * (cropData.frameHeight / cropData.frameWidth)}px;
                        background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                                    linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                                    linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
                                    linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
                        background-size: 20px 20px;
                        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
                    "></div>
                </div>
                <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <strong>×¤×¨×˜×™ ××–×•×¨ ×”×§×œ×˜×”:</strong><br>
                    ××™×§×•×: (${cropData.x}, ${cropData.y})<br>
                    ×’×•×“×œ: ${cropData.width} Ã— ${cropData.height}<br>
                    ××¡×’×¨×ª: ${cropData.frameWidth} Ã— ${cropData.frameHeight}<br>
                    ×™×—×¡ ×’×•×‘×”-×¨×•×—×‘: ${(cropData.width / cropData.height).toFixed(2)}:1
                </div>
                <div style="text-align: center;">
                    <button onclick="this.closest('.preview-modal').remove()" class="btn btn-primary">×¡×’×•×¨</button>
                </div>
            `;
            
            modal.className = 'preview-modal';
            modal.appendChild(preview);
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        function centerCropArea() {
            const frameData = getFrameSizeData();
            const cropWidth = parseInt(document.getElementById('crop-width').value) || frameData.width / 2;
            const cropHeight = parseInt(document.getElementById('crop-height').value) || frameData.height / 2;
            
            const centerX = Math.max(0, (frameData.width - cropWidth) / 2);
            const centerY = Math.max(0, (frameData.height - cropHeight) / 2);
            
            document.getElementById('crop-x').value = Math.floor(centerX);
            document.getElementById('crop-y').value = Math.floor(centerY);
            document.getElementById('crop-width').value = cropWidth;
            document.getElementById('crop-height').value = cropHeight;
            
            showStatus('××–×•×¨ ×”×§×œ×˜×” ×××•×¨×›×–', 'success');
        }
        
        function resetCropArea() {
            const frameData = getFrameSizeData();
            
            document.getElementById('crop-x').value = 0;
            document.getElementById('crop-y').value = 0;
            document.getElementById('crop-width').value = frameData.width;
            document.getElementById('crop-height').value = frameData.height;
            
            showStatus('××–×•×¨ ×”×§×œ×˜×” ××•×¤×¡', 'info');
        }
        
        function getFrameSizeData() {
            const preset = document.getElementById('frame-size-preset').value;
            
            if (preset === 'custom') {
                return {
                    width: parseInt(document.getElementById('custom-width').value) || 1920,
                    height: parseInt(document.getElementById('custom-height').value) || 1080
                };
            } else if (frameSizePresets[preset]) {
                return frameSizePresets[preset];
            }
            
            return { width: 1920, height: 1080 }; // Default
        }
        
        function getCropAreaData() {
            const frameData = getFrameSizeData();
            const isCustomCrop = document.getElementById('enable-crop').checked;
            
            if (!isCustomCrop) {
                return {
                    x: 0,
                    y: 0,
                    width: frameData.width,
                    height: frameData.height,
                    frameWidth: frameData.width,
                    frameHeight: frameData.height
                };
            }
            
            return {
                x: parseInt(document.getElementById('crop-x').value) || 0,
                y: parseInt(document.getElementById('crop-y').value) || 0,
                width: parseInt(document.getElementById('crop-width').value) || frameData.width,
                height: parseInt(document.getElementById('crop-height').value) || frameData.height,
                frameWidth: frameData.width,
                frameHeight: frameData.height
            };
        }
        
        function getAdvancedVideoSettings() {
            return {
                smoothMotion: document.getElementById('enable-smooth-motion').checked,
                backgroundBlur: document.getElementById('enable-background-blur').checked,
                fadeEffects: document.getElementById('enable-fade-effects').checked,
                audioSync: document.getElementById('enable-audio-sync').checked
            };
        }
        
        async function handleCustomVideoUpload(files) {
            const uploadArea = document.getElementById('custom-upload-area');
            const maxSize = 100 * 1024 * 1024; // 100MB
            
            for (let file of files) {
                if (file.size > maxSize) {
                    showStatus(`×§×•×‘×¥ ${file.name} ×’×“×•×œ ××“×™ (××¢×œ 100MB)`, 'error');
                    continue;
                }
                
                if (!file.type.startsWith('video/')) {
                    showStatus(`×§×•×‘×¥ ${file.name} ××™× ×• ×§×•×‘×¥ ×•×™×“××• ×ª×§×™×Ÿ`, 'error');
                    continue;
                }
                
                await uploadCustomVideo(file);
            }
        }
        
        async function uploadCustomVideo(file) {
            try {
                // Get selected conversation from dropdown
                let conversationId = document.getElementById('upload-conversation-select').value;
                
                // If no conversation selected, show selection dialog
                if (!conversationId) {
                    conversationId = await showConversationSelectionDialog();
                    if (!conversationId) return;
                }
                
                const formData = new FormData();
                formData.append('video', file);
                formData.append('conversation', conversationId);
                formData.append('source', 'custom');
                
                showStatus(`××¢×œ×” ${file.name} ×¢×‘×•×¨ ${conversationId}...`, 'info');
                
                const response = await fetch(`${apiBaseUrl}/api/upload-custom-video`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                showStatus(`×•×™×“××• ${file.name} ×”×•×¢×œ×” ×‘×”×¦×œ×—×” ×¢×‘×•×¨ ${conversationId}`, 'success');
                
                // Refresh video list
                await loadEnhancedVideoList();
                
            } catch (error) {
                console.error('Error uploading custom video:', error);
                showStatus(`×©×’×™××” ×‘×”×¢×œ××ª ${file.name}: ${error.message}`, 'error');
            }
        }
        
        async function showConversationSelectionDialog() {
            return new Promise((resolve) => {
                // Create modal dialog
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.5); z-index: 10000; display: flex;
                    align-items: center; justify-content: center;
                `;
                
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: white; padding: 2rem; border-radius: 12px;
                    max-width: 500px; width: 90%; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;
                
                dialog.innerHTML = `
                    <h3 style="margin: 0 0 1rem 0;">×‘×—×¨ ×©×™×—×” ×¢×‘×•×¨ ×”×•×™×“××•</h3>
                    <select id="conversation-select" style="width: 100%; padding: 0.75rem; margin-bottom: 1rem; border: 1px solid #ddd; border-radius: 4px;">
                        ${videoManagementData.conversations.map(conv => 
                            `<option value="${conv.id}">${conv.name || conv.id}</option>`
                        ).join('')}
                    </select>
                    <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                        <button onclick="this.closest('.modal').remove(); resolve(null);" class="btn btn-secondary">×‘×™×˜×•×œ</button>
                        <button onclick="
                            const selected = document.getElementById('conversation-select').value;
                            this.closest('.modal').remove();
                            resolve(selected);
                        " class="btn btn-primary">××™×©×•×¨</button>
                    </div>
                `;
                
                modal.className = 'modal';
                modal.appendChild(dialog);
                document.body.appendChild(modal);
                
                // Handle button clicks with proper scope
                modal.querySelectorAll('button').forEach(btn => {
                    btn.onclick = function() {
                        const isConfirm = this.classList.contains('btn-primary');
                        const selected = isConfirm ? document.getElementById('conversation-select').value : null;
                        modal.remove();
                        resolve(selected);
                    };
                });
            });
        }
        
        async function loadEnhancedVideoList() {
            try {
                // Load conversations
                const convResponse = await fetch(`${apiBaseUrl}/api/conversations`);
                if (convResponse.ok) {
                    const data = await convResponse.json();
                    // Handle different API response formats
                    if (data.conversations && Array.isArray(data.conversations)) {
                        // API returns {conversations: [...]}
                        const convList = data.conversations;
                        const conversations = {};
                        convList.forEach(convId => {
                            conversations[convId] = {
                                metadata: { name: `×©×™×—×” ${convId.replace('convo', '')}` }
                            };
                        });
                        videoManagementData.conversations = conversations;
                    } else if (typeof data === 'object') {
                        // API returns conversation object directly
                        videoManagementData.conversations = data;
                    }
                } else {
                    console.warn('Could not load conversations, using empty list');
                    videoManagementData.conversations = {};
                }
                
                // Load existing videos
                const videosResponse = await fetch(`${apiBaseUrl}/api/videos`);
                if (videosResponse.ok) {
                    videoManagementData.videos = await videosResponse.json();
                } else {
                    console.warn('Could not load videos, using empty list');
                    videoManagementData.videos = [];
                }
                
                // Populate conversation select dropdowns
                await populateConversationSelects();
                
                renderVideoManagementGrid();
                
            } catch (error) {
                console.error('Error loading video management data:', error);
                showStatus('×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™ ×•×™×“××•', 'error');
                
                // Initialize with empty data to allow UI to render
                videoManagementData.conversations = {};
                videoManagementData.videos = [];
                await populateConversationSelects();
                renderVideoManagementGrid();
            }
        }
        
        async function populateConversationSelects() {
            const uploadSelect = document.getElementById('upload-conversation-select');
            const generationSelect = document.getElementById('generation-conversation-select');
            
            if (!uploadSelect || !generationSelect) return;
            
            // Clear existing options except defaults
            uploadSelect.innerHTML = '<option value="">-- ×‘×—×¨ ×©×™×—×” --</option>';
            generationSelect.innerHTML = '<option value="all">×›×œ ×”×©×™×—×•×ª</option><option value="">-- ×‘×—×¨ ×©×™×—×” ×¡×¤×¦×™×¤×™×ª --</option>';
            
            // Get conversations
            let conversations = videoManagementData.conversations || {};
            
            // Try to load conversations if empty
            if (Object.keys(conversations).length === 0) {
                try {
                    const response = await fetch(`${apiBaseUrl}/api/conversations`);
                    if (response.ok) {
                        const data = await response.json();
                        // Handle different API response formats
                        if (data.conversations && Array.isArray(data.conversations)) {
                            // API returns {conversations: [...]}
                            const convList = data.conversations;
                            conversations = {};
                            convList.forEach(convId => {
                                conversations[convId] = {
                                    metadata: { name: `×©×™×—×” ${convId.replace('convo', '')}` }
                                };
                            });
                        } else if (typeof data === 'object') {
                            // API returns conversation object directly
                            conversations = data;
                        }
                        videoManagementData.conversations = conversations;
                    }
                } catch (error) {
                    console.warn('Could not load conversations for selects');
                }
            }
            
            let conversationList = [];
            if (Object.keys(conversations).length > 0) {
                conversationList = Object.keys(conversations);
            } else {
                // Fallback to known conversations
                conversationList = ['convo1', 'convo2', 'convo3', 'convo4', 'convo5', 'convo6', 'convo7', 'convo8', 'convo10', 'convo12', 'convo13'];
            }
            
            // Populate both selects
            conversationList.forEach(convId => {
                const convData = conversations[convId];
                let displayName;
                
                // Better display name logic
                if (convData && convData.metadata && convData.metadata.name) {
                    displayName = convData.metadata.name;
                } else if (convId.startsWith('convo')) {
                    displayName = `×©×™×—×” ${convId.replace('convo', '')}`;
                } else {
                    displayName = convId;
                }
                
                // Upload select
                const uploadOption = document.createElement('option');
                uploadOption.value = convId;
                uploadOption.textContent = displayName;
                uploadSelect.appendChild(uploadOption);
                
                // Generation select
                const generationOption = document.createElement('option');
                generationOption.value = convId;
                generationOption.textContent = displayName;
                generationSelect.appendChild(generationOption);
            });
        }
        
        function renderVideoManagementGrid() {
            const grid = document.getElementById('video-management-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            // Handle both array and object formats for conversations
            let conversationList = [];
            if (Array.isArray(videoManagementData.conversations)) {
                conversationList = videoManagementData.conversations;
            } else if (typeof videoManagementData.conversations === 'object') {
                conversationList = Object.keys(videoManagementData.conversations).map(key => ({
                    id: key,
                    name: videoManagementData.conversations[key].metadata?.name || key
                }));
            }
            
            conversationList.forEach(conv => {
                const convId = conv.id || conv;
                const existingVideo = videoManagementData.videos.find(v => 
                    v.conversationFolder === convId || v.conversation === convId
                );
                const card = createVideoManagementCard(conv, existingVideo);
                grid.appendChild(card);
            });
            
            if (conversationList.length === 0) {
                grid.innerHTML = '<div style="text-align: center; color: #666; padding: 2rem;">××™×Ÿ ×©×™×—×•×ª ×–××™× ×•×ª</div>';
            }
        }
        
        function createVideoManagementCard(conversation, existingVideo) {
            const card = document.createElement('div');
            card.className = 'video-management-card';
            card.style.cssText = `
                border: 1px solid #e9ecef; border-radius: 12px; padding: 1rem;
                background: white; transition: all 0.3s ease;
                position: relative; overflow: hidden;
            `;
            
            const hasVideo = !!existingVideo;
            const isCustom = existingVideo?.source === 'custom';
            const statusColor = hasVideo ? (isCustom ? '#f39c12' : '#28a745') : '#dc3545';
            const statusText = hasVideo ? (isCustom ? '××•×ª×× ××™×©×™×ª' : '××¢×¨×›×ª') : '×—×¡×¨';
            
            card.innerHTML = `
                <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem;">
                    <input type="checkbox" class="video-select" data-conversation="${conversation.id}" 
                           style="transform: scale(1.2);">
                    <h4 style="margin: 0; flex: 1; color: #333;">${conversation.name || conversation.id}</h4>
                    <span style="
                        background: ${statusColor}; color: white; padding: 0.25rem 0.75rem;
                        border-radius: 12px; font-size: 0.8rem; font-weight: 500;
                    ">${statusText}</span>
                </div>
                
                ${hasVideo ? `
                    <div style="margin-bottom: 1rem;">
                        <video controls style="width: 100%; max-height: 150px; border-radius: 8px;">
                            <source src="${existingVideo.url || `${apiBaseUrl}/videos/${conversation.id || conversation}.mp4`}" type="video/mp4">
                        </video>
                        <div style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
                            <div>ğŸ“Š ×’×•×“×œ: ${formatFileSize(existingVideo.size || 0)}</div>
                            <div>â±ï¸ ××©×š: ${existingVideo.duration || '×œ× ×™×“×•×¢'}</div>
                            <div>ğŸ“… × ×•×¦×¨: ${formatDate(existingVideo.created)}</div>
                        </div>
                    </div>
                ` : `
                    <div style="
                        background: #f8f9fa; border: 2px dashed #dee2e6; 
                        border-radius: 8px; padding: 2rem; text-align: center;
                        color: #6c757d; margin-bottom: 1rem;
                    ">
                        <i class="material-icons" style="font-size: 2rem; margin-bottom: 0.5rem;">video_call</i>
                        <div>××™×Ÿ ×•×™×“××•</div>
                    </div>
                `}
                
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                    ${hasVideo ? `
                        <button onclick="downloadVideo('${conversation.id}')" class="btn btn-sm btn-success" style="flex: 1;">
                            <i class="material-icons" style="font-size: 1rem;">download</i>
                            ×”×•×¨×“
                        </button>
                        <button onclick="replaceVideo('${conversation.id}')" class="btn btn-sm btn-secondary">
                            <i class="material-icons" style="font-size: 1rem;">swap_horiz</i>
                            ×”×—×œ×£
                        </button>
                        <button onclick="deleteVideo('${conversation.id}')" class="btn btn-sm btn-danger">
                            <i class="material-icons" style="font-size: 1rem;">delete</i>
                            ××—×§
                        </button>
                    ` : `
                        <button onclick="generateSingleVideo('${conversation.id}')" class="btn btn-sm btn-primary" style="flex: 1;">
                            <i class="material-icons" style="font-size: 1rem;">smart_display</i>
                            ×¦×•×¨ ××”××¢×¨×›×ª
                        </button>
                        <button onclick="uploadForConversation('${conversation.id}')" class="btn btn-sm btn-secondary">
                            <i class="material-icons" style="font-size: 1rem;">cloud_upload</i>
                            ×”×¢×œ×”
                        </button>
                    `}
                </div>
            `;
            
            return card;
        }
        
        // Helper functions
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function formatDate(dateString) {
            if (!dateString) return '×œ× ×™×“×•×¢';
            return new Date(dateString).toLocaleDateString('he-IL');
        }
        
        // Enhanced Video management functions
        async function generateSingleVideo(conversationId) {
            try {
                const videoSettings = getEnhancedVideoSettings();
                
                showStatus(`×™×•×¦×¨ ×•×™×“××• ××ª×§×“× ×¢×‘×•×¨ ${conversationId}...`, 'info');
                
                const response = await fetch(`${apiBaseUrl}/api/generate-enhanced-video`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversation: conversationId,
                        ...videoSettings
                    })
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const result = await response.json();
                showStatus(`×•×™×“××• ××ª×§×“× ×¢×‘×•×¨ ${conversationId} × ×•×¦×¨ ×‘×”×¦×œ×—×”`, 'success');
                await loadEnhancedVideoList();
                
            } catch (error) {
                console.error('Error generating enhanced video:', error);
                showStatus(`×©×’×™××” ×‘×™×¦×™×¨×ª ×•×™×“××• ×¢×‘×•×¨ ${conversationId}`, 'error');
            }
        }
        
        function getEnhancedVideoSettings() {
            const frameData = getFrameSizeData();
            const cropData = getCropAreaData();
            const advancedSettings = getAdvancedVideoSettings();
            
            return {
                // Basic video settings
                quality: parseInt(document.getElementById('video-quality').value),
                duration: parseInt(document.getElementById('video-duration').value),
                fps: parseInt(document.getElementById('video-fps').value),
                
                // Frame and crop settings
                frameSize: {
                    width: frameData.width,
                    height: frameData.height,
                    preset: document.getElementById('frame-size-preset').value
                },
                
                cropArea: {
                    enabled: document.getElementById('enable-crop').checked,
                    x: cropData.x,
                    y: cropData.y,
                    width: cropData.width,
                    height: cropData.height
                },
                
                // Advanced options
                advancedOptions: advancedSettings,
                
                // Background color (ensure it matches current setting)
                backgroundColor: '#f7f9f3'
            };
        }
        
        // ==================== VISUAL CONVERSATION SELECTION SYSTEM ====================
        
        function openConversationVisualSelector(mode) {
            console.log(`ğŸ¯ Opening visual conversation selector for mode: ${mode}`);
            
            // Create fullscreen modal for visual conversation selection
            const modal = document.createElement('div');
            modal.id = 'conversation-visual-selector';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.9); z-index: 10000; display: flex;
                flex-direction: column; padding: 2rem; box-sizing: border-box;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 12px; height: 100%; display: flex; flex-direction: column; overflow: hidden;">
                    <!-- Header -->
                    <div style="padding: 1.5rem; border-bottom: 1px solid #ddd; display: flex; justify-content: space-between; align-items: center;">
                        <h2 style="margin: 0; color: #333;">
                            <i class="material-icons" style="vertical-align: middle; margin-left: 0.5rem;">visibility</i>
                            ×‘×—×™×¨×” ×•×™×–×•××œ×™×ª ×©×œ ×©×™×—×”
                        </h2>
                        <button onclick="closeConversationVisualSelector()" style="background: #f44336; color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer;">
                            <i class="material-icons">close</i>
                        </button>
                    </div>
                    
                    <!-- Instructions -->
                    <div style="padding: 1rem; background: #f8f9fa; border-bottom: 1px solid #ddd;">
                        <p style="margin: 0; color: #666; font-size: 0.9rem;">
                            <i class="material-icons" style="font-size: 1rem; vertical-align: middle; color: #2196f3;">info</i>
                            ×œ×—×¥ ×¢×œ ×›×œ ×©×™×—×” ×œ×¨××•×ª ×ª×¦×•×’×” ××§×“×™××” ×•×œ×‘×—×•×¨ ××•×ª×”
                        </p>
                    </div>
                    
                    <!-- Loading -->
                    <div id="conversation-loading" style="flex: 1; display: flex; align-items: center; justify-content: center;">
                        <div style="text-align: center; color: #666;">
                            <i class="material-icons" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5; animation: spin 2s linear infinite;">refresh</i>
                            <p>×˜×•×¢×Ÿ ×©×™×—×•×ª...</p>
                        </div>
                    </div>
                    
                    <!-- Conversation Grid -->
                    <div id="conversation-grid-container" style="flex: 1; padding: 1.5rem; overflow-y: auto; display: none;">
                        <div id="visual-conversation-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 1.5rem;">
                            <!-- Conversation cards will be populated here -->
                        </div>
                    </div>
                    
                    <!-- Footer -->
                    <div style="padding: 1rem; border-top: 1px solid #ddd; text-align: center;">
                        <button onclick="closeConversationVisualSelector()" class="btn btn-secondary">
                            ×‘×™×˜×•×œ
                        </button>
                    </div>
                </div>
                
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
            
            document.body.appendChild(modal);
            
            // Load conversations asynchronously
            loadVisualConversationGrid(mode).then(() => {
                const loading = document.getElementById('conversation-loading');
                const container = document.getElementById('conversation-grid-container');
                if (loading) loading.style.display = 'none';
                if (container) container.style.display = 'block';
            }).catch(error => {
                console.error('Error loading conversation grid:', error);
                const loading = document.getElementById('conversation-loading');
                if (loading) {
                    loading.innerHTML = `
                        <div style="text-align: center; color: #f44336;">
                            <i class="material-icons" style="font-size: 3rem; margin-bottom: 1rem;">error</i>
                            <p>×©×’×™××” ×‘×˜×¢×™× ×ª ×©×™×—×•×ª</p>
                        </div>
                    `;
                }
            });
        }
        
        async function loadVisualConversationGrid(mode) {
            const grid = document.getElementById('visual-conversation-grid');
            if (!grid) return;
            
            // Get conversations data
            let conversations = videoManagementData.conversations || {};
            let conversationList = [];
            
            // Try to load conversations if empty
            if (Object.keys(conversations).length === 0) {
                console.log('ğŸ“¡ Loading conversations from API...');
                try {
                    const response = await fetch(`${apiBaseUrl}/api/conversations`);
                    if (response.ok) {
                        const data = await response.json();
                        // Handle different API response formats
                        if (data.conversations && Array.isArray(data.conversations)) {
                            // API returns {conversations: [...]}
                            const convList = data.conversations;
                            conversations = {};
                            convList.forEach(convId => {
                                conversations[convId] = {
                                    metadata: { name: `×©×™×—×” ${convId.replace('convo', '')}` }
                                };
                            });
                        } else if (typeof data === 'object') {
                            // API returns conversation object directly
                            conversations = data;
                        }
                        videoManagementData.conversations = conversations;
                        console.log('âœ… Loaded conversations:', Object.keys(conversations));
                    } else {
                        console.warn('âŒ API response not ok:', response.status);
                    }
                } catch (error) {
                    console.warn('âŒ Could not load conversations for visual grid:', error);
                }
            } else {
                console.log('ğŸ“‹ Using cached conversations:', Object.keys(conversations));
            }
            
            // Create conversation list
            if (Object.keys(conversations).length > 0) {
                conversationList = Object.keys(conversations);
            } else {
                // Fallback to known conversations
                conversationList = ['convo1', 'convo2', 'convo3', 'convo4', 'convo5', 'convo6', 'convo7', 'convo8', 'convo10', 'convo12', 'convo13'];
            }
            
            grid.innerHTML = '';
            
            // Add "All Conversations" option for generation mode
            if (mode === 'generation') {
                const allCard = document.createElement('div');
                allCard.className = 'visual-conversation-card';
                allCard.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    border: 2px solid #667eea;
                    border-radius: 12px;
                    padding: 1rem;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    position: relative;
                    overflow: hidden;
                    text-align: center;
                `;
                
                allCard.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; min-height: 200px;">
                        <i class="material-icons" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.9;">video_library</i>
                        <h4 style="margin: 0 0 0.5rem 0; color: white;">×›×œ ×”×©×™×—×•×ª</h4>
                        <p style="margin: 0 0 1rem 0; color: rgba(255,255,255,0.8); font-size: 0.8rem;">×¦×•×¨ ×•×™×“××• ×œ×›×œ ×”×©×™×—×•×ª</p>
                        <button onclick="selectConversationFromVisual('all', '×›×œ ×”×©×™×—×•×ª', '${mode}')" class="btn" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); width: 100%;">
                            <i class="material-icons" style="font-size: 1rem; vertical-align: middle;">check</i>
                            ×‘×—×¨ ×›×œ ×”×©×™×—×•×ª
                        </button>
                    </div>
                `;
                
                allCard.addEventListener('mouseenter', () => {
                    allCard.style.transform = 'scale(1.02)';
                    allCard.style.boxShadow = '0 8px 25px rgba(102, 126, 234, 0.4)';
                });
                
                allCard.addEventListener('mouseleave', () => {
                    allCard.style.transform = 'scale(1)';
                    allCard.style.boxShadow = 'none';
                });
                
                grid.appendChild(allCard);
            }
            
            conversationList.forEach(convId => {
                const convData = conversations[convId];
                let displayName;
                
                // Better display name logic
                if (convData && convData.metadata && convData.metadata.name) {
                    displayName = convData.metadata.name;
                } else if (convId.startsWith('convo')) {
                    displayName = `×©×™×—×” ${convId.replace('convo', '')}`;
                } else {
                    displayName = convId;
                }
                
                const card = document.createElement('div');
                card.className = 'visual-conversation-card';
                card.style.cssText = `
                    background: white;
                    border: 2px solid #ddd;
                    border-radius: 12px;
                    padding: 1rem;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    position: relative;
                    overflow: hidden;
                `;
                
                card.innerHTML = `
                    <div style="text-align: center; margin-bottom: 1rem;">
                        <h4 style="margin: 0 0 0.5rem 0; color: #333;">${displayName}</h4>
                        <p style="margin: 0; color: #666; font-size: 0.8rem;">${convId}</p>
                    </div>
                    
                    <!-- Live Preview Iframe -->
                    <div style="position: relative; width: 100%; height: 150px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; background: #f5f5f5;">
                        <iframe 
                            src="visualization.html?conversation=${convId}&static=true&scale=0.3&hideControls=true"
                            style="width: 333%; height: 333%; transform: scale(0.3); transform-origin: 0 0; border: none;"
                            scrolling="no">
                        </iframe>
                    </div>
                    
                    <div style="margin-top: 1rem; text-align: center;">
                        <button onclick="selectConversationFromVisual('${convId}', '${displayName.replace(/'/g, "\\'")}', '${mode}')" class="btn btn-primary" style="width: 100%;">
                            <i class="material-icons" style="font-size: 1rem; vertical-align: middle;">check</i>
                            ×‘×—×¨ ×©×™×—×” ×–×•
                        </button>
                    </div>
                `;
                
                // Add hover effects
                card.addEventListener('mouseenter', () => {
                    card.style.borderColor = '#2196f3';
                    card.style.boxShadow = '0 4px 12px rgba(33, 150, 243, 0.3)';
                });
                
                card.addEventListener('mouseleave', () => {
                    card.style.borderColor = '#ddd';
                    card.style.boxShadow = 'none';
                });
                
                grid.appendChild(card);
            });
            
            // Add loading message if no conversations found
            if (conversationList.length === 0) {
                grid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 2rem; color: #666;">
                        <i class="material-icons" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5;">chat</i>
                        <p>×œ× × ××¦××• ×©×™×—×•×ª ×–××™× ×•×ª</p>
                    </div>
                `;
            }
        }
        
        function selectConversationFromVisual(convId, displayName, mode) {
            // Ensure displayName is not undefined
            if (!displayName || displayName === 'undefined') {
                if (convId === 'all') {
                    displayName = '×›×œ ×”×©×™×—×•×ª';
                } else if (convId && convId.startsWith('convo')) {
                    displayName = `×©×™×—×” ${convId.replace('convo', '')}`;
                } else {
                    displayName = convId || '×©×™×—×” ×œ× ×™×“×•×¢×”';
                }
            }
            
            if (mode === 'upload') {
                // Update upload conversation selection
                document.getElementById('upload-conversation-select').value = convId;
                document.getElementById('selected-conversation-name').textContent = displayName;
                document.getElementById('selected-conversation-info').style.display = 'block';
            } else if (mode === 'generation') {
                // Update generation conversation selection
                document.getElementById('generation-conversation-select').value = convId;
                document.getElementById('generation-conversation-name').textContent = displayName;
                document.getElementById('generation-conversation-info').style.display = 'block';
            } else if (mode === 'editor') {
                // Update editor tab conversation selection - call the original selectConversation function
                // We need to use a different approach since we already have a selectConversation function
                setTimeout(() => {
                    // Call the original editor selectConversation function
                    if (typeof selectConversationImmediate === 'function') {
                        selectConversationImmediate(convId);
                    } else {
                        console.warn('selectConversationImmediate function not found');
                    }
                }, 100);
            }
            
            closeConversationVisualSelector();
            showStatus(`× ×‘×—×¨×” ×©×™×—×”: ${displayName}`, 'success');
        }
        
        function closeConversationVisualSelector() {
            const modal = document.getElementById('conversation-visual-selector');
            if (modal) {
                modal.remove();
            }
        }
        
        // ==================== VISUAL CROP SELECTOR (macOS style) ====================
        
        function openVisualCropSelector() {
            // Get selected conversation
            const selectedConv = document.getElementById('generation-conversation-select').value;
            if (!selectedConv || selectedConv === 'all') {
                showStatus('×‘×—×¨ ×©×™×—×” ×¡×¤×¦×™×¤×™×ª ×ª×—×™×œ×”', 'error');
                return;
            }
            
            // Create fullscreen crop selector
            const modal = document.createElement('div');
            modal.id = 'visual-crop-selector';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10001; cursor: crosshair;
                user-select: none;
            `;
            
            // Create the visualization iframe as background
            const iframe = document.createElement('iframe');
            iframe.src = `visualization.html?conversation=${selectedConv}&static=true&hideControls=true`;
            iframe.style.cssText = `
                position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                border: none; pointer-events: none;
            `;
            
            // Create crop overlay
            const cropOverlay = document.createElement('div');
            cropOverlay.id = 'crop-overlay';
            cropOverlay.style.cssText = `
                position: absolute; border: 2px solid #2196f3; background: rgba(33, 150, 243, 0.1);
                display: none; pointer-events: none;
            `;
            
            // Create instructions
            const instructions = document.createElement('div');
            instructions.style.cssText = `
                position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
                background: rgba(0,0,0,0.8); color: white; padding: 1rem 2rem;
                border-radius: 8px; text-align: center; z-index: 10002;
            `;
            instructions.innerHTML = `
                <h3 style="margin: 0 0 0.5rem 0;">×—×™×ª×•×š ×•×™×–×•××œ×™ - ×¡×’× ×•×Ÿ macOS</h3>
                <p style="margin: 0; font-size: 0.9rem;">×’×¨×•×¨ ×œ×‘×—×™×¨×ª ××–×•×¨ ×”×§×œ×˜×” â€¢ ESC ×œ×‘×™×˜×•×œ â€¢ Enter ×œ××™×©×•×¨</p>
            `;
            
            // Create control panel
            const controlPanel = document.createElement('div');
            controlPanel.style.cssText = `
                position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                background: rgba(0,0,0,0.8); color: white; padding: 1rem 2rem;
                border-radius: 8px; display: flex; gap: 1rem; align-items: center;
            `;
            controlPanel.innerHTML = `
                <div style="font-size: 0.9rem;">
                    ××–×•×¨: <span id="crop-dimensions">0 Ã— 0</span> |
                    ××™×§×•×: <span id="crop-position">0, 0</span>
                </div>
                <button onclick="applyCropSelection()" class="btn btn-success" style="margin: 0;">
                    <i class="material-icons" style="font-size: 1rem; vertical-align: middle;">check</i>
                    ××™×©×•×¨
                </button>
                <button onclick="cancelCropSelection()" class="btn btn-danger" style="margin: 0;">
                    <i class="material-icons" style="font-size: 1rem; vertical-align: middle;">close</i>
                    ×‘×™×˜×•×œ
                </button>
            `;
            
            modal.appendChild(iframe);
            modal.appendChild(cropOverlay);
            modal.appendChild(instructions);
            modal.appendChild(controlPanel);
            document.body.appendChild(modal);
            
            // Initialize crop selection
            initializeCropSelection(modal);
        }
        
        let cropSelection = { startX: 0, startY: 0, endX: 0, endY: 0, isSelecting: false };
        
        function initializeCropSelection(modal) {
            const overlay = document.getElementById('crop-overlay');
            
            modal.addEventListener('mousedown', (e) => {
                if (e.target === modal) {
                    cropSelection.isSelecting = true;
                    cropSelection.startX = e.clientX;
                    cropSelection.startY = e.clientY;
                    overlay.style.left = e.clientX + 'px';
                    overlay.style.top = e.clientY + 'px';
                    overlay.style.width = '0px';
                    overlay.style.height = '0px';
                    overlay.style.display = 'block';
                }
            });
            
            modal.addEventListener('mousemove', (e) => {
                if (cropSelection.isSelecting) {
                    const width = Math.abs(e.clientX - cropSelection.startX);
                    const height = Math.abs(e.clientY - cropSelection.startY);
                    const left = Math.min(e.clientX, cropSelection.startX);
                    const top = Math.min(e.clientY, cropSelection.startY);
                    
                    overlay.style.left = left + 'px';
                    overlay.style.top = top + 'px';
                    overlay.style.width = width + 'px';
                    overlay.style.height = height + 'px';
                    
                    // Update display
                    document.getElementById('crop-dimensions').textContent = `${width} Ã— ${height}`;
                    document.getElementById('crop-position').textContent = `${left}, ${top}`;
                }
            });
            
            modal.addEventListener('mouseup', (e) => {
                if (cropSelection.isSelecting) {
                    cropSelection.isSelecting = false;
                    cropSelection.endX = e.clientX;
                    cropSelection.endY = e.clientY;
                }
            });
            
            // Keyboard controls
            document.addEventListener('keydown', handleCropKeydown);
        }
        
        function handleCropKeydown(e) {
            if (document.getElementById('visual-crop-selector')) {
                if (e.key === 'Escape') {
                    cancelCropSelection();
                } else if (e.key === 'Enter') {
                    applyCropSelection();
                }
            }
        }
        
        function applyCropSelection() {
            const overlay = document.getElementById('crop-overlay');
            if (!overlay || overlay.style.display === 'none') {
                showStatus('×‘×—×¨ ××–×•×¨ ×§×œ×˜×” ×ª×—×™×œ×”', 'error');
                return;
            }
            
            // Get crop dimensions
            const left = parseInt(overlay.style.left);
            const top = parseInt(overlay.style.top);
            const width = parseInt(overlay.style.width);
            const height = parseInt(overlay.style.height);
            
            // Update crop controls in the main panel
            document.getElementById('enable-crop').checked = true;
            document.getElementById('crop-x').value = left;
            document.getElementById('crop-y').value = top;
            document.getElementById('crop-width').value = width;
            document.getElementById('crop-height').value = height;
            
            // Show crop controls
            toggleCropControls();
            
            // Close modal
            cancelCropSelection();
            
            showStatus(`××–×•×¨ ×§×œ×˜×” × ×‘×—×¨: ${width}Ã—${height} ×‘-(${left}, ${top})`, 'success');
        }
        
        function cancelCropSelection() {
            const modal = document.getElementById('visual-crop-selector');
            if (modal) {
                modal.remove();
            }
            document.removeEventListener('keydown', handleCropKeydown);
        }
        
        // ==================== ENHANCED UPLOAD HANDLING ====================
        
        function handleUploadAreaClick() {
            const selectedConv = document.getElementById('upload-conversation-select').value;
            if (!selectedConv) {
                showStatus('×‘×—×¨ ×©×™×—×” ×ª×—×™×œ×”', 'error');
                return;
            }
            document.getElementById('custom-video-input').click();
        }
        
        // Additional video management helper functions
        async function previewVideo(conversationId) {
            const videoUrl = `${apiBaseUrl}/videos/${conversationId}.mp4`;
            
            // Create preview modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10000; display: flex;
                align-items: center; justify-content: center; flex-direction: column;
            `;
            
            const preview = document.createElement('div');
            preview.style.cssText = `
                background: white; padding: 2rem; border-radius: 12px;
                max-width: 90%; max-height: 90%; overflow: auto;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            `;
            
            preview.innerHTML = `
                <h3 style="margin: 0 0 1rem 0; text-align: center;">×ª×¦×•×’×” ××§×“×™××” - ${conversationId}</h3>
                <video controls style="width: 100%; max-width: 600px; height: auto;">
                    <source src="${videoUrl}" type="video/mp4">
                    ×”×“×¤×“×¤×Ÿ ×©×œ×š ×œ× ×ª×•××š ×‘×•×•×™×“××• HTML5.
                </video>
                <div style="text-align: center; margin-top: 1rem;">
                    <button onclick="this.closest('.preview-modal').remove()" class="btn btn-primary">×¡×’×•×¨</button>
                </div>
            `;
            
            modal.className = 'preview-modal';
            modal.appendChild(preview);
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        async function deleteVideo(conversationId) {
            if (!confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª ×”×•×•×™×“××• ×©×œ ${conversationId}?`)) {
                return;
            }
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/delete-video/${conversationId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    showStatus(`×•×™×“××• ×©×œ ${conversationId} × ××—×§ ×‘×”×¦×œ×—×”`, 'success');
                    await loadEnhancedVideoList();
                } else {
                    throw new Error(`Delete failed: ${response.status}`);
                }
                
            } catch (error) {
                console.error('Error deleting video:', error);
                showStatus(`×©×’×™××” ×‘××—×™×§×ª ×•×™×“××• ×©×œ ${conversationId}`, 'error');
            }
        }
        
        function uploadForConversation(conversationId) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'video/*';
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (file) {
                    await uploadCustomVideoForConversation(file, conversationId);
                }
            };
            input.click();
        }
        
        async function uploadCustomVideoForConversation(file, conversationId) {
            try {
                const formData = new FormData();
                formData.append('video', file);
                formData.append('conversation', conversationId);
                formData.append('source', 'custom');
                
                showStatus(`××¢×œ×” ×•×™×“××• ×¢×‘×•×¨ ${conversationId}...`, 'info');
                
                const response = await fetch(`${apiBaseUrl}/api/upload-custom-video`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                showStatus(`×•×™×“××• ×”×•×¢×œ×” ×‘×”×¦×œ×—×” ×¢×‘×•×¨ ${conversationId}`, 'success');
                await loadEnhancedVideoList();
                
            } catch (error) {
                console.error('Error uploading video:', error);
                showStatus(`×©×’×™××” ×‘×”×¢×œ××ª ×•×™×“××• ×¢×‘×•×¨ ${conversationId}`, 'error');
            }
        }
        
        function filterVideoList() {
            const filter = document.getElementById('video-filter').value;
            const cards = document.querySelectorAll('.video-management-card');
            
            cards.forEach(card => {
                const statusSpan = card.querySelector('span');
                const statusText = statusSpan.textContent;
                
                let show = true;
                switch(filter) {
                    case 'system':
                        show = statusText === '××¢×¨×›×ª';
                        break;
                    case 'custom':
                        show = statusText === '××•×ª×× ××™×©×™×ª';
                        break;
                    case 'missing':
                        show = statusText === '×—×¡×¨';
                        break;
                    case 'all':
                    default:
                        show = true;
                }
                
                card.style.display = show ? 'block' : 'none';
            });
        }
        
        function selectAllVideos() {
            document.querySelectorAll('.video-select:not([style*="display: none"])').forEach(cb => {
                cb.checked = true;
            });
        }
        
        function deselectAllVideos() {
            document.querySelectorAll('.video-select').forEach(cb => {
                cb.checked = false;
            });
        }
        
        async function regenerateSelectedVideos() {
            const selected = getSelectedConversations();
            if (selected.length === 0) {
                showStatus('×œ× × ×‘×—×¨×• ×©×™×—×•×ª', 'warning');
                return;
            }
            
            showStatus(`×™×•×¦×¨ ××—×“×© ${selected.length} ×•×™×“××•...`, 'info');
            
            for (const conversationId of selected) {
                await generateSingleVideo(conversationId);
            }
        }
        
        function getSelectedConversations() {
            return Array.from(document.querySelectorAll('.video-select:checked'))
                .map(cb => cb.dataset.conversation);
        }
        
        async function downloadSelectedVideos() {
            const selected = getSelectedConversations();
            if (selected.length === 0) {
                showStatus('×œ× × ×‘×—×¨×• ×©×™×—×•×ª', 'warning');
                return;
            }
            
            // Create zip file with selected videos
            showStatus(`××›×™×Ÿ ×§×•×‘×¥ ZIP ×¢× ${selected.length} ×•×™×“××•...`, 'info');
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/download-videos`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ conversations: selected })
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `videos_${new Date().toISOString().split('T')[0]}.zip`;
                a.click();
                window.URL.revokeObjectURL(url);
                
                showStatus('×”×•×¨×“×” ×”×•×©×œ××” ×‘×”×¦×œ×—×”', 'success');
                
            } catch (error) {
                console.error('Error downloading videos:', error);
                showStatus('×©×’×™××” ×‘×”×•×¨×“×ª ×•×™×“××•', 'error');
            }
        }
        
        async function deleteSelectedVideos() {
            const selected = getSelectedConversations();
            if (selected.length === 0) {
                showStatus('×œ× × ×‘×—×¨×• ×©×™×—×•×ª', 'warning');
                return;
            }
            
            if (!confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ${selected.length} ×•×™×“××•?`)) {
                return;
            }
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/delete-videos`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ conversations: selected })
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                showStatus(`${selected.length} ×•×™×“××• × ××—×§×• ×‘×”×¦×œ×—×”`, 'success');
                await loadEnhancedVideoList();
                
            } catch (error) {
                console.error('Error deleting videos:', error);
                showStatus('×©×’×™××” ×‘××—×™×§×ª ×•×™×“××•', 'error');
            }
        }
        
        // Add drag and drop functionality
        document.addEventListener('DOMContentLoaded', function() {
            const uploadArea = document.getElementById('custom-upload-area');
            if (uploadArea) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, preventDefaults, false);
                });
                
                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, highlight, false);
                });
                
                ['dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, unhighlight, false);
                });
                
                uploadArea.addEventListener('drop', handleDrop, false);
            }
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            function highlight(e) {
                uploadArea.style.background = 'rgba(255, 193, 7, 0.2)';
                uploadArea.style.borderColor = '#f39c12';
            }
            
            function unhighlight(e) {
                uploadArea.style.background = 'rgba(255, 193, 7, 0.1)';
                uploadArea.style.borderColor = '#f39c12';
            }
            
            function handleDrop(e) {
                const files = e.dataTransfer.files;
                handleCustomVideoUpload(files);
            }
                 });

        // Individual video management functions
        async function downloadVideo(conversationId) {
            try {
                const response = await fetch(`${apiBaseUrl}/api/download-video/${conversationId}`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${conversationId}.mp4`;
                a.click();
                window.URL.revokeObjectURL(url);
                
                showStatus(`×•×™×“××• ${conversationId} ×”×•×¨×“ ×‘×”×¦×œ×—×”`, 'success');
                
            } catch (error) {
                console.error('Error downloading video:', error);
                showStatus(`×©×’×™××” ×‘×”×•×¨×“×ª ×•×™×“××• ${conversationId}`, 'error');
            }
        }
        
        function replaceVideo(conversationId) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'video/*';
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (file) {
                    if (confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×”×—×œ×™×£ ××ª ×”×•×™×“××• ×¢×‘×•×¨ ${conversationId}?`)) {
                        await uploadCustomVideoForConversation(file, conversationId);
                    }
                }
            };
            input.click();
        }
        
        async function deleteVideo(conversationId) {
            if (!confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª ×”×•×™×“××• ×¢×‘×•×¨ ${conversationId}?`)) {
                return;
            }
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/delete-video/${conversationId}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                showStatus(`×•×™×“××• ${conversationId} × ××—×§ ×‘×”×¦×œ×—×”`, 'success');
                await loadEnhancedVideoList();
                
            } catch (error) {
                console.error('Error deleting video:', error);
                showStatus(`×©×’×™××” ×‘××—×™×§×ª ×•×™×“××• ${conversationId}`, 'error');
            }
        }
        
        function refreshVideoList() {
            loadEnhancedVideoList();
        }
        
        function exportVideoList() {
            const data = {
                conversations: videoManagementData.conversations,
                videos: videoManagementData.videos,
                exportDate: new Date().toISOString(),
                summary: {
                    totalConversations: videoManagementData.conversations.length,
                    totalVideos: videoManagementData.videos.length,
                    systemGenerated: videoManagementData.videos.filter(v => v.source !== 'custom').length,
                    customUploaded: videoManagementData.videos.filter(v => v.source === 'custom').length
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `video_list_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            window.URL.revokeObjectURL(url);
            
            showStatus('×¨×©×™××ª ×•×™×“××• ×™×•×¦××” ×‘×”×¦×œ×—×”', 'success');
        }

        function displayVideoStatus(status) {
            const container = document.getElementById('video-status-details');
            
            let html = '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; font-size: 0.9rem;">';
            
            // Status indicators
            html += '<div>';
            html += `<div style="margin-bottom: 0.5rem;">
                <span style="color: ${status.selenium_available ? '#4caf50' : '#f44336'};">
                    ${status.selenium_available ? 'âœ…' : 'âŒ'} Selenium WebDriver
                </span>
            </div>`;
            
            html += `<div style="margin-bottom: 0.5rem;">
                <span style="color: ${status.ffmpeg_available ? '#4caf50' : '#f44336'};">
                    ${status.ffmpeg_available ? 'âœ…' : 'âŒ'} FFmpeg
                </span>
            </div>`;
            
            html += `<div style="margin-bottom: 0.5rem;">
                <span style="color: ${status.chrome_available ? '#4caf50' : '#f44336'};">
                    ${status.chrome_available ? 'âœ…' : 'âŒ'} Chrome Browser
                </span>
            </div>`;
            html += '</div>';
            
            // Method and quality info
            html += '<div>';
            html += `<div style="margin-bottom: 0.5rem;">
                <strong>×©×™×˜×”:</strong> ${getMethodDisplayName(status.video_generation_method)}
            </div>`;
            
            html += `<div style="margin-bottom: 0.5rem;">
                <strong>××™×›×•×ª:</strong> ${getQualityDisplayName(status.quality)}
            </div>`;
            html += '</div>';
            
            html += '</div>';
            
            // Installation instructions if needed
            if (status.install_instructions) {
                html += '<div style="margin-top: 1rem; padding: 1rem; background: #fff3cd; border-radius: 6px; border: 1px solid #ffc107;">';
                html += '<h4 style="margin: 0 0 0.5rem 0; color: #856404;">ğŸ”§ ×œ×”×ª×§× ×ª ×™×›×•×œ×•×ª ×•×™×“××• ××œ××•×ª:</h4>';
                html += '<div style="font-family: monospace; font-size: 0.8rem; line-height: 1.4;">';
                
                if (status.install_instructions.selenium) {
                    html += `<div style="margin-bottom: 0.5rem;">1. ${status.install_instructions.selenium}</div>`;
                }
                if (status.install_instructions.chromedriver) {
                    html += `<div style="margin-bottom: 0.5rem;">2. ${status.install_instructions.chromedriver}</div>`;
                }
                if (status.install_instructions.ffmpeg) {
                    html += `<div style="margin-bottom: 0.5rem;">3. ${status.install_instructions.ffmpeg}</div>`;
                }
                
                html += '</div>';
                html += '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #856404;">';
                html += '×œ××—×¨ ×”×ª×§× ×”, ×”×¨×¥ ××—×“×© ××ª ×”×©×¨×ª ×•×—×–×•×¨ ×œ×‘×“×•×§ ××ª ×”×¡×˜×˜×•×¡.';
                html += '</div>';
                html += '</div>';
            }
            
            container.innerHTML = html;
        }

        function getMethodDisplayName(method) {
            const methods = {
                'selenium_webdriver': 'Selenium WebDriver (××•××œ×¥)',
                'ffmpeg_test_pattern': 'FFmpeg Test Pattern',
                'simple_fallback': 'Python Fallback',
                'none': '×œ× ×–××™×Ÿ'
            };
            return methods[method] || method;
        }

        function getQualityDisplayName(quality) {
            const qualities = {
                'high_quality_real_capture': '××™×›×•×ª ×’×‘×•×”×” - ×¦×™×œ×•× ×××™×ª×™',
                'test_pattern_only': '×ª×‘× ×™×ª ×‘×“×™×§×” ×‘×œ×‘×“',
                'basic_mp4_file': '×§×•×‘×¥ MP4 ×‘×¡×™×¡×™',
                'none': '×œ× ×–××™×Ÿ'
            };
            return qualities[quality] || quality;
        }

        // ==================== END VIDEO GENERATION FUNCTIONS ====================

        // ==================== EMOTIONS AVAILABILITY UPDATE FUNCTIONS ====================
        
        function updateEmotionsAvailability(availableEmotions, emotionMapping) {
            console.log('ğŸ­ Updating emotions availability with:', availableEmotions);
            
            // Update all emotion dropdowns to include the detected emotions
            setTimeout(() => {
                populateAllEmotionDropdowns();
                
                // Force refresh of all emotion displays
                refreshAllEmotionDisplays();
                
                console.log('âœ… Emotions dropdown updated with detected emotions');
            }, 100);
        }
        
        function autoAddDetectedEmotion(mp3File, detectedEmotion) {
            console.log(`ğŸ¯ Auto-adding detected emotion '${detectedEmotion}' to ${mp3File}`);
            
            if (!emotionData[mp3File]) {
                console.error(`âŒ No emotion data found for ${mp3File}`);
                return;
            }
            
            // ğŸ¯ SMART EMOTION HANDLING: Map both Hebrew and English emotions to proper config keys
            let finalEmotion = detectedEmotion;
            let emotionDisplay = detectedEmotion;
            let emotionKey = null;
            
            // Check if this is a Hebrew emotion (contains Hebrew characters)
            // ğŸ­ Hebrew-only config - emotions are now Hebrew keys
            console.log(`ğŸ­ Processing emotion: ${detectedEmotion}`);
            
            // Check if the emotion exists in the Hebrew-based config
            if (emotionsConfig && emotionsConfig[detectedEmotion]) {
                emotionKey = detectedEmotion;
                finalEmotion = detectedEmotion;  // Use Hebrew emotion directly
                const config = emotionsConfig[detectedEmotion];
                emotionDisplay = `${config.emoji} ${detectedEmotion}`;
                console.log(`âœ… Found emotion in Hebrew config: ${detectedEmotion}`);
            } else {
                console.warn(`âš ï¸ Emotion '${detectedEmotion}' not found in emotions config`);
                // Use as-is if not found in config
                finalEmotion = detectedEmotion;
                emotionDisplay = detectedEmotion;
            }
            
            // Get current emotions
            const currentEmotions = emotionData[mp3File].emotions || ['neutral'];
            
            // Check if emotion already exists
            if (currentEmotions.includes(finalEmotion)) {
                console.log(`âš ï¸ Emotion '${detectedEmotion}' already exists in ${mp3File}`);
                return;
            }
            
            // Replace current emotions with the detected one (since AI analysis should set the primary emotion)
            const newEmotions = [finalEmotion];
            
            // Update the emotion data
            updateParam(mp3File, 'emotions', newEmotions);
            
            // Refresh the emotion display
            refreshEmotionDisplay(mp3File);
            
            // Update UI displays
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            console.log(`âœ… Auto-added emotion '${emotionDisplay}' to ${mp3File}`);
            showStatus(`ğŸ¤– AI ×–×™×”×” ×•×”×’×“×™×¨ ×¨×’×©: ${emotionDisplay}`, 'success');
        }

        // ==================== EMOTIONS MANAGEMENT FUNCTIONS ====================
        
        let emotionsConfig = {};
        let defaultEmotionsConfig = {};
        
        // Default emotions configuration with colors and emojis
        const DEFAULT_EMOTIONS = {
            'happiness': { color: '#FFD700', emoji: 'ğŸ˜Š', hebrew: '×©××—×”', active: true },
            'sadness': { color: '#4169E1', emoji: 'ğŸ˜¢', hebrew: '×¢×¦×‘', active: true },
            'anger': { color: '#FF4500', emoji: 'ğŸ˜ ', hebrew: '×›×¢×¡', active: true },
            'fear': { color: '#8B008B', emoji: 'ğŸ˜¨', hebrew: '×¤×—×“', active: true },
            'surprise': { color: '#FF69B4', emoji: 'ğŸ˜²', hebrew: '×”×¤×ª×¢×”', active: true },
            'disgust': { color: '#228B22', emoji: 'ğŸ¤¢', hebrew: '×’×•×¢×œ', active: true },
            'neutral': { color: '#808080', emoji: 'ğŸ˜', hebrew: '× ×™×˜×¨×œ×™', active: true },
            'curiosity': { color: '#00CED1', emoji: 'ğŸ¤”', hebrew: '×¡×§×¨× ×•×ª', active: true },
            'confusion': { color: '#DDA0DD', emoji: 'ğŸ˜µ', hebrew: '×‘×œ×‘×•×œ', active: true },
            'excitement': { color: '#FF1493', emoji: 'ğŸ¤©', hebrew: '×”×ª×¨×’×©×•×ª', active: true },
            'annoyance': { color: '#CD853F', emoji: 'ğŸ˜¤', hebrew: '×¢×¦×‘× ×•×ª', active: true },
            'frustration': { color: '#B22222', emoji: 'ğŸ˜«', hebrew: '×ª×¡×›×•×œ', active: true },
            'caring': { color: '#20B2AA', emoji: 'ğŸ¤—', hebrew: '×“××’×”', active: true },
            'love': { color: '#DC143C', emoji: 'â¤ï¸', hebrew: '××”×‘×”', active: true },
            'anxiety': { color: '#9370DB', emoji: 'ğŸ˜°', hebrew: '×—×¨×“×”', active: true },
            'hope': { color: '#32CD32', emoji: 'ğŸŒŸ', hebrew: '×ª×§×•×•×”', active: true },
            'pride': { color: '#FF8C00', emoji: 'ğŸ˜¤', hebrew: '×’××•×•×”', active: true },
            'joy': { color: '#FFFF00', emoji: 'ğŸ˜„', hebrew: '×©××—×” ×’×“×•×œ×”', active: true },
            'embarrassment': { color: '#FF69B4', emoji: 'ğŸ˜³', hebrew: '××‘×•×›×”', active: true },
            'gratitude': { color: '#90EE90', emoji: 'ğŸ™', hebrew: '×”×›×¨×ª ×ª×•×“×”', active: true }
        };
        
        // Recommended color palette
        const RECOMMENDED_COLORS = [
            '#FF4500', '#FFD700', '#32CD32', '#00CED1', '#4169E1', '#8B008B',
            '#FF69B4', '#FF1493', '#228B22', '#DC143C', '#9370DB', '#FF8C00',
            '#20B2AA', '#DDA0DD', '#CD853F', '#B22222', '#90EE90', '#FFFF00',
            '#808080', '#696969', '#2F4F4F', '#483D8B', '#6B8E23', '#8B4513',
            '#556B2F', '#8FBC8F', '#B8860B', '#DAA520', '#CD5C5C', '#F0E68C'
        ];
        
        // Load emotions configuration
        async function loadEmotionsConfig() {
            try {
                showLoading('×˜×•×¢×Ÿ ×”×’×“×¨×•×ª ×¨×’×©×•×ª...');
                
                // Try to load from server
                const response = await fetch(`${apiBaseUrl}/config/emotions_config.json?t=${Date.now()}`);
                if (response.ok) {
                    emotionsConfig = await response.json();
                    console.log('ğŸ“¥ Loaded emotions config from server:', emotionsConfig);
                    console.log('ğŸ“¥ Loaded config has', Object.keys(emotionsConfig).length, 'emotions');
                    
                    // Log a few sample colors for verification
                    Object.entries(emotionsConfig).slice(0, 3).forEach(([emotion, config]) => {
                        console.log(`ğŸ“¥ Loaded: ${emotion} = ${config.color} (active: ${config.active})`);
                    });
                } else {
                    console.warn('âš ï¸ Could not load emotions config from server, using defaults. Response:', response.status);
                    // Use default configuration
                    emotionsConfig = JSON.parse(JSON.stringify(DEFAULT_EMOTIONS));
                    console.log('ğŸ“¥ Using default emotions config');
                }
                
                // Store default configuration
                defaultEmotionsConfig = JSON.parse(JSON.stringify(DEFAULT_EMOTIONS));
                
                // Count active emotions
                const activeEmotions = Object.keys(emotionsConfig).filter(key => emotionsConfig[key].active);
                
                // Display emotions
                displayEmotionsList();
                displayColorPalette();
                updateEmotionsStats();
                
                console.log('ğŸ¨ Emotions list updated with current configuration');
                
                // Refresh all emotion dropdowns with new config
                setTimeout(() => {
                    populateAllEmotionDropdowns();
                }, 100);
                
                // Send emotion colors to visualization immediately after loading
                setTimeout(() => {
                    updateVisualizationColors();
                    console.log('ğŸ¨ Initial emotion colors sent to visualizations');
                }, 1000); // Small delay to ensure visualizations are ready
                
                // Also send colors multiple times to catch any visualizations that load later
                setTimeout(() => {
                    updateVisualizationColors();
                    console.log('ğŸ¨ Second wave of emotion colors sent');
                }, 3000);
                
                setTimeout(() => {
                    updateVisualizationColors();
                    console.log('ğŸ¨ Final wave of emotion colors sent');
                }, 5000);
                
                showStatus(`ğŸ­ ${activeEmotions.length} ×¨×’×©×•×ª × ×˜×¢× ×•! AI ×™×•×›×œ ×œ× ×ª×— ×¢× ×›×œ ×”×¨×’×©×•×ª ×”×–××™× ×™×`, 'success');
                
                // Immediately send colors to any open visualizations
                setTimeout(() => {
                    updateVisualizationColors();
                    console.log('ğŸ¨ Sent initial emotion colors to visualizations after config load');
                }, 100);
                
            } catch (error) {
                console.error('Error loading emotions config:', error);
                showStatus(`×©×’×™××” ×‘×˜×¢×™× ×ª ×”×’×“×¨×•×ª ×¨×’×©×•×ª: ${error.message}`, 'error');
                
                // Fallback to default
                emotionsConfig = JSON.parse(JSON.stringify(DEFAULT_EMOTIONS));
                defaultEmotionsConfig = JSON.parse(JSON.stringify(DEFAULT_EMOTIONS));
                
                displayEmotionsList();
                displayColorPalette();
                updateEmotionsStats();
                
                // Refresh all emotion dropdowns with fallback config
                setTimeout(() => {
                    populateAllEmotionDropdowns();
                }, 100);
                
                // Still send colors even with default config
                setTimeout(() => {
                    updateVisualizationColors();
                }, 1000);
            } finally {
                hideLoading();
            }
        }
        
        // Display emotions list
        function displayEmotionsList() {
            const container = document.getElementById('emotions-list');
            if (!container) return;
            
            container.innerHTML = '';
            
            const emotions = Object.entries(emotionsConfig);
            emotions.sort((a, b) => {
                try {
                    // Hebrew keys are the emotion names themselves
                    return a[0].localeCompare(b[0], 'he');
                } catch(e) {
                    return a[0] > b[0] ? 1 : -1;
                }
            });
            
            emotions.forEach(([emotion, config]) => {
                const emotionItem = document.createElement('div');
                emotionItem.className = 'emotion-item';
                emotionItem.style.cssText = `
                    background: white;
                    border: 2px solid ${config.active ? '#e0e0e0' : '#ffcccb'};
                    border-radius: 8px;
                    padding: 1rem;
                    transition: all 0.3s ease;
                    ${config.active ? '' : 'opacity: 0.7;'}
                `;
                
                emotionItem.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <span style="font-size: 1.5rem;">${config.emoji}</span>
                            <div>
                                <div style="font-weight: bold; font-size: 1.1rem;">${emotion}</div>
                                <div style="color: #666; font-size: 0.9rem;">${config.english || emotion}</div>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
                                <input type="checkbox" ${config.active ? 'checked' : ''} 
                                       onchange="toggleEmotionActive('${emotion}', this.checked)">
                                <span style="font-size: 0.9rem;">×¤×¢×™×œ</span>
                            </label>
                            <button onclick="deleteEmotion('${emotion}')" class="btn btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">
                                <i class="material-icons" style="font-size: 14px;">delete</i>
                            </button>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                        <div>
                            <label style="display: block; margin-bottom: 0.3rem; font-size: 0.9rem;">×¦×‘×¢:</label>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <input type="color" value="${config.color}" 
                                       onchange="updateEmotionColor('${emotion}', this.value)"
                                       style="width: 40px; height: 40px; border: none; border-radius: 4px; cursor: pointer;">
                                <input type="text" value="${config.color}" 
                                       onchange="updateEmotionColor('${emotion}', this.value)"
                                       style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 0.9rem;">
                            </div>
                        </div>
                        
                        <div>
                            <label style="display: block; margin-bottom: 0.3rem; font-size: 0.9rem;">×××•×’'×™:</label>
                            <input type="text" value="${config.emoji}" 
                                   onchange="updateEmotionEmoji('${emotion}', this.value)"
                                   style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1.2rem; text-align: center;">
                        </div>
                    </div>
                    
                    <div>
                        <label style="display: block; margin-bottom: 0.3rem; font-size: 0.9rem;">×©× ×‘×¢×‘×¨×™×ª:</label>
                        <input type="text" value="${emotion}" 
                               onchange="updateEmotionHebrew('${emotion}', this.value)"
                               style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;"
                               readonly title="×”×©× ×‘×¢×‘×¨×™×ª ×”×•× ×”××¤×ª×— - ×œ× × ×™×ª×Ÿ ×œ×©× ×•×ª ×™×©×™×¨×•×ª">
                    </div>
                `;
                
                container.appendChild(emotionItem);
            });
        }
        
        // Display color palette
        function displayColorPalette() {
            const container = document.getElementById('color-palette');
            if (!container) return;
            
            container.innerHTML = '';
            
            RECOMMENDED_COLORS.forEach(color => {
                const colorItem = document.createElement('div');
                colorItem.style.cssText = `
                    background: ${color};
                    height: 60px;
                    border-radius: 8px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: ${getContrastColor(color)};
                    font-weight: bold;
                    font-size: 0.8rem;
                    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
                `;
                
                colorItem.textContent = color;
                colorItem.onclick = () => copyToClipboard(color);
                colorItem.title = `×œ×—×¥ ×œ×”×¢×ª×§×ª ${color}`;
                
                colorItem.addEventListener('mouseenter', () => {
                    colorItem.style.transform = 'scale(1.1)';
                    colorItem.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
                });
                
                colorItem.addEventListener('mouseleave', () => {
                    colorItem.style.transform = 'scale(1)';
                    colorItem.style.boxShadow = 'none';
                });
                
                container.appendChild(colorItem);
            });
        }
        
        // Update emotions statistics
        function updateEmotionsStats() {
            const totalCount = Object.keys(emotionsConfig).length;
            const activeCount = Object.values(emotionsConfig).filter(e => e.active).length;
            const customCount = Object.values(emotionsConfig).filter(e => 
                !DEFAULT_EMOTIONS[Object.keys(emotionsConfig).find(key => emotionsConfig[key] === e)]
            ).length;
            
            document.getElementById('total-emotions-count').textContent = totalCount;
            document.getElementById('active-emotions-count').textContent = activeCount;
            document.getElementById('custom-colors-count').textContent = customCount;
        }
        
        // Test emotion colors function
        function testEmotionColors() {
            console.log('ğŸ§ª Testing emotion colors system...');
            
            // Check if emotions config is loaded
            if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                alert('âŒ ××™×Ÿ ×”×’×“×¨×•×ª ×¨×’×©×•×ª ×–××™× ×•×ª!\n× × ×œ×˜×¢×•×Ÿ ×ª×—×™×œ×” ××ª ×”×’×“×¨×•×ª ×”×¨×’×©×•×ª.');
                return;
            }
            
            console.log('ğŸ­ Available emotions:', Object.keys(emotionsConfig));
            
            // Test color preparation
            const testColors = {};
            Object.entries(emotionsConfig).forEach(([emotion, config]) => {
                if (config.active && config.color) {
                    testColors[emotion] = hexToRgb(config.color);
                    console.log(`ğŸ¨ Test: "${emotion}" â†’ ${config.color} â†’ [${testColors[emotion].join(', ')}]`);
                }
            });
            
            console.log('ğŸ¨ Test colors prepared:', testColors);
            
            // Force update visualization multiple times for thorough testing
            console.log('ğŸ”„ Sending test color updates...');
            updateVisualizationColors();
            
            setTimeout(() => {
                updateVisualizationColors();
                console.log('ğŸ”„ Sent second test update');
            }, 200);
            
            setTimeout(() => {
                updateVisualizationColors();
                console.log('ğŸ”„ Sent third test update');
            }, 500);
            
            const activeCount = Object.keys(testColors).length;
            const totalCount = Object.keys(emotionsConfig).length;
            
            alert(`âœ… ×‘×“×™×§×ª ×¦×‘×¢×™ ×¨×’×©×•×ª ×”×•×©×œ××”!
            
ğŸ“Š ×¡×˜×˜×™×¡×˜×™×§×•×ª:
â€¢ ×¡×”"×› ×¨×’×©×•×ª: ${totalCount}
â€¢ ×¨×’×©×•×ª ×¤×¢×™×œ×™×: ${activeCount}
â€¢ ×¦×‘×¢×™× × ×©×œ×—×• ×œ×•×™×–×•××œ×™×–×¦×™×” 3 ×¤×¢××™×
            
ğŸ” ×‘×“×•×§ ××ª ×”×§×•× ×¡×•×œ ×œ×¤×¨×˜×™× × ×•×¡×¤×™×.
ğŸ’¡ × ×¡×” ×œ×©× ×•×ª ×¦×‘×¢ ×©×œ ×¨×’×© ×›×œ×©×”×• - ×”×©×™× ×•×™ ×××•×¨ ×œ×”×•×¤×™×¢ ××™×“!`);
        }
        
        // Toggle emotion active state
        function toggleEmotionActive(emotion, isActive) {
            if (emotionsConfig[emotion]) {
                emotionsConfig[emotion].active = isActive;
                displayEmotionsList();
                updateEmotionsStats();
                
                // Auto-save configuration after state change
                scheduleEmotionConfigAutoSave();
                
                showStatus(`×¨×’×© "${emotionsConfig[emotion].hebrew}" ${isActive ? '×”×•×¤×¢×œ' : '×”×•×©×‘×ª'}`, 'success');
            }
        }
        
        // Update emotion color
        function updateEmotionColor(emotion, color) {
            if (emotionsConfig[emotion]) {
                const oldColor = emotionsConfig[emotion].color;
                emotionsConfig[emotion].color = color;
                
                console.log(`ğŸ¨ Emotion color updated: "${emotion}" from ${oldColor} to ${color}`);
                console.log(`ğŸ¨ New emotions config for ${emotion}:`, emotionsConfig[emotion]);
                
                // Immediately update the emotion item color in the list
                const colorInputs = document.querySelectorAll(`input[onchange*="updateEmotionColor('${emotion}'"]`);
                colorInputs.forEach(input => {
                    if (input.type === 'color') {
                        input.value = color;
                    } else if (input.type === 'text') {
                        input.value = color;
                    }
                });
                
                // Refresh the emotions list display
                displayEmotionsList();
                
                // Update visualization colors in real-time with immediate effect
                console.log('ğŸ”„ Sending immediate color update to visualizations...');
                updateVisualizationColors();
                
                // Force reload colors in visualization from emotions_config.json
                setTimeout(() => {
                    reloadVisualizationColors();
                }, 500);
                
                // Also force update in any open conversation visualization windows
                setTimeout(() => {
                    console.log('ğŸ”„ Broadcasting to all open visualization windows...');
                    // Send to parent window (main index page)
                    if (window.opener) {
                        window.opener.postMessage({
                            type: 'emotionColorsUpdated',
                            timestamp: Date.now()
                        }, '*');
                        console.log('ğŸ“¤ Sent emotionColorsUpdated to opener (main index)');
                    }
                    // Also send through broadcast channel for any other open tabs
                    try {
                        const bc = new BroadcastChannel('emotion-updates');
                        bc.postMessage({
                            type: 'emotionColorsUpdated',
                            timestamp: Date.now()
                        });
                        bc.close();
                        console.log('ğŸ“» Broadcast emotionColorsUpdated to all tabs');
                    } catch (e) {
                        console.log('ğŸ“» BroadcastChannel not available, skipping...');
                    }
                }, 1000);
                
                // Also immediately update the emotions list display to show new color
                displayEmotionsList();
                
                // Send additional updates to ensure all visualizations get the change
                setTimeout(() => {
                    console.log('ğŸ”„ Sending delayed color update for reliability...');
                    updateVisualizationColors();
                }, 100);
                
                setTimeout(() => {
                    console.log('ğŸ”„ Sending final color update for maximum reliability...');
                    updateVisualizationColors();
                }, 500);
                
                setTimeout(() => {
                    console.log('ğŸ”„ Sending extra delayed color update...');
                    updateVisualizationColors();
                }, 1000);
                
                // Update current conversation data if available
                updateCurrentConversationEmotionColors();
                
                // Auto-save configuration after color change (debounced)
                scheduleEmotionConfigAutoSave();
                
                // Show immediate feedback with saving indicator
                showStatus(`×¦×‘×¢ ×©×œ "${emotionsConfig[emotion].hebrew}" ×¢×•×“×›×Ÿ ×œ-${color} (×©×•××¨...)`, 'info');
            }
        }
        
        // Update current conversation emotion colors after config change
        async function updateCurrentConversationEmotionColors() {
            if (!currentConversation || !emotionData) {
                console.log('â­ï¸ No current conversation loaded, skipping emotion color update');
                return;
            }
            
            try {
                console.log('ğŸ¨ Updating emotion colors in current conversation data...');
                
                let hasChanges = false;
                const mp3Files = Object.keys(emotionData).filter(key => key.endsWith('.mp3'));
                
                // Update emotion colors in local emotion data
                mp3Files.forEach(mp3File => {
                    const segment = emotionData[mp3File];
                    if (segment && segment.emotions && Array.isArray(segment.emotions)) {
                        segment.emotions.forEach(emotion => {
                            if (emotionsConfig[emotion] && emotionsConfig[emotion].color) {
                                // Store the color in the segment data for future reference
                                if (!segment.emotionColors) {
                                    segment.emotionColors = {};
                                }
                                
                                // Only update if color actually changed
                                const newColor = emotionsConfig[emotion].color;
                                if (segment.emotionColors[emotion] !== newColor) {
                                    segment.emotionColors[emotion] = newColor;
                                    hasChanges = true;
                                    
                                    // Mark this segment as changed for auto-save
                                    if (!pendingChanges[mp3File]) {
                                        pendingChanges[mp3File] = {};
                                    }
                                    pendingChanges[mp3File].emotionColors = segment.emotionColors;
                                }
                            }
                        });
                    }
                });
                
                if (hasChanges) {
                    hasUnsavedChanges = true;
                    updateSaveButtonState();
                    
                    // Auto-save the changes after a short delay
                    scheduleAutoSave();
                    
                    console.log('âœ… Updated emotion colors in conversation data, auto-save scheduled');
                    
                    // Refresh displays to show updated colors
                    refreshAllEmotionDisplays();
                } else {
                    console.log('â„¹ï¸ No emotion color changes needed in current conversation');
                }
                
            } catch (error) {
                console.error('âŒ Error updating conversation emotion colors:', error);
            }
        }
        
        // Update all conversations with new emotion colors (bulk update)
        async function updateAllConversationsEmotionColors() {
            try {
                console.log('ğŸ”„ Triggering bulk emotion color update for all conversations...');
                
                const response = await fetch(`${apiBaseUrl}/api/update-all-emotion-colors`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        emotionsConfig: emotionsConfig
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log(`âœ… Updated emotion colors in ${result.updatedConversations || 0} conversations`);
                } else {
                    console.warn('âš ï¸ Bulk emotion color update failed, but continuing...');
                }
                
            } catch (error) {
                console.warn('âš ï¸ Error in bulk emotion color update:', error);
                // Don't show error to user since this is a background operation
            }
        }
        
        // Update emotion emoji
        function updateEmotionEmoji(emotion, emoji) {
            if (emotionsConfig[emotion]) {
                emotionsConfig[emotion].emoji = emoji;
                displayEmotionsList();
                
                // Update visualization and current conversation
                updateVisualizationColors();
                refreshAllEmotionDisplays();
                
                // Auto-save configuration after emoji change
                scheduleEmotionConfigAutoSave();
                
                showStatus(`×××•×’'×™ ×©×œ "${emotionsConfig[emotion].hebrew}" ×¢×•×“×›×Ÿ`, 'success');
            }
        }
        
        // Update emotion Hebrew name
        function updateEmotionHebrew(emotion, hebrew) {
            if (emotionsConfig[emotion]) {
                emotionsConfig[emotion].hebrew = hebrew;
                displayEmotionsList();
                
                // Update visualization and current conversation
                updateVisualizationColors();
                refreshAllEmotionDisplays();
                
                // Auto-save configuration after name change
                scheduleEmotionConfigAutoSave();
                
                showStatus(`×©× ×¢×‘×¨×™ ×©×œ "${emotion}" ×¢×•×“×›×Ÿ`, 'success');
            }
        }
        
        // Add new emotion
        function addNewEmotion() {
            const emotion = prompt('×”×–×Ÿ ×©× ×¨×’×© ×—×“×© ×‘×× ×’×œ×™×ª (×œ×œ× ×¨×•×•×—×™×):');
            if (!emotion) return;
            
            const cleanEmotion = emotion.toLowerCase().replace(/\s+/g, '_');
            
            if (emotionsConfig[cleanEmotion]) {
                showStatus(`×”×¨×’×© "${cleanEmotion}" ×›×‘×¨ ×§×™×™×`, 'error');
                return;
            }
            
            const hebrew = prompt('×”×–×Ÿ ×©× ×”×¨×’×© ×‘×¢×‘×¨×™×ª:');
            if (!hebrew) return;
            
            const emoji = prompt('×”×–×Ÿ ×××•×’\'×™ ×œ×¨×’×© (××•×¤×¦×™×•× ×œ×™):') || 'ğŸ˜';
            
            // Generate random color
            const randomColor = RECOMMENDED_COLORS[Math.floor(Math.random() * RECOMMENDED_COLORS.length)];
            
            emotionsConfig[cleanEmotion] = {
                color: randomColor,
                emoji: emoji,
                hebrew: hebrew,
                active: true
            };
            
            displayEmotionsList();
            updateEmotionsStats();
            
            // Refresh all emotion dropdowns with new emotion
            setTimeout(() => {
                populateAllEmotionDropdowns();
            }, 100);
            
            // Auto-save configuration after adding new emotion
            scheduleEmotionConfigAutoSave();
            
            showStatus(`×¨×’×© ×—×“×© "${hebrew}" × ×•×¡×£ ×‘×”×¦×œ×—×”`, 'success');
        }
        
        // Delete emotion
        function deleteEmotion(emotion) {
            if (!confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª ×”×¨×’×© "${emotionsConfig[emotion].hebrew}"?`)) {
                return;
            }
            
            delete emotionsConfig[emotion];
            displayEmotionsList();
            updateEmotionsStats();
            
            // Refresh all emotion dropdowns after deletion
            setTimeout(() => {
                populateAllEmotionDropdowns();
            }, 100);
            
            // Auto-save configuration after deleting emotion
            scheduleEmotionConfigAutoSave();
            
            showStatus(`×¨×’×© "${emotion}" × ××—×§ ×‘×”×¦×œ×—×”`, 'success');
        }
        
        // Reset emotions to default
        function resetEmotionsToDefault() {
            if (!confirm('×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×©×—×–×¨ ××ª ×›×œ ×”×¨×’×©×•×ª ×œ×‘×¨×™×¨×ª ×”××—×“×œ?\n\n×¤×¢×•×œ×” ×–×• ×ª××—×§ ××ª ×›×œ ×”×”×ª×××•×ª ×”××™×©×™×•×ª!')) {
                return;
            }
            
            emotionsConfig = JSON.parse(JSON.stringify(DEFAULT_EMOTIONS));
            displayEmotionsList();
            updateEmotionsStats();
            
            // Refresh all emotion dropdowns with default emotions
            setTimeout(() => {
                populateAllEmotionDropdowns();
            }, 100);
            
            showStatus('×”×¨×’×©×•×ª ×©×•×—×–×¨×• ×œ×‘×¨×™×¨×ª ×”××—×“×œ', 'success');
        }
        
        // Save emotions configuration
        async function saveEmotionsConfig(isAutoSave = false) {
            try {
                if (!isAutoSave) {
                    showLoading('×©×•××¨ ×”×’×“×¨×•×ª ×¨×’×©×•×ª...');
                }
                
                // Log what we're trying to save
                console.log('ğŸ’¾ Saving emotions configuration:', emotionsConfig);
                console.log('ğŸ’¾ Emotions config has', Object.keys(emotionsConfig).length, 'emotions');
                
                // Log a few sample colors for verification
                Object.entries(emotionsConfig).slice(0, 3).forEach(([emotion, config]) => {
                    console.log(`ğŸ’¾ Sample: ${emotion} = ${config.color} (active: ${config.active})`);
                });
                
                const response = await fetch(`${apiBaseUrl}/api/save-emotions-config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(emotionsConfig)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('âŒ Save failed with response:', response.status, errorText);
                    throw new Error(`×©×’×™××” ×‘×©××™×¨×”: ${response.status} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('âœ… Save successful, server response:', result);
                
                // Update all visualizations with new emotion colors
                updateVisualizationColors();
                
                // Refresh all emotion dropdowns with updated config
                setTimeout(() => {
                    populateAllEmotionDropdowns();
                }, 100);
                
                // Update current conversation if loaded
                await updateCurrentConversationEmotionColors();
                
                // Also trigger bulk update for all conversations with these emotions
                updateAllConversationsEmotionColors();
                
                if (!isAutoSave) {
                    showStatus('×”×’×“×¨×•×ª ×”×¨×’×©×•×ª × ×©××¨×• ×•×¢×•×“×›× ×• ×‘×›×œ ×”×©×™×—×•×ª ×•×”×•×•×™×–×•××œ×™×–×¦×™×”!', 'success');
                }
                
            } catch (error) {
                console.error('Error saving emotions config:', error);
                if (!isAutoSave) {
                    showStatus(`×©×’×™××” ×‘×©××™×¨×ª ×”×’×“×¨×•×ª: ${error.message}`, 'error');
                }
            } finally {
                if (!isAutoSave) {
                    hideLoading();
                }
            }
        }
        
        // Update visualization colors when emotions config changes
        function updateVisualizationColors() {
            try {
                console.log('ğŸ¨ Updating visualization with new emotion colors...');
                
                // Ensure emotions config is loaded
                if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                    console.warn('âš ï¸ No emotions config available - cannot update visualization colors');
                    return;
                }
                
                // Prepare emotion colors for visualization
                const emotionColorsForViz = {};
                let activeCount = 0;
                Object.entries(emotionsConfig).forEach(([emotion, config]) => {
                    if (config.active && config.color) {
                        // Convert hex to RGB array for visualization
                        const rgbColor = hexToRgb(config.color);
                        
                        // Store with Hebrew name (original key)
                        emotionColorsForViz[emotion] = rgbColor;
                        
                        // Also store with English equivalent if available for better compatibility
                        if (config.english) {
                            emotionColorsForViz[config.english] = rgbColor;
                            console.log(`ğŸ¨ Prepared color for "${emotion}" (${config.english}): ${config.color} â†’ [${rgbColor.join(', ')}]`);
                        } else {
                            console.log(`ğŸ¨ Prepared color for "${emotion}": ${config.color} â†’ [${rgbColor.join(', ')}]`);
                        }
                        
                        activeCount++;
                    }
                });
                
                console.log(`ğŸ¨ Sending ${activeCount} emotion colors to visualization:`, emotionColorsForViz);
                
                // Debug: Log each color being sent
                Object.entries(emotionColorsForViz).forEach(([emotion, rgbArray]) => {
                    const hexColor = emotionsConfig[emotion]?.color || 'unknown';
                    console.log(`ğŸ¨ ${emotion}: ${hexColor} â†’ RGB[${rgbArray.join(', ')}]`);
                });
                
                const updateMessage = {
                    type: 'updateEmotions',
                    emotions: emotionsConfig,
                        emotionColorMap: emotionColorsForViz,
                        timestamp: Date.now()
                    };
                    
                console.log('ğŸ“¤ Full update message being sent:', updateMessage);
                    
                // 1. Send update to visualization iframes (admin panel previews)
                const visualizationIframes = document.querySelectorAll('iframe');
                console.log(`ğŸ“º Found ${visualizationIframes.length} iframes to update`);
                visualizationIframes.forEach((iframe, index) => {
                    try {
                        iframe.contentWindow.postMessage(updateMessage, '*');
                        console.log(`ğŸ¨ Sent color update to iframe ${index + 1}/${visualizationIframes.length}`);
                    } catch (error) {
                        console.warn(`Could not update iframe ${index + 1}:`, error);
                    }
                });
                
                // 2. Send to parent window (if admin panel is embedded)
                if (window.parent && window.parent !== window) {
                    try {
                        window.parent.postMessage(updateMessage, '*');
                        console.log('ğŸ¨ Sent color update to parent window');
                    } catch (error) {
                        console.warn('Could not update parent visualization:', error);
                    }
                } else {
                    console.log('ğŸ“„ No parent window to update');
                }
                
                // 3. Send to opener window (if admin panel was opened from main page)
                if (window.opener && window.opener !== window) {
                    try {
                        window.opener.postMessage(updateMessage, '*');
                        console.log('ğŸ¨ Sent color update to opener window');
                        
                        // Also send a refresh message specifically for the main index page
                        setTimeout(() => {
                            window.opener.postMessage({
                                type: 'forceVisualRefresh',
                                timestamp: Date.now()
                            }, '*');
                            console.log('ğŸ”„ Sent forceVisualRefresh to opener (main index)');
                        }, 500);
                        
                    } catch (error) {
                        console.warn('Could not update opener visualization:', error);
                    }
                } else {
                    console.log('ğŸ”— No opener window to update');
                }
                
                // 4. Broadcast to other tabs/windows using same origin
                if (typeof BroadcastChannel !== 'undefined') {
                    const channel = new BroadcastChannel('emotion-colors-sync');
                    channel.postMessage(updateMessage);
                    channel.close();
                    console.log(`ğŸ“» Broadcast color update to all tabs (${activeCount} colors)`);
                } else {
                    console.log('ğŸ“» BroadcastChannel not available');
                }
                
                // 5. Send to all known visualization windows
                if (window.visualizationWindows) {
                    window.visualizationWindows.forEach(vizWindow => {
                        try {
                            if (vizWindow && !vizWindow.closed) {
                                vizWindow.postMessage(updateMessage, '*');
                                console.log('ğŸ¨ Sent color update to known visualization window');
                            }
                        } catch (error) {
                            console.warn('Could not update known visualization window:', error);
                        }
                    });
                }
                
                // 6. Try sending to main visualization window by name (skip if no valid window)
                try {
                    // Only try to access existing window, don't create new blank ones
                    if (window.visualizationMainWindow && !window.visualizationMainWindow.closed) {
                        window.visualizationMainWindow.postMessage(updateMessage, '*');
                        console.log('ğŸ¨ Sent color update to main visualization window');
                    }
                } catch (error) {
                    // Silently ignore - window might not exist
                }
                
                // 7. Update local displays in admin panel
                refreshAllEmotionDisplays();
                
                console.log('âœ… Emotion color updates sent to all visualizations and displays');
                
            } catch (error) {
                console.error('Error updating visualization colors:', error);
            }
        }
        
        // Refresh all emotion displays in the edit parameters tab
        function refreshAllEmotionDisplays() {
            try {
                console.log('ğŸ¨ Refreshing all emotion displays in edit parameters tab...');
                
                // Only refresh if we have loaded conversations and emotion data
                if (!emotionData || !currentConversation) {
                    console.log('â­ï¸ Skipping emotion display refresh - no conversation loaded');
                    return;
                }
                
                // Refresh all segment displays
                const mp3Files = Object.keys(emotionData).filter(key => key.endsWith('.mp3'));
                mp3Files.forEach(mp3File => {
                    if (emotionData[mp3File] && emotionData[mp3File].emotions) {
                        refreshEmotionDisplay(mp3File);
                    }
                });
                
                // Refresh the segments container
                if (typeof displaySegments === 'function') {
                    displaySegments();
                }
                
                // If there's a currently selected segment, refresh its editor
                if (currentSelectedSegment && emotionData[currentSelectedSegment]) {
                    loadSegmentEditor(currentSelectedSegment, emotionData[currentSelectedSegment]);
                }
                
                console.log('âœ… All emotion displays refreshed with new colors');
                
                        } catch (error) {
                console.error('Error refreshing emotion displays:', error);
            }
        }
        
        // Force color update function for debugging
        async function forceColorUpdate() {
            console.log('ğŸ”§ FORCING COLOR UPDATE FOR DEBUGGING...');
            console.log('ğŸ¨ Current emotions config:', emotionsConfig);
            
            // Check if emotions config is loaded
            if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                alert('âŒ ××™×Ÿ ×”×’×“×¨×•×ª ×¨×’×©×•×ª × ×˜×¢× ×•×ª! ×œ×—×¥ ×¢×œ "×¨×¢× ×Ÿ ×¦×‘×¢×™×" ×§×•×“×.');
                return;
            }
            
            // Count active emotions with colors
            const activeEmotions = Object.entries(emotionsConfig).filter(([emotion, config]) => config.active && config.color);
            console.log(`ğŸ¯ Found ${activeEmotions.length} active emotions with colors:`, activeEmotions);
            
            // Test: reload emotions config from server to compare
            try {
                const response = await fetch(`${apiBaseUrl}/config/emotions_config.json`);
                if (response.ok) {
                    const serverConfig = await response.json();
                    console.log('ğŸŒ Server emotions config:', serverConfig);
                    
                    // Compare with current config
                    let differences = 0;
                    Object.keys(emotionsConfig).forEach(emotion => {
                        if (serverConfig[emotion] && emotionsConfig[emotion].color !== serverConfig[emotion].color) {
                            console.log(`ğŸ” Color difference for ${emotion}: local=${emotionsConfig[emotion].color}, server=${serverConfig[emotion].color}`);
                            differences++;
                        }
                    });
                    
                    if (differences > 0) {
                        console.warn(`âš ï¸ Found ${differences} color differences between local and server config!`);
                    } else {
                        console.log('âœ… Local and server configurations match');
                    }
                }
            } catch (error) {
                console.error('âŒ Could not load server config for comparison:', error);
            }
            
            // Force update visualization colors
            updateVisualizationColors();
            
            // Also refresh the display
            displayEmotionsList();
            
            // Show detailed debug info
            const debugInfo = activeEmotions.map(([emotion, config]) => 
                `${config.hebrew} (${emotion}): ${config.color}`
            ).join('\n');
            
            alert(`ğŸ”§ ×¢×“×›×•×Ÿ ×¦×‘×¢×™× × ××œ×¥!\n\nğŸ“Š ×¨×’×©×•×ª ×¤×¢×™×œ×™×: ${activeEmotions.length}\n\n${debugInfo}\n\nâœ… ×‘×“×•×§ ××ª ×§×•× ×¡×•×œ ×”×“×¤×“×¤×Ÿ ×œ×¤×¨×˜×™× × ×•×¡×¤×™×`);
        }
        
        // Test color persistence function
        async function testColorPersistence() {
            console.log('ğŸ§ª TESTING COLOR PERSISTENCE...');
            
            if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                alert('âŒ ××™×Ÿ ×”×’×“×¨×•×ª ×¨×’×©×•×ª × ×˜×¢× ×•×ª!');
                return;
            }
            
            // Pick a random emotion to test
            const emotions = Object.keys(emotionsConfig);
            const testEmotion = emotions[0]; // Use first emotion for test
            const originalColor = emotionsConfig[testEmotion].color;
            const testColor = originalColor === '#FF0000' ? '#00FF00' : '#FF0000'; // Toggle between red and green
            
            try {
                console.log(`ğŸ¯ Testing with emotion: ${testEmotion}`);
                console.log(`ğŸ¨ Original color: ${originalColor}`);
                console.log(`ğŸ¨ Test color: ${testColor}`);
                
                // 1. Change color locally
                emotionsConfig[testEmotion].color = testColor;
                displayEmotionsList();
                updateVisualizationColors();
                
                // 2. Save to server
                console.log('ğŸ’¾ Saving to server...');
                await saveEmotionsConfig(true); // silent save
                
                // 3. Wait a moment
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // 4. Reload from server
                console.log('ğŸ“¥ Reloading from server...');
                const response = await fetch(`${apiBaseUrl}/config/emotions_config.json`);
                if (response.ok) {
                    const serverConfig = await response.json();
                    const serverColor = serverConfig[testEmotion]?.color;
                    
                    console.log(`ğŸŒ Server color: ${serverColor}`);
                    
                    if (serverColor === testColor) {
                        console.log('âœ… SUCCESS: Color was saved and loaded correctly!');
                        alert(`âœ… ×‘×“×™×§×ª ×©××™×¨×ª ×¦×‘×¢×™× ×”×¦×œ×™×—×”!\n\n×¨×’×©: ${emotionsConfig[testEmotion].hebrew}\n×¦×‘×¢ × ×©××¨: ${testColor}`);
                    } else {
                        console.error('âŒ FAILED: Color was not saved correctly!');
                        alert(`âŒ ×‘×“×™×§×ª ×©××™×¨×ª ×¦×‘×¢×™× × ×›×©×œ×”!\n\n×¦×¤×•×™: ${testColor}\n× ×˜×¢×Ÿ ××”×©×¨×ª: ${serverColor}`);
                    }
                } else {
                    throw new Error('Could not load from server');
                }
                
                // 5. Restore original color
                emotionsConfig[testEmotion].color = originalColor;
                displayEmotionsList();
                await saveEmotionsConfig(true);
                
            } catch (error) {
                console.error('âŒ Test failed:', error);
                alert(`âŒ ×©×’×™××” ×‘×‘×“×™×§×”: ${error.message}`);
                
                // Restore original color on error
                emotionsConfig[testEmotion].color = originalColor;
                displayEmotionsList();
            }
        }
        
        // Manual save function with verification
        async function manualSaveEmotions() {
            console.log('ğŸ“ MANUAL SAVE TRIGGERED');
            
            try {
                // Show what we're about to save
                console.log('ğŸ’¾ About to save emotions config:', emotionsConfig);
                
                // Call the regular save function
                await saveEmotionsConfig(false); // not auto-save
                
                // Wait a moment then verify
                setTimeout(async () => {
                    console.log('ğŸ” Verifying manual save...');
                    await verifyColorSave();
                }, 1000);
                
            } catch (error) {
                console.error('âŒ Manual save failed:', error);
                showStatus(`×©×’×™××” ×‘×©××™×¨×” ×™×“× ×™×ª: ${error.message}`, 'error');
            }
        }
        
        // Verify color save function
        async function verifyColorSave() {
            console.log('ğŸ” VERIFYING COLOR SAVE...');
            
            try {
                // Get current emotions config from memory
                const currentConfig = emotionsConfig;
                console.log('ğŸ§  Current in-memory config:', currentConfig);
                
                // Pick a test emotion to verify
                const testEmotions = ['love', 'happiness', 'anger', 'sadness'].filter(e => currentConfig[e]);
                if (testEmotions.length === 0) {
                    console.warn('âš ï¸ No test emotions found');
                    return;
                }
                
                const testEmotion = testEmotions[0];
                const memoryColor = currentConfig[testEmotion]?.color;
                console.log(`ğŸ§  In memory: ${testEmotion} = ${memoryColor}`);
                
                // Force save current config
                console.log('ğŸ’¾ Force saving current config...');
                await saveEmotionsConfig(true);
                
                // Wait a moment
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Load fresh from server
                console.log('ğŸ“¥ Loading fresh from server...');
                const response = await fetch(`${apiBaseUrl}/config/emotions_config.json?t=${Date.now()}`);
                
                if (response.ok) {
                    const serverConfig = await response.json();
                    const serverColor = serverConfig[testEmotion]?.color;
                    console.log(`ğŸ“¥ From server: ${testEmotion} = ${serverColor}`);
                    
                    const match = memoryColor === serverColor;
                    const status = match ? 'MATCH âœ…' : 'MISMATCH âŒ';
                    
                    console.log(`ğŸ” Verification result: ${status}`);
                    
                    // Show result to user
                    const message = match 
                        ? `âœ… ×©××™×¨×” ×ª×§×™× ×”!\n\n×¨×’×©: ${testEmotion}\n×¦×‘×¢ ×‘×–×™×›×¨×•×Ÿ: ${memoryColor}\n×¦×‘×¢ ×‘×©×¨×ª: ${serverColor}`
                        : `âŒ ×‘×¢×™×” ×‘×©××™×¨×”!\n\n×¨×’×©: ${testEmotion}\n×¦×‘×¢ ×‘×–×™×›×¨×•×Ÿ: ${memoryColor}\n×¦×‘×¢ ×‘×©×¨×ª: ${serverColor}\n\n×”×¦×‘×¢ ×œ× × ×©××¨ ×›×¨××•×™!`;
                    
                    alert(message);
                    
                    if (!match) {
                        showStatus('âŒ ×‘×¢×™×” ×‘×©××™×¨×ª ×¦×‘×¢×™× - ×‘×“×•×§ ××ª ×”×§×•× ×¡×•×œ', 'error');
                    } else {
                        showStatus('âœ… ×©××™×¨×ª ×¦×‘×¢×™× ×¤×•×¢×œ×ª ×›×¨××•×™', 'success');
                    }
                    
                } else {
                    console.error('âŒ Failed to load from server:', response.status);
                    alert('âŒ ×©×’×™××” ×‘×˜×¢×™× ×” ××”×©×¨×ª');
                }
                
            } catch (error) {
                console.error('âŒ Error in verification:', error);
                alert(`âŒ ×©×’×™××” ×‘×‘×“×™×§×”: ${error.message}`);
            }
        }
        
        // Reload visualization colors function
        async function reloadVisualizationColors() {
            console.log('ğŸ”„ RELOADING VISUALIZATION COLORS...');
            
            try {
                // Send reload message to all iframes
                const iframes = document.querySelectorAll('iframe');
                iframes.forEach((iframe, index) => {
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'reloadEmotionColors',
                            timestamp: Date.now()
                        }, '*');
                        console.log(`âœ… Sent reload colors message to iframe ${index + 1}`);
                    }
                });
                
                // Also send to other windows
                if (window.opener) {
                    window.opener.postMessage({
                        type: 'reloadEmotionColors',
                        timestamp: Date.now()
                    }, '*');
                    console.log('âœ… Sent reload colors to opener window');
                }
                
                // Also try broadcasting
                if (typeof BroadcastChannel !== 'undefined') {
                    try {
                        const channel = new BroadcastChannel('emotion-colors');
                        channel.postMessage({
                            type: 'reloadEmotionColors',
                            timestamp: Date.now()
                        });
                        console.log('âœ… Broadcast reload colors message');
                    } catch (e) {
                        console.log('âš ï¸ BroadcastChannel not available:', e.message);
                    }
                }
                
                // Try to directly call the global function if available
                setTimeout(() => {
                    if (window.forceUpdateAllBlobColors) {
                        window.forceUpdateAllBlobColors();
                        console.log('âœ… Called global forceUpdateAllBlobColors');
                    }
                    
                    // Also try on iframe windows
                    iframes.forEach((iframe, index) => {
                        try {
                            if (iframe.contentWindow && iframe.contentWindow.forceUpdateAllBlobColors) {
                                iframe.contentWindow.forceUpdateAllBlobColors();
                                console.log(`âœ… Called forceUpdateAllBlobColors on iframe ${index + 1}`);
                            }
                        } catch (e) {
                            console.log(`âš ï¸ Could not call forceUpdateAllBlobColors on iframe ${index + 1}:`, e.message);
                        }
                    });
                }, 1000);
                
                showStatus('ğŸ¨ ×”×•×“×¢×ª ×˜×¢×™× ×ª ×¦×‘×¢×™× × ×©×œ×—×” ×œ×›×œ ×”×•×•×™×–×•××œ×™×–×¦×™×•×ª', 'success');
                
            } catch (error) {
                console.error('âŒ Error reloading visualization colors:', error);
                showStatus('×©×’×™××” ×‘×˜×¢×™× ×ª ×¦×‘×¢×™× ××—×“×©', 'error');
            }
        }
        
        // Force visualization reload function
        async function forceVisualizationReload() {
            console.log('ğŸ”„ FORCING COMPLETE VISUALIZATION RELOAD...');
            
            try {
                // Send force reload message to all iframes
                const iframes = document.querySelectorAll('iframe');
                iframes.forEach((iframe, index) => {
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'forceCompleteReload',
                            timestamp: Date.now()
                        }, '*');
                        console.log(`âœ… Sent force reload to iframe ${index + 1}`);
                    }
                });
                
                // Also send to other windows
                if (window.opener) {
                    window.opener.postMessage({
                        type: 'forceCompleteReload',
                        timestamp: Date.now()
                    }, '*');
                    console.log('âœ… Sent force reload to opener window');
                }
                
                // Try to directly reload visualizations after a short delay
                setTimeout(() => {
                    // Refresh any visualization iframes completely
                    iframes.forEach((iframe, index) => {
                        if (iframe.src && iframe.src.includes('visualization.html')) {
                            console.log(`ğŸ”„ Reloading visualization iframe ${index + 1}`);
                            const currentSrc = iframe.src;
                            iframe.src = currentSrc + (currentSrc.includes('?') ? '&' : '?') + 'reload=' + Date.now();
                        }
                    });
                }, 1000);
                
                showStatus('ğŸ”„ ×›×¤×™×™×ª ×¨×¢× ×•×Ÿ ××œ× ×©×œ ×”×•×•×™×–×•××œ×™×–×¦×™×”', 'warning');
                
            } catch (error) {
                console.error('âŒ Error forcing visualization reload:', error);
                showStatus('×©×’×™××” ×‘×¨×¢× ×•×Ÿ ×•×™×–×•××œ×™×–×¦×™×”', 'error');
            }
        }
        
        // Test direct color update function
        function testDirectColorUpdate() {
            console.log('ğŸ§ª TESTING DIRECT COLOR UPDATE...');
            
            try {
                // Try to call the global function directly
                if (window.forceUpdateAllBlobColors) {
                    window.forceUpdateAllBlobColors();
                    showStatus('âœ… × ×§×¨× ×¤×•× ×§×¦×™×™×ª ×¢×“×›×•×Ÿ ×™×©×™×¨', 'success');
                } else {
                    console.log('âš ï¸ Global forceUpdateAllBlobColors not available');
                    showStatus('âš ï¸ ×¤×•× ×§×¦×™×” ×’×œ×•×‘×œ×™×ª ×œ× ×–××™× ×”', 'warning');
                }
                
                // Also try on any iframe windows
                const iframes = document.querySelectorAll('iframe');
                let foundIframes = 0;
                
                iframes.forEach((iframe, index) => {
                    try {
                        if (iframe.contentWindow && iframe.contentWindow.forceUpdateAllBlobColors) {
                            iframe.contentWindow.forceUpdateAllBlobColors();
                            foundIframes++;
                            console.log(`âœ… Called direct update on iframe ${index + 1}`);
                        }
                    } catch (e) {
                        console.log(`âš ï¸ Could not call direct update on iframe ${index + 1}:`, e.message);
                    }
                });
                
                if (foundIframes > 0) {
                    showStatus(`âœ… ×¢×“×›×•×Ÿ ×™×©×™×¨ × ×©×œ×— ×œ-${foundIframes} ×•×™×–×•××œ×™×–×¦×™×•×ª`, 'success');
                } else {
                    showStatus('âš ï¸ ×œ× × ××¦××• ×•×™×–×•××œ×™×–×¦×™×•×ª ×¤×¢×™×œ×•×ª', 'warning');
                }
                
            } catch (error) {
                console.error('âŒ Error in direct color update:', error);
                showStatus('âŒ ×©×’×™××” ×‘×¢×“×›×•×Ÿ ×™×©×™×¨', 'error');
            }
        }
        
        // Test conversation colors function
        function testConversationColors() {
            console.log('ğŸ§ª TESTING CONVERSATION COLORS...');
            
            try {
                // Open a test conversation visualization in a new window
                const testConversation = 'convo1'; // You can change this to any conversation
                const testUrl = `/visualization.html?folder=${testConversation}&t=${Date.now()}`;
                
                console.log(`ğŸ”„ Opening test conversation: ${testUrl}`);
                
                const testWindow = window.open(testUrl, 'testConversation', 'width=800,height=600');
                
                if (testWindow) {
                    // Wait for the window to load then send color update
                    setTimeout(() => {
                        console.log('ğŸ“¤ Sending color update to test conversation...');
                        testWindow.postMessage({
                            type: 'reloadEmotionColors',
                            timestamp: Date.now()
                        }, '*');
                        
                        setTimeout(() => {
                            testWindow.postMessage({
                                type: 'forceVisualRefresh',
                                timestamp: Date.now()
                            }, '*');
                        }, 1000);
                        
                    }, 3000); // Wait for conversation to load
                    
                    showStatus(`ğŸ”„ ×¤×ª×— ×©×™×—×ª ×‘×“×™×§×”: ${testConversation}`, 'info');
                } else {
                    showStatus('âŒ ×œ× × ×™×ª×Ÿ ×œ×¤×ª×•×— ×©×™×—×ª ×‘×“×™×§×”', 'error');
                }
                
            } catch (error) {
                console.error('âŒ Error testing conversation colors:', error);
                showStatus('âŒ ×©×’×™××” ×‘×‘×“×™×§×ª ×¦×‘×¢×™ ×©×™×—×”', 'error');
            }
        }
        
        // Test index page colors function
        function testIndexPageColors() {
            console.log('ğŸ  TESTING INDEX PAGE CONVERSATION COLORS...');
            
            try {
                if (window.opener && window.opener !== window) {
                    console.log('ğŸ“¤ Sending test messages to main index page...');
                    
                    // Send multiple update messages with delays
                    const messages = [
                        { type: 'emotionColorsUpdated', timestamp: Date.now() },
                        { type: 'reloadEmotionColors', timestamp: Date.now() + 100 },
                        { type: 'forceVisualRefresh', timestamp: Date.now() + 200 }
                    ];
                    
                    messages.forEach((message, index) => {
                        setTimeout(() => {
                            window.opener.postMessage(message, '*');
                            console.log(`ğŸ“¤ Sent ${message.type} to main index page (${index + 1}/${messages.length})`);
                        }, index * 300);
                    });
                    
                    showStatus('ğŸ”„ ×©×œ×— ×¢×“×›×•× ×™ ×¦×‘×¢×™× ×œ×¢××•×“ ×”×¨××©×™', 'success');
                } else {
                    showStatus('âŒ ×œ× × ×™×ª×Ÿ ×œ××¦×•× ×¢××•×“ ×¨××©×™', 'error');
                    console.log('âŒ No opener window found (admin panel may not be opened from main index)');
                }
                
            } catch (error) {
                console.error('âŒ Error testing index page colors:', error);
                showStatus('âŒ ×©×’×™××” ×‘×‘×“×™×§×ª ×¢××•×“ ×¨××©×™', 'error');
            }
        }
        
        // Immediate visual refresh function
        async function immediateVisualRefresh() {
            console.log('ğŸš€ IMMEDIATE VISUAL REFRESH TRIGGERED');
            
            try {
                // 1. Force update all emotion displays
                displayEmotionsList();
                console.log('âœ… Refreshed emotions list display');
                
                // 2. Force visualization color update
                updateVisualizationColors();
                console.log('âœ… Sent visualization color updates');
                
                // 3. Wait a moment then force another update
                setTimeout(() => {
                    updateVisualizationColors();
                    console.log('âœ… Sent delayed visualization update');
                }, 500);
                
                // 4. Send direct force refresh message to all iframes
                const iframes = document.querySelectorAll('iframe');
                iframes.forEach((iframe, index) => {
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'forceVisualRefresh',
                            timestamp: Date.now()
                        }, '*');
                        console.log(`âœ… Sent force refresh to iframe ${index + 1}`);
                    }
                });
                
                // 5. Also broadcast to other windows
                if (window.opener) {
                    window.opener.postMessage({
                        type: 'forceVisualRefresh',
                        timestamp: Date.now()
                    }, '*');
                    console.log('âœ… Sent force refresh to opener window');
                }
                
                showStatus('ğŸ¨ ×›×¤×™×™×ª ×¨×¢× ×•×Ÿ ××™×™×“×™ ×©×œ ×”×•×•×™×–×•××œ×™×–×¦×™×” - ×‘×“×•×§ ××ª ×”×ª×¦×•×’×” ×¢×›×©×™×•!', 'success');
                
            } catch (error) {
                console.error('âŒ Error in immediate visual refresh:', error);
                showStatus('×©×’×™××” ×‘×¨×¢× ×•×Ÿ ××™×™×“×™', 'error');
            }
        }
        
        // Hex to RGB conversion function
        function hexToRgb(hex) {
            // Remove # if present
            hex = hex.replace('#', '');
            
            // Parse RGB values
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            return [r, g, b];
        }
        
        // Filter emotions
        function filterEmotions(searchTerm) {
            const emotionItems = document.querySelectorAll('.emotion-item');
            const term = searchTerm.toLowerCase();
            
            emotionItems.forEach(item => {
                const emotionText = item.textContent.toLowerCase();
                const isVisible = emotionText.includes(term);
                item.style.display = isVisible ? 'block' : 'none';
            });
        }
        
        // Helper function to get contrast color
        function getContrastColor(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128 ? '#000000' : '#ffffff';
        }
        
        // Copy to clipboard
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showStatus(`×¦×‘×¢ ${text} ×”×•×¢×ª×§ ×œ×œ×•×—`, 'success');
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                showStatus('×©×’×™××” ×‘×”×¢×ª×§×”', 'error');
            });
        }
        
        // ENHANCED: Force immediate color update test function
        window.forceEmotionColorUpdate = function() {
            console.log('ğŸš€ FORCING IMMEDIATE EMOTION COLOR UPDATE');
            
            if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                console.error('âŒ No emotions config loaded!');
                return false;
            }
            
            console.log('ğŸ¨ Current emotions config:', emotionsConfig);
            
            // Force an immediate update
            updateVisualizationColors();
            
            // Also try to refresh any open visualization
            const iframe = document.getElementById('segment-preview-iframe');
            if (iframe && iframe.contentWindow) {
                        const emotionColorsForViz = {};
                        Object.entries(emotionsConfig).forEach(([emotion, config]) => {
                            if (config.active && config.color) {
                                emotionColorsForViz[emotion] = hexToRgb(config.color);
                            }
                        });
                        
                iframe.contentWindow.postMessage({
                    type: 'updateEmotions',
                            emotionColorMap: emotionColorsForViz,
                            emotions: emotionsConfig,
                            timestamp: Date.now()
                }, '*');
                
                console.log('ğŸ¨ Sent direct update to preview iframe:', emotionColorsForViz);
            }
            
            return true;
        };
        
        // Comprehensive test function to debug emotion colors
        window.testEmotionColors = function() {
            console.log('ğŸ§ª COMPREHENSIVE EMOTION COLOR TEST');
            console.log('=' .repeat(50));
            
            // 1. Check emotions config
            console.log('1ï¸âƒ£ EMOTIONS CONFIG CHECK:');
            console.log('ğŸ¨ Current emotions config:', emotionsConfig);
            console.log('ğŸ¨ Emotions config keys:', Object.keys(emotionsConfig || {}));
            console.log('ğŸ¨ Config loaded:', !!(emotionsConfig && Object.keys(emotionsConfig).length > 0));
            
            // Test love emotion specifically
            console.log('\nğŸ” LOVE EMOTION DETAILED CHECK:');
            const loveConfig = emotionsConfig['love'];
            if (loveConfig) {
                console.log('âœ… Love emotion config found:', loveConfig);
                console.log('ğŸ¯ Love color:', loveConfig.color);
                console.log('ğŸ¯ Love RGB:', hexToRgb(loveConfig.color));
                console.log('ğŸ¯ Love hebrew:', loveConfig.hebrew);
                console.log('ğŸ¯ Love emoji:', loveConfig.emoji);
                console.log('ğŸ¯ Love active:', loveConfig.active);
            } else {
                console.log('âŒ No love emotion config found!');
                console.log('Available emotions:', Object.keys(emotionsConfig || {}));
            }
            
            // 2. Check conversation data
            console.log('\n2ï¸âƒ£ CONVERSATION DATA CHECK:');
            console.log('ğŸ¨ Current conversation:', currentConversation);
            console.log('ğŸ¨ Current emotion data loaded:', !!(emotionData && Object.keys(emotionData).length > 0));
            console.log('ğŸ¨ Emotion data keys count:', Object.keys(emotionData || {}).length);
            
            // 3. Check if any segments have love emotion
            console.log('\n3ï¸âƒ£ SEGMENTS WITH LOVE EMOTION:');
            if (emotionData) {
                const mp3Files = Object.keys(emotionData).filter(key => key.endsWith('.mp3'));
                let loveCount = 0;
                mp3Files.slice(0, 10).forEach(mp3File => {
                    const segment = emotionData[mp3File];
                    if (segment && segment.emotions && segment.emotions.includes('love')) {
                        loveCount++;
                        console.log(`ğŸ’ ${mp3File}: emotions = [${segment.emotions.join(', ')}]`);
                        if (segment.emotionColors) {
                            console.log(`   ğŸ’¾ emotionColors:`, segment.emotionColors);
                        }
                    }
                });
                console.log(`ğŸ“Š Found ${loveCount} segments with love emotion (from first 10 checked)`);
            }
            
            // 4. Test color conversion
            console.log('\n4ï¸âƒ£ COLOR CONVERSION TEST:');
            if (loveConfig && loveConfig.color) {
                const hexColor = loveConfig.color;
                const rgbColor = hexToRgb(hexColor);
                console.log(`ğŸ¨ Love Hex color: ${hexColor}`);
                console.log(`ğŸ¨ Love RGB color: [${rgbColor.join(', ')}]`);
                
                // Test visualization message format
                const emotionColorsForViz = {};
                emotionColorsForViz['love'] = rgbColor;
                console.log(`ğŸ¨ Message format for love:`, emotionColorsForViz);
            }
            
            // 5. Force color updates
            console.log('\n5ï¸âƒ£ FORCING COLOR UPDATES:');
            try {
                console.log('ğŸ”„ Calling updateVisualizationColors()...');
                updateVisualizationColors();
                
                console.log('ğŸ”„ Calling refreshAllEmotionDisplays()...');
                refreshAllEmotionDisplays();
                
                console.log('ğŸ”„ Calling updateCurrentConversationEmotionColors()...');
                updateCurrentConversationEmotionColors();
                
                console.log('âœ… All update functions called successfully');
            } catch (error) {
                console.error('âŒ Error calling update functions:', error);
            }
            
            // 6. Check iframe targets
            console.log('\n6ï¸âƒ£ IFRAME AND WINDOW TARGETS:');
            const iframes = document.querySelectorAll('iframe');
            console.log(`ğŸ“º Found ${iframes.length} iframes on page`);
            iframes.forEach((iframe, i) => {
                console.log(`   iframe ${i}: src = ${iframe.src}`);
                if (iframe.contentWindow) {
                    console.log(`   iframe ${i}: contentWindow available`);
                }
            });
            
            if (window.opener) {
                console.log('ğŸ”— Window opener available:', !!window.opener);
            }
            if (window.parent !== window) {
                console.log('ğŸ”— Window parent available:', !!window.parent);
            }
            
            // 7. Test direct iframe update
            console.log('\n7ï¸âƒ£ DIRECT IFRAME UPDATE TEST:');
            const previewIframe = document.getElementById('segment-preview-iframe');
            if (previewIframe && previewIframe.contentWindow) {
                console.log('ğŸ“º Found preview iframe, sending direct update...');
                
                const emotionColorsForViz = {};
                Object.entries(emotionsConfig).forEach(([emotion, config]) => {
                    if (config.active && config.color) {
                        emotionColorsForViz[emotion] = hexToRgb(config.color);
                    }
                });
                
                previewIframe.contentWindow.postMessage({
                    type: 'updateEmotions',
                    emotionColorMap: emotionColorsForViz,
                    emotions: emotionsConfig,
                    timestamp: Date.now()
                }, '*');
                
                console.log('âœ… Sent direct update to preview iframe');
                console.log('ğŸ¨ Emotion colors sent:', emotionColorsForViz);
            } else {
                console.log('âŒ No preview iframe found or contentWindow not available');
            }
            
            console.log('\nâœ… COMPREHENSIVE TEST COMPLETE');
            console.log('=' .repeat(50));
            
            return {
                emotionsConfigLoaded: !!(emotionsConfig && Object.keys(emotionsConfig).length > 0),
                conversationLoaded: !!currentConversation,
                emotionDataLoaded: !!(emotionData && Object.keys(emotionData).length > 0),
                loveConfigExists: !!(emotionsConfig && emotionsConfig['love']),
                loveColor: emotionsConfig?.['love']?.color,
                iframeCount: document.querySelectorAll('iframe').length,
                previewIframeAvailable: !!(document.getElementById('segment-preview-iframe')),
                broadcastSupported: typeof BroadcastChannel !== 'undefined'
            };
        };
        
        // Simple test to force update a specific emotion color
        window.forceUpdateNeutralColor = function(newColor = '#FF0000') {
            console.log(`ğŸ”´ FORCING NEUTRAL COLOR UPDATE TO: ${newColor}`);
            
            if (!emotionsConfig || !emotionsConfig['neutral']) {
                console.error('âŒ No neutral emotion config found!');
                return false;
            }
            
            // Update the config
            emotionsConfig['neutral'].color = newColor;
            console.log('âœ… Updated emotions config');
            
            // Update all visualizations
            updateVisualizationColors();
            console.log('âœ… Called updateVisualizationColors');
            
            // Update displays
            refreshAllEmotionDisplays();
            console.log('âœ… Called refreshAllEmotionDisplays');
            
            // Update conversation data
            updateCurrentConversationEmotionColors();
            console.log('âœ… Called updateCurrentConversationEmotionColors');
            
            console.log(`ğŸ¨ Neutral color should now be: ${newColor}`);
            return true;
        };
        
        // ==================== ENHANCED EMOTIONS VIEW FUNCTIONS ====================
        
        // Enhanced Emotions View Functions
        window.analyzeConversationEmotions = function() {
            console.log('ğŸ­ Analyzing conversation emotions...');
            
            fetch('/api/conversations')
                .then(response => response.json())
                .then(data => {
                    const conversations = data.conversations || [];
                    const emotionGroups = {};
                    let totalConversations = 0;
                    
                    // Group conversations by main emotions
                    conversations.forEach(conv => {
                        const mainEmotions = conv.metadata?.mainEmotions || ['neutral'];
                        totalConversations++;
                        
                        mainEmotions.forEach(emotion => {
                            if (!emotionGroups[emotion]) {
                                emotionGroups[emotion] = [];
                            }
                            emotionGroups[emotion].push(conv);
                        });
                    });
                    
                    // Update stats
                    const emotionCount = Object.keys(emotionGroups).length;
                    const analysisStats = `${totalConversations} ×©×™×—×•×ª, ${emotionCount} ×¨×’×©×•×ª ×©×•× ×™×`;
                    const circlesStats = `${emotionCount} ××¢×’×œ×™ ×¨×’×©×•×ª ×¤×¢×™×œ×™×`;
                    
                    document.getElementById('emotion-analysis-stats').innerHTML = analysisStats;
                    document.getElementById('emotion-circles-stats').innerHTML = circlesStats;
                    
                    // Update emotion groups preview
                    updateEmotionGroupsPreview(emotionGroups);
                    
                    console.log(`âœ… Emotion analysis complete: ${emotionCount} emotions, ${totalConversations} conversations`);
                })
                .catch(error => {
                    console.error('âŒ Error analyzing emotions:', error);
                    document.getElementById('emotion-analysis-stats').innerHTML = '×©×’×™××” ×‘× ×™×ª×•×—';
                    document.getElementById('emotion-circles-stats').innerHTML = '×©×’×™××” ×‘× ×™×ª×•×—';
                });
        };
        
        window.generateEmotionReport = function() {
            console.log('ğŸ“Š Generating emotion report...');
            
            fetch('/api/conversations')
                .then(response => response.json())
                .then(data => {
                    const conversations = data.conversations || [];
                    const emotionStats = {};
                    
                    conversations.forEach(conv => {
                        const mainEmotions = conv.metadata?.mainEmotions || ['neutral'];
                        mainEmotions.forEach(emotion => {
                            emotionStats[emotion] = (emotionStats[emotion] || 0) + 1;
                        });
                    });
                    
                    // Sort emotions by frequency
                    const sortedEmotions = Object.entries(emotionStats)
                        .sort(([,a], [,b]) => b - a)
                        .map(([emotion, count]) => `${emotion}: ${count} ×©×™×—×•×ª`)
                        .join('\n');
                    
                    const reportText = `×“×•×— ×¨×’×©×•×ª - ${new Date().toLocaleDateString('he-IL')}\n\n${sortedEmotions}`;
                    
                    // Create download link
                    const blob = new Blob([reportText], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `emotion_report_${new Date().toISOString().split('T')[0]}.txt`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    alert('âœ… ×“×•×— ×¨×’×©×•×ª ×”×•×¤×§ ×‘×”×¦×œ×—×”!');
                })
                .catch(error => {
                    console.error('âŒ Error generating report:', error);
                    alert('âŒ ×©×’×™××” ×‘×™×¦×™×¨×ª ×”×“×•×—');
                });
        };
        
        window.refreshEmotionView = function() {
            console.log('ğŸ”„ Refreshing emotion view...');
            analyzeConversationEmotions();
            
            // Refresh the main emotions view if it's open
            const mainWindow = window.opener || window.parent;
            if (mainWindow && mainWindow.refreshLayoutCache) {
                mainWindow.refreshLayoutCache('emotions');
            }
            
            setTimeout(() => {
                alert('âœ… ×ª×¦×•×’×ª ×”×¨×’×©×•×ª ×¨×•×¢× ×” ×‘×”×¦×œ×—×”!');
            }, 1000);
        };
        
        function updateEmotionGroupsPreview(emotionGroups) {
            const container = document.getElementById('emotion-groups-preview');
            if (!container) return;
            
            container.innerHTML = '';
            
            Object.entries(emotionGroups).forEach(([emotion, conversations]) => {
                const emotionCard = document.createElement('div');
                emotionCard.style.cssText = `
                    background: linear-gradient(135deg, #f8f9ff 0%, #e8ecff 100%);
                    border: 1px solid #667eea;
                    border-radius: 8px;
                    padding: 1rem;
                    text-align: center;
                `;
                
                emotionCard.innerHTML = `
                    <div style="font-size: 24px; margin-bottom: 0.5rem;">ğŸ­</div>
                    <div style="font-weight: bold; color: #333; margin-bottom: 0.25rem;">${emotion}</div>
                    <div style="color: #666; font-size: 0.9rem;">${conversations.length} ×©×™×—×•×ª</div>
                    <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #888;">
                        ${conversations.map(conv => conv.metadata?.name || conv.id).slice(0, 3).join(', ')}
                        ${conversations.length > 3 ? '...' : ''}
                    </div>
                `;
                
                container.appendChild(emotionCard);
            });
        }
        
        // Initialize enhanced emotions view when tab is opened
        window.initializeEmotions = function() {
            console.log('ğŸ­ Initializing enhanced emotions view...');
            
            // Reload emotions configuration to get latest changes
            loadEmotionsConfig().then(() => {
                console.log('ğŸ¨ Emotions configuration reloaded successfully');
                
                // Auto-analyze emotions when the tab opens
                setTimeout(() => {
                    analyzeConversationEmotions();
                }, 500);
            }).catch(error => {
                console.error('âŒ Error reloading emotions config:', error);
                showStatus('×©×’×™××” ×‘×˜×¢×™× ×ª ×”×’×“×¨×•×ª ×¨×’×©×•×ª', 'error');
            });
        };
        
        // ==================== END EMOTIONS MANAGEMENT FUNCTIONS ====================
        
        // ==================== PREVENT FORM SUBMISSIONS & BLANK TABS ====================
        
        // Comprehensive fix for preventing blank tabs and form submissions
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ğŸ”§ Applying admin panel button fixes...');
            
            // Prevent all form submissions in the admin panel
            document.addEventListener('submit', function(e) {
                e.preventDefault();
                console.warn('âš ï¸ Form submission prevented to avoid blank tabs');
                return false;
            });
            
            // Ensure all buttons with onclick handlers have type="button"
            const buttons = document.querySelectorAll('button[onclick]:not([type])');
            buttons.forEach(button => {
                button.setAttribute('type', 'button');
                console.log('ğŸ”§ Fixed button:', button.getAttribute('onclick'));
            });
            
            // More aggressive prevention of form submissions and blank tabs
            document.addEventListener('click', function(e) {
                // Prevent any form submission attempts
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
                    // Only prevent default if the button might cause navigation
                    if (e.target.type === 'submit' || !e.target.type || e.target.type === '') {
                        e.preventDefault();
                        console.log('ğŸš« Prevented potential form submission from:', e.target.outerHTML.substring(0, 100));
                        return false;
                    }
                }
            }, true); // Use capture phase
            
            // Also prevent any accidental form submissions at the document level
            document.addEventListener('submit', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.warn('ğŸš« Form submission blocked at document level');
                return false;
            }, true);
            
            // Prevent any window navigation that might open blank tabs
            const originalOpen = window.open;
            window.open = function(...args) {
                // Only block if it's likely to be an unwanted blank tab
                if (args.length === 0 || args[0] === '' || args[0] === 'about:blank') {
                    console.warn('ğŸš« Blocked blank/empty window.open call with args:', args);
                    console.trace('window.open call stack:');
                    return null;
                } else {
                    console.log('ğŸ”— Allowing legitimate window.open to:', args[0]);
                    return originalOpen.apply(window, args);
                }
            };
            
            // Block location.assign only to blank/empty URLs
            const originalAssign = window.location.assign;
            window.location.assign = function(url) {
                if (!url || url === '' || url === 'about:blank') {
                    console.warn('ğŸš« Blocked blank/empty location.assign to:', url);
                    console.trace('location.assign call stack:');
                } else {
                    console.log('ğŸ”— Allowing legitimate location.assign to:', url);
                    return originalAssign.call(window.location, url);
                }
            };
            
            console.log('âœ… Admin panel button fixes and navigation blocks applied');
        });
        
        // ==================== END BUTTON FIXES ====================
        
        // ==================== PEOPLE MANAGER FUNCTIONS ====================
        
        let currentPeopleData = {};
        
        // Open the people manager modal
        function openPeopleManager() {
            console.log('ğŸ“‹ Opening people manager...');
            loadPeopleForManager();
            document.getElementById('people-manager-modal').style.display = 'block';
        }
        
        // Close the people manager modal
        function closePeopleManager() {
            document.getElementById('people-manager-modal').style.display = 'none';
            document.getElementById('new-person-name').value = '';
            document.getElementById('new-person-color').value = '#667eea';
        }
        
        // Load people data for the manager
        async function loadPeopleForManager() {
            try {
                console.log('ğŸ“¡ Loading people data for manager...');
                const response = await fetch('/config/people_data.json');
                const data = await response.json();
                currentPeopleData = data;
                
                displayExistingPeople(data.people || {});
                updateMainParticipantDropdown(data.people || {});
                
                console.log('âœ… People data loaded for manager');
            } catch (error) {
                console.error('âŒ Error loading people data:', error);
                showStatus('×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™ ×× ×©×™×', 'error');
            }
        }
        
        // Display existing people in the manager
        function displayExistingPeople(people) {
            const listContainer = document.getElementById('existing-people-list');
            
            if (Object.keys(people).length === 0) {
                listContainer.innerHTML = '<div style="text-align: center; color: #999; padding: 2rem;">××™×Ÿ ×× ×©×™× ×‘××¢×¨×›×ª</div>';
                return;
            }
            
            let html = '';
            Object.entries(people).forEach(([personId, person]) => {
                html += `
                    <div class="person-item" data-person-id="${personId}" style="display: flex; align-items: center; gap: 1rem; padding: 0.75rem; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 0.5rem; background: white;">
                        <div style="width: 30px; height: 30px; background: ${person.color}; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
                        <input type="text" value="${person.name}" data-field="name" style="flex: 1; padding: 0.25rem; border: 1px solid #ccc; border-radius: 3px;">
                        <input type="color" value="${person.color}" data-field="color" style="width: 40px; padding: 0; border: 1px solid #ccc; border-radius: 3px;">
                        <button onclick="removePersonFromList('${personId}')" class="btn btn-danger btn-sm" style="background: #dc3545; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 3px; cursor: pointer;">
                            <i class="material-icons" style="font-size: 14px;">delete</i>
                        </button>
                    </div>
                `;
            });
            
            listContainer.innerHTML = html;
        }
        
        // Update the main participant dropdown
        function updateMainParticipantDropdown(people) {
            const dropdown = document.getElementById('main-participant');
            const currentValue = dropdown.value;
            
            // Clear existing options (except the first "select" option)
            dropdown.innerHTML = '<option value="">×‘×—×¨ ××©×ª×ª×£...</option>';
            
            // Add people from data
            Object.entries(people).forEach(([personId, person]) => {
                const option = document.createElement('option');
                option.value = person.name;
                option.textContent = person.name;
                dropdown.appendChild(option);
            });
            
            // Add custom option
            const customOption = document.createElement('option');
            customOption.value = 'custom';
            customOption.textContent = '××•×ª×× ××™×©×™×ª...';
            dropdown.appendChild(customOption);
            
            // Restore previous selection if it still exists
            if (currentValue && [...dropdown.options].some(opt => opt.value === currentValue)) {
                dropdown.value = currentValue;
            }
        }
        
        // Add a new person to the list
        function addNewPersonToList() {
            const nameInput = document.getElementById('new-person-name');
            const colorInput = document.getElementById('new-person-color');
            
            const name = nameInput.value.trim();
            const color = colorInput.value;
            
            if (!name) {
                showStatus('×™×© ×œ×”×–×™×Ÿ ×©× ×œ××“× ×”×—×“×©', 'warning');
                return;
            }
            
            // Check if name already exists
            const existingNames = Object.values(currentPeopleData.people || {}).map(p => p.name.toLowerCase());
            if (existingNames.includes(name.toLowerCase())) {
                showStatus('×©× ×–×” ×›×‘×¨ ×§×™×™× ×‘××¢×¨×›×ª', 'warning');
                return;
            }
            
            // Generate new person ID
            const personId = 'person_' + name.toLowerCase().replace(/\s+/g, '_').replace(/[^\w]/g, '');
            
            // Add to current data
            if (!currentPeopleData.people) currentPeopleData.people = {};
            currentPeopleData.people[personId] = {
                name: name,
                description: `× ×•×¡×£ ×“×¨×š × ×™×”×•×œ ×©×™×—×•×ª`,
                color: color,
                status: 'active',
                conversations: [],
                totalSegments: 0,
                totalDuration: 0,
                defaultSpeaker: 0,
                createdAt: new Date().toISOString(),
                lastModified: new Date().toISOString()
            };
            
            // Refresh display
            displayExistingPeople(currentPeopleData.people);
            updateMainParticipantDropdown(currentPeopleData.people);
            
            // Clear inputs
            nameInput.value = '';
            colorInput.value = '#667eea';
            
            showStatus(`× ×•×¡×£ ××“× ×—×“×©: ${name}`, 'success');
        }
        
        // Remove a person from the list
        function removePersonFromList(personId) {
            const person = currentPeopleData.people[personId];
            if (!person) return;
            
            if (confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª ${person.name}?`)) {
                delete currentPeopleData.people[personId];
                
                // Also remove from conversation assignments
                if (currentPeopleData.conversationAssignments) {
                    Object.keys(currentPeopleData.conversationAssignments).forEach(convId => {
                        currentPeopleData.conversationAssignments[convId] = 
                            currentPeopleData.conversationAssignments[convId].filter(id => id !== personId);
                        
                        if (currentPeopleData.conversationAssignments[convId].length === 0) {
                            delete currentPeopleData.conversationAssignments[convId];
                        }
                    });
                }
                
                // Remove from speaker mappings
                if (currentPeopleData.speakerMappings) {
                    Object.keys(currentPeopleData.speakerMappings).forEach(convId => {
                        if (currentPeopleData.speakerMappings[convId]) {
                            Object.keys(currentPeopleData.speakerMappings[convId]).forEach(speaker => {
                                if (currentPeopleData.speakerMappings[convId][speaker] === personId) {
                                    delete currentPeopleData.speakerMappings[convId][speaker];
                                }
                            });
                            
                            if (Object.keys(currentPeopleData.speakerMappings[convId]).length === 0) {
                                delete currentPeopleData.speakerMappings[convId];
                            }
                        }
                    });
                }
                
                displayExistingPeople(currentPeopleData.people);
                updateMainParticipantDropdown(currentPeopleData.people);
                showStatus(`× ××—×§: ${person.name}`, 'info');
            }
        }
        
        // Save changes to people data
        async function savePeopleChanges() {
            try {
                console.log('ğŸ’¾ Saving people changes...');
                
                // Collect changes from the form
                const personItems = document.querySelectorAll('.person-item');
                personItems.forEach(item => {
                    const personId = item.dataset.personId;
                    const nameInput = item.querySelector('[data-field="name"]');
                    const colorInput = item.querySelector('[data-field="color"]');
                    
                    if (currentPeopleData.people[personId]) {
                        currentPeopleData.people[personId].name = nameInput.value.trim();
                        currentPeopleData.people[personId].color = colorInput.value;
                        currentPeopleData.people[personId].lastModified = new Date().toISOString();
                    }
                });
                
                // Update last modified time
                currentPeopleData.lastUpdated = new Date().toISOString();
                
                // Save to server
                const response = await fetch('/api/save-people-data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(currentPeopleData)
                });
                
                if (response.ok) {
                    // Synchronize speaker names with conversation metadata
                    await synchronizeSpeakerNames();
                    
                    showStatus('×©×™× ×•×™×™× × ×©××¨×• ×‘×”×¦×œ×—×”', 'success');
                    closePeopleManager();
                    
                    // Reload the people list to ensure consistency
                    setTimeout(() => {
                        loadPeopleForManager();
                    }, 500);
                } else {
                    throw new Error('Failed to save people data');
                }
                
            } catch (error) {
                console.error('âŒ Error saving people changes:', error);
                showStatus('×©×’×™××” ×‘×©××™×¨×ª ×”×©×™× ×•×™×™×', 'error');
            }
        }
        
        // Synchronize speaker names from people data to conversation metadata
        async function synchronizeSpeakerNames() {
            try {
                console.log('ğŸ”„ Synchronizing speaker names with conversation metadata...');
                
                // Check if we have speaker mappings
                if (!currentPeopleData.speakerMappings) {
                    console.log('âš ï¸ No speaker mappings found');
                    return;
                }
                
                // Get current conversation metadata
                if (!conversationMetadata) {
                    console.log('âš ï¸ No conversation metadata loaded');
                    return;
                }
                
                let hasChanges = false;
                
                // For each conversation in speaker mappings
                Object.keys(currentPeopleData.speakerMappings).forEach(conversationId => {
                    const speakerMapping = currentPeopleData.speakerMappings[conversationId];
                    
                    // Skip if conversation doesn't exist in metadata
                    if (!conversationMetadata[conversationId]) {
                        return;
                    }
                    
                    const metadata = conversationMetadata[conversationId].metadata || {};
                    
                    // Update speaker1Name if mapped
                    if (speakerMapping['0'] && currentPeopleData.people[speakerMapping['0']]) {
                        const newName = currentPeopleData.people[speakerMapping['0']].name;
                        if (metadata.speaker1Name !== newName) {
                            metadata.speaker1Name = newName;
                            hasChanges = true;
                            console.log(`ğŸ­ Updated ${conversationId} speaker1Name: ${newName}`);
                        }
                    }
                    
                    // Update speaker2Name if mapped
                    if (speakerMapping['1'] && currentPeopleData.people[speakerMapping['1']]) {
                        const newName = currentPeopleData.people[speakerMapping['1']].name;
                        if (metadata.speaker2Name !== newName) {
                            metadata.speaker2Name = newName;
                            hasChanges = true;
                            console.log(`ğŸ­ Updated ${conversationId} speaker2Name: ${newName}`);
                        }
                    }
                    
                    // Update lastModified timestamp
                    if (hasChanges) {
                        metadata.lastModified = new Date().toISOString();
                    }
                });
                
                // Save conversation metadata if changes were made
                if (hasChanges) {
                    console.log('ğŸ’¾ Saving updated conversation metadata...');
                    await saveConversationMetadata();
                    
                    // Refresh the metadata form if we're currently viewing it
                    if (currentMetadataConversation) {
                        loadMetadataForm(currentMetadataConversation, conversationMetadata[currentMetadataConversation]);
                    }
                    
                    console.log('âœ… Speaker names synchronized successfully');
                } else {
                    console.log('â„¹ï¸ No changes needed - speaker names already synchronized');
                }
                
            } catch (error) {
                console.error('âŒ Error synchronizing speaker names:', error);
                showStatus('×©×’×™××” ×‘×¡× ×›×¨×•×Ÿ ×©××•×ª ×”×“×•×‘×¨×™×', 'error');
            }
        }
        
        // Override the existing initializeMetadata function to include people loading
        const originalInitializeMetadata = window.initializeMetadata;
        window.initializeMetadata = function() {
            console.log('ğŸ“Š Initializing metadata tab with people manager...');
            
            // Call original function if it exists
            if (originalInitializeMetadata && typeof originalInitializeMetadata === 'function') {
                originalInitializeMetadata();
            } else {
                // Fallback initialization with force refresh
                loadConversationMetadata(true);
            }
            
            // Load people data for dropdown
            loadPeopleForManager();
        };
        
        // ==================== END PEOPLE MANAGER FUNCTIONS ====================
    </script>

    <!-- People Manager Modal -->
    <div id="people-manager-modal" class="modal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);" onclick="if(event.target === this) closePeopleManager();">
        <div class="modal-content" style="background-color: #fefefe; margin: 5% auto; padding: 0; border: none; border-radius: 12px; width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.3);" onclick="event.stopPropagation();">
            <div class="modal-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1.5rem; border-radius: 12px 12px 0 0; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; font-size: 1.5rem;">× ×™×”×•×œ ×¨×©×™××ª ×× ×©×™×</h2>
                <span class="close" onclick="closePeopleManager()" style="color: white; float: right; font-size: 28px; font-weight: bold; cursor: pointer; line-height: 1;">&times;</span>
            </div>
            <div class="modal-body" style="padding: 2rem;">
                <div style="margin-bottom: 2rem; background: #f8f9ff; padding: 1.5rem; border-radius: 8px;">
                    <h3 style="margin: 0 0 1rem 0; color: #667eea;">×”×•×¡×£ ××“× ×—×“×©</h3>
                    <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                                                 <input type="text" id="new-person-name" placeholder="×©× ×”××“× ×”×—×“×©" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;" onkeypress="if(event.key==='Enter') addNewPersonToList();">
                        <input type="color" id="new-person-color" value="#667eea" style="width: 60px; padding: 0; border: 1px solid #ddd; border-radius: 4px;">
                        <button onclick="addNewPersonToList()" class="btn btn-success btn-sm" style="background: #28a745; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">
                            <i class="material-icons" style="font-size: 16px;">add</i>
                            ×”×•×¡×£
                        </button>
                    </div>
                </div>
                
                <div>
                    <h3 style="margin: 0 0 1rem 0; color: #e53e3e;">×¨×©×™××ª ×× ×©×™× ×§×™×™××ª</h3>
                    <div id="existing-people-list" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; padding: 1rem; background: #f8f9fa;">
                        <!-- Existing people will be loaded here -->
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="background: #f8f9fa; padding: 1.5rem; border-radius: 0 0 12px 12px; display: flex; gap: 1rem; justify-content: flex-end;">
                <button onclick="savePeopleChanges()" class="btn btn-success" style="background: #28a745; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 4px; cursor: pointer;">
                    <i class="material-icons" style="font-size: 16px;">save</i>
                    ×©××•×¨ ×©×™× ×•×™×™×
                </button>
                <button onclick="closePeopleManager()" class="btn btn-secondary" style="background: #6c757d; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 4px; cursor: pointer;">
                    <i class="material-icons" style="font-size: 16px;">close</i>
                    ×‘×™×˜×•×œ
                </button>
            </div>
        </div>
    </div>
</body>
</html> 