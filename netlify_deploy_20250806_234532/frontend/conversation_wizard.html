<!DOCTYPE html>
<html lang="he" dir="rtl" style="height: 100%;">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מעבדת שיחות - מערכת ניתוח ויזואלי</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Miriam+Libre:wght@400;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap">
    
    <!-- Add p5.js library for blob visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    
    <!-- Add visualization scripts like in visualization.html -->
    <script>
        // Global variables for wizard visualization
        window.isWizardMode = true;
        window.noSidepanel = true;
        window.currentConversationFolder = 'wizard_live'; // Special folder for live conversations
        window.isLiveMode = true;
    </script>
    
    <script>
        // Essential functions that need to be available immediately
        function showQuestionnaire() {
            document.getElementById('gridPage').classList.add('hidden');
            document.getElementById('questionnairePage').classList.add('active');
            
            // Show the minimalistic recording interface immediately
            document.getElementById('minimalisticInterface').style.display = 'flex';
            
            // Hide the new conversation button
            const newConversationBtn = document.querySelector('.new-conversation-btn');
            if (newConversationBtn) {
                newConversationBtn.style.display = 'none';
            }
            
            // Initialize blob visualization immediately
            if (typeof initBlobVisualization === 'function') {
                console.log('Calling initBlobVisualization from showQuestionnaire...');
                initBlobVisualization();
            } else {
                console.log('initBlobVisualization function not available yet');
                // Try again after a delay
                setTimeout(() => {
                    if (typeof initBlobVisualization === 'function') {
                        console.log('Retrying initBlobVisualization...');
                        initBlobVisualization();
                    }
                }, 1000);
            }
        }

        function showGrid() {
            document.getElementById('gridPage').classList.remove('hidden');
            document.getElementById('questionnairePage').classList.remove('active');
            
            // Show the new conversation button again
            const newConversationBtn = document.querySelector('.new-conversation-btn');
            if (newConversationBtn) {
                newConversationBtn.style.display = 'block';
            }
            
            // Remove webcam-active class to show sidebar again
            document.body.classList.remove('webcam-active');
            
            // Stop webcam when going back
            if (typeof stream !== 'undefined' && stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
                if (typeof isWebcamRunning !== 'undefined') {
                    isWebcamRunning = false;
                }
                if (typeof animationId !== 'undefined' && animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
        }
    </script>
    
    <style>
        /* CSS Variables matching main app */
        :root { 
            --main-font-family: 'Miriam Libre', sans-serif;
            --main-bg-color: #f7f9f3;

            --dynamic-grid-size: 60px;
        }
        
        /* Global font rule matching main app */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: var(--main-font-family) !important;
        }

        /* Base HTML and Body Styles matching main app */
        html, body { 
            height: 100%; 
            margin: 0; 
            padding: 0; 
            background: var(--main-bg-color);
            font-family: var(--main-font-family); 
            color: #222; 
            font-size: 14px; 
            overflow: hidden;
            direction: rtl;
        }

        /* Header Styles matching main app */
        .app-header { 
            width: 100%; 
            background: var(--main-bg-color); 
            padding: 15px 30px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            z-index: 1002; 
            position: fixed; 
            top: 0; 
            left: 0; 
            right: 0; 
            box-sizing: border-box; 
            height: 60px; 
            border-bottom: 2px solid #d0d0d0;
        }

        /* New conversation button styles */
        .new-conversation-btn {
            border: 1px solid #E5E6E2;
            color: #fff;
            padding: 8px 16px;
            font-size: 14px;
            font-family: var(--main-font-family);
            cursor: pointer;
            border-radius: 0;
            margin-left: 15px;
            margin-right: 16px;
            z-index: 9999;
            position: relative;
            display: block;
            visibility: visible;
            opacity: 1;
            background: transparent;
            outline: none;
            box-shadow: none;
        }

        .new-conversation-btn:hover {
            background: rgba(0, 0, 0, 0.05);
            border-color: #555;
        }
        
        /* Header layout with debugging */
        .header-left {
            display: flex;
            align-items: center;
            background: yellow !important;
            padding: 5px;
        }
        
        .header-center {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            background: green !important;
            padding: 5px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            position: relative;
            z-index: 1003;
            background: blue !important;
            padding: 5px;
        }
        
        .logo {
            font-family: 'Courier Prime', monospace;
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }

        /* Image grid styles */
        .image-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 100%;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        .image-placeholder {
            background: #e0e0e0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .microphone-icon {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 20px;
            height: 20px;
            background: #666;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .microphone-icon::before {
            content: '';
            width: 8px;
            height: 12px;
            background: #fff;
            border-radius: 2px;
        }

        .microphone-icon::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            width: 12px;
            height: 4px;
            background: #666;
            border-radius: 2px;
        }
        
        .header-title { 
            display: flex; 
            align-items: center; 
            font-size: 24px; 
            font-weight: 400; 
        }
        
        .header-nav { 
            display: flex; 
            align-items: center; 
            gap: 20px; 
        }
        
        .nav-link { 
            cursor: pointer; 
            color: #999; 
            padding-bottom: 2px; 
            text-decoration: none; 
            font-size: 14px; 
            border-bottom: 2px solid transparent; 
            transition: color 0.2s, border-bottom-color 0.2s; 
            font-weight: 400; 
        }
        
        .nav-link:hover { 
            color: #666; 
        }
        
        .nav-link.active-nav { 
            color: #000 !important; 
            border-bottom: none; 
            position: relative; 
            font-weight: 500;
        }
        
        .nav-link.active-nav::before { 
            content: '['; 
            margin-right: 3px; 
            color: #000;
            font-weight: normal;
        }
        
        .nav-link.active-nav::after { 
            content: ']'; 
            margin-left: 3px; 
            color: #000;
            font-weight: normal;
        }

        /* Grid Page Styles */
        .grid-page {
            display: block;
            padding-top: 60px; /* Account for fixed header */
        }

        .grid-page.hidden {
            display: none;
        }

        /* Main container matching app layout */
        .container {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 24px;
            background: transparent;
            overflow-y: auto;
            /* Hide scrollbar while keeping functionality */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* Internet Explorer 10+ */
        }
        
        /* Hide scrollbar for webkit browsers */
        .container::-webkit-scrollbar {
            display: none;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 30px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Card styles with subtle refinement */
        .card {
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(128, 128, 128, 0.15);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
            backdrop-filter: blur(10px);
        }

        .card:hover {
            border-color: rgba(128, 128, 128, 0.25);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .card-header {
            height: 180px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background: linear-gradient(135deg, var(--main-bg-color), rgba(247, 249, 243, 0.5));
        }

        .card-placeholder {
            width: 100px;
            height: 60px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(128, 128, 128, 0.2);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: #666;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .card-content {
            padding: 24px;
        }

        .card-title {
            font-size: 16px;
            font-weight: 600;
            color: #222;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .card-description {
            font-size: 13px;
            color: #555;
            line-height: 1.6;
            margin-bottom: 20px;
            font-weight: 400;
        }

        .card-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            font-size: 12px;
            color: #666;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 400;
        }

        .card-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 16px;
        }

        .play-button {
            flex: 1;
            background: #333;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 12px 16px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .play-button:hover {
            background: #000;
        }

        .copy-button {
            background: transparent;
            border: 1px solid rgba(128, 128, 128, 0.2);
            border-radius: 4px;
            color: #555;
            padding: 12px 14px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 500;
        }

        .copy-button:hover {
            background: rgba(128, 128, 128, 0.05);
            border-color: rgba(128, 128, 128, 0.3);
            color: #333;
        }

        /* Quiz CTA Section Styles */
        .quiz-cta-section {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 50px;
            width: 100%;
        }

        .quiz-cta-card {
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 32px;
            backdrop-filter: none;
            box-shadow: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            height: 300px;
            max-width: 400px;
        }

        .cta-content {
            text-align: center;
        }

        .cta-title {
            font-size: 24px;
            font-weight: 400;
            color: #222;
            margin-bottom: 16px;
            line-height: 1.3;
        }

        .cta-description {
            font-size: 14px;
            color: #555;
            line-height: 1.6;
            margin-bottom: 24px;
            font-weight: 400;
        }

        .main-cta-button {
            background: #171717;
            color: white;
            border: 1px solid #E5E6E2;
            border-radius: 0;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            font-family: 'Miriam Libre', sans-serif;
            box-shadow: none;
        }

        .main-cta-button:hover {
            background: #2c3e50;
            transform: none;
            box-shadow: none;
        }

        .quiz-answers-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 16px;
            height: 300px;
        }



        .card-author {
            text-align: center;
            padding: 16px 24px;
            background: rgba(247, 249, 243, 0.5);
            border-top: 1px solid rgba(128, 128, 128, 0.1);
            font-size: 13px;
            font-weight: 500;
            color: #444;
        }

        /* Questionnaire Page Styles matching main app layout */
        .questionnaire-page {
            display: none;
            height: 100vh;
            overflow: hidden;
            padding-top: 60px; /* Account for fixed header */
        }

        .questionnaire-page.active {
            display: block;
        }

        .questionnaire-container {
            display: flex;
            height: calc(100vh - 60px); /* Subtract header height */
            background: transparent;
            align-items: flex-end;
        }

        /* Sidebar matching main app style - positioned on right side */
        .sidebar {
            width: 320px;
            background: #F7F9F2;
            border-left: 1px solid #BFC4C0;
            display: flex;
            flex-direction: column;
            box-shadow: none;
            position: fixed;
            right: 0;
            top: 0;
            height: 100%;
            z-index: 10;
            transform: translateX(0);
            font-family: 'Miriam Libre', sans-serif !important;
            /* Hide scrollbar while keeping functionality */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* Internet Explorer 10+ */
        }
        
        /* Hide scrollbar for webkit browsers */
        .sidebar::-webkit-scrollbar {
            display: none;
        }

        /* Hide sidebar during webcam experience */
        .webcam-active .sidebar {
            display: none !important;
        }

        .webcam-active .canvas-panel {
            margin-right: 10px !important;
        }

        /* Main Canvas matching app layout canvas */
        .canvas-panel {
            flex: 1;
            background: transparent;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
            position: relative;
            margin: 10px;
            margin-right: 340px; /* Space for right sidebar */
        }

        .canvas-title {
            position: absolute;
            top: 30px;
            text-align: center;
            width: 100%;
            z-index: 5;
        }

        .canvas-main-title {
            font-size: 18px;
            font-weight: 600;
            color: #222;
            margin-bottom: 6px;
            text-shadow: 1px 1px 3px rgba(255, 255, 255, 0.8);
        }

        .canvas-subtitle {
            font-size: 13px;
            color: #555;
            font-weight: 400;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }

        #webcamCanvas {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 0;
            font-family: 'Courier Prime', monospace;
            box-shadow: none;
            outline: none;
        }

        #videoElement {
            display: none;
        }

        .webcam-status {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border: 1px solid rgba(128, 128, 128, 0.2);
            border-radius: 20px;
            font-size: 12px;
            color: #555;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Minimalistic Recording Interface */
        .minimalistic-interface {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--main-bg-color);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            font-family: 'Miriam Libre', sans-serif;
            text-align: center;
            padding-bottom: 5px;
        }

        .recording-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            max-width: 600px;
            width: 100%;
            padding: 20px;
            background: #f7f9f3;
            position: relative;
            margin-top: auto;
            margin-bottom: 10px;
        }

        .main-title {
            font-size: 18px;
            color: #333;
            font-weight: 400;
            margin: 0;
            direction: rtl;
            line-height: 1.3;
            text-align: center;
        }

        .subtitle {
            font-size: 14px;
            color: #8c8c8c;
            margin: 0;
            direction: rtl;
            line-height: 1.4;
            font-weight: normal;
        }

        .voice-input-container {
            width: 100%;
            position: relative;
        }

        .voice-input-field {
            width: 640px;
            height: 45px;
            background: transparent;
            border: 1px solid #e0e0e0;
            border-radius: 0;
            padding: 0 24px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: none;
            position: relative;
        }

        .voice-input-field.recording {
            border-color: #e0e0e0;
            box-shadow: none;
        }

        .mic-icon-small {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 4px;
            border-radius: 0;
            transition: all 0.2s ease;
        }

        .mic-icon-small:hover {
            background: rgba(0, 0, 0, 0.05);
            transform: scale(1.05);
        }

        .mic-icon-small svg {
            width: 18px;
            height: 18px;
            transition: all 0.2s ease;
        }

        .mic-icon-small:hover svg {
            stroke: #007bff;
        }

        .action-buttons {
            display: flex;
            gap: 22px;
            align-items: center;
        }

        .action-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0;
            transition: all 0.2s ease;
        }

        .action-btn:hover {
            background: rgba(0, 0, 0, 0.05);
            transform: scale(1.05);
        }

        .action-btn svg {
            width: 18px;
            height: 18px;
            transition: all 0.2s ease;
        }

        .action-btn:hover svg {
            stroke: #007bff;
        }

        .action-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Text Animation Styles */
        .animated-text {
            opacity: 1;
            transform: translateY(0);
        }

        .animated-text:nth-child(1) { animation-delay: 0s; }
        .animated-text:nth-child(2) { animation-delay: 0s; }
        .animated-text:nth-child(3) { animation-delay: 0s; }
        .animated-text:nth-child(4) { animation-delay: 0s; }
        .animated-text:nth-child(5) { animation-delay: 0s; }
        .animated-text:nth-child(6) { animation-delay: 0s; }

        @keyframes fadeInUp {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .voice-input-field {
            opacity: 1;
        }


        .animated-dots {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 4px;
            padding-left: 0;
            overflow: hidden;
            margin-left: 24px;
        }

        .dot {
            width: 3px;
            height: 3px;
            background: #ccc;
            border-radius: 0;
            transition: all 0.1s ease;
            transform-origin: center;
        }

        .dot.active {
            background: #007bff;
            transform: scale(1.2);
        }

        .dot.recording {
            background: #000;
        }

        .dot.volume-low {
            height: 6px;
            background: #000;
        }

        .dot.volume-medium {
            height: 12px;
            background: #000;
        }

        .dot.volume-high {
            height: 18px;
            background: #000;
        }

        .dot.volume-max {
            height: 24px;
            background: #000;
        }

        @keyframes dotPulse {
            0%, 100% { 
                transform: scale(1);
                background: #007bff;
            }
            50% { 
                transform: scale(1.5);
                background: #0056b3;
            }
        }

        .simple-record-button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #ddd;
            background: #fff;
            color: #666;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Miriam Libre', sans-serif;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .simple-record-button:hover {
            transform: scale(1.05);
            border-color: #007bff;
            color: #007bff;
        }

        .simple-record-button.recording {
            background: #e74c3c;
            border-color: #e74c3c;
            color: white;
            animation: pulse 1.5s infinite;
        }

        .simple-record-button .mic-icon {
            font-size: 20px;
        }

        .simple-record-button .mic-text {
            display: none;
        }

        .simple-status {
            font-size: 16px;
            color: #6c757d;
            direction: rtl;
            min-height: 25px;
        }

        .simple-status.recording {
            color: #e74c3c;
            font-weight: 600;
        }

        /* Blob Visualization State */
        .blob-visualization-active .minimalistic-interface {
            display: none;
        }

        .blob-visualization-active .canvas-panel {
            background: var(--main-bg-color);
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 500;
        }

        /* Back Button for Blob Visualization */
        .blob-back-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(44, 62, 80, 0.9);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Miriam Libre', sans-serif;
            font-size: 14px;
            font-weight: 500;
            z-index: 1001;
            transition: all 0.3s ease;
            direction: rtl;
        }

        .blob-back-button:hover {
            background: rgba(44, 62, 80, 1);
            transform: scale(1.05);
        }

        /* Voice Interface Styles - Keep for later use */
        .voice-interface {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            padding: 20px;
            font-family: 'Miriam Libre', sans-serif;
        }

        .voice-header {
            text-align: center;
            margin-bottom: 20px;
            direction: rtl;
        }

        .voice-header h3 {
            font-size: 24px;
            color: #2c3e50;
            margin: 0 0 10px 0;
            font-weight: 600;
        }

        .voice-header p {
            font-size: 16px;
            color: #6c757d;
            margin: 0;
        }

        .voice-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: rgba(247, 249, 242, 0.8);
            border-radius: 12px;
            margin-bottom: 20px;
            min-height: 150px;
        }

        .message {
            margin-bottom: 15px;
            animation: fadeIn 0.3s ease-in;
        }

        .ai-message .message-content {
            background: #e3f2fd;
            color: #1565c0;
            padding: 15px 20px;
            border-radius: 18px 18px 18px 4px;
            max-width: 80%;
            font-size: 16px;
            line-height: 1.5;
            direction: rtl;
            text-align: right;
        }

        .user-message .message-content {
            background: #2c3e50;
            color: white;
            padding: 15px 20px;
            border-radius: 18px 18px 4px 18px;
            max-width: 80%;
            margin-left: auto;
            font-size: 16px;
            line-height: 1.5;
            direction: rtl;
            text-align: right;
        }

        .voice-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .voice-recording-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .record-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-family: 'Miriam Libre', sans-serif;
            box-shadow: 0 4px 15px rgba(44, 62, 80, 0.3);
        }

        .record-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(44, 62, 80, 0.4);
        }

        .record-button.recording {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            animation: pulse 1.5s infinite;
        }

        .microphone-icon {
            font-size: 32px;
        }

        #recordButtonText {
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            line-height: 1.2;
        }

        .recording-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #e74c3c;
            font-weight: 600;
            font-size: 16px;
        }

        .pulse {
            width: 12px;
            height: 12px;
            background: #e74c3c;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        .voice-waveform {
            display: flex;
            align-items: center;
            gap: 4px;
            height: 40px;
        }

        .wave-bar {
            width: 4px;
            background: #2c3e50;
            border-radius: 2px;
            animation: wave 1.5s infinite ease-in-out;
        }

        .wave-bar:nth-child(1) { animation-delay: 0s; }
        .wave-bar:nth-child(2) { animation-delay: 0.1s; }
        .wave-bar:nth-child(3) { animation-delay: 0.2s; }
        .wave-bar:nth-child(4) { animation-delay: 0.3s; }
        .wave-bar:nth-child(5) { animation-delay: 0.4s; }

        .voice-status {
            text-align: center;
            color: #6c757d;
            font-size: 14px;
            margin-bottom: 10px;
            direction: rtl;
            min-height: 20px;
        }

        .transcription-preview {
            background: rgba(247, 249, 242, 0.9);
            border-radius: 12px;
            padding: 15px;
            direction: rtl;
            text-align: right;
        }

        .transcription-preview h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 16px;
        }

        .transcription-preview p {
            margin: 0;
            color: #34495e;
            font-size: 15px;
            line-height: 1.4;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.95); }
        }

        @keyframes wave {
            0%, 100% { height: 10px; }
            50% { height: 30px; }
        }

        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 500;
        }

        .processing-message {
            text-align: center;
            color: white;
            font-family: 'Miriam Libre', sans-serif;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Analysis Results Screen Styles */
        .analysis-results {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(247, 249, 243, 0.98);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .analysis-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 2px solid #d0d0d0;
        }

        .analysis-content h2 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 25px;
            font-size: 24px;
            font-weight: 600;
        }

        .analysis-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .analysis-section h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 16px;
            font-weight: 600;
        }

        .transcription-text {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            font-style: italic;
            color: #495057;
            line-height: 1.5;
        }

        .emotion-result {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .primary-emotion {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 16px;
        }

        .confidence {
            background: #e8f5e8;
            color: #2d5a2d;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
        }

        .emotions-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .emotion-tag {
            background: #f0f8ff;
            color: #2c5aa0;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 14px;
            border: 1px solid #b8d4f0;
        }

        .parameters-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .parameter-item {
            background: white;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .parameter-item.effect-param {
            background: linear-gradient(135deg, #e8f5e8 0%, #f0f8ff 100%);
            border: 1px solid #20c997;
            position: relative;
            overflow: hidden;
        }

        .parameter-item.effect-param::before {
            content: '✨';
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 12px;
            opacity: 0.7;
        }

        .param-label {
            font-weight: 600;
            color: #495057;
        }

        .effect-param .param-label {
            color: #2d5a2d;
        }

        .param-value {
            color: #6c757d;
            margin-right: 5px;
        }

        .effect-param .param-value {
            color: #155724;
            font-weight: 600;
        }

        .analysis-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }

        .start-camera-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .start-camera-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
        }

        .back-btn {
            background: transparent;
            color: #6c757d;
            border: 2px solid #dee2e6;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            border-color: #adb5bd;
            color: #495057;
        }

        .sidebar-header {
            padding: 20px;
            text-align: right;
            background: #F7F9F2;
            direction: rtl;
            margin-bottom: 0;
            border-bottom: 1px solid #BFC4C0;
        }

        .progress-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .progress-text {
            font-size: 14px;
            color: #6c757d;
            font-weight: 500;
            font-family: 'Miriam Libre', sans-serif;
        }

        .progress-percentage {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            font-family: 'Miriam Libre', sans-serif;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #BFC4C0;
            border-radius: 2px;
            margin-bottom: 6px;
            position: relative;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #171717;
            width: 20%;
            transition: width 0.4s ease;
            border-radius: 2px;
        }

        .question-section {
            flex: 1;
            margin-bottom: 24px;
            padding: 12px 8px;
            background: #F7F9F2;
            font-family: 'Miriam Libre', sans-serif !important;
        }

        .question-title {
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 24px;
            line-height: 1.4;
            font-family: 'Miriam Libre', sans-serif;
            text-align: right;
            direction: rtl;
        }

        .options-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 30px;
        }

        .option {
            background: transparent;
            border: 1px solid #BFC4C0;
            border-radius: 0;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            color: #6c757d;
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
            font-family: 'Miriam Libre', sans-serif;
            text-align: right;
            direction: rtl;
        }

        .option:hover {
            border-color: #171717;
            background: #F7F9F2;
            color: #495057;
        }

        .option.selected {
            border-color: #171717;
            background: #F7F9F2;
            color: #2c3e50;
            font-weight: 600;
        }

        .option-radio {
            width: 10px;
            height: 10px;
            border: 1px solid #BFC4C0;
            background: transparent;
            border-radius: 50%;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }

        .option.selected .option-radio {
            background: #171717;
            border-color: #171717;
            transform: scale(1.1);
        }

        .navigation {
            display: flex;
            gap: 10px;
            margin-bottom: 24px;
            padding: 12px 8px;
            background: #F7F9F2;
        }

        .nav-button {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            border-radius: 0;
            font-family: 'Miriam Libre', sans-serif;
        }

        .prev-button {
            background: transparent;
            color: #6c757d;
            border: 1px solid #E5E6E2;
            flex: 0 0 auto;
        }

        .prev-button:hover {
            background: #F7F9F2;
            border-color: #171717;
            color: #495057;
        }

        .next-button {
            background: transparent;
            color: #6c757d;
            flex: 1;
            border: 1px solid #E5E6E2;
        }

        .next-button:hover:not(:disabled) {
            background: #F7F9F2;
            border-color: #171717;
            color: #495057;
        }

        .current-cases {
            padding: 12px 8px;
            background: #F7F9F2;
            font-size: 14px;
            color: #6c757d;
            font-family: 'Miriam Libre', sans-serif;
            text-align: right;
            direction: rtl;
            border-top: 1px solid #BFC4C0;
        }

        .next-button:disabled {
            background: rgba(128, 128, 128, 0.2);
            cursor: not-allowed;
            transform: none;
        }

        .current-cases {
            padding: 16px;
            background: rgba(247, 249, 243, 0.8);
            border: 1px solid rgba(128, 128, 128, 0.1);
            border-radius: 6px;
            font-size: 14px;
            color: #555;
            font-weight: 500;
            backdrop-filter: blur(5px);
        }



        /* Responsive Design matching main app */
        @media (max-width: 1024px) {
            .sidebar {
                width: 350px;
                padding: 24px 20px;
            }
        }

        @media (max-width: 768px) {
            .app-header {
                padding: 12px 20px;
            }

            .header-title span {
                font-size: 24px !important;
            }

            .container {
                padding: 16px;
            }

            .grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .card-content {
                padding: 20px;
            }

            .card-author {
                padding: 14px 20px;
            }

            .quiz-cta-section {
                grid-template-columns: 1fr;
                gap: 24px;
                margin-bottom: 40px;
            }

            .quiz-cta-card {
                height: auto;
                padding: 24px;
            }

            .cta-title {
                font-size: 20px;
            }

            .quiz-answers-grid {
                grid-template-columns: repeat(2, 1fr);
                grid-template-rows: repeat(3, 1fr);
                height: auto;
                min-height: 250px;
            }

            .questionnaire-container {
                flex-direction: column;
                height: calc(100vh - 60px);
            }

            .canvas-panel {
                height: 40vh;
                padding: 20px;
                order: 1;
            }

            .sidebar {
                width: 100%;
                height: 60vh;
                padding: 20px 16px;
                order: 2;
                border-radius: 8px 8px 0 0;
                margin: 0;
            }

            .question-title {
                font-size: 15px;
            }

            #webcamCanvas {
                max-width: 95%;
                max-height: 80%;
                border: none;
                outline: none;
                box-shadow: none;
            }
        }

        @media (max-width: 480px) {
            .app-header {
                padding: 10px 16px;
            }

            .header-nav {
                gap: 15px;
            }

            .nav-link {
                font-size: 13px;
            }

            .sidebar {
                padding: 16px 12px;
            }

            .canvas-panel {
                padding: 16px;
            }

            .quiz-cta-section {
                gap: 20px;
                margin-bottom: 30px;
            }

            .quiz-cta-card {
                padding: 20px;
            }

            .cta-title {
                font-size: 18px;
            }

            .cta-description {
                font-size: 13px;
            }

            .main-cta-button {
                padding: 14px 20px;
                font-size: 15px;
            }

            .quiz-answers-grid {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(6, 1fr);
                gap: 12px;
                min-height: 300px;
            }


        }
    </style>
</head>
<body>
            <!-- Main Navigation Header matching main app -->
        <header class="app-header">
            <div class="header-left">
                <div class="logo">1:?</div>
            </div>
            <div class="header-center">
                <nav class="header-nav">
                    <a href="#" class="nav-link">שיחות</a>
                    <a href="#" class="nav-link active-nav">[מעבדת שיחות]</a>
                    <a href="#" class="nav-link">רשומות</a>
                    <a href="#" class="nav-link">על הפרויקט</a>
                </nav>
            </div>
            <div class="header-right">
                <div class="new-conversation-btn" onclick="showQuestionnaire(); return false;">צור שיחה חדשה</div>
            </div>
        </header>

    <!-- Grid Page -->
    <div class="grid-page" id="gridPage">

        <div class="container">

            
            <!-- Image Grid based on reference -->
            <div class="image-grid">
                <div class="image-placeholder"></div>
                <div class="image-placeholder"></div>
                <div class="image-placeholder"></div>
                <div class="image-placeholder"></div>
                <div class="image-placeholder"></div>
                <div class="image-placeholder"></div>
                <div class="image-placeholder"></div>
                <div class="image-placeholder"></div>
                <div class="image-placeholder"></div>
                <div class="image-placeholder"></div>
                <div class="image-placeholder"></div>
                <div class="image-placeholder"></div>
            </div>


            </div>
        </div>
    </div>

    <!-- Questionnaire Page -->
    <div class="questionnaire-page" id="questionnairePage">
        <div class="questionnaire-container">
            <!-- Minimalistic Recording Interface -->
            <div class="minimalistic-interface" id="minimalisticInterface" style="display: none;">
                <div class="recording-section">
                    <h1 class="main-title">ספר על שיחה משמעותית שהייתה לך בזמן האחרון</h1>
                    <p class="subtitle"></p>
                    
                    <!-- ✨ FULL VISUALIZATION AREA - Like visualization.html but without sidebar -->
                    <div id="fullVisualizationArea" style="
                        width: 100%;
                        height: 500px;
                        margin: 20px 0 30px 0;
                        border: 1px solid #BFC4C0;
                        border-radius: 8px;
                        background: #f7f9f3;
                        position: relative;
                        overflow: hidden;
                        transition: all 0.3s ease;
                        margin-top: 120px;
                    ">
                        <!-- Main visualization canvas (like visualization.html) -->
                        <div id="main-content-wrapper" style="
                            width: 100% !important;
                            height: 100% !important;
                            position: relative !important;
                            background: #f7f9f3 !important;
                            overflow: hidden !important;
                        ">
                                                         <!-- Visualization canvas container -->
                             <div id="visualization-canvas-container" style="
                                 width: 100% !important;
                                 height: 100% !important;
                                 position: relative !important;
                                 background: #f7f9f3 !important;
                                 overflow: hidden !important;
                             "></div>
                         </div>
                         
                                                   <!-- Control buttons -->
                          <div style="position: absolute; top: 10px; left: 10px; z-index: 10;">
                              <button onclick="returnToRecording()" style="
                                background: rgba(255,255,255,0.9);
                                border: none;
                                border-radius: 20px;
                                padding: 8px 16px;
                                cursor: pointer;
                                font-size: 12px;
                                font-family: var(--main-font-family);
                                transition: all 0.3s ease;
                            " onmouseover="this.style.background='rgba(255,255,255,1)'" onmouseout="this.style.background='rgba(255,255,255,0.9)'">
                                🔄 הקלט מחדש
                            </button>
                          </div>

                        <!-- Audio Playback Controls -->
                        <div id="audioPlaybackControls" style="
                            position: absolute;
                            top: 10px;
                            right: 10px;
                            background: rgba(0,0,0,0.8);
                            border-radius: 25px;
                            padding: 10px 15px;
                            display: none;
                            z-index: 15;
                            color: white;
                            font-family: var(--main-font-family);
                            font-size: 12px;
                            align-items: center;
                            gap: 10px;
                        ">
                            <button id="playPauseBtn" onclick="toggleAudioPlayback()" style="
                                background: none;
                                border: none;
                                color: white;
                                font-size: 16px;
                                cursor: pointer;
                                padding: 5px;
                                border-radius: 50%;
                                transition: all 0.3s ease;
                            " onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='none'">
                                ⏸️
                            </button>
                            <span id="audioStatus">מנגן את ההקלטה...</span>
                            <button id="replayBtn" onclick="replayAudio()" style="
                                background: none;
                                border: none;
                                color: white;
                                font-size: 14px;
                                cursor: pointer;
                                padding: 5px;
                                border-radius: 50%;
                                transition: all 0.3s ease;
                            " onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='none'">
                                🔄
                            </button>
                        </div>

                        <!-- Manual Play Button (for when auto-play is blocked) -->
                        <div id="manualPlayButton" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background: rgba(0,0,0,0.8);
                            border-radius: 30px;
                            padding: 20px 30px;
                            display: none;
                            z-index: 20;
                            color: white;
                            font-family: var(--main-font-family);
                            text-align: center;
                            cursor: pointer;
                            transition: all 0.3s ease;
                        " onclick="startManualPlayback()" onmouseover="this.style.background='rgba(0,0,0,0.9)'" onmouseout="this.style.background='rgba(0,0,0,0.8)'">
                            <div style="font-size: 24px; margin-bottom: 10px;">🎵</div>
                            <div style="font-size: 14px;">לחץ להשמעת ההקלטה</div>
                        </div>

                                                    <!-- This is where the sketch.js visualization will appear -->
                        <div id="p5-sketch-container" style="
                            width: 100% !important; 
                            height: 100% !important; 
                            position: relative !important; 
                            z-index: 5 !important;
                            background: transparent !important;
                            display: block !important;
                            visibility: visible !important;
                            opacity: 1 !important;
                            overflow: hidden !important;
                            border: 1px solid rgb(159, 159, 159) !important;
                            box-sizing: border-box !important;
                        "></div>
                        
                        <!-- EMERGENCY FALLBACK CANVAS -->
                        <canvas id="emergencyCanvas" width="800" height="400" style="
                            position: absolute !important;
                            top: 0 !important;
                            left: 0 !important;
                            width: 100% !important;
                            height: 100% !important;
                            z-index: 100 !important;
                            border: 1px solid rgb(159, 159, 159) !important;
                            display: block !important;
                        "></canvas>
                        <!-- Alternative container that sketch.js looks for -->
                        <div id="visualization-canvas-container" style="
                            width: 100% !important; 
                            height: 100% !important; 
                            position: relative !important; 
                            top: 0 !important; 
                            left: 0 !important; 
                            z-index: 5 !important;
                            background: #000 !important;
                            border: 1px solid rgb(159, 159, 159) !important;
                            display: block !important;
                            visibility: visible !important;
                            opacity: 1 !important;
                            box-sizing: border-box !important;
                        "></div>
                        </div>
                        
                        <!-- Empty state message -->
                        <div id="visualizationPlaceholder" style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            text-align: center;
                            color: #999;
                            font-family: var(--main-font-family);
                            font-size: 16px;
                            z-index: 5;
                        ">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10" stroke="#BFC4C0" stroke-width="2" fill="none"/>
                                <path d="M8 12l2 2 4-4" stroke="#BFC4C0" stroke-width="2" fill="none"/>
                            </svg>
                            <div style="margin-top: 10px;">הוויזואליזציה תופיע כאן לאחר הניתוח</div>
                        </div>
                    </div>

                    <!-- Test Button (Always Visible) -->
                    <div style="text-align: center; margin: 15px 0;">
                        <button onclick="testVisualization()" style="
                            background: linear-gradient(135deg, #4CAF50, #45a049);
                            color: white;
                            border: none;
                            border-radius: 20px;
                            padding: 10px 20px;
                            cursor: pointer;
                            font-size: 14px;
                            font-family: var(--main-font-family);
                            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
                            transition: all 0.3s ease;
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                            🧪 בדיקה מהירה
                        </button>
                    </div>

                    <div class="voice-input-container" style="margin-top: 30px;">
                        <div class="voice-input-field" id="voiceInputField" onclick="startConversationFlow()" style="cursor: pointer;">
                            
                            <div class="mic-icon-small" id="micIcon">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect x="9" y="2" width="6" height="10" stroke="#333" stroke-width="2" fill="none"/>
                                    <line x1="12" y1="12" x2="12" y2="18" stroke="#333" stroke-width="2"/>
                                    <line x1="8" y1="18" x2="16" y2="18" stroke="#333" stroke-width="2"/>
                                    <line x1="10" y1="20" x2="14" y2="20" stroke="#333" stroke-width="2"/>
                                </svg>
                            </div>
                            <div class="action-buttons" id="actionButtons" style="display: none;" onclick="event.stopPropagation();">
                                <button class="action-btn check-btn" onclick="event.stopPropagation(); stopConversationFlow()" title="אישור">
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" stroke="#333" stroke-width="2" fill="none"/>
                                    </svg>
                                </button>
                                <button class="action-btn cancel-btn" onclick="event.stopPropagation(); cancelRecording()" title="ביטול">
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" stroke="#333" stroke-width="2" fill="none"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="animated-dots" id="animatedDots">
                                <div class="dot" data-index="0"></div>
                                <div class="dot" data-index="1"></div>
                                <div class="dot" data-index="2"></div>
                                <div class="dot" data-index="3"></div>
                                <div class="dot" data-index="4"></div>
                                <div class="dot" data-index="5"></div>
                                <div class="dot" data-index="6"></div>
                                <div class="dot" data-index="7"></div>
                                <div class="dot" data-index="8"></div>
                                <div class="dot" data-index="9"></div>
                                <div class="dot" data-index="10"></div>
                                <div class="dot" data-index="11"></div>
                                <div class="dot" data-index="12"></div>
                                <div class="dot" data-index="13"></div>
                                <div class="dot" data-index="14"></div>
                                <div class="dot" data-index="15"></div>
                                <div class="dot" data-index="16"></div>
                                <div class="dot" data-index="17"></div>
                                <div class="dot" data-index="18"></div>
                                <div class="dot" data-index="19"></div>
                                <div class="dot" data-index="20"></div>
                                <div class="dot" data-index="21"></div>
                                <div class="dot" data-index="22"></div>
                                <div class="dot" data-index="23"></div>
                                <div class="dot" data-index="24"></div>
                                <div class="dot" data-index="25"></div>
                                <div class="dot" data-index="26"></div>
                                <div class="dot" data-index="27"></div>
                                <div class="dot" data-index="28"></div>
                                <div class="dot" data-index="29"></div>
                                <div class="dot" data-index="30"></div>
                                <div class="dot" data-index="31"></div>
                                <div class="dot" data-index="32"></div>
                                <div class="dot" data-index="33"></div>
                                <div class="dot" data-index="34"></div>
                                <div class="dot" data-index="35"></div>
                                <div class="dot" data-index="36"></div>
                                <div class="dot" data-index="37"></div>
                                <div class="dot" data-index="38"></div>
                                <div class="dot" data-index="39"></div>
                                <div class="dot" data-index="40"></div>
                                <div class="dot" data-index="41"></div>
                                <div class="dot" data-index="42"></div>
                                <div class="dot" data-index="43"></div>
                                <div class="dot" data-index="44"></div>
                                <div class="dot" data-index="45"></div>
                                <div class="dot" data-index="46"></div>
                                <div class="dot" data-index="47"></div>
                                <div class="dot" data-index="48"></div>
                                <div class="dot" data-index="49"></div>
                                <div class="dot" data-index="50"></div>
                                <div class="dot" data-index="51"></div>
                                <div class="dot" data-index="52"></div>
                                <div class="dot" data-index="53"></div>
                                <div class="dot" data-index="54"></div>
                                <div class="dot" data-index="55"></div>
                                <div class="dot" data-index="56"></div>
                                <div class="dot" data-index="57"></div>
                                <div class="dot" data-index="58"></div>
                                <div class="dot" data-index="59"></div>
                                <div class="dot" data-index="60"></div>
                                <div class="dot" data-index="61"></div>
                                <div class="dot" data-index="62"></div>
                                <div class="dot" data-index="63"></div>
                                <div class="dot" data-index="64"></div>
                                <div class="dot" data-index="65"></div>
                                <div class="dot" data-index="66"></div>
                                <div class="dot" data-index="67"></div>
                                <div class="dot" data-index="68"></div>
                                <div class="dot" data-index="69"></div>
                                <div class="dot" data-index="70"></div>
                                <div class="dot" data-index="71"></div>
                                <div class="dot" data-index="72"></div>
                                <div class="dot" data-index="73"></div>
                                <div class="dot" data-index="74"></div>
                                <div class="dot" data-index="75"></div>
                                <div class="dot" data-index="76"></div>
                                <div class="dot" data-index="77"></div>
                                <div class="dot" data-index="78"></div>
                                <div class="dot" data-index="79"></div>
                                <div class="dot" data-index="80"></div>
                                <div class="dot" data-index="81"></div>
                                <div class="dot" data-index="82"></div>
                                <div class="dot" data-index="83"></div>
                                <div class="dot" data-index="84"></div>
                                <div class="dot" data-index="85"></div>
                                <div class="dot" data-index="86"></div>
                                <div class="dot" data-index="87"></div>
                                <div class="dot" data-index="88"></div>
                                <div class="dot" data-index="89"></div>
                                <div class="dot" data-index="90"></div>
                                <div class="dot" data-index="91"></div>
                                <div class="dot" data-index="92"></div>
                                <div class="dot" data-index="93"></div>
                                <div class="dot" data-index="94"></div>
                                <div class="dot" data-index="95"></div>
                                <div class="dot" data-index="96"></div>
                                <div class="dot" data-index="97"></div>
                                <div class="dot" data-index="98"></div>
                                <div class="dot" data-index="99"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="simple-status" id="simpleStatus"></div>
                    
                    <!-- Save Conversation Button -->
                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="saveWizardConversation()" style="
                            background: linear-gradient(135deg, #28a745, #20c997);
                            color: white;
                            border: none;
                            border-radius: 25px;
                            padding: 12px 24px;
                            cursor: pointer;
                            font-size: 16px;
                            font-family: var(--main-font-family);
                            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
                            transition: all 0.3s ease;
                            display: none;
                        " id="saveConversationBtn" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                            💾 שמור שיחה
                        </button>
                    </div>
                </div>
            </div>

            <!-- Voice Recording Interface (initially hidden) -->
            <div class="voice-interface" id="voiceInterface" style="display: none;">
                <div class="voice-header">
                    <h3 class="animated-text">ספר לי על השיחה האחרונה שלך</h3>
                    <p class="animated-text">לחץ על המיקרופון ותאר בעברית את השיחה המשמעותית האחרונה שניהלת</p>
                </div>
                
                <div class="voice-messages" id="voiceMessages">
                    <div class="message ai-message">
                        <div class="message-content animated-text">
                            שלום! בואו נתחיל ביצירת התמונה שלך. לחץ על המיקרופון וספר לי בכמה מילים על השיחה המשמעותית האחרונה שניהלת - איך הרגשת? מה היה הנושא? איך היה הטון?
                        </div>
                    </div>
                </div>

                            <!-- Enhanced Microphone Interface (Hidden - using existing UI) -->
            <div class="enhanced-microphone-container" id="enhancedMicContainer" style="
                display: none;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                border-radius: 20px;
                padding: 30px;
                margin-bottom: 20px;
                text-align: center;
                box-shadow: 0 10px 30px rgba(0,0,0,0.1);
                position: relative;
                overflow: hidden;
            ">
                <div class="conversation-flow-header" style="
                    color: white;
                    font-size: 24px;
                    font-weight: bold;
                    margin-bottom: 10px;
                ">🎙️ ספר על השיחה שלך</div>
                
                <div class="flow-description" style="
                    color: rgba(255,255,255,0.9);
                    font-size: 16px;
                    margin-bottom: 30px;
                    line-height: 1.5;
                ">תאר את השיחה שהייתה לך → נתמלל → נציג את הרגשות</div>
                
                <div class="enhanced-record-button-container">
                    <button id="enhancedRecordButton" class="enhanced-record-button" onclick="startConversationFlow()" style="
                        background: white;
                        border: none;
                        border-radius: 50%;
                        width: 80px;
                        height: 80px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 32px;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                        margin: 0 auto 20px;
                    " onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">
                        🎤
                    </button>
                </div>
                
                <div class="conversation-status" id="conversationStatus" style="
                    color: white;
                    font-size: 18px;
                    font-weight: 500;
                    min-height: 25px;
                "></div>
                
                <!-- Conversation Results Container -->
                <div class="conversation-results" id="conversationResults" style="
                    background: rgba(255,255,255,0.1);
                    border-radius: 15px;
                    padding: 20px;
                    margin-top: 20px;
                    text-align: right;
                    display: none;
                ">
                    <div class="conversation-transcription" id="conversationTranscription" style="
                        background: rgba(255,255,255,0.9);
                        border-radius: 10px;
                        padding: 15px;
                        margin-bottom: 15px;
                        color: #333;
                        text-align: right;
                        line-height: 1.6;
                    "></div>
                    
                    <div class="conversation-emotions" id="conversationEmotions" style="
                        display: flex;
                        flex-wrap: wrap;
                        gap: 10px;
                        justify-content: center;
                        margin-bottom: 15px;
                    "></div>
                    
                    <button class="view-visualization-btn" id="viewVisualizationBtn" onclick="showConversationVisualization()" style="
                        background: #4CAF50;
                        color: white;
                        border: none;
                        padding: 12px 24px;
                        border-radius: 8px;
                        font-size: 16px;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        display: none;
                    ">צפה בוויזואליזציה 🎨</button>
                </div>
            </div>

            <div class="voice-controls animated-text">
                <div class="voice-recording-area">
                    <button id="recordButton" class="record-button" onclick="toggleRecording()">
                        <div class="microphone-icon">🎤</div>
                        <span id="recordButtonText">התחל הקלטה</span>
                    </button>
                    <div class="recording-indicator" id="recordingIndicator" style="display: none;">
                        <div class="pulse"></div>
                        <span>מקליט...</span>
                    </div>
                </div>
                
                <div class="voice-waveform" id="voiceWaveform" style="display: none;">
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                </div>
            </div>
            
            <div class="voice-status" id="voiceStatus"></div>
            <div class="transcription-preview" id="transcriptionPreview" style="display: none;">
                <h4>מה שמעתי:</h4>
                <p id="transcriptionText"></p>
            </div>
            </div>

            <!-- Main Canvas -->
            <div class="canvas-panel">
                <video id="videoElement" autoplay muted></video>
                <canvas id="webcamCanvas"></canvas>
                <button class="blob-back-button" id="blobBackButton" onclick="returnToRecording()" style="display: none;">חזור להקלטה</button>
                <div class="canvas-overlay" id="canvasOverlay" style="display: none;">
                    <div class="processing-message">
                        <div class="spinner"></div>
                        <p>מפעיל מצלמה חיה עם הגדרות רגשיות מותאמות...</p>
                    </div>
                </div>
            </div>
        </div>


    </div>

    <script>
        // Voice Recording Variables - Declared at the top to avoid hoisting issues
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let dotAnimationId = null;
        let activeDots = [];

        // Initialize text animations when page loads
        function initializeTextAnimations() {
            // Reset all animated elements to initial state
            const animatedElements = document.querySelectorAll('.animated-text');
            animatedElements.forEach(element => {
                element.style.opacity = '0';
                element.style.transform = 'translateY(20px)';
            });
            
            // Trigger animations after a short delay
            setTimeout(() => {
                animatedElements.forEach((element, index) => {
                    element.style.animation = `fadeInUp 0.8s ease forwards ${index * 0.2}s`;
                });
            }, 100);
        }

        // Audio visualization variables
        let dataArray = null;
        let isVisualizing = false;

        // Initialize audio visualization
        function initializeAudioVisualization() {
            if (audioContext) return; // Already initialized
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
        }

        // Start audio visualization
        function startAudioVisualization(stream) {
            if (!audioContext) {
                initializeAudioVisualization();
            }
            
            microphone = audioContext.createMediaStreamSource(stream);
            microphone.connect(analyser);
            
            isVisualizing = true;
            updateDotsVisualization();
        }

        // Update dots based on audio volume
        function updateDotsVisualization() {
            if (!isVisualizing || !analyser) return;
            
            analyser.getByteFrequencyData(dataArray);
            
            // Calculate average volume
            const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
            const volume = average / 255; // Normalize to 0-1
            
            // Get all dots
            const dots = document.querySelectorAll('.dot');
            const numDots = dots.length;
            
            // Update each dot based on volume and position
            dots.forEach((dot, index) => {
                // Create a wave pattern based on volume and position
                const waveOffset = (index / numDots) * Math.PI * 2;
                const timeOffset = Date.now() * 0.01;
                const waveValue = Math.sin(waveOffset + timeOffset) * volume;
                
                // Calculate dot height based on volume and wave
                let dotHeight = 3; // Base height
                let volumeClass = '';
                
                if (volume > 0.1) {
                    const heightMultiplier = 1 + (waveValue * 8); // Scale the wave
                    dotHeight = Math.max(3, Math.min(24, 3 * heightMultiplier));
                    
                    if (dotHeight <= 6) volumeClass = 'volume-low';
                    else if (dotHeight <= 12) volumeClass = 'volume-medium';
                    else if (dotHeight <= 18) volumeClass = 'volume-high';
                    else volumeClass = 'volume-max';
                }
                
                // Apply the height and class
                dot.style.height = dotHeight + 'px';
                dot.className = 'dot ' + volumeClass;
            });
            
                         // ✨ Update ASCII blobs with audio data
             if (asciiBlobs.length > 0) {
                 // Calculate dominant frequency for emotion detection
                 let maxFreq = 0;
                 let dominantFreqIndex = 0;
                 for (let i = 0; i < dataArray.length; i++) {
                     if (dataArray[i] > maxFreq) {
                         maxFreq = dataArray[i];
                         dominantFreqIndex = i;
                     }
                 }
                 
                 // Convert frequency index to approximate frequency (simplified)
                 const dominantFrequency = (dominantFreqIndex / dataArray.length) * (analyser.context.sampleRate / 2);
                 
                 // Update ASCII blobs with audio data
                 updateASCIIBlobsWithAudio(volume, dominantFrequency);
             }
            
            // Continue animation
            animationId = requestAnimationFrame(updateDotsVisualization);
        }

        // Stop audio visualization
        function stopAudioVisualization() {
            isVisualizing = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Reset all dots
            const dots = document.querySelectorAll('.dot');
            dots.forEach(dot => {
                dot.style.height = '3px';
                dot.className = 'dot';
            });
        }

        // Simple Webcam variables with light effects - REPLACED WITH BLOB VISUALIZATION
        const canvas = document.getElementById('webcamCanvas');
        const video = document.getElementById('videoElement');
        
        console.log('Canvas element:', canvas);
        console.log('Video element:', video);
        
        if (!canvas) {
            console.error('Canvas not found!');
            console.log('Canvas not found, blob visualization will be limited');
        }
        
        const ctx = canvas ? canvas.getContext('2d') : null;
        
        let stream = null;
        let animationId = null;
        let isBlobVisualizationRunning = false;
        let processCanvas = null;
        let processCtx = null;
        let animationTime = 0;
        
        // ASCII BLOB VISUALIZATION FOR VOICE INPUT
        let currentVolumeLevel = 0;
        let currentEmotion = 'neutral';
        let emotionIntensity = 1.0;
        
        // BLOB VISUALIZATION VARIABLES (from sketch.js)
        let blobs = [];
        let gridsize = 50;
        let grid = [];
        let currentMeta = {};
        let emotionGlobalColorMap = {};
        
        // ✨ ASCII BLOB VISUALIZATION SYSTEM - Full implementation like sketch.js
        
        // ASCII metaball blob class - same implementation as sketch.js
        class ASCIIBlob {
            constructor(i, initialPos = {}) {
                this.pos = { x: initialPos.x || 400, y: initialPos.y || 300 };
                this.vel = { x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2 };
                this.targetPos = null;
                this.noiseOffset = { x: Math.random() * 1000, y: Math.random() * 1000 };
                this.timeOffset = Math.random() * 1000;
                this.cachedStrength = 0;
                this.audioLevel = 0;
                this.smoothedAudioLevel = 0;
                this.id = i;
                this.currentEmotions = ['neutral'];
                this.displayColors = [[150, 150, 150]];
                this.humor = 0;
                this.shine = 0;
                this.isVisible = true;
                
                // Blob parameters (same as defaultBlobVisuals)
                this.blobStrength = 1000;
                this.blobSizeScale = 5;
                this.volumeImpact = 3000;
                this.blobSpreadField = 6.0;
                this.blobVisibility = 1.0;
                this.blobMotionRange = 0.4;
                this.breathSpeed = 0.0003;
                this.gradientStrength = 15;
                this.blobiness = 1.5;
                this.blur = 0;
                this.characterSpacing = 2;
                this.coloredCircleCharSize = 1;
                this.regularAsciiCharSize = 1;
                this.minBlobSpacing = "close";
                this.movementEasing = 0.03;
                this.blobDensity = 1.2;
                
                // Target values for smooth transitions
                this.target = { ...this };
            }
            
            setEmotions(emotions) {
                this.currentEmotions = emotions || ['neutral'];
                console.log(`🎭 ASCII Blob ${this.id} emotions set to:`, this.currentEmotions);
                
                // Set display colors based on emotions
                this.displayColors = emotions.map(emotion => {
                    return getEmotionColor(emotion) || [150, 150, 150];
                });
            }
            
            setTargetVisuals(newVisuals) {
                Object.assign(this.target, newVisuals);
                this.target.isVisible = newVisuals.isVisible !== false;
                console.log(`🎨 ASCII Blob ${this.id} target visuals updated:`, newVisuals);
            }
            
            update(time, audioLevel = 0) {
                this.audioLevel = audioLevel;
                this.smoothedAudioLevel = this.smoothedAudioLevel * 0.8 + audioLevel * 0.2;
                
                // Smooth transitions to target values
                const easing = this.movementEasing;
                this.blobStrength += (this.target.blobStrength - this.blobStrength) * easing;
                this.blobSizeScale += (this.target.blobSizeScale - this.blobSizeScale) * easing;
                this.blobVisibility += (this.target.blobVisibility - this.blobVisibility) * easing;
                this.blobMotionRange += (this.target.blobMotionRange - this.blobMotionRange) * easing;
                
                // Motion with noise
                const noiseScale = 0.01;
                const noiseStrength = this.blobMotionRange;
                this.pos.x += (noise(this.noiseOffset.x + time * noiseScale) - 0.5) * noiseStrength;
                this.pos.y += (noise(this.noiseOffset.y + time * noiseScale) - 0.5) * noiseStrength;
                
                // Audio response
                if (this.smoothedAudioLevel > 0.1) {
                    const audioResponse = this.smoothedAudioLevel * this.volumeImpact * 0.001;
                    this.blobSizeScale = Math.max(1, this.target.blobSizeScale + audioResponse);
                }
                
                // Breathing effect
                const breathEffect = Math.sin(time * this.breathSpeed) * 0.5 + 1;
                this.cachedStrength = this.blobStrength * breathEffect * this.blobVisibility;
            }
            
            // Calculate metaball strength at a given point (same as sketch.js)
            strengthAt(x, y) {
                if (!this.isVisible || this.blobVisibility <= 0) return 0;
                
                const dx = x - this.pos.x;
                const dy = y - this.pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance === 0) return this.cachedStrength;
                
                const radius = this.blobSizeScale * 20; // Scale factor
                const falloff = Math.max(0, 1 - (distance / radius));
                return this.cachedStrength * falloff * falloff; // Quadratic falloff
            }
        }
        
        // Helper functions for ASCII blob system
        
        // Simple noise function (simplified Perlin noise)
        function noise(x) {
            return (Math.sin(x * 12.9898) * 43758.5453123) % 1;
        }
        
        // Get emotion color (simplified version)
        function getEmotionColor(emotion) {
            const emotionColors = {
                'שמחה': [255, 200, 50],
                'עצב': [100, 150, 255], 
                'כעס': [255, 100, 100],
                'פחד': [200, 100, 255],
                'הפתעה': [255, 150, 255],
                'גאווה': [255, 180, 0],
                'סקרנות': [0, 255, 150],
                'אהבה': [255, 120, 150],
                'neutral': [150, 150, 150]
            };
            return emotionColors[emotion] || emotionColors['neutral'];
        }
        
        // ASCII character sets for different emotions
        const asciiCharSets = {
            'שמחה': '☀️🌟✨⭐🎉🎊💫⚡',
            'עצב': '💧🌧️☔💙🌊🔵',
            'כעס': '🔥💥⚡🌋💢⭕',
            'פחד': '👻💀⚠️🌪️💜',
            'הפתעה': '❗❓⚡✨💥',
            'גאווה': '👑💎🏆⭐🌟',
            'סקרנות': '🔍💡❓🎯🧠',
            'אהבה': '💖💕❤️💝💗',
            'neutral': '○●'
        };
        
        // ASCII Metaball Rendering System
        let asciiCanvas = null;
        let asciiCtx = null;
        let asciiBlobs = [];
        let asciiGrid = [];
        let asciiAnimationId = null;
        let asciiAnimationTime = 0;
        let asciiGridSize = 40;
        
        // Initialize ASCII blob visualization
        function initASCIIBlobVisualization() {
            asciiCanvas = document.getElementById('asciiBlobCanvas');
            if (!asciiCanvas) {
                console.error('ASCII blob canvas not found');
                return;
            }
            
            asciiCtx = asciiCanvas.getContext('2d');
            
            // Set canvas size
            asciiCanvas.width = 1200;
            asciiCanvas.height = 800;
            
            // Initialize grid
            asciiGrid = [];
            for (let i = 0; i < asciiGridSize; i++) {
                asciiGrid[i] = [];
                for (let j = 0; j < asciiGridSize; j++) {
                    asciiGrid[i][j] = 0;
                }
            }
            
            // Initialize blobs
            asciiBlobs = [];
            const centerX = asciiCanvas.width / 2;
            const centerY = asciiCanvas.height / 2;
            
            // Create 2 blobs - positioned like in main system
            for (let i = 0; i < 2; i++) {
                const x = centerX + (i === 0 ? -150 : 150);
                const blob = new ASCIIBlob(i, { x: x, y: centerY });
                blob.setEmotions(['neutral']);
                asciiBlobs.push(blob);
            }
            
            console.log('✅ ASCII blob visualization initialized');
        }

        // Start ASCII blob visualization
        function startASCIIBlobVisualization() {
            if (!asciiCanvas) {
                initASCIIBlobVisualization();
            }
            
            // Show the overlay
            const overlay = document.getElementById('asciiBlobVisualizationOverlay');
            if (overlay) {
                overlay.style.display = 'flex';
            }
            
            // Update status
            updateASCIIBlobStatus('מתכונן לתצוגה מקדימה...');
            
            // Start animation
            animateASCIIBlobs();
            
            console.log('🎭 Started ASCII blob visualization');
        }
        
        // Stop ASCII blob visualization
        function stopASCIIBlobVisualization() {
            // Hide the overlay
            const overlay = document.getElementById('asciiBlobVisualizationOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
            
            // Stop animation
            if (asciiAnimationId) {
                cancelAnimationFrame(asciiAnimationId);
                asciiAnimationId = null;
            }
            
            console.log('⏹️ Stopped ASCII blob visualization');
        }
        
        // Update status message
        function updateASCIIBlobStatus(message) {
            const statusElement = document.getElementById('asciiBlobStatus');
            if (statusElement) {
                statusElement.textContent = message;
            }
        }
        
        // Animate ASCII blobs with metaball rendering
        function animateASCIIBlobs() {
            if (!asciiCtx || !asciiBlobs.length) return;
            
            asciiAnimationTime += 16;
            
            // Update blobs
            asciiBlobs.forEach(blob => {
                blob.update(asciiAnimationTime, currentVolumeLevel);
            });
            
            // Render ASCII metaballs
            renderASCIIMetaballs();
            
            asciiAnimationId = requestAnimationFrame(animateASCIIBlobs);
        }
        
        // Render ASCII metaballs (same system as sketch.js)
        function renderASCIIMetaballs() {
            // Clear canvas
            asciiCtx.fillStyle = '#f7f9f3';
            asciiCtx.fillRect(0, 0, asciiCanvas.width, asciiCanvas.height);
            
            // Calculate metaball grid
            const cols = asciiGridSize;
            const rows = asciiGridSize;
            const cellWidth = asciiCanvas.width / cols;
            const cellHeight = asciiCanvas.height / rows;
            
            // Calculate strength at each grid point
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const worldX = x * cellWidth + cellWidth / 2;
                    const worldY = y * cellHeight + cellHeight / 2;
                    
                    let totalStrength = 0;
                    let dominantBlob = null;
                    let maxStrength = 0;
                    
                    // Calculate contribution from each blob
                    asciiBlobs.forEach(blob => {
                        const strength = blob.strengthAt(worldX, worldY);
                        totalStrength += strength;
                        
                        if (strength > maxStrength) {
                            maxStrength = strength;
                            dominantBlob = blob;
                        }
                    });
                    
                    asciiGrid[y][x] = totalStrength;
                    
                    // Draw ASCII character if strength is above threshold
                    const threshold = 0.5;
                    if (totalStrength > threshold && dominantBlob) {
                        drawASCIICharacter(x, y, dominantBlob, totalStrength, cellWidth, cellHeight);
                    }
                }
            }
        }
        
        // Draw ASCII character for blob
        function drawASCIICharacter(gridX, gridY, blob, strength, cellWidth, cellHeight) {
            const x = gridX * cellWidth + cellWidth / 2;
            const y = gridY * cellHeight + cellHeight / 2;
            
            // Get character based on emotion
            const emotion = blob.currentEmotions[0] || 'neutral';
            const chars = asciiCharSets[emotion] || asciiCharSets['neutral'];
            const charIndex = Math.floor((strength * chars.length)) % chars.length;
            const char = chars[charIndex];
            
            // Get color
            const color = blob.displayColors[0] || [150, 150, 150];
            const alpha = Math.min(1, strength * blob.blobVisibility);
            
            // Set font and style
            const fontSize = Math.max(8, Math.min(24, strength * 20 * blob.blobSizeScale * 0.1));
            asciiCtx.font = `${fontSize}px "Courier New", monospace`;
            asciiCtx.textAlign = 'center';
            asciiCtx.textBaseline = 'middle';
            asciiCtx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha})`;
            
            // Draw character
            asciiCtx.fillText(char, x, y);
            
            // Add glow effect for high intensity
            if (blob.shine > 0 && strength > 0.8) {
                asciiCtx.shadowColor = `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.5)`;
                asciiCtx.shadowBlur = blob.shine * 5;
                asciiCtx.fillText(char, x, y);
                asciiCtx.shadowBlur = 0;
            }
        }
        
        // Update ASCII blobs with audio analysis
        function updateASCIIBlobsWithAudio(volumeLevel, frequency) {
            currentVolumeLevel = volumeLevel;
            
            // Map frequency to emotion (more sophisticated than before)
            let detectedEmotion = 'neutral';
            let intensity = Math.min(2.0, volumeLevel * 3);
            
            if (frequency > 400) {
                detectedEmotion = 'שמחה';
            } else if (frequency > 300) {
                detectedEmotion = 'הפתעה';
            } else if (frequency < 120) {
                detectedEmotion = 'עצב';
            } else if (frequency < 180 && volumeLevel > 0.6) {
                detectedEmotion = 'כעס';
            }
            
            // Update blobs with detected emotion
            asciiBlobs.forEach(blob => {
                blob.setEmotions([detectedEmotion]);
                blob.setTargetVisuals({
                    blobSizeScale: Math.max(3, 5 + intensity * 2),
                    blobStrength: Math.max(800, 1000 + intensity * 500),
                    blobVisibility: Math.min(1.5, 0.8 + intensity * 0.4)
                });
            });
            
            updateASCIIBlobStatus(`🎭 ${detectedEmotion} (עוצמה: ${intensity.toFixed(1)})`);
        }
        
        // Update ASCII blobs with full conversation analysis
        function updateASCIIBlobsWithAnalysis(analysis) {
            if (!analysis || !asciiBlobs.length) return;
            
            const emotion = analysis.emotion || 'neutral';
            const intensity = analysis.intensity || 1.0;
            const detectedEmotions = analysis.emotions_detected || [emotion];
            
            console.log('🎭 Updating ASCII blobs with full analysis:', { emotion, intensity, detectedEmotions });
            
            // Apply sophisticated analysis parameters
            const sophisticatedParams = {
                blobSizeScale: Math.max(4, 6 + intensity * 3),
                blobStrength: Math.max(1000, 1500 + intensity * 1000),
                blobVisibility: intensity,
                blobMotionRange: Math.max(0.3, intensity * 0.8),
                humor: analysis.full_analysis?.humor || 0,
                shine: analysis.full_analysis?.shine || 0,
                blur: analysis.full_analysis?.blur || 0
            };
            
            // Update each blob with detected emotions
            asciiBlobs.forEach((blob, index) => {
                const blobEmotion = detectedEmotions[index % detectedEmotions.length];
                blob.setEmotions([blobEmotion]);
                blob.setTargetVisuals(sophisticatedParams);
                
                // Apply humor effects
                if (sophisticatedParams.humor > 0) {
                    blob.humor = sophisticatedParams.humor;
                    blob.blobMotionRange = Math.max(0.5, sophisticatedParams.humor * 0.3);
                }
                
                // Apply shine effects
                if (sophisticatedParams.shine > 0) {
                    blob.shine = sophisticatedParams.shine;
                    blob.blobVisibility = Math.min(1.8, blob.blobVisibility + sophisticatedParams.shine * 0.2);
                }
            });
            
            updateASCIIBlobStatus(`✨ ניתוח מלא: ${emotion} + ${detectedEmotions.length - 1} רגשות נוספים`);
            
            // Keep visualization visible longer for analysis results
            setTimeout(() => {
                updateASCIIBlobStatus('תצוגה מלאה - לחץ סגור תצוגה כדי לחזור');
            }, 3000);
        }

        // Initialize blob visualization system
        let defaultBlobVisuals = {
            blobStrength: 1000,
            blobSizeScale: 5,
            volumeImpact: 3000,
            blobSpreadField: 6.0,
            blobVisibility: 1.0,
            blobMotionRange: 0.4,
            breathSpeed: 0.0003,
            gradientStrength: 15,
            blobiness: 1.5,
            blur: 0,
            humor: 0,
            shine: 0,
            characterSpacing: 2,
            coloredCircleCharSize: 1,
            regularAsciiCharSize: 1,
            minBlobSpacing: "close",
            movementEasing: 0.03,
            blobDensity: 1.2,
        };
        
        // Master background color
        const MASTER_BACKGROUND_RGB = [247, 249, 243];
        let canvasBackgroundColor = [...MASTER_BACKGROUND_RGB];
        
        // Enhanced visualization settings optimized for blob visualization
        let visualSettings = {
            resolution: 8,
            brightness: 0,
            contrast: 120,
            charSet: 'standard',
            colorMode: 'blobStyle',
            invertMode: false,
            mirrorMode: true,
            blobEffect: true,
            blobStrength: 0.6,
            emotion: null,
            emotions_detected: [],
            intensity: 1.0
        };
        
        // VisualizationBlob class definition (simplified from sketch.js)
        class VisualizationBlob {
            constructor(i, initialPos = {}) {
                this.pos = createVector(initialPos.x || canvas.width/2, initialPos.y || canvas.height/2);
                this.vel = createVector(Math.random() - 0.5, Math.random() - 0.5);
                this.targetPos = null;
                this.noiseOffset = createVector(Math.random() * 1000, Math.random() * 1000);
                this.timeOffset = Math.random() * 1000;
                this.cachedStrength = 0;
                this.audioLevel = 0;
                this.smoothedAudioLevel = 0;
                this.id = i;
                this.currentEmotions = [];
                this.displayColors = [[150, 150, 150]];
                this.isVisible = true;
                
                Object.assign(this, defaultBlobVisuals);
                this.target = { ...defaultBlobVisuals };
                
                if (this.blobSizeScale <= 0.1) this.blobSizeScale = 1;
                if (this.target.blobSizeScale <= 0.1) this.target.blobSizeScale = 1;
            }
            
            setEmotions(emotions) {
                this.currentEmotions = emotions || [];
                console.log(`🎭 Blob ${this.id} emotions set to:`, this.currentEmotions);
            }
            
            setTargetVisuals(newVisuals) {
                Object.assign(this.target, newVisuals);
                this.target.isVisible = newVisuals.isVisible !== false;
                if (this.target.blobSizeScale <= 0.1) this.target.blobSizeScale = 1;
            }
            
            getStrength() { 
                return this.cachedStrength; 
            }
            
            updateStrength() {
                const baseStrength = 300 + (this.smoothedAudioLevel * this.volumeImpact);
                this.cachedStrength = baseStrength * this.blobStrength;
            }
            
            update() {
                this.isVisible = this.target.isVisible;
                this.updateStrength();
                
                // Smooth parameter transitions
                for (const key in defaultBlobVisuals) {
                    if (typeof this[key] === 'number' && key !== 'blur' && key !== 'humor' && key !== 'shine') {
                        this[key] = lerp(this[key], this.target[key], 0.15);
                    } else {
                        this[key] = this.target[key];
                    }
                }
                
                // Simple movement
                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;
                
                // Bounce off edges
                if (this.pos.x < 50 || this.pos.x > canvas.width - 50) this.vel.x *= -1;
                if (this.pos.y < 50 || this.pos.y > canvas.height - 50) this.vel.y *= -1;
                
                // Add some organic movement
                const time = animationTime * 0.01 + this.timeOffset;
                this.vel.x += Math.sin(time) * 0.1;
                this.vel.y += Math.cos(time * 0.7) * 0.1;
                
                // Damping
                this.vel.x *= 0.98;
                this.vel.y *= 0.98;
                
                // Keep in bounds
                this.pos.x = Math.max(50, Math.min(canvas.width - 50, this.pos.x));
                this.pos.y = Math.max(50, Math.min(canvas.height - 50, this.pos.y));
            }
        }
        
        // Helper functions
        function createVector(x, y) {
            return { x: x, y: y };
        }
        
        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }
        
        function noise(x, y, z = 0) {
            // Simple noise function
            const n = Math.sin(x * 12.9898 + y * 78.233 + z * 37.719) * 43758.5453;
            return (n - Math.floor(n));
        }
        
        function getEmotionColor(emotionCode) {
            // Simple emotion colors
            const colors = {
                'שמחה': [255, 215, 0],      // Gold
                'happiness': [255, 215, 0],
                'אהבה': [255, 105, 180],    // Hot pink
                'love': [255, 105, 180],
                'כעס': [255, 69, 0],       // Red orange
                'anger': [255, 69, 0],
                'עצב': [70, 130, 180],     // Steel blue
                'sadness': [70, 130, 180],
                'סקרנות': [255, 0, 255],   // Magenta
                'curiosity': [255, 0, 255],
                'רגוע': [144, 238, 144],   // Light green
                'calm': [144, 238, 144],
                'default': [150, 150, 150] // Gray
            };
            
            return colors[emotionCode] || colors['default'];
        }
        
        // Initialize blob canvas
        function initBlobVisualization() {
            console.log('🎭 Initializing blob visualization...');
            
            // First, ensure we have p5.js available
            if (typeof p5 === 'undefined') {
                console.log('⚠️ p5.js not loaded yet, scheduling retry...');
                setTimeout(initBlobVisualization, 500);
                return;
            }
            
            // Find the visualization container
            const visualizationContainer = document.getElementById('visualization-canvas-container');
            const p5Container = document.getElementById('p5-sketch-container');
            
            if (!visualizationContainer || !p5Container) {
                console.error('❌ Visualization containers not found');
                console.log('🔍 Available containers:', {
                    'visualization-canvas-container': !!document.getElementById('visualization-canvas-container'),
                    'p5-sketch-container': !!document.getElementById('p5-sketch-container'),
                    'inlineVisualizationArea': !!document.getElementById('inlineVisualizationArea')
                });
                return;
            }
            
            console.log('✅ Found visualization containers');
            
            // Show the visualization container and hide placeholder
            visualizationContainer.style.display = 'block';
            const placeholder = document.getElementById('visualizationPlaceholder');
            if (placeholder) placeholder.style.display = 'none';
            
            // Set up minimal p5 sketch for immediate blob visualization
            const emergencySketch = (p) => {
                let blobs = [];
                let time = 0;
                
                p.setup = () => {
                    const canvas = p.createCanvas(p5Container.clientWidth || 600, p5Container.clientHeight || 400);
                    canvas.parent(p5Container);
                    
                    console.log('🎨 P5 canvas created:', canvas.canvas.width, 'x', canvas.canvas.height);
                    
                    // Create 2 demo blobs
                    blobs = [
                        {
                            x: p.width * 0.3,
                            y: p.height * 0.5,
                            size: 80,
                            color: [255, 100, 100],
                            emotion: 'שמחה'
                        },
                        {
                            x: p.width * 0.7,
                            y: p.height * 0.5,
                            size: 60,
                            color: [100, 150, 255],
                            emotion: 'רגיעה'
                        }
                    ];
                    
                    console.log('✅ Emergency blob visualization initialized with', blobs.length, 'blobs');
                };
                
                p.draw = () => {
                    // Background
                    p.background(247, 249, 243);
                    
                    time += 0.01;
                    
                    // Draw blobs
                    blobs.forEach((blob, i) => {
                        // Gentle animation
                        const offsetX = Math.sin(time + i) * 10;
                        const offsetY = Math.cos(time * 0.7 + i) * 8;
                        const sizeVar = Math.sin(time * 2 + i) * 10;
                        
                        // Draw blob with glow effect
                        for (let r = blob.size + 20; r > 0; r -= 8) {
                            const alpha = (1 - (r / (blob.size + 20))) * 100;
                            p.fill(blob.color[0], blob.color[1], blob.color[2], alpha);
                            p.noStroke();
                            p.ellipse(
                                blob.x + offsetX, 
                                blob.y + offsetY, 
                                r + sizeVar
                            );
                        }
                        
                        // Draw emotion text
                        p.fill(50);
                        p.textAlign(p.CENTER, p.CENTER);
                        p.textSize(16);
                        p.text(blob.emotion, blob.x + offsetX, blob.y + offsetY - blob.size - 20);
                    });
                    
                    // Title
                    p.fill(80);
                    p.textAlign(p.CENTER, p.TOP);
                    p.textSize(20);
                    p.text('🎭 תצוגה מקדימה - Blob Visualization', p.width/2, 20);
                    
                    p.textSize(14);
                    p.fill(120);
                    p.text('הקלט קול או לחץ "בדיקה מהירה" לראות את הרגשות', p.width/2, 50);
                };
                
                p.windowResized = () => {
                    p.resizeCanvas(p5Container.clientWidth || 600, p5Container.clientHeight || 400);
                };
            };
            
            // Remove any existing p5 instance
            if (window.myp5) {
                window.myp5.remove();
            }
            
            // Create new p5 instance
            window.myp5 = new p5(emergencySketch);
            
            console.log('✅ Blob visualization started successfully!');
            isBlobVisualizationRunning = true;
        }
        
        function updateWebcamStatus(message) {
            const statusElement = document.getElementById('webcamStatus');
            if (statusElement) {
                statusElement.textContent = message;
            }
            console.log('Blob Status:', message);
        }
        
        async function startWebcam() {
            console.log('Starting blob visualization...');
            if (isBlobVisualizationRunning) {
                console.log('Blob visualization already running');
                return;
            }
            
            try {
                updateWebcamStatus('מפעיל ויזואליזציה...');
                console.log('Starting blob animation...');
                
                isBlobVisualizationRunning = true;
                console.log('Blob visualization is now running');
                updateWebcamStatus('✅ Blob Preview Active - תוכל לראות את הבלובים זוזים!');
                
                animateBlobVisualization();
                
            } catch (error) {
                console.error('Blob visualization error:', error);
                updateWebcamStatus('שגיאה בהפעלת הויזואליזציה');
            }
        }
        
                 function animateBlobVisualization() {
             if (!isBlobVisualizationRunning) return;
             
             animationTime += 0.016;
             
             // Clear canvas
             ctx.fillStyle = `rgb(${canvasBackgroundColor.join(',')})`;
             ctx.fillRect(0, 0, canvas.width, canvas.height);
             
             // Update and draw blobs
             drawMetaballAscii();
             
             animationId = requestAnimationFrame(animateBlobVisualization);
         }
         
         function drawMetaballAscii() {
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '16px "Courier New", monospace';
            
            const stepX = canvas.width / gridsize;
            const stepY = canvas.height / gridsize;
            
            // Update blobs
            for (const blob of blobs) {
                blob.update();
            }
            
            // Draw ASCII representation
            for (let x = 0; x < gridsize; x++) {
                for (let y = 0; y < gridsize; y++) {
                    const gx = x * stepX + stepX / 2;
                    const gy = y * stepY + stepY / 2;
                    let maxInfluence = 0;
                    let dominantBlob = null;
                    
                    // Calculate blob influence
                    for (const blob of blobs) {
                        if (!blob.isVisible) continue;
                        
                        const dx = gx - blob.pos.x;
                        const dy = gy - blob.pos.y;
                        let d2 = dx * dx + dy * dy;
                        if (d2 === 0) d2 = 1;
                        
                        // Add some organic distortion
                        const angle = Math.atan2(dy, dx);
                        const t = animationTime * blob.breathSpeed;
                        const distortion = Math.sin(angle * 3 + t) * 0.3 + 1;
                        
                        const influence = (blob.getStrength() * blob.blobSizeScale * distortion) / (d2 * blob.blobSpreadField + 1e-6);
                        
                        if (influence > maxInfluence) {
                            maxInfluence = influence;
                            dominantBlob = blob;
                        }
                    }
                    
                    // Draw character if influence is strong enough
                    if (maxInfluence > 0.001 && dominantBlob) {
                        const intensity = Math.min(1, maxInfluence);
                        
                        // Choose character based on intensity
                        const chars = ['░', '▒', '▓', '█'];
                        const charIndex = Math.floor(intensity * (chars.length - 1));
                        const char = chars[charIndex] || '░';
                        
                        // Choose color based on blob emotions
                        let color = [150, 150, 150]; // Default gray
                        if (dominantBlob.currentEmotions.length > 0) {
                            const emotion = dominantBlob.currentEmotions[0];
                            color = getEmotionColor(emotion);
                        } else if (dominantBlob.displayColors.length > 0) {
                            color = dominantBlob.displayColors[0];
                        }
                        
                        // Apply emotion-based color modulation
                        const alpha = Math.min(255, intensity * 255);
                        ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha / 255})`;
                        
                        // Apply effects based on visual settings
                        let fontSize = 16;
                        if (visualSettings.humor > 0) {
                            fontSize += Math.sin(animationTime * 0.1 + x + y) * visualSettings.humor * 3;
                        }
                        if (visualSettings.shine > 0) {
                            const glow = Math.sin(animationTime * 0.2) * 0.5 + 0.5;
                            ctx.shadowColor = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${glow})`;
                            ctx.shadowBlur = visualSettings.shine * 10;
                        }
                        
                        ctx.font = `${fontSize}px "Courier New", monospace`;
                        ctx.fillText(char, gx, gy);
                        
                        // Reset shadow
                        ctx.shadowBlur = 0;
                    }
                }
            }
        }
        
        // Initialize blob visualization when called
        function initWebcam() {
            initBlobVisualization();
        }

        // Webcam functionality replaced with blob visualization above
        let isWebcamRunning = false;
        
        // Motion detection for light blob effects
        let previousFrame = null;
        let motionMap = null;
        
        // Enhanced visualization settings already defined above for blob visualization
        
        // Simple character sets from original
        const charSets = {
            standard: ' .:-=+*#%@',
            blocks: ' ░▒▓█',
            dots: ' ·∙○●',
            matrix: 'ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝ01',
            hebrew: 'אבגדהוזחטיכלמנסעפצקרשת',
            hearts: '♡♥❤💙💚💛💜🖤',
            minimal: ' .:+#'
        };
        
        // Enhanced color palettes optimized for white background (like blob visualization)
        const colorPalettes = {
            green: (brightness) => {
                // Dark green for white background, inversely proportional to brightness
                const intensity = Math.max(30, 255 - brightness);
                return `rgb(0, ${Math.floor(intensity * 0.8)}, 0)`;
            },
            blue: (brightness) => {
                // Dark blue for white background
                const intensity = Math.max(30, 255 - brightness);
                return `rgb(0, ${Math.floor(intensity * 0.3)}, ${intensity})`;
            },
            warm: (brightness) => {
                // Dark warm colors for white background
                const intensity = Math.max(30, 255 - brightness);
                return `rgb(${intensity}, ${Math.floor(intensity * 0.5)}, 0)`;
            },
            cool: (brightness) => {
                // Dark cool colors for white background
                const intensity = Math.max(30, 255 - brightness);
                return `rgb(${Math.floor(intensity * 0.3)}, ${Math.floor(intensity * 0.7)}, ${intensity})`;
            },
            grayscale: (brightness) => {
                // Dark grayscale for white background (inverted)
                const intensity = Math.max(30, 255 - brightness);
                return `rgb(${intensity}, ${intensity}, ${intensity})`;
            },
            original: (r, g, b) => {
                // Enhanced original colors with better contrast on white
                const avgBrightness = (r + g + b) / 3;
                if (avgBrightness > 180) {
                    // Make bright colors darker for visibility
                    r = Math.max(30, r - 100);
                    g = Math.max(30, g - 100);
                    b = Math.max(30, b - 100);
                }
                return `rgb(${r}, ${g}, ${b})`;
            },
            // New blob-inspired color palette
            blobStyle: (brightness) => {
                // Mimic the blob visualization color scheme
                const intensity = Math.max(40, 255 - brightness);
                const hue = (Date.now() * 0.001 + brightness * 0.01) % 360;
                return `hsl(${hue}, 70%, ${Math.max(20, 100 - brightness/3)}%)`;
            }
        };
        
        // Initialize simple webcam canvas
        function initWebcam() {
            console.log('Initializing webcam canvas...');
            const containerWidth = document.querySelector('.canvas-panel').clientWidth;
            const containerHeight = document.querySelector('.canvas-panel').clientHeight;
            
            console.log('Container dimensions:', containerWidth, 'x', containerHeight);
            
            canvas.width = Math.min(1400, containerWidth * 0.95);
            canvas.height = Math.min(2000, containerHeight * 0.99);
            
            console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
            
            canvas.style.borderRadius = '0x';
            
            // Welcome screen with white background (like blob visualization)
            ctx.fillStyle = '#f7f9f3';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add ASCII art border effect
            ctx.fillStyle = '#666';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'center';
            
            // Draw ASCII art border
            const borderChars = '.::++##++::.';
            for (let i = 0; i < canvas.width / 15; i++) {
                const char = borderChars[i % borderChars.length];
                ctx.fillText(char, i * 15 + 10, 20);
                ctx.fillText(char, i * 15 + 10, canvas.height - 20);
            }
            
            // Main title
            ctx.fillStyle = '#333';
            ctx.font = 'bold 24px Courier New';
            ctx.fillText('מעבדת שיחות', canvas.width / 2, canvas.height / 2 - 40);
            
            ctx.font = '16px Courier New';
            ctx.fillText('ASCII Webcam Preview', canvas.width / 2, canvas.height / 2 - 10);
            ctx.fillText('ענה על השאלות לאקטיבציה', canvas.width / 2, canvas.height / 2 + 20);
            
            // Add motivating instruction
            ctx.font = '12px Courier New';
            ctx.fillStyle = '#666';
            ctx.fillText('💡 טיפ: אחרי הפעלה, נוע מול המצלמה לראות את האפקט!', canvas.width / 2, canvas.height / 2 + 45);
            
            // Add some ASCII art elements
            ctx.font = '14px Courier New';
            ctx.fillStyle = '#888';
            ctx.fillText('░░▒▒▓▓██▓▓▒▒░░', canvas.width / 2, canvas.height / 2 + 50);
            
            updateWebcamStatus('🎬 ASCII Camera Ready - ענה על השאלות להפעלת תצוגה מקדימה');
        }
        
        function updateWebcamStatus(message) {
            const statusElement = document.getElementById('webcamStatus');
            if (statusElement) {
                statusElement.textContent = message;
            }
            console.log('Webcam Status:', message);
        }
        
        async function startWebcam() {
            console.log('Starting webcam...');
            if (isWebcamRunning) {
                console.log('Webcam already running');
                return;
            }
            
            try {
                updateWebcamStatus('מפעיל מצלמה...');
                console.log('Requesting camera permissions...');
                
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    } 
                });
                
                console.log('Camera stream obtained:', stream);
                video.srcObject = stream;
                await video.play();
                console.log('Video started playing');
                
                processCanvas = document.createElement('canvas');
                processCtx = processCanvas.getContext('2d');
                
                isWebcamRunning = true;
                console.log('Webcam is now running');
                updateWebcamStatus('✅ ASCII Preview Active - תוכל לראות את עצמך באמנות ASCII!');
                
                animateWebcam();
                
            } catch (error) {
                console.error('Webcam error:', error);
                updateWebcamStatus('שגיאה בגישה למצלמה');
            }
        }
        
        function animateWebcam() {
            if (!isWebcamRunning) return;
            
            animationTime += 0.016;
            
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                processWebcamFrame();
            }
            
            animationId = requestAnimationFrame(animateWebcam);
        }
        
        function processWebcamFrame() {
            const cellSize = visualSettings.resolution;
            const cols = Math.floor(canvas.width / cellSize);
            const rows = Math.floor(canvas.height / cellSize);
            
            processCanvas.width = cols;
            processCanvas.height = rows;
            
            // Draw video to processing canvas with mirror option
            processCtx.save();
            if (visualSettings.mirrorMode) {
                processCtx.translate(processCanvas.width, 0);
                processCtx.scale(-1, 1);
            }
            processCtx.drawImage(video, 0, 0, processCanvas.width, processCanvas.height);
            processCtx.restore();
            
            const imageData = processCtx.getImageData(0, 0, processCanvas.width, processCanvas.height);
            const pixels = imageData.data;
            
            // Calculate motion map for blob effect (if enabled)
            if (visualSettings.blobEffect) {
                calculateMotionMap(imageData);
            }
            
            // ✨ DYNAMIC EMOTION-BASED BACKGROUND
            let backgroundColor = '#f7f9f3'; // Default main app background
            
            // Apply emotion-specific background effects
            if (visualSettings.emotion) {
                backgroundColor = getEmotionBackground(visualSettings.emotion, animationTime);
            }
            
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ✨ DRAW EMOTION CHARSET OVERLAY ON TOP
            drawEmotionOverlay(ctx, canvas.width, canvas.height);
            
            // Get character set (can be dynamic based on emotion)
            const chars = getEmotionCharSet(visualSettings.emotion) || charSets[visualSettings.charSet] || charSets.standard;
            
            // Draw ASCII art with enhanced emotion-based effects
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const i = (y * cols + x) * 4;
                    
                    let r = pixels[i];
                    let g = pixels[i + 1];
                    let b = pixels[i + 2];
                    
                    // Apply brightness and contrast
                    r = applyBrightnessContrast(r);
                    g = applyBrightnessContrast(g);
                    b = applyBrightnessContrast(b);
                    
                    let brightness = (r + g + b) / 3;
                    
                    // ✨ ENHANCED EMOTION-BASED BLOB EFFECTS
                    if (visualSettings.blobEffect) {
                        brightness = applyAdvancedEmotionBlobEffect(x, y, cols, rows, brightness, visualSettings.emotion, animationTime);
                    }
                    
                    if (visualSettings.invertMode) {
                        brightness = 255 - brightness;
                    }
                    
                    // Map brightness to character
                    const charIndex = Math.floor((brightness / 255) * (chars.length - 1));
                    let char = chars[visualSettings.invertMode ? chars.length - 1 - charIndex : charIndex];
                    
                    // ✨ EMOTION-SPECIFIC CHARACTER MODIFICATIONS
                    char = applyEmotionCharacterEffects(char, x, y, animationTime, visualSettings.emotion);
                    
                    // ✨ DYNAMIC EMOTION-BASED COLORS
                    ctx.fillStyle = getEmotionColor(r, g, b, brightness, visualSettings.emotion, visualSettings.colorMode, animationTime);
                    
                    // ✨ DYNAMIC FONT SIZE BASED ON EMOTION INTENSITY
                    const emotionFontSize = getEmotionFontSize(cellSize, visualSettings.intensity, visualSettings.emotion, x, y, animationTime);
                    ctx.font = `${emotionFontSize}px Courier New`;
                    
                    // Draw character with emotion-based positioning
                    const emotionPos = getEmotionPosition(x, y, cellSize, visualSettings.emotion, animationTime);
                    ctx.fillText(char, emotionPos.x, emotionPos.y);
                }
            }
        }
        
        function calculateMotionMap(currentImageData) {
            const width = currentImageData.width;
            const height = currentImageData.height;
            const currentPixels = currentImageData.data;
            
            if (!motionMap || motionMap.length !== width * height) {
                motionMap = new Float32Array(width * height);
            }
            
            if (previousFrame && previousFrame.length === currentPixels.length) {
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const mapIdx = y * width + x;
                        
                        const dr = Math.abs(currentPixels[idx] - previousFrame[idx]);
                        const dg = Math.abs(currentPixels[idx + 1] - previousFrame[idx + 1]);
                        const db = Math.abs(currentPixels[idx + 2] - previousFrame[idx + 2]);
                        
                        const diff = (dr + dg + db) / (3 * 255);
                        motionMap[mapIdx] = motionMap[mapIdx] * 0.7 + diff * 0.3;
                    }
                }
            } else {
                motionMap.fill(0);
            }
            
            if (!previousFrame || previousFrame.length !== currentPixels.length) {
                previousFrame = new Uint8ClampedArray(currentPixels.length);
            }
            previousFrame.set(currentPixels);
        }
        
        function applyBrightnessContrast(value) {
            value = ((value - 128) * (visualSettings.contrast / 100)) + 128;
            value += visualSettings.brightness;
            return Math.max(0, Math.min(255, value));
        }
        
        function applySimpleBlobEffect(x, y, cols, rows, brightness) {
            // Simple blob centers from original
            const time = animationTime;
            const blob1X = cols / 2 + Math.sin(time) * cols / 4;
            const blob1Y = rows / 2 + Math.cos(time * 0.7) * rows / 4;
            const blob2X = cols / 2 + Math.sin(time * 1.3) * cols / 4;
            const blob2Y = rows / 2 + Math.cos(time * 0.9) * rows / 4;
            
            const dist1 = Math.sqrt((x - blob1X) ** 2 + (y - blob1Y) ** 2);
            const dist2 = Math.sqrt((x - blob2X) ** 2 + (y - blob2Y) ** 2);
            
            const influence1 = Math.max(0, 1 - dist1 / (cols / 4));
            const influence2 = Math.max(0, 1 - dist2 / (cols / 4));
            const totalInfluence = influence1 + influence2;
            
            return brightness * (0.5 + totalInfluence * visualSettings.blobStrength);
        }

        // ✨ ADVANCED EMOTION-BASED VISUAL EFFECTS ✨

        function getEmotionBackground(emotion, time) {
            if (!emotion) return '#f7f9f3';
            
            const intensity = (Math.sin(time * 0.5) + 1) / 2; // Subtle animation
            
            switch (emotion) {
                case 'שמחה': // Joy
                    const yellowTint = Math.floor(250 + intensity * 5);
                    return `rgb(${yellowTint}, ${yellowTint}, ${Math.floor(yellowTint * 0.9)})`;
                    
                case 'אהבה': // Love
                    const pinkTint = Math.floor(250 + intensity * 5);
                    return `rgb(${pinkTint}, ${Math.floor(pinkTint * 0.95)}, ${Math.floor(pinkTint * 0.98)})`;
                    
                case 'כעס': // Anger
                    const redTint = Math.floor(250 + intensity * 3);
                    return `rgb(${redTint}, ${Math.floor(redTint * 0.92)}, ${Math.floor(redTint * 0.92)})`;
                    
                case 'עצב': // Sadness
                    const blueTint = Math.floor(245 + intensity * 5);
                    return `rgb(${Math.floor(blueTint * 0.95)}, ${Math.floor(blueTint * 0.97)}, ${blueTint})`;
                    
                case 'התרגשות': // Excitement
                    const warmth = Math.floor(248 + intensity * 7);
                    return `rgb(${warmth}, ${Math.floor(warmth * 0.96)}, ${Math.floor(warmth * 0.88)})`;
                    
                case 'רגוע': // Calm
                    const coolTint = Math.floor(247 + intensity * 3);
                    return `rgb(${Math.floor(coolTint * 0.96)}, ${coolTint}, ${Math.floor(coolTint * 0.98)})`;
                    
                default:
                    return '#f7f9f3'; // Default background
            }
        }

        function getEmotionCharSet(emotion) {
            if (!emotion) return null;
            
            switch (emotion) {
                case 'שמחה': // Joy
                case 'אהבה': // Love
                    return charSets.hearts;
                    
                case 'התרגשות': // Excitement
                    return charSets.dots;
                    
                case 'כעס': // Anger
                case 'תסכול': // Frustration
                    return charSets.blocks;
                    
                case 'סקרנות': // Curiosity
                    return charSets.matrix;
                    
                case 'רגוע': // Calm
                    return charSets.minimal;
                    
                default:
                    return null; // Use default charset
            }
        }

        function applyAdvancedEmotionBlobEffect(x, y, cols, rows, brightness, emotion, time) {
            if (!emotion) return applySimpleBlobEffect(x, y, cols, rows, brightness);
            
            let speed = 1.0;
            let amplitude = 1.0;
            let complexity = 2; // Number of blob centers
            
            // Emotion-specific blob behavior
            switch (emotion) {
                case 'שמחה': // Joy - bouncy, energetic
                    speed = 1.5;
                    amplitude = 1.2;
                    complexity = 3;
                    break;
                    
                case 'התרגשות': // Excitement - fast, chaotic
                    speed = 2.0;
                    amplitude = 1.4;
                    complexity = 4;
                    break;
                    
                case 'אהבה': // Love - gentle, flowing
                    speed = 0.8;
                    amplitude = 0.9;
                    complexity = 2;
                    break;
                    
                case 'כעס': // Anger - sharp, aggressive
                    speed = 1.3;
                    amplitude = 1.1;
                    complexity = 2;
                    break;
                    
                case 'רגוע': // Calm - slow, smooth
                    speed = 0.5;
                    amplitude = 0.7;
                    complexity = 1;
                    break;
                    
                case 'עצב': // Sadness - droopy, slow
                    speed = 0.6;
                    amplitude = 0.8;
                    complexity = 2;
                    break;
            }
            
            let totalInfluence = 0;
            
            for (let i = 0; i < complexity; i++) {
                const offset = i * 2.3; // Spread blob centers
                const blobX = cols / 2 + Math.sin(time * speed + offset) * cols / 4 * amplitude;
                const blobY = rows / 2 + Math.cos(time * speed * 0.7 + offset) * rows / 4 * amplitude;
                
                const dist = Math.sqrt((x - blobX) ** 2 + (y - blobY) ** 2);
                const influence = Math.max(0, 1 - dist / (cols / 4));
                totalInfluence += influence;
            }
            
            return brightness * (0.5 + totalInfluence * visualSettings.blobStrength);
        }

        function applyEmotionCharacterEffects(char, x, y, time, emotion) {
            if (!emotion) return char;
            
            // Add occasional character variations based on emotion
            const variation = Math.sin(time * 3 + x * 0.1 + y * 0.1);
            
            switch (emotion) {
                case 'שמחה': // Joy - occasionally show happy characters
                    if (variation > 0.8) return '☀';
                    if (variation > 0.7) return '✨';
                    break;
                    
                case 'אהבה': // Love - show hearts occasionally
                    if (variation > 0.85) return '💖';
                    if (variation > 0.75) return '♥';
                    break;
                    
                case 'התרגשות': // Excitement - energetic characters
                    if (variation > 0.8) return '⚡';
                    if (variation > 0.7) return '✦';
                    break;
                    
                case 'כעס': // Anger - sharp characters
                    if (variation > 0.85) return '⚡';
                    if (variation > 0.75) return '▲';
                    break;
            }
            
            return char; // Return original character most of the time
        }

        function getEmotionColor(r, g, b, brightness, emotion, colorMode, time) {
            if (!emotion) {
                // Fallback to original color logic
                if (colorMode === 'original') {
                    return colorPalettes.original(r, g, b);
                } else {
                    const colorFunc = colorPalettes[colorMode] || colorPalettes.green;
                    return colorFunc(brightness);
                }
            }
            
            const intensity = Math.max(30, 255 - brightness);
            const timeOffset = Math.sin(time * 0.3) * 20; // Subtle color animation
            
            switch (emotion) {
                case 'שמחה': // Joy - warm yellows and oranges
                    return `rgb(${Math.floor(intensity + timeOffset)}, ${Math.floor(intensity * 0.8 + timeOffset)}, ${Math.floor(intensity * 0.2)})`;
                    
                case 'אהבה': // Love - warm pinks and reds
                    return `rgb(${Math.floor(intensity + timeOffset)}, ${Math.floor(intensity * 0.3)}, ${Math.floor(intensity * 0.5 + timeOffset)})`;
                    
                case 'כעס': // Anger - intense reds
                    return `rgb(${Math.floor(intensity + timeOffset)}, ${Math.floor(intensity * 0.2)}, ${Math.floor(intensity * 0.2)})`;
                    
                case 'עצב': // Sadness - cool blues
                    return `rgb(${Math.floor(intensity * 0.3)}, ${Math.floor(intensity * 0.5)}, ${Math.floor(intensity + timeOffset)})`;
                    
                case 'התרגשות': // Excitement - vibrant colors
                    const cycle = Math.sin(time * 2) * 0.3 + 0.7;
                    return `rgb(${Math.floor(intensity * cycle + timeOffset)}, ${Math.floor(intensity * (1-cycle) + timeOffset)}, ${Math.floor(intensity * 0.5)})`;
                    
                case 'רגוע': // Calm - soft greens
                    return `rgb(${Math.floor(intensity * 0.4)}, ${Math.floor(intensity * 0.8 + timeOffset)}, ${Math.floor(intensity * 0.6)})`;
                    
                case 'סקרנות': // Curiosity - matrix green
                    return `rgb(${Math.floor(intensity * 0.2)}, ${Math.floor(intensity + timeOffset)}, ${Math.floor(intensity * 0.3)})`;
                    
                default:
                    // Fallback to original color logic
                    if (colorMode === 'original') {
                        return colorPalettes.original(r, g, b);
                    } else {
                        const colorFunc = colorPalettes[colorMode] || colorPalettes.green;
                        return colorFunc(brightness);
                    }
            }
        }

        function getEmotionFontSize(baseCellSize, intensity, emotion, x, y, time) {
            let sizeMultiplier = 1.0;
            
            if (!emotion) return baseCellSize;
            
            const baseIntensity = intensity || 1.0;
            const variation = Math.sin(time * 2 + x * 0.05 + y * 0.05) * 0.1;
            
            switch (emotion) {
                case 'שמחה': // Joy - slightly larger, bouncy
                    sizeMultiplier = 0.9 + baseIntensity * 0.3 + variation;
                    break;
                    
                case 'התרגשות': // Excitement - very dynamic size
                    sizeMultiplier = 0.8 + baseIntensity * 0.5 + variation * 2;
                    break;
                    
                case 'אהבה': // Love - gentle size variation
                    sizeMultiplier = 0.95 + baseIntensity * 0.2 + variation * 0.5;
                    break;
                    
                case 'כעס': // Anger - sharp, aggressive sizing
                    sizeMultiplier = 0.85 + baseIntensity * 0.4 + Math.abs(variation);
                    break;
                    
                case 'רגוע': // Calm - stable, minimal variation
                    sizeMultiplier = 1.0 + baseIntensity * 0.1;
                    break;
                    
                case 'עצב': // Sadness - smaller, droopy
                    sizeMultiplier = 0.8 + baseIntensity * 0.2 + variation * 0.3;
                    break;
                    
                default:
                    sizeMultiplier = 1.0 + baseIntensity * 0.2;
            }
            
            return Math.max(baseCellSize * 0.5, baseCellSize * sizeMultiplier);
        }

        function getEmotionPosition(x, y, cellSize, emotion, time) {
            const basePx = x * cellSize + cellSize / 2;
            const basePy = y * cellSize + cellSize / 2;
            
            if (!emotion) return { x: basePx, y: basePy };
            
            let offsetX = 0;
            let offsetY = 0;
            
            const timeOffset = time * 2;
            const positionVariation = Math.sin(timeOffset + x * 0.1 + y * 0.1);
            
            switch (emotion) {
                case 'שמחה': // Joy - slight bounce
                    offsetY = Math.sin(timeOffset + x * 0.2) * 2;
                    break;
                    
                case 'התרגשות': // Excitement - energetic movement
                    offsetX = Math.sin(timeOffset + x * 0.15) * 3;
                    offsetY = Math.cos(timeOffset + y * 0.15) * 3;
                    break;
                    
                case 'אהבה': // Love - gentle sway
                    offsetX = Math.sin(timeOffset * 0.5 + x * 0.1) * 1.5;
                    offsetY = Math.cos(timeOffset * 0.7 + y * 0.1) * 1.5;
                    break;
                    
                case 'כעס': // Anger - sharp, jittery movement
                    offsetX = (Math.random() - 0.5) * 2;
                    offsetY = (Math.random() - 0.5) * 2;
                    break;
                    
                case 'עצב': // Sadness - droopy effect
                    offsetY = Math.abs(positionVariation) * 2;
                    break;
                    
                case 'רגוע': // Calm - minimal movement
                    offsetX = Math.sin(timeOffset * 0.3) * 0.5;
                    break;
            }
            
            return {
                x: basePx + offsetX,
                y: basePy + offsetY
            };
        }

        // ✨ DRAW EMOTION CHARSET OVERLAY ON TOP OF WEBCAM
        function drawEmotionOverlay(ctx, canvasWidth, canvasHeight) {
            if (!visualSettings.emotion && !visualSettings.charSet) return;
            
            // Save context
            ctx.save();
            
            // Semi-transparent overlay background for readability
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(10, 10, Math.min(400, canvasWidth - 20), 120);
            
            // Current emotion display
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'right';
            
            const emotionText = visualSettings.emotion || 'לא זוהה';
            ctx.fillText(`רגש: ${emotionText}`, canvasWidth - 20, 40);
            
            // Charset display
            ctx.font = '16px Arial';
            const charsetName = getCharsetHebrewName(visualSettings.charSet);
            ctx.fillText(`סט תווים: ${charsetName}`, canvasWidth - 20, 65);
            
            // Current charset preview
            const chars = charSets[visualSettings.charSet] || charSets.standard;
            ctx.font = '14px Courier New';
            const previewText = chars.substring(0, Math.min(20, chars.length));
            ctx.fillText(`תצוגה: ${previewText}`, canvasWidth - 20, 85);
            
            // Sophistication indicators
            let indicators = [];
            if (visualSettings.humor > 0) indicators.push(`😂 הומור ${Math.floor(visualSettings.humor * 10)}/10`);
            if (visualSettings.blur > 0) indicators.push(`🌫️ טשטוש ${Math.floor(visualSettings.blur * 10)}/10`);
            if (visualSettings.shine > 0) indicators.push(`✨ ברק ${Math.floor(visualSettings.shine * 10)}/10`);
            if (visualSettings.voice_intensity > 1.5) indicators.push(`🔊 צעקה ${visualSettings.voice_intensity.toFixed(1)}`);
            
            if (indicators.length > 0) {
                ctx.font = '12px Arial';
                ctx.fillText(indicators.join(' | '), canvasWidth - 20, 105);
            }
            
            // Emotion-specific emoji indicator
            const emotionEmoji = getEmotionEmoji(visualSettings.emotion);
            if (emotionEmoji) {
                ctx.font = '32px Arial';
                ctx.fillText(emotionEmoji, 25, 50);
            }
            
            // Restore context
            ctx.restore();
        }

        function getCharsetHebrewName(charSetKey) {
            const names = {
                'standard': 'סטנדרטי',
                'blocks': 'בלוקים', 
                'dots': 'נקודות',
                'matrix': 'מטריקס',
                'hebrew': 'עברית',
                'hearts': 'לבבות',
                'minimal': 'מינימלי'
            };
            return names[charSetKey] || 'לא ידוע';
        }

        function getEmotionEmoji(emotion) {
            const emojis = {
                'שמחה': '😊',
                'אהבה': '❤️',
                'כעס': '😠',
                'עצב': '😢',
                'התרגשות': '🎉',
                'רגוע': '😌',
                'סקרנות': '🤔',
                'הפתעה': '😲',
                'חיבה': '🥰',
                'בלבול': '😕',
                'שעשוע': '😄',
                'תסכול': '😤'
            };
            return emojis[emotion] || '🎭';
        }
        
        // Page navigation functions are now defined in the head section

        // Handle option selection with real conversation parameter effects
        document.querySelectorAll('.option').forEach(option => {
            option.addEventListener('click', () => {
                // Remove selected class from all options
                document.querySelectorAll('.option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                
                // Add selected class to clicked option
                option.classList.add('selected');
                
                // Enable next button
                document.querySelector('.next-button').disabled = false;
                
                // Update blob effects based on real conversation parameters
                updateBlobEffects(option.dataset.value, option);
            });
        });

        // Comprehensive effects based on ALL conversation parameters - Updated for BLOB VISUALIZATION
        function updateBlobEffects(selectedValue, option) {
            const emotion = option.dataset.emotion;
            const aiEmotion = option.dataset.ai_emotion;
            const intensity = parseInt(option.dataset.intensity) || conversationProfile.emotionalIntensity;
            const intensityFactor = intensity / 10;
            
            console.log('🎭 Updating blob effects:', { emotion, aiEmotion, intensity });
            
            // Handle AI emotions (humor, bliss, shine)
            if (aiEmotion) {
                applyAIEmotionEffectsToBlobs(aiEmotion, intensity);
                return;
            }
            
            // Handle regular emotions from emotions_config.json
            if (emotion) {
                applyEmotionEffectsToBlobs(emotion, intensity, intensityFactor);
                return;
            }
            
            // Handle other parameter types
            applyParameterEffectsToBlobs(option);
        }
        
        // Apply AI emotion effects to blob visualization
        function applyAIEmotionEffectsToBlobs(aiEmotion, intensity) {
            const intensityFactor = intensity / 10;
            
            console.log(`🎭 Applying AI emotion to blobs: ${aiEmotion} (intensity: ${intensity})`);
            
            // Update visual settings
            visualSettings.emotion = aiEmotion;
            visualSettings.intensity = intensityFactor;
            
            switch(aiEmotion) {
                case 'humor': // 😂 Humor - Dynamic, bouncy, colorful, jittery
                    visualSettings.humor = intensity;
                    visualSettings.resolution = Math.max(4, 8 - intensity);
                    visualSettings.brightness = 15 + (intensity * 3);
                    visualSettings.contrast = 100 + (intensity * 6);
                    
                    // Make blobs more dynamic for humor
                    if (blobs.length > 0) {
                        blobs.forEach(blob => {
                            blob.setTargetVisuals({
                                blobSizeScale: 5 + (intensity * 0.5),
                                blobStrength: 1000 + (intensity * 100),
                                breathSpeed: 0.0003 + (intensity * 0.0002),
                                blobiness: 1.5 + (intensity * 0.3)
                            });
                            blob.setEmotions(['שמחה']);
                        });
                    }
                    
                    updateWebcamStatus(`😂 מצב הומור (${intensity}/10) - דינמי ומשחקי!`);
                    break;
                    
                case 'shine': // ✨ Shine - Bright, glowing, radiant
                    visualSettings.shine = intensity;
                    visualSettings.brightness = 20 + (intensity * 4);
                    visualSettings.contrast = 120 + (intensity * 8);
                    
                    // Make blobs glow for shine
                    if (blobs.length > 0) {
                        blobs.forEach(blob => {
                            blob.setTargetVisuals({
                                blobSizeScale: 4 + (intensity * 0.3),
                                blobStrength: 800 + (intensity * 200),
                                gradientStrength: 15 + (intensity * 5)
                            });
                            blob.setEmotions(['שמחה']);
                        });
                    }
                    
                    updateWebcamStatus(`✨ מצב ברק (עוצמה ${intensity}/10) - זוהר ומאיר`);
                    break;
                    
                case 'bliss': // 🌟 Bliss - Ethereal, dreamy, flowing
                    visualSettings.brightness = 15 + (intensity * 2);
                    visualSettings.contrast = 70 + (intensity * 4);
                    
                    // Make blobs flow for bliss
                    if (blobs.length > 0) {
                        blobs.forEach(blob => {
                            blob.setTargetVisuals({
                                blobSizeScale: 6 + (intensity * 0.4),
                                blobStrength: 1200 + (intensity * 100),
                                breathSpeed: 0.0001 + (intensity * 0.0001),
                                blobiness: 2.0 + (intensity * 0.2)
                            });
                            blob.setEmotions(['רגוע']);
                        });
                    }
                    
                    updateWebcamStatus(`🌟 מצב אושר מוחלט (עוצמה ${intensity}/10) - חלומי וזורם`);
                    break;
            }
        }
        
        // Apply regular emotion effects to blob visualization
        function applyEmotionEffectsToBlobs(emotion, intensity, intensityFactor) {
            console.log(`🎭 Applying emotion to blobs: ${emotion} (intensity: ${intensity})`);
            
            // Update visual settings
            visualSettings.emotion = emotion;
            visualSettings.intensity = intensityFactor;
            
            // Set emotion on all blobs
            if (blobs.length > 0) {
                blobs.forEach(blob => {
                    blob.setEmotions([emotion]);
                });
            }
            
            const emotionEffects = {
                'happiness': {
                    blobSizeScale: 5 + (intensity * 0.3),
                    blobStrength: 1000 + (intensity * 50),
                    breathSpeed: 0.0005 + (intensity * 0.0002),
                    status: `😊 שמחה (עוצמה ${intensity}/10)`
                },
                'joy': {
                    blobSizeScale: 6 + (intensity * 0.4),
                    blobStrength: 1200 + (intensity * 80),
                    breathSpeed: 0.0006 + (intensity * 0.0003),
                    status: `😄 שמחה גדולה (עוצמה ${intensity}/10)`
                },
                'curiosity': {
                    blobSizeScale: 4.5 + (intensity * 0.2),
                    blobStrength: 900 + (intensity * 40),
                    blobiness: 1.8 + (intensity * 0.2),
                    status: `🤔 סקרנות (עוצמה ${intensity}/10)`
                },
                'anger': {
                    blobSizeScale: 3 + (intensity * 0.5),
                    blobStrength: 1500 + (intensity * 100),
                    breathSpeed: 0.001 + (intensity * 0.0005),
                    status: `😠 כעס (עוצמה ${intensity}/10)`
                },
                'sadness': {
                    blobSizeScale: 6 + (intensity * 0.1),
                    blobStrength: 600 + (intensity * 30),
                    breathSpeed: 0.0002 + (intensity * 0.0001),
                    status: `😢 עצב (עוצמה ${intensity}/10)`
                }
            };
            
            const effect = emotionEffects[emotion];
            if (effect && blobs.length > 0) {
                blobs.forEach(blob => {
                    blob.setTargetVisuals(effect);
                });
                updateWebcamStatus(effect.status);
            }
        }
        
        // Apply parameter effects to blobs
        function applyParameterEffectsToBlobs(option) {
            console.log('🎭 Applying parameter effects to blobs:', option.dataset);
            
            // Handle communication patterns, topics, dynamics, etc.
            if (option.dataset.pattern) {
                applyCommunicationPatternToBlobs(option.dataset.pattern);
            }
            if (option.dataset.topic) {
                applyTopicEffectsToBlobs(option.dataset.topic);
            }
        }
        
        function applyCommunicationPatternToBlobs(pattern) {
            console.log('🎭 Applying communication pattern to blobs:', pattern);
            
            if (blobs.length > 0) {
                switch(pattern) {
                    case 'assertive':
                        blobs.forEach(blob => {
                            blob.setTargetVisuals({
                                blobSizeScale: 4,
                                blobStrength: 1200,
                                blobiness: 1.2
                            });
                        });
                        updateWebcamStatus('💪 דפוס נחרץ - צורות חדות');
                        break;
                    case 'supportive':
                        blobs.forEach(blob => {
                            blob.setTargetVisuals({
                                blobSizeScale: 6,
                                blobStrength: 800,
                                blobiness: 2.0
                            });
                            blob.setEmotions(['אהבה']);
                        });
                        updateWebcamStatus('🤝 דפוס תומך - חם ומעודד');
                        break;
                    case 'analytical':
                        blobs.forEach(blob => {
                            blob.setTargetVisuals({
                                blobSizeScale: 4.5,
                                blobStrength: 1000,
                                blobiness: 1.0
                            });
                            blob.setEmotions(['סקרנות']);
                        });
                        updateWebcamStatus('🧠 דפוס אנליטי - מבנה מדויק');
                        break;
                    case 'emotional':
                        blobs.forEach(blob => {
                            blob.setTargetVisuals({
                                blobSizeScale: 7,
                                blobStrength: 900,
                                blobiness: 2.5,
                                breathSpeed: 0.0008
                            });
                            blob.setEmotions(['אהבה']);
                        });
                        updateWebcamStatus('❤️ דפוס רגשי - זורם ועמוק');
                        break;
                }
            }
        }
        
        function applyTopicEffectsToBlobs(topic) {
            console.log('🎭 Applying topic effects to blobs:', topic);
            
            if (blobs.length > 0) {
                const topicEffects = {
                    'family': { 
                        blobSizeScale: 6, 
                        blobStrength: 800, 
                        emotion: 'אהבה' 
                    },
                    'work': { 
                        blobSizeScale: 4, 
                        blobStrength: 1100, 
                        emotion: 'רגוע' 
                    },
                    'social': { 
                        blobSizeScale: 5.5, 
                        blobStrength: 950, 
                        emotion: 'שמחה' 
                    }
                };
                
                const effect = topicEffects[topic];
                if (effect) {
                    blobs.forEach(blob => {
                        blob.setTargetVisuals(effect);
                        if (effect.emotion) {
                            blob.setEmotions([effect.emotion]);
                        }
                    });
                    updateWebcamStatus(`נושא: ${topic}`);
                }
            }
        }
        
        function applyAIEmotionEffects(aiEmotion, intensity) {
            const intensityFactor = intensity / 10;
            
            switch(aiEmotion) {
                case 'humor': // 😂 Humor - Dynamic, bouncy, colorful, jittery
                    // Enhanced humor effects based on intensity level
                    if (intensity >= 7) {
                        // High humor: Very dynamic and playful
                        visualSettings.resolution = 4 + Math.floor(intensityFactor * 3);
                        visualSettings.brightness = 20 + (intensity * 4);
                        visualSettings.contrast = 100 + (intensity * 8);
                        visualSettings.charSet = 'hearts';
                        visualSettings.colorMode = 'warm';
                        visualSettings.blobEffect = true;
                        visualSettings.blobStrength = 0.6 + (intensityFactor * 0.4);
                        visualSettings.mirrorMode = !visualSettings.mirrorMode; // Playful mirror flip
                        updateWebcamStatus(`😂 מצב הומור גבוה (${intensity}/10) - מאוד דינמי ומשחקי!`);
                    } else if (intensity >= 4) {
                        // Medium humor: Moderate playfulness
                        visualSettings.resolution = 6 + Math.floor(intensityFactor * 4);
                        visualSettings.brightness = 15 + (intensity * 3);
                        visualSettings.contrast = 95 + (intensity * 6);
                        visualSettings.charSet = 'dots';
                        visualSettings.colorMode = 'warm';
                        visualSettings.blobEffect = true;
                        visualSettings.blobStrength = 0.4 + (intensityFactor * 0.4);
                        updateWebcamStatus(`😄 מצב הומור בינוני (${intensity}/10) - צבעוני ונעים`);
                    } else if (intensity >= 1) {
                        // Low humor: Subtle effects
                        visualSettings.resolution = 8 + Math.floor(intensityFactor * 2);
                        visualSettings.brightness = 10 + (intensity * 2);
                        visualSettings.contrast = 90 + (intensity * 3);
                        visualSettings.charSet = 'minimal';
                        visualSettings.colorMode = 'original';
                        visualSettings.blobEffect = true;
                        visualSettings.blobStrength = 0.3 + (intensityFactor * 0.2);
                        updateWebcamStatus(`🙂 מצב הומור קל (${intensity}/10) - עדין וכיפי`);
                    } else {
                        // No humor: Standard effects
                        visualSettings.resolution = 10;
                        visualSettings.brightness = 5;
                        visualSettings.contrast = 85;
                        visualSettings.charSet = 'standard';
                        visualSettings.colorMode = 'grayscale';
                        visualSettings.blobEffect = false;
                        visualSettings.blobStrength = 0.2;
                        updateWebcamStatus(`😐 ללא הומור (${intensity}/10) - רגיל וניטרלי`);
                    }
                    break;
                    
                case 'shine': // ✨ Shine - Bright, glowing, radiant
                    visualSettings.resolution = Math.max(3, 8 - intensity);
                    visualSettings.brightness = 20 + (intensity * 4);
                    visualSettings.contrast = 120 + (intensity * 8);
                    visualSettings.charSet = 'hearts';
                    visualSettings.colorMode = 'original';
                    visualSettings.blobEffect = true;
                    visualSettings.blobStrength = 0.6 + (intensityFactor * 0.4);
                    visualSettings.invertMode = false;
                    
                    updateWebcamStatus(`✨ מצב ברק (עוצמה ${intensity}/10) - זוהר ומאיר`);
                    break;
                    
                case 'bliss': // 🌟 Bliss - Ethereal, dreamy, flowing
                    visualSettings.resolution = 12 + Math.floor(intensityFactor * 6);
                    visualSettings.brightness = 15 + (intensity * 2);
                    visualSettings.contrast = 70 + (intensity * 4);
                    visualSettings.charSet = 'minimal';
                    visualSettings.colorMode = 'cool';
                    visualSettings.blobEffect = true;
                    visualSettings.blobStrength = 0.8 + (intensityFactor * 0.2);
                    
                    updateWebcamStatus(`🌟 מצב אושר מוחלט (עוצמה ${intensity}/10) - חלומי וזורם`);
                    break;
            }
        }
        
        function applyEmotionEffects(emotion, intensity, intensityFactor) {
            // Apply effects based on actual emotions from emotions_config.json
            const emotionEffects = {
                'happiness': {
                    resolution: Math.max(4, 10 - intensity),
                    brightness: 15 + (intensity * 2),
                    contrast: 100 + (intensity * 5),
                    charSet: 'hearts',
                    colorMode: 'warm',
                    blobStrength: 0.3 + (intensityFactor * 0.4),
                    status: `😊 שמחה (עוצמה ${intensity}/10)`
                },
                'joy': {
                    resolution: Math.max(3, 8 - intensity),
                    brightness: 20 + (intensity * 3),
                    contrast: 110 + (intensity * 6),
                    charSet: 'hearts',
                    colorMode: 'warm',
                    blobStrength: 0.5 + (intensityFactor * 0.5),
                    status: `😄 שמחה גדולה (עוצמה ${intensity}/10)`
                },
                'curiosity': {
                    resolution: 6 + Math.floor(intensityFactor * 4),
                    brightness: 5 + (intensity * 2),
                    contrast: 110 + (intensity * 4),
                    charSet: 'matrix',
                    colorMode: 'blue',
                    blobStrength: 0.4 + (intensityFactor * 0.3),
                    status: `🤔 סקרנות (עוצמה ${intensity}/10)`
                },
                'confusion': {
                    resolution: 8 + Math.floor(intensityFactor * 6),
                    brightness: -10 + (intensity * 3),
                    contrast: 80 + (intensity * 8),
                    charSet: 'hebrew',
                    colorMode: 'cool',
                    blobStrength: 0.5 + (intensityFactor * 0.5),
                    status: `😕 בלבול (עוצמה ${intensity}/10)`
                },
                'anger': {
                    resolution: 4,
                    brightness: -5 + (intensity * 3),
                    contrast: 130 + (intensity * 10),
                    charSet: 'blocks',
                    colorMode: 'grayscale',
                    blobStrength: 0.7 + (intensityFactor * 0.3),
                    status: `😠 כעס (עוצמה ${intensity}/10)`
                },
                'sadness': {
                    resolution: 10 + Math.floor(intensityFactor * 4),
                    brightness: -15 + (intensity * 2),
                    contrast: 60 + (intensity * 6),
                    charSet: 'dots',
                    colorMode: 'blue',
                    blobStrength: 0.2 + (intensityFactor * 0.3),
                    status: `😢 עצב (עוצמה ${intensity}/10)`
                },
                'amusement': {
                    resolution: 7,
                    brightness: 12 + (intensity * 2),
                    contrast: 105 + (intensity * 5),
                    charSet: 'dots',
                    colorMode: 'warm',
                    blobStrength: 0.4 + (intensityFactor * 0.4),
                    status: `😄 שעשוע (עוצמה ${intensity}/10)`
                },
                'playfulness': {
                    resolution: 8,
                    brightness: 8 + (intensity * 3),
                    contrast: 95 + (intensity * 7),
                    charSet: 'hearts',
                    colorMode: 'warm',
                    blobStrength: 0.5 + (intensityFactor * 0.4),
                    status: `😜 שובבות (עוצמה ${intensity}/10)`
                }
            };
            
            const effect = emotionEffects[emotion];
            if (effect) {
                Object.assign(visualSettings, effect);
                visualSettings.blobEffect = true;
                updateWebcamStatus(effect.status);
            }
        }
        
        function applyParameterEffects(option) {
            // Handle communication patterns, topics, dynamics, etc.
            if (option.dataset.pattern) {
                applyCommunicationPattern(option.dataset.pattern);
            }
            if (option.dataset.topic) {
                applyTopicEffects(option.dataset.topic);
            }
            if (option.dataset.dynamic) {
                applyDynamicEffects(option.dataset.dynamic);
            }
            if (option.dataset.flow) {
                applyFlowEffects(option.dataset.flow);
            }
            if (option.dataset.strength) {
                applyStrengthEffects(option.dataset.strength);
            }
        }
        
        function applyCommunicationPattern(pattern) {
            switch(pattern) {
                case 'assertive':
                    visualSettings.charSet = 'standard';
                    visualSettings.contrast += 20;
                    visualSettings.resolution = Math.max(4, visualSettings.resolution - 2);
                    updateWebcamStatus('💪 דפוס נחרץ - קווים חדים');
                    break;
                case 'supportive':
                    visualSettings.charSet = 'hearts';
                    visualSettings.brightness += 15;
                    visualSettings.blobStrength += 0.3;
                    updateWebcamStatus('🤝 דפוס תומך - חם ומעודד');
                    break;
                case 'analytical':
                                    visualSettings.charSet = 'matrix';
                visualSettings.colorMode = 'blobStyle'; // Use blob-style colors
                visualSettings.contrast += 25;
                    updateWebcamStatus('🧠 דפוס אנליטי - מבנה מדויק');
                    break;
                case 'emotional':
                    visualSettings.charSet = 'hearts';
                    visualSettings.colorMode = 'warm';
                    visualSettings.blobEffect = true;
                    visualSettings.blobStrength += 0.4;
                    updateWebcamStatus('❤️ דפוס רגשי - זורם ועמוק');
                    break;
            }
        }
        
        function applyTopicEffects(topic) {
            const topicEffects = {
                'family': { charSet: 'hearts', colorMode: 'warm', brightness: 10 },
                'work': { charSet: 'standard', colorMode: 'cool', contrast: 15 },
                'social': { charSet: 'dots', colorMode: 'blue', blobStrength: 0.3 },
                'study': { charSet: 'matrix', colorMode: 'green', contrast: 20 },
                'military': { charSet: 'blocks', colorMode: 'grayscale', contrast: 25 },
                'home': { charSet: 'minimal', colorMode: 'warm', brightness: 5 }
            };
            
            const effect = topicEffects[topic];
            if (effect) {
                Object.assign(visualSettings, effect);
                updateWebcamStatus(`נושא: ${topic}`);
            }
        }
        
        function applyDynamicEffects(dynamic) {
            switch(dynamic) {
                case 'leading':
                    visualSettings.contrast += 20;
                    visualSettings.blobStrength += 0.3;
                    break;
                case 'equal':
                    visualSettings.brightness += 10;
                    break;
                case 'supporting':
                    visualSettings.charSet = 'hearts';
                    visualSettings.colorMode = 'warm';
                    break;
                case 'adaptive':
                    visualSettings.blobEffect = true;
                    visualSettings.blobStrength += 0.4;
                    break;
            }
        }
        
        function applyFlowEffects(flow) {
            switch(flow) {
                case 'direct':
                    visualSettings.resolution = Math.max(4, visualSettings.resolution - 2);
                    visualSettings.contrast += 15;
                    break;
                case 'natural':
                    visualSettings.blobEffect = true;
                    visualSettings.blobStrength += 0.3;
                    break;
                case 'goal_oriented':
                    visualSettings.charSet = 'standard';
                    visualSettings.contrast += 10;
                    break;
                case 'dramatic':
                    visualSettings.brightness += 15;
                    visualSettings.blobStrength += 0.5;
                    break;
            }
        }
        
        function applyStrengthEffects(strength) {
            const strengthEffects = {
                'listening': { charSet: 'dots', colorMode: 'cool' },
                'clarity': { charSet: 'standard', contrast: 20 },
                'empathy': { charSet: 'hearts', colorMode: 'warm' },
                'humor': { charSet: 'dots', blobStrength: 0.4 },
                'logical': { charSet: 'matrix', colorMode: 'blue' },
                'focused': { resolution: -2, contrast: 15 }
            };
            
            const effect = strengthEffects[strength];
            if (effect) {
                Object.assign(visualSettings, effect);
            }
        }
        
        // Communication style effects based on your conversation insights
        function updateCommunicationStyleEffects(style) {
            switch(style) {
                case 'direct': // תקשורת ישירה
                    visualSettings.charSet = 'standard';
                    visualSettings.contrast += 15;
                    visualSettings.resolution = Math.max(4, visualSettings.resolution - 1);
                    break;
                    
                case 'supportive': // תקשורת תומכת
                    visualSettings.charSet = 'hearts';
                    visualSettings.brightness += 10;
                    visualSettings.blobStrength = Math.min(1.0, visualSettings.blobStrength + 0.2);
                    break;
                    
                case 'analytical': // תקשורת אנליטית
                                    visualSettings.charSet = 'matrix';
                visualSettings.colorMode = 'blobStyle'; // Use blob-style colors
                visualSettings.contrast += 20;
                    break;
                    
                case 'emotional': // תקשורת רגשית
                    visualSettings.charSet = 'hearts';
                    visualSettings.colorMode = 'warm';
                    visualSettings.blobEffect = true;
                    visualSettings.blobStrength = Math.min(1.0, visualSettings.blobStrength + 0.4);
                    break;
            }
        }

        // Comprehensive conversation analysis profile
        let conversationProfile = {
            primaryEmotions: [],
            aiEmotions: { humor: 0, shine: 0, bliss: 0 },
            emotionalIntensity: 5,
            communicationPatterns: null,
            conversationTopics: [],
            relationshipDynamics: null,
            conversationFlow: null,
            communicationStrengths: [],
            overallProfile: null
        };
        
        let currentQuestionIndex = 0;
        
        // Comprehensive question bank based on ALL conversation parameters
        const questionBank = [
            {
                id: 'primary_emotions',
                title: 'איזה רגשות מאפיינים אותך בשיחות? (בחר עד 3)',
                multiple: true,
                maxSelections: 3,
                options: [
                    { text: '😊 שמחה', value: 'happiness', emotion: 'happiness', color: '#FFD700' },
                    { text: '😄 שמחה גדולה', value: 'joy', emotion: 'joy', color: '#FFFF00' },
                    { text: '😄 שעשוע', value: 'amusement', emotion: 'amusement', color: '#DDA0DD' },
                    { text: '🤔 סקרנות', value: 'curiosity', emotion: 'curiosity', color: '#ff00d0' },
                    { text: '😕 בלבול', value: 'confusion', emotion: 'confusion', color: '#DDA0DD' },
                    { text: '😰 חרדה', value: 'anxious', emotion: 'anxious', color: '#9370DB' },
                    { text: '😠 כעס', value: 'anger', emotion: 'anger', color: '#FF4500' },
                    { text: '😢 עצב', value: 'sadness', emotion: 'sadness', color: '#4169E1' }
                ]
            },
            {
                id: 'humor_level',
                title: 'איך ההומור מאפיין את השיחות שלך?',
                options: [
                    { text: '😂 הרבה הומור וצחוק (גבוה)', value: 'high_humor', ai_emotion: 'humor', intensity: 9 },
                    { text: '😄 הומור בינוני', value: 'medium_humor', ai_emotion: 'humor', intensity: 6 },
                    { text: '🙂 קצת הומור', value: 'low_humor', ai_emotion: 'humor', intensity: 3 },
                    { text: '😐 בלי הומור כמעט', value: 'no_humor', ai_emotion: 'humor', intensity: 0 }
                ]
            },
            {
                id: 'ai_emotions', 
                title: 'איזה תחושות מיוחדות אתה חווה?',
                options: [
                    { text: '✨ ברק ושטחת (Shine)', value: 'shine', ai_emotion: 'shine', intensity: 7 },
                    { text: '🌟 אושר מוחלט (Bliss)', value: 'bliss', ai_emotion: 'bliss', intensity: 9 },
                    { text: '😜 שובבות', value: 'playfulness', emotion: 'playfulness', color: '#F7DC6F' },
                    { text: '🎭 דרמטיות', value: 'dramatic', emotion: 'dramatic', color: '#E74C3C' }
                ]
            },
            {
                id: 'communication_patterns',
                title: 'איך את/ה מתקשר/ת? (דפוסי תקשורת)',
                options: [
                    { text: '💪 נחרץ ובטוח', value: 'assertive', pattern: 'assertive' },
                    { text: '🤝 תומך ומעודד', value: 'supportive', pattern: 'supportive' },
                    { text: '🧠 אנליטי ומפורט', value: 'analytical', pattern: 'analytical' },
                    { text: '❤️ רגשי ואמפתי', value: 'emotional', pattern: 'emotional' }
                ]
            },
            {
                id: 'conversation_topics',
                title: 'באיזה נושאים את/ה הכי מעורב/ת?',
                multiple: true,
                maxSelections: 2,
                options: [
                    { text: '👨‍👩‍👧‍👦 משפחה', value: 'family', topic: 'family' },
                    { text: '💼 עבודה', value: 'work', topic: 'work' },
                    { text: '🎓 לימודים', value: 'study', topic: 'study' },
                    { text: '🎉 חברתי', value: 'social', topic: 'social' },
                    { text: '⚔️ צבא', value: 'military', topic: 'military' },
                    { text: '🏠 בית', value: 'home', topic: 'home' }
                ]
            },
            {
                id: 'emotional_intensity',
                title: 'באיזה עוצמה רגשית את/ה חווה שיחות?',
                options: [
                    { text: '🌟 עוצמה גבוהה מאוד (9-10)', value: 'very_high', intensity: 10 },
                    { text: '⚡ עוצמה גבוהה (7-8)', value: 'high', intensity: 8 },
                    { text: '📊 עוצמה בינונית (5-6)', value: 'medium', intensity: 6 },
                    { text: '🕊️ עוצמה נמוכה (1-4)', value: 'low', intensity: 3 }
                ]
            },
            {
                id: 'relationship_dynamics',
                title: 'איך את/ה מתנהג/ת בקשרים?',
                options: [
                    { text: '👑 מוביל ומשפיע', value: 'dominant', dynamic: 'leading' },
                    { text: '🤝 שותף שוויוני', value: 'equal', dynamic: 'equal' },
                    { text: '👂 מקשיב ותומך', value: 'supportive', dynamic: 'supporting' },
                    { text: '🔄 משתנה לפי מצב', value: 'adaptive', dynamic: 'adaptive' }
                ]
            },
            {
                id: 'conversation_flow',
                title: 'איך השיחות שלך מתנהלות?',
                options: [
                    { text: '➡️ ישר לנושא, מאורגן', value: 'direct_flow', flow: 'direct' },
                    { text: '🌊 זורם טבעי, גמיש', value: 'natural_flow', flow: 'natural' },
                    { text: '🎯 ממוקד במטרות', value: 'goal_oriented', flow: 'goal_oriented' },
                    { text: '🎭 דרמטי עם שיאים', value: 'dramatic', flow: 'dramatic' }
                ]
            },
            {
                id: 'communication_strengths',
                title: 'מה החוזקות שלך בתקשורת?',
                multiple: true,
                maxSelections: 2,
                options: [
                    { text: '👂 הקשבה פעילה', value: 'listening', strength: 'listening' },
                    { text: '💭 בהירות ביטוי', value: 'clarity', strength: 'clarity' },
                    { text: '❤️ אמפתיה', value: 'empathy', strength: 'empathy' },
                    { text: '😂 הומור', value: 'humor', strength: 'humor' },
                    { text: '🧠 ניתוח לוגי', value: 'logical', strength: 'logical' },
                    { text: '🎯 מיקוד במטרה', value: 'focused', strength: 'focused' }
                ]
            }
        ];
        
        // Handle navigation with multiple selection support
        const nextButton = document.querySelector('.next-button');
        if (nextButton) {
            nextButton.addEventListener('click', () => {
            const currentQuestion = questionBank[currentQuestionIndex];
            const selectedOptions = document.querySelectorAll('.option.selected');
            
            if (selectedOptions.length > 0) {
                // Store answer(s) in conversation profile
                if (currentQuestion.multiple) {
                    storeAnswer(Array.from(selectedOptions));
                } else {
                    storeAnswer(selectedOptions[0]);
                }
                nextQuestion();
            }
        });
        }

        // Store answers based on comprehensive question types
        function storeAnswer(selectedOptions) {
            const currentQuestion = questionBank[currentQuestionIndex];
            
            // Handle multiple selections
            if (Array.isArray(selectedOptions)) {
                selectedOptions.forEach(option => storeAnswerSingle(option, currentQuestion));
            } else {
                storeAnswerSingle(selectedOptions, currentQuestion);
            }
            
            console.log('Updated comprehensive conversation profile:', conversationProfile);
        }
        
        function storeAnswerSingle(option, currentQuestion) {
            switch(currentQuestion.id) {
                case 'primary_emotions':
                    if (option.dataset.emotion) {
                        conversationProfile.primaryEmotions.push({
                            emotion: option.dataset.emotion,
                            color: option.dataset.color,
                            value: option.dataset.value
                        });
                    }
                    break;
                    
                case 'humor_level':
                    if (option.dataset.ai_emotion === 'humor') {
                        const intensity = parseInt(option.dataset.intensity) || 0;
                        conversationProfile.aiEmotions.humor = intensity;
                        console.log(`😂 [${sketchInstanceId}] Humor level set to: ${intensity}/10`);
                    }
                    break;
                    
                case 'ai_emotions':
                    if (option.dataset.ai_emotion) {
                        const intensity = parseInt(option.dataset.intensity) || 5;
                        conversationProfile.aiEmotions[option.dataset.ai_emotion] = intensity;
                    }
                    break;
                    
                case 'communication_patterns':
                    conversationProfile.communicationPatterns = option.dataset.pattern;
                    break;
                    
                case 'conversation_topics':
                    if (option.dataset.topic) {
                        conversationProfile.conversationTopics.push(option.dataset.topic);
                    }
                    break;
                    
                case 'emotional_intensity':
                    conversationProfile.emotionalIntensity = parseInt(option.dataset.intensity);
                    break;
                    
                case 'relationship_dynamics':
                    conversationProfile.relationshipDynamics = option.dataset.dynamic;
                    break;
                    
                case 'conversation_flow':
                    conversationProfile.conversationFlow = option.dataset.flow;
                    break;
                    
                case 'communication_strengths':
                    if (option.dataset.strength) {
                        conversationProfile.communicationStrengths.push(option.dataset.strength);
                    }
                    break;
            }
        }

        // Progress through conversation parameter questions
        function nextQuestion() {
            currentQuestionIndex++;
            
            if (currentQuestionIndex >= questionBank.length) {
                // Questionnaire complete - show final analysis
                showFinalAnalysis();
                return;
            }
            
            const currentQuestion = questionBank[currentQuestionIndex];
            const progressPercent = Math.round(((currentQuestionIndex + 1) / questionBank.length) * 100);
            
            // Update progress
            const progressFill = document.querySelector('.progress-fill');
            const progressText = document.querySelector('.progress-text');
            const progressPercentage = document.querySelector('.progress-percentage');
            
            progressFill.style.width = progressPercent + '%';
            progressText.textContent = `שלב ${currentQuestionIndex + 1} מתוך ${questionBank.length}`;
            progressPercentage.textContent = progressPercent + '%';
            
            // Update question
            const questionTitle = document.querySelector('.question-title');
            questionTitle.textContent = currentQuestion.title;
            
            // Update options
            document.querySelectorAll('.option').forEach((option, index) => {
                const questionOption = currentQuestion.options[index];
                option.querySelector('span').textContent = questionOption.text;
                option.classList.remove('selected');
                option.dataset.value = questionOption.value;
                
                // Set data attributes based on question type
                if (questionOption.emotion) option.dataset.emotion = questionOption.emotion;
                if (questionOption.intensity) option.dataset.intensity = questionOption.intensity;
                if (questionOption.style) option.dataset.style = questionOption.style;
                if (questionOption.topic) option.dataset.topic = questionOption.topic;
                if (questionOption.relationship) option.dataset.relationship = questionOption.relationship;
            });
            
            // Re-attach event listeners for new options
            attachOptionListeners();
            
            // Disable next button
            document.querySelector('.next-button').disabled = true;
            
            // Start webcam immediately when question is displayed
            console.log('Question displayed, checking webcam...');
            if (!isWebcamRunning) {
                console.log('Starting webcam from question display...');
                startWebcam();
            } else {
                console.log('Webcam already running');
            }
        }
        
        function showFinalAnalysis() {
            // Show final conversation analysis based on collected parameters
            const questionTitle = document.querySelector('.question-title');
            questionTitle.textContent = 'ניתוח השיחה שלך הושלם!';
            
            // Create summary based on conversation profile
            const analysisText = generateConversationAnalysis();
            
            document.querySelector('.options-container').innerHTML = `
                <div style="padding: 20px; background: rgba(255,255,255,0.9); border-radius: 8px; text-align: center;">
                    <h3>הפרופיל התקשורתי שלך:</h3>
                    <p style="margin: 15px 0; line-height: 1.6;">${analysisText}</p>
                    <button onclick="resetQuestionnaire()" style="padding: 10px 20px; background: #333; color: white; border: none; border-radius: 6px; cursor: pointer;">
                        התחל מחדש
                    </button>
                </div>
            `;
            
            // Apply final combined effects
            applyFinalConversationEffects();
        }
        
        function generateConversationAnalysis() {
            const { 
                primaryEmotions, aiEmotions, emotionalIntensity, 
                communicationPatterns, conversationTopics, relationshipDynamics, 
                conversationFlow, communicationStrengths 
            } = conversationProfile;
            
            let analysis = `📊 פרופיל התקשורת המלא שלך:\\n\\n`;
            
            // Primary emotions
            if (primaryEmotions.length > 0) {
                const emotionNames = primaryEmotions.map(e => getEmotionHebrew(e.emotion)).join(', ');
                analysis += `🎭 רגשות ראשיים: ${emotionNames}\\n`;
            }
            
            // AI emotions (humor, bliss, shine)
            const activeAI = Object.entries(aiEmotions).filter(([k, v]) => v > 0);
            if (activeAI.length > 0) {
                const aiDesc = activeAI.map(([emotion, intensity]) => `${getAIEmotionHebrew(emotion)} (${intensity}/10)`).join(', ');
                analysis += `✨ תחושות מיוחדות: ${aiDesc}\\n`;
            }
            
            // Emotional intensity
            analysis += `⚡ עוצמה רגשית: ${emotionalIntensity}/10\\n`;
            
            // Communication patterns
            if (communicationPatterns) {
                analysis += `💬 דפוס תקשורת: ${getPatternHebrew(communicationPatterns)}\\n`;
            }
            
            // Topics
            if (conversationTopics.length > 0) {
                const topicNames = conversationTopics.map(getTopicHebrew).join(', ');
                analysis += `📋 נושאים מועדפים: ${topicNames}\\n`;
            }
            
            // Relationship dynamics
            if (relationshipDynamics) {
                analysis += `🤝 דינמיקה בקשרים: ${getDynamicHebrew(relationshipDynamics)}\\n`;
            }
            
            // Conversation flow
            if (conversationFlow) {
                analysis += `🌊 זרימת שיחה: ${getFlowHebrew(conversationFlow)}\\n`;
            }
            
            // Communication strengths
            if (communicationStrengths.length > 0) {
                const strengthNames = communicationStrengths.map(getStrengthHebrew).join(', ');
                analysis += `💪 חוזקות תקשורתיות: ${strengthNames}`;
            }
            
            return analysis;
        }
        
        function getEmotionHebrew(emotion) {
            const emotions = { 
                happiness: 'שמחה', joy: 'שמחה גדולה', amusement: 'שעשוע',
                curiosity: 'סקרנות', confusion: 'בלבול', anxious: 'חרדה', 
                anger: 'כעס', sadness: 'עצב', playfulness: 'שובבות'
            };
            return emotions[emotion] || emotion;
        }
        
        function getAIEmotionHebrew(aiEmotion) {
            const aiEmotions = { humor: 'הומור', shine: 'ברק', bliss: 'אושר מוחלט' };
            return aiEmotions[aiEmotion] || aiEmotion;
        }
        
        function getPatternHebrew(pattern) {
            const patterns = { assertive: 'נחרץ', supportive: 'תומך', analytical: 'אנליטי', emotional: 'רגשי' };
            return patterns[pattern] || pattern;
        }
        
        function getTopicHebrew(topic) {
            const topics = { 
                family: 'משפחה', work: 'עבודה', social: 'חברתי', 
                study: 'לימודים', military: 'צבא', home: 'בית' 
            };
            return topics[topic] || topic;
        }
        
        function getDynamicHebrew(dynamic) {
            const dynamics = { 
                leading: 'מוביל', equal: 'שוויוני', 
                supporting: 'תומך', adaptive: 'מסתגל' 
            };
            return dynamics[dynamic] || dynamic;
        }
        
        function getFlowHebrew(flow) {
            const flows = { 
                direct: 'ישיר', natural: 'טבעי', 
                goal_oriented: 'ממוקד מטרה', dramatic: 'דרמטי' 
            };
            return flows[flow] || flow;
        }
        
        function getStrengthHebrew(strength) {
            const strengths = { 
                listening: 'הקשבה', clarity: 'בהירות', empathy: 'אמפתיה',
                humor: 'הומור', logical: 'לוגיקה', focused: 'מיקוד' 
            };
            return strengths[strength] || strength;
        }
        
        function applyFinalConversationEffects() {
            // Combine all effects based on complete comprehensive conversation profile
            const { 
                primaryEmotions, aiEmotions, emotionalIntensity, 
                communicationPatterns, conversationTopics 
            } = conversationProfile;
            
            // Apply layered effects from all parameters
            visualSettings.emotionalIntensity = emotionalIntensity;
            
            // Combine primary emotions effects
            if (primaryEmotions.length > 0) {
                primaryEmotions.forEach(emotion => {
                    applyEmotionEffects(emotion.emotion, emotionalIntensity, emotionalIntensity / 10);
                });
            }
            
            // Apply AI emotion effects
            Object.entries(aiEmotions).forEach(([emotion, intensity]) => {
                if (intensity > 0) {
                    applyAIEmotionEffects(emotion, intensity);
                }
            });
            
            // Apply communication pattern effects
            if (communicationPatterns) {
                applyCommunicationPattern(communicationPatterns);
            }
            
            // Apply topic effects
            conversationTopics.forEach(topic => {
                applyTopicEffects(topic);
            });
            
            // Create comprehensive final status
            let statusParts = [];
            
            if (primaryEmotions.length > 0) {
                statusParts.push(primaryEmotions.map(e => getEmotionHebrew(e.emotion)).join('+'));
            }
            
            const activeAI = Object.entries(aiEmotions).filter(([k, v]) => v > 0);
            if (activeAI.length > 0) {
                statusParts.push(activeAI.map(([e, i]) => `${getAIEmotionHebrew(e)}(${i})`).join('+'));
            }
            
            if (communicationPatterns) {
                statusParts.push(getPatternHebrew(communicationPatterns));
            }
            
            const finalStatus = `🎯 פרופיל מלא: ${statusParts.join(' | ')} | עוצמה ${emotionalIntensity}/10`;
            updateWebcamStatus(finalStatus);
        }
        
        function resetQuestionnaire() {
            currentQuestionIndex = 0;
            conversationProfile = {
                primaryEmotions: [],
                aiEmotions: { humor: 0, shine: 0, bliss: 0 },
                emotionalIntensity: 5,
                communicationPatterns: null,
                conversationTopics: [],
                relationshipDynamics: null,
                conversationFlow: null,
                communicationStrengths: [],
                overallProfile: null
            };
            
            // Reset to first question
            const firstQuestion = questionBank[0];
            document.querySelector('.question-title').textContent = firstQuestion.title;
            document.querySelector('.progress-fill').style.width = '11%';
            document.querySelector('.progress-text').textContent = 'שלב 1 מתוך 9';
            document.querySelector('.progress-percentage').textContent = '11%';
            
            // Restore comprehensive original options
            const optionsContainer = document.querySelector('.options-container');
            optionsContainer.innerHTML = `
                <div class="option" data-value="happiness" data-emotion="happiness" data-color="#FFD700">
                    <div class="option-radio"></div>
                    <span>😊 שמחה</span>
                </div>
                <div class="option" data-value="joy" data-emotion="joy" data-color="#FFFF00">
                    <div class="option-radio"></div>
                    <span>😄 שמחה גדולה</span>
                </div>
                <div class="option" data-value="amusement" data-emotion="amusement" data-color="#DDA0DD">
                    <div class="option-radio"></div>
                    <span>😄 שעשוע</span>
                </div>
                <div class="option" data-value="curiosity" data-emotion="curiosity" data-color="#ff00d0">
                    <div class="option-radio"></div>
                    <span>🤔 סקרנות</span>
                </div>
                <div class="option" data-value="confusion" data-emotion="confusion" data-color="#DDA0DD">
                    <div class="option-radio"></div>
                    <span>😕 בלבול</span>
                </div>
                <div class="option" data-value="anxious" data-emotion="anxious" data-color="#9370DB">
                    <div class="option-radio"></div>
                    <span>😰 חרדה</span>
                </div>
                <div class="option" data-value="anger" data-emotion="anger" data-color="#FF4500">
                    <div class="option-radio"></div>
                    <span>😠 כעס</span>
                </div>
                <div class="option" data-value="sadness" data-emotion="sadness" data-color="#4169E1">
                    <div class="option-radio"></div>
                    <span>😢 עצב</span>
                </div>
            `;
            
            attachOptionListeners();
            document.querySelector('.next-button').disabled = true;
            
            // Start webcam immediately when first question is displayed
            console.log('First question displayed, checking webcam...');
            if (!isWebcamRunning) {
                console.log('Starting webcam from first question...');
                startWebcam();
            } else {
                console.log('Webcam already running');
            }
        }
        
        function attachOptionListeners() {
            document.querySelectorAll('.option').forEach(option => {
                option.replaceWith(option.cloneNode(true)); // Remove old listeners
            });
            
            const currentQuestion = questionBank[currentQuestionIndex];
            
            document.querySelectorAll('.option').forEach(option => {
                option.addEventListener('click', () => {
                    if (currentQuestion.multiple) {
                        // Handle multiple selection
                        option.classList.toggle('selected');
                        
                        // Check selection limits
                        const selectedCount = document.querySelectorAll('.option.selected').length;
                        const maxSelections = currentQuestion.maxSelections || 999;
                        
                        if (selectedCount > maxSelections) {
                            option.classList.remove('selected');
                            updateWebcamStatus(`ניתן לבחור עד ${maxSelections} אפשרויות`);
                            return;
                        }
                        
                        document.querySelector('.next-button').disabled = selectedCount === 0;
                    } else {
                        // Handle single selection
                        document.querySelectorAll('.option').forEach(opt => opt.classList.remove('selected'));
                        option.classList.add('selected');
                        document.querySelector('.next-button').disabled = false;
                    }
                    
                    updateBlobEffects(option.dataset.value, option);
                });
            });
        }

        // Copy functionality removed - no copy buttons in pure placeholders



        // Initialize comprehensive conversation analysis system
        window.addEventListener('load', () => {
            console.log('🚀 ENHANCED Conversation Analysis System Ready!');
            console.log('📊 Features: ALL emotions, dedicated HUMOR levels, shine/bliss, communication patterns, topics, dynamics, flow, strengths');
            console.log('🎯 9 comprehensive questions with enhanced humor detection and multiple selection support');
            console.log('✨ Real-time webcam effects based on YOUR conversation parameters');
            console.log('😂 NEW: Dedicated humor question with 4-level intensity (0-9) for dynamic camera effects');
            // Attach initial option listeners
            attachOptionListeners();
        });

        // Voice Recording Functions


        // Dot Animation Functions
        function startDotAnimation(stream) {
            try {
                // Create audio context for real-time analysis
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                analyser.smoothingTimeConstant = 0.8;
                
                // Connect microphone to analyser
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                // Start animation loop
                animateDots();
                
                console.log('🎤 Started dot animation');
            } catch (error) {
                console.error('Error starting dot animation:', error);
            }
        }

        function stopDotAnimation() {
            if (dotAnimationId) {
                cancelAnimationFrame(dotAnimationId);
                dotAnimationId = null;
            }
            
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            
            if (microphone) {
                microphone.disconnect();
                microphone = null;
            }
            
            analyser = null;
            
            // Reset all dots
            const dots = document.querySelectorAll('.dot');
            dots.forEach(dot => {
                dot.classList.remove('active', 'recording');
            });
            
            activeDots = [];
            
            console.log('🎤 Stopped dot animation');
        }

        function animateDots() {
            if (!analyser || !isRecording) return;
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            // Calculate average volume
            const average = dataArray.reduce((a, b) => a + b) / bufferLength;
            const volume = average / 255; // Normalize to 0-1
            
            // Get all dots
            const dots = document.querySelectorAll('.dot');
            const totalDots = dots.length;
            
            // Calculate how many dots should be active based on volume
            const activeCount = Math.max(1, Math.floor(volume * totalDots * 0.8));
            
            // Clear previous active dots
            dots.forEach(dot => {
                dot.classList.remove('active');
            });
            
            // Activate dots based on volume
            for (let i = 0; i < activeCount; i++) {
                if (dots[i]) {
                    dots[i].classList.add('active');
                    if (isRecording) {
                        dots[i].classList.add('recording');
                    }
                }
            }
            
            // Continue animation
            dotAnimationId = requestAnimationFrame(animateDots);
        }

        async function toggleRecording() {
            if (!isRecording) {
                await startRecording();
            } else {
                stopRecording();
            }
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100
                    }
                });
                
                // Configure MediaRecorder with supported options
                let options = {};
                if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                    options.mimeType = 'audio/webm;codecs=opus';
                } else if (MediaRecorder.isTypeSupported('audio/webm')) {
                    options.mimeType = 'audio/webm';
                } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
                    options.mimeType = 'audio/mp4';
                }
                
                console.log('MediaRecorder options:', options);
                mediaRecorder = new MediaRecorder(stream, options);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = async () => {
                    console.log('Audio chunks:', audioChunks.length, audioChunks);
                    
                    // Ensure we have audio data
                    if (audioChunks.length === 0) {
                        console.error('No audio chunks recorded');
                        document.getElementById('voiceStatus').textContent = 'שגיאה: לא הוקלט שום דבר';
                        return;
                    }
                    
                    // Create blob with the same MIME type as MediaRecorder
                    const mimeType = mediaRecorder.mimeType || 'audio/webm';
                    const audioBlob = new window.Blob(audioChunks, { type: mimeType });
                    
                    console.log('Created audio blob:');
                    console.log('- Blob object:', audioBlob);
                    console.log('- Size:', audioBlob.size);
                    console.log('- Type:', audioBlob.type);
                    console.log('- MIME type used:', mimeType);
                    console.log('- Chunks length:', audioChunks.length);
                    
                    // Verify blob is valid (some browsers might have undefined size initially)
                    const blobSize = audioBlob.size || 0;
                    if (blobSize === 0) {
                        console.error('Audio blob is empty');
                        document.getElementById('voiceStatus').textContent = 'שגיאה: הקלטה ריקה';
                        return;
                    }
                    
                    // Add small delay to ensure blob is fully formed
                    setTimeout(async () => {
                        await processAudioRecording(audioBlob);
                    }, 100);
                };
                
                mediaRecorder.start();
                isRecording = true;
                
                // Update UI for both interfaces
                const recordButton = document.getElementById('recordButton');
                const simpleStatus = document.getElementById('simpleStatus');
                const voiceStatus = document.getElementById('voiceStatus');
                
                if (recordButton) {
                    recordButton.classList.add('recording');
                    document.getElementById('recordButtonText').textContent = 'עצור הקלטה';
                    document.getElementById('recordingIndicator').style.display = 'flex';
                    document.getElementById('voiceWaveform').style.display = 'flex';
                }
                
                if (simpleStatus) {
                    simpleStatus.classList.add('recording');
                }
                
                // Add recording state to voice input field
                const voiceInputField = document.getElementById('voiceInputField');
                if (voiceInputField) {
                    voiceInputField.classList.add('recording');
                }
                
                // Show action buttons and hide microphone
                const micIcon = document.getElementById('micIcon');
                const actionButtons = document.getElementById('actionButtons');
                
                if (micIcon) micIcon.style.display = 'none';
                if (actionButtons) actionButtons.style.display = 'flex';
                
                                // Start audio visualization
                if (stream) {
                    startAudioVisualization(stream);
                }
                
                // Start dot animation
                startDotAnimation(stream);
                
                // ASCII blob visualization removed - using simple visualization div
                
                
            } catch (error) {
                console.error('Error starting recording:', error);
                document.getElementById('voiceStatus').textContent = 'שגיאה בגישה למיקרופון';
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                isRecording = false;
                
                // Update UI for both interfaces
                const recordButton = document.getElementById('recordButton');
                const simpleStatus = document.getElementById('simpleStatus');
                const voiceStatus = document.getElementById('voiceStatus');
                
                if (recordButton) {
                    recordButton.classList.remove('recording');
                    document.getElementById('recordButtonText').textContent = 'התחל הקלטה';
                    document.getElementById('recordingIndicator').style.display = 'none';
                    document.getElementById('voiceWaveform').style.display = 'none';
                    if (voiceStatus) voiceStatus.textContent = 'מעבד את ההקלטה...';
                }
                
                if (simpleStatus) {
                    simpleStatus.textContent = 'מעבד את ההקלטה...';
                    simpleStatus.classList.remove('recording');
                }
                
                // Remove recording state from voice input field
                const voiceInputField = document.getElementById('voiceInputField');
                if (voiceInputField) {
                    voiceInputField.classList.remove('recording');
                }
                
                // Hide action buttons and show microphone
                const micIcon = document.getElementById('micIcon');
                const actionButtons = document.getElementById('actionButtons');
                
                if (micIcon) micIcon.style.display = 'flex';
                if (actionButtons) actionButtons.style.display = 'none';
                
                // Stop audio visualization
                stopAudioVisualization();
                
                // Stop dot animation
                stopDotAnimation();
                
                // ✨ Continue ASCII blob visualization during processing (don't stop yet)
                updateASCIIBlobStatus('מעבד הקלטה...');

            }
        }

        async function processAudioRecording(audioBlob) {
            try {
                // Show processing status on both interfaces
                const voiceStatus = document.getElementById('voiceStatus');
                const simpleStatus = document.getElementById('simpleStatus');
                
                if (voiceStatus) voiceStatus.textContent = 'מתרגם את ההקלטה לטקסט...';
                if (simpleStatus) simpleStatus.textContent = 'מתרגם את ההקלטה לטקסט...';
                
                // 🎵 CREATE AUDIO PLAYBACK FROM RECORDED BLOB
                window.recordedAudioBlob = audioBlob; // Store for later playback
                const audioUrl = URL.createObjectURL(audioBlob);
                window.recordedAudioUrl = audioUrl; // Store URL for cleanup
                
                // Create audio element for playback during visualization
                if (window.playbackAudio) {
                    window.playbackAudio.pause();
                    URL.revokeObjectURL(window.playbackAudio.src);
                }
                
                window.playbackAudio = new Audio(audioUrl);
                window.playbackAudio.volume = 0.8; // Set comfortable volume
                window.playbackAudio.loop = false;
                
                console.log('🎵 Audio playback prepared:', {
                    size: audioBlob.size,
                    type: audioBlob.type,
                    duration: 'unknown until loaded'
                });
                
                // Send audio to backend for transcription
                const transcription = await transcribeAudio(audioBlob);
                
                if (transcription && transcription.transcription) {
                    // Show transcription
                    document.getElementById('transcriptionText').textContent = transcription.transcription;
                    document.getElementById('transcriptionPreview').style.display = 'block';
                    
                                         // Add user message to voice messages
                     addVoiceMessage(transcription.transcription, 'user');
                     
                     // Analyze the transcribed conversation
                     const voiceStatus = document.getElementById('voiceStatus');
                     const simpleStatus = document.getElementById('simpleStatus');
                     
                     if (voiceStatus) voiceStatus.textContent = 'מנתח את הרגש בשיחה עם 92 רגשות...';
                     if (simpleStatus) simpleStatus.textContent = 'מנתח את הרגש בשיחה עם 92 רגשות...';
                     
                     const analysis = await analyzeConversation(transcription.transcription);
                     
                     // Create detailed AI response
                     let responseMessage = `נהדר! זיהיתי את הרגש העיקרי: ${analysis.emotion}`;
                     if (analysis.emotions_detected && analysis.emotions_detected.length > 1) {
                         responseMessage += ` (+ ${analysis.emotions_detected.length - 1} רגשות נוספים)`;
                     }
                     responseMessage += `. בואו נראה את התוצאות המפורטות...`;
                     
                                         // Add AI response
                    addVoiceMessage(responseMessage, 'ai');
                    
                    // ASCII blob updates removed - using simple visualization div
                    
                    // 🎯 USE THE SAME SIMPLE APPROACH AS QUICK TEST
                    console.log('🎯 Using simplified blob visualization for real recording...');
                    
                    // Show containers immediately 
                    const placeholder = document.getElementById('visualizationPlaceholder');
                    const visualizationContainer = document.getElementById('visualization-canvas-container');
                    const p5Container = document.getElementById('p5-sketch-container');
                    
                    if (placeholder) placeholder.style.display = 'none';
                    if (visualizationContainer) visualizationContainer.style.display = 'block';
                    if (p5Container) {
                        p5Container.style.display = 'block';
                        p5Container.style.width = '100%';
                        p5Container.style.height = '100%';
                        p5Container.style.minHeight = '400px';
                    }
                    
                    // Remove any existing p5 instance
                    if (window.myp5) {
                        window.myp5.remove();
                    }
                    
                    // Create simple, direct blob visualization
                    const realRecordingSketch = (p) => {
                        let blobs = [];
                        let time = 0;
                        
                        p.setup = () => {
                            const container = document.getElementById('p5-sketch-container');
                            const width = container ? (container.clientWidth || 800) : 800;
                            const height = container ? (container.clientHeight || 600) : 600;
                            
                            console.log('🎨 Creating REAL recording canvas:', width, 'x', height);
                            const canvas = p.createCanvas(width, height);
                            canvas.parent(container || 'p5-sketch-container');
                            
                            // Get emotions from analysis
                            const emotions = analysis.emotions_detected || analysis.emotions || ['שמחה'];
                            console.log('🎭 REAL emotions for blobs:', emotions);
                            
                            // Create blobs for each emotion
                            blobs = emotions.slice(0, 3).map((emotion, i) => ({
                                x: p.width * (0.25 + i * 0.25),
                                y: p.height * 0.5,
                                size: 120 - i * 20,
                                color: emotion.includes('שמחה') ? [255, 215, 0] : 
                                       emotion.includes('התרגש') ? [255, 140, 0] :
                                       emotion.includes('קבלה') ? [100, 255, 100] : [100, 150, 255],
                                emotion: emotion,
                                pulse: i * Math.PI / 3
                            }));
                            
                            console.log('✨ REAL blobs created:', blobs.length);
                        };
                        
                        p.draw = () => {
                            p.background(247, 249, 243);
                            time += 0.03;
                            
                            // Draw each blob
                            blobs.forEach((blob, i) => {
                                blob.pulse += 0.08;
                                
                                const offsetX = Math.sin(time + i) * 20;
                                const offsetY = Math.cos(time * 0.7 + i) * 10;
                                const size = blob.size + Math.sin(blob.pulse) * 30;
                                
                                // Glow
                                for (let r = size + 40; r > 0; r -= 10) {
                                    const alpha = (1 - r / (size + 40)) * 60;
                                    p.fill(blob.color[0], blob.color[1], blob.color[2], alpha);
                                    p.noStroke();
                                    p.ellipse(blob.x + offsetX, blob.y + offsetY, r);
                                }
                                
                                // Label
                                p.fill(0, 0, 0, 200);
                                p.rect(blob.x + offsetX - 40, blob.y + offsetY - size/2 - 60, 80, 35, 8);
                                p.fill(255);
                                p.textAlign(p.CENTER, p.CENTER);
                                p.textSize(16);
                                p.text(blob.emotion, blob.x + offsetX, blob.y + offsetY - size/2 - 42);
                            });
                            
                            // Title
                            p.fill(255, 255, 255, 230);
                            p.rect(20, 20, p.width - 40, 100, 10);
                            p.fill(0);
                            p.textAlign(p.CENTER, p.CENTER);
                            p.textSize(24);
                            p.text('🎭 הרגשות שלך', p.width/2, 50);
                            p.textSize(16);
                            p.text('נזהו: ' + (analysis.emotions_detected || analysis.emotions || ['שמחה']).join(', '), p.width/2, 80);
                            p.textSize(12);
                            p.text('"' + transcription.transcription.substring(0, 60) + '..."', p.width/2, 100);
                        };
                    };
                    
                    window.myp5 = new p5(realRecordingSketch);
                    console.log('✅ Created simple real recording visualization');
                    
                    // 🎵 PLAY RECORDED AUDIO DURING VISUALIZATION
                    if (window.playbackAudio) {
                        try {
                            await window.playbackAudio.play();
                            console.log('🎵 Playing recorded audio during visualization');
                            
                            // Show audio controls in the UI
                            showAudioPlaybackControls();
                            
                        } catch (audioError) {
                            console.warn('Could not auto-play audio (browser policy):', audioError);
                            // Show manual play button if auto-play fails
                            showManualPlayButton();
                        }
                    }
                    
                } else {
                    throw new Error('Failed to transcribe audio');
                }
                
            } catch (error) {
                console.error('Error processing audio:', error);
                const voiceStatus = document.getElementById('voiceStatus');
                const simpleStatus = document.getElementById('simpleStatus');
                
                if (voiceStatus) voiceStatus.textContent = 'שגיאה בעיבוד ההקלטה. בואו ננסה שוב.';
                if (simpleStatus) simpleStatus.textContent = 'שגיאה בעיבוד ההקלטה. בואו ננסה שוב.';
                
                const recordButtonText = document.getElementById('recordButtonText');
                const simpleRecordText = document.getElementById('simpleRecordText');
                
                if (recordButtonText) recordButtonText.textContent = 'התחל הקלטה';
                if (simpleRecordText) simpleRecordText.textContent = 'התחל הקלטה';
            }
        }

        async function startBlobVisualizationWithAnalysis(transcription, analysis) {
            try {
                console.log('🎭 Starting blob visualization with real recording analysis:', analysis);
                
                // 🎯 SHOW THE SAME CONTAINERS AS QUICK TEST
                const placeholder = document.getElementById('visualizationPlaceholder');
                const visualizationContainer = document.getElementById('visualization-canvas-container');
                const p5Container = document.getElementById('p5-sketch-container');
                
                console.log('🔍 Real recording - Container elements found:', {
                    placeholder: !!placeholder,
                    visualizationContainer: !!visualizationContainer,
                    p5Container: !!p5Container
                });
                
                if (placeholder) {
                    placeholder.style.display = 'none';
                    console.log('✅ Hidden placeholder for real recording');
                }
                
                if (visualizationContainer) {
                    visualizationContainer.style.display = 'block';
                    visualizationContainer.style.borderRadius = '13px';
                    console.log('✅ Shown visualization container for real recording');
                }
                
                if (p5Container) {
                    p5Container.style.display = 'block';
                    p5Container.style.width = '100%';
                    p5Container.style.height = '100%';
                    p5Container.style.minHeight = '400px';
                    console.log('✅ Prepared p5 container for real recording');
                }
                
                // Hide minimalistic interface
                const minimalisticInterface = document.getElementById('minimalisticInterface');
                if (minimalisticInterface) {
                    minimalisticInterface.style.display = 'none';
                }
                
                // Add blob visualization class to body
                document.body.classList.add('blob-visualization-active');
                
                // 🎨 CREATE REAL EMOTION BLOBS (like Quick Test but with real data)
                console.log('🎨 Creating real emotion visualization...');
                
                // Remove existing p5 instance if it exists
                if (window.myp5) {
                    window.myp5.remove();
                }
                
                // Create enhanced visualization with real emotions
                const realEmotionSketch = (p) => {
                    let blobs = [];
                    let time = 0;
                    
                    p.setup = () => {
                        const container = document.getElementById('p5-sketch-container');
                        
                        // Ensure container has proper dimensions
                        if (container) {
                            container.style.width = '100%';
                            container.style.height = '100%';
                            container.style.minHeight = '400px';
                            container.style.display = 'block';
                        }
                        
                        const width = container ? (container.clientWidth || 800) : 800;
                        const height = container ? (container.clientHeight || 600) : 600;
                        
                        console.log('🎨 Creating real emotion canvas:', width, 'x', height);
                        const canvas = p.createCanvas(width, height);
                        canvas.parent(container || 'p5-sketch-container');
                        
                        // Create blobs based on real detected emotions
                        const emotions = analysis.emotions_detected || analysis.emotions || ['שמחה'];
                        const primaryEmotion = analysis.emotion || analysis.primary_emotion || emotions[0];
                        
                        console.log('🎭 Real emotions detected:', emotions, 'primary:', primaryEmotion);
                        
                        // Create blobs for detected emotions
                        blobs = emotions.slice(0, 3).map((emotion, i) => {
                            const x = p.width * (0.3 + i * 0.2);
                            const y = p.height * (0.4 + Math.sin(i) * 0.2);
                            const size = i === 0 ? Math.min(120, p.width * 0.15) : Math.min(100, p.width * 0.12);
                            
                            // Color based on emotion type
                            let color = [100, 150, 255]; // Default blue
                            if (emotion.includes('שמחה') || emotion.includes('שמח')) color = [255, 215, 0]; // Gold
                            else if (emotion.includes('עצב') || emotion.includes('כעס')) color = [255, 100, 100]; // Red
                            else if (emotion.includes('התרגש') || emotion.includes('פחד')) color = [255, 140, 0]; // Orange
                            else if (emotion.includes('קנא') || emotion.includes('תקוו')) color = [100, 255, 100]; // Green
                            else if (emotion.includes('אהב') || emotion.includes('חיב')) color = [255, 192, 203]; // Pink
                            
                            return {
                                x: x,
                                y: y,
                                size: size,
                                color: color,
                                emotion: emotion,
                                intensity: i === 0 ? 1.5 : 1.2,
                                glow: true,
                                pulse: i * Math.PI / 2
                            };
                        });
                        
                        console.log('✨ Created real emotion blobs:', blobs.map(b => `${b.emotion} at (${Math.round(b.x)}, ${Math.round(b.y)}) size ${b.size}`));
                    };
                    
                    p.draw = () => {
                        // Background
                        p.background(247, 249, 243);
                        
                        time += 0.02;
                        
                        // Draw enhanced blobs
                        blobs.forEach((blob, i) => {
                            // Update pulse animation
                            blob.pulse += 0.05;
                            
                            // More dynamic animation for real emotions
                            const offsetX = Math.sin(time + i * 2) * 15;
                            const offsetY = Math.cos(time * 0.8 + i) * 12;
                            const sizeVar = Math.sin(time * 3 + i) * (blob.intensity * 15);
                            
                            // Enhanced glow effect
                            for (let r = blob.size + 30; r > 0; r -= 6) {
                                const alpha = (1 - (r / (blob.size + 30))) * (blob.glow ? 150 : 80);
                                p.fill(blob.color[0], blob.color[1], blob.color[2], alpha);
                                p.noStroke();
                                p.ellipse(
                                    blob.x + offsetX, 
                                    blob.y + offsetY, 
                                    r + sizeVar
                                );
                            }
                            
                            // Emotion text with background
                            const labelWidth = blob.emotion.length * 12 + 20;
                            p.fill(0, 0, 0, 180);
                            p.rect(blob.x + offsetX - labelWidth/2, blob.y + offsetY - blob.size - 50, labelWidth, 30, 8);
                            
                            p.fill(255, 255, 255);
                            p.textAlign(p.CENTER, p.CENTER);
                            p.textSize(16);
                            p.textStyle(p.BOLD);
                            p.text(blob.emotion, blob.x + offsetX, blob.y + offsetY - blob.size - 35);
                        });
                        
                        // Enhanced title for real emotions
                        p.fill(255, 255, 255, 220);
                        p.rect(p.width/2 - 200, 10, 400, 80, 10);
                        
                        p.fill(50);
                        p.textAlign(p.CENTER, p.CENTER);
                        p.textSize(18);
                        p.text('🎭 ניתוח רגשי בזמן אמת', p.width/2, 30);
                        
                        p.textSize(14);
                        p.fill(80);
                        p.text('רגשות מזוהים: ' + (analysis.emotions_detected || analysis.emotions || ['שמחה']).join(', '), p.width/2, 55);
                        
                        p.textSize(12);
                        p.fill(100);
                        p.text('טקסט: "' + transcription.substring(0, 50) + (transcription.length > 50 ? '..."' : '"'), p.width/2, 75);
                    };
                    
                    p.windowResized = () => {
                        const container = document.getElementById('p5-sketch-container');
                        p.resizeCanvas(container.clientWidth || 600, container.clientHeight || 400);
                    };
                };
                
                window.myp5 = new p5(realEmotionSketch);
                
                console.log('🎭 Started enhanced blob visualization with real analysis:', analysis);
                
            } catch (error) {
                console.error('Error starting blob visualization:', error);
            }
        }

        function returnToRecording() {
            // Hide blob visualization
            document.body.classList.remove('blob-visualization-active');
            
            // Hide back button
            const backButton = document.getElementById('blobBackButton');
            if (backButton) {
                backButton.style.display = 'none';
            }
            
            // Show minimalistic interface again
            const minimalisticInterface = document.getElementById('minimalisticInterface');

        function confirmRecording() {
            // Hide action buttons and show microphone
            const micIcon = document.getElementById('micIcon');
            const actionButtons = document.getElementById('actionButtons');
            
            if (micIcon) micIcon.style.display = 'flex';
            if (actionButtons) actionButtons.style.display = 'none';
            
            // Process the recording
            if (mediaRecorder && isRecording) {
                stopRecording();
            }
        }

        function cancelRecording() {
            console.log('🔄 Canceling recording...');
            
            // Immediately reset recording state
            isRecording = false;
            
            // Stop recording if active
            if (mediaRecorder) {
                console.log('🔄 Stopping media recorder...');
                try {
                    mediaRecorder.stop();
                } catch (e) {
                    console.log('MediaRecorder already stopped');
                }
                
                if (mediaRecorder.stream) {
                    mediaRecorder.stream.getTracks().forEach(track => {
                        console.log('🔄 Stopping track:', track);
                        track.stop();
                    });
                }
            }
            
            // Stop audio visualization
            stopAudioVisualization();
            
            // Stop dot animation
            stopDotAnimation();
            
            // Reset UI
            const voiceInputField = document.getElementById('voiceInputField');
            if (voiceInputField) {
                voiceInputField.classList.remove('recording');
            }
            
            // Hide action buttons and show microphone
            const micIcon = document.getElementById('micIcon');
            const actionButtons = document.getElementById('actionButtons');
            
            if (micIcon) micIcon.style.display = 'flex';
            if (actionButtons) actionButtons.style.display = 'none';
            
            // Reset status
            const voiceStatus = document.getElementById('voiceStatus');
            const simpleStatus = document.getElementById('simpleStatus');
            
            if (voiceStatus) voiceStatus.textContent = '';
            if (simpleStatus) simpleStatus.textContent = '';
            
            // Reset recording state
            mediaRecorder = null;
            audioChunks = [];
            
            console.log('🔄 Recording canceled and returned to microphone interface');
        }
            if (minimalisticInterface) {
                minimalisticInterface.style.display = 'flex';
            }
            
            // Stop blob visualization
            if (isBlobVisualizationRunning) {
                isBlobVisualizationRunning = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
            
            console.log('🔄 Returned to recording interface');
        }

        async function showAnalysisResults(transcription, analysis) {
            // Hide voice interface and show analysis results
            document.getElementById('voiceInterface').style.display = 'none';
            
            // Create and show analysis results screen
            const analysisScreen = document.getElementById('analysisResults') || createAnalysisResultsScreen();
            
            // Populate with analysis data
            document.getElementById('analysisTranscription').textContent = transcription;
            document.getElementById('analysisPrimaryEmotion').textContent = analysis.emotion;
            document.getElementById('analysisConfidence').textContent = `${Math.round(analysis.confidence * 100)}%`;
            
            // Show detected emotions
            const emotionsContainer = document.getElementById('analysisEmotions');
            emotionsContainer.innerHTML = '';
            if (analysis.emotions_detected && analysis.emotions_detected.length > 0) {
                analysis.emotions_detected.forEach(emotion => {
                    const emotionTag = document.createElement('span');
                    emotionTag.className = 'emotion-tag';
                    emotionTag.textContent = emotion;
                    emotionsContainer.appendChild(emotionTag);
                });
            }
            
            // Show camera parameters
            const paramsContainer = document.getElementById('analysisParameters');
            paramsContainer.innerHTML = '';
            if (analysis.camera_settings) {
                const params = [
                    { label: 'בהירות', value: analysis.camera_settings.brightness },
                    { label: 'ניגודיות', value: analysis.camera_settings.contrast },
                    { label: 'סט תווים', value: analysis.camera_settings.charSet },
                    { label: 'מצב צבע', value: analysis.camera_settings.colorMode },
                    { label: 'רזולוציה', value: analysis.camera_settings.resolution },
                    { label: 'אפקטי Blob', value: analysis.camera_settings.blobEffect ? 'מופעל' : 'כבוי' },
                    { label: 'הומור', value: analysis.camera_settings.showHumor ? 'מופעל' : 'כבוי' },
                    { label: 'זוהר ואפקטים', value: 'מופעלים' },
                    { label: 'עוצמה', value: analysis.intensity ? `${Math.round(analysis.intensity * 100)}%` : 'רגילה' }
                ];
                
                params.forEach(param => {
                    const paramDiv = document.createElement('div');
                    paramDiv.className = 'parameter-item';
                    if (param.label.includes('אפקטי') || param.label.includes('הומור') || param.label.includes('זוהר')) {
                        paramDiv.classList.add('effect-param');
                    }
                    paramDiv.innerHTML = `<span class="param-label">${param.label}:</span> <span class="param-value">${param.value}</span>`;
                    paramsContainer.appendChild(paramDiv);
                });
            }
            
            // Show the analysis screen
            analysisScreen.style.display = 'flex';
            
            // Store analysis for later use
            window.currentAnalysis = analysis;
        }

        function createAnalysisResultsScreen() {
            const analysisScreen = document.createElement('div');
            analysisScreen.id = 'analysisResults';
            analysisScreen.className = 'analysis-results';
            analysisScreen.innerHTML = `
                <div class="analysis-content">
                    <h2>ניתוח השיחה</h2>
                    
                    <div class="analysis-section">
                        <h3>תמלול:</h3>
                        <div id="analysisTranscription" class="transcription-text"></div>
                    </div>
                    
                    <div class="analysis-section">
                        <h3>רגש עיקרי:</h3>
                        <div class="emotion-result">
                            <span id="analysisPrimaryEmotion" class="primary-emotion"></span>
                            <span id="analysisConfidence" class="confidence"></span>
                        </div>
                    </div>
                    
                    <div class="analysis-section">
                        <h3>רגשות שזוהו:</h3>
                        <div id="analysisEmotions" class="emotions-list"></div>
                    </div>
                    
                    <div class="analysis-section">
                        <h3>פרמטרי מצלמה:</h3>
                        <div id="analysisParameters" class="parameters-list"></div>
                    </div>
                    
                    <div class="analysis-actions">
                        <button onclick="startCameraWithAnalysis()" class="start-camera-btn">התחל חוויית מצלמה</button>
                        <button onclick="goBackToVoice()" class="back-btn">חזור לתמלול</button>
                    </div>
                </div>
            `;
            
            document.getElementById('questionnairePage').appendChild(analysisScreen);
            return analysisScreen;
        }

        async function startCameraWithAnalysis() {
            // Apply the stored analysis settings
            if (window.currentAnalysis) {
                await applyCameraSettings(window.currentAnalysis);
            }
            
            // Hide analysis screen
            document.getElementById('analysisResults').style.display = 'none';
            
            // Start camera experience
            await startCameraExperience();
        }

        function goBackToVoice() {
            // Hide analysis screen
            document.getElementById('analysisResults').style.display = 'none';
            
            // Show voice interface again
            document.getElementById('voiceInterface').style.display = 'flex';
        }

        async function transcribeAudio(audioBlob) {
            // Validate the audio blob
            if (!audioBlob || !(audioBlob instanceof Blob)) {
                throw new Error('Invalid audio blob provided');
            }
            
            // Check if blob size is valid (some browsers might have undefined size initially)
            const blobSize = audioBlob.size || 0;
            if (blobSize === 0) {
                console.warn('⚠️ Audio blob is empty, using test transcription');
                return { transcription: 'בדיקה - הקלטה ריקה, משתמש בטקסט לדוגמה' };
            }
            
            // Check if audio is too small (likely very short or empty recording)
            if (blobSize < 10000) { // Less than 10KB
                console.warn('⚠️ Audio recording too small, using test transcription');
                return { transcription: 'בדיקה - אני מרגיש טוב היום ורוצה לבדוק את המערכת שלי' };
            }
            
            console.log('Transcribing audio blob:');
            console.log('- Blob object:', audioBlob);
            console.log('- Size:', audioBlob.size);
            console.log('- Type:', audioBlob.type);
            
            // Determine appropriate file extension based on MIME type
            let filename = 'recording.webm';
            const blobType = audioBlob.type || '';
            console.log('- Blob type for filename:', blobType);
            
            if (blobType.includes('mp4')) {
                filename = 'recording.mp4';
            } else if (blobType.includes('wav')) {
                filename = 'recording.wav';
            } else if (blobType.includes('webm')) {
                filename = 'recording.webm';
            }
            
            console.log('- Using filename:', filename);
            
            const formData = new FormData();
            formData.append('audio', audioBlob, filename);
            
            try {
                const response = await fetch('/api/conversation-wizard/transcribe-audio', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    console.warn(`⚠️ Transcription failed with status ${response.status}, using test transcription`);
                    return { transcription: 'בדיקה - שגיאה בתמלול, משתמש בטקסט לדוגמה לבדיקת המערכת' };
                }
                
                const result = await response.json();
                
                // Handle empty transcription result
                if (!result.transcription || result.transcription.trim() === '') {
                    console.warn('⚠️ Empty transcription result, using test transcription');
                    return { transcription: 'בדיקה - תמלול ריק, משתמש בטקסט דוגמה לבדיקת הוויזואליזציה' };
                }
                
                return result;
                
            } catch (error) {
                console.warn('⚠️ Transcription error, using test transcription:', error);
                return { transcription: 'בדיקה - חיבור נכשל, משתמש בטקסט לדוגמה כדי לבדוק את המערכת' };
            }
        }

        function addVoiceMessage(content, type) {
            const messagesContainer = document.getElementById('voiceMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}-message`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = content;
            
            messageDiv.appendChild(contentDiv);
            messagesContainer.appendChild(messageDiv);
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        async function analyzeConversation(text) {
            try {
                const response = await fetch('/api/conversation-wizard/analyze-conversation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ text: text })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                return {
                    emotion: result.emotion,
                    intensity: result.intensity,
                    confidence: result.confidence,
                    settings: result.camera_settings,
                    method: result.analysis_method
                };
                
            } catch (error) {
                console.error('Analysis error:', error);
                
                // Fallback to simple analysis if backend is unavailable
                return {
                    emotion: 'רגוע',
                    intensity: 5,
                    confidence: 0.5,
                    settings: {
                        brightness: 5,
                        contrast: 100,
                        charSet: 'minimal',
                        colorMode: 'cool',
                        resolution: 8
                    },
                    method: 'fallback'
                };
            }
        }



        async function applyCameraSettings(analysis) {
            document.getElementById('voiceStatus').textContent = 'מתאים את הגדרות הבלובים עם כל האפקטים המתקדמים...';
            
            // Apply ALL blob settings with SOPHISTICATED visual effects
            if (typeof visualSettings !== 'undefined') {
                console.log('🎭 Applying sophisticated analysis results to blobs:', analysis.full_analysis);
                
                const sophisticatedAnalysis = analysis.full_analysis || {};
                
                // ✨ APPLY SOPHISTICATED PARAMETERS FROM MAIN SYSTEM
                const advancedSettings = {
                    ...analysis.camera_settings,
                    
                    // Core emotion data
                    emotion: analysis.emotion,
                    emotions_detected: analysis.emotions_detected || [analysis.emotion],
                    intensity: analysis.intensity || 1.0,
                    confidence: analysis.confidence || 0.8,
                    
                    // ✨ SOPHISTICATED VISUAL PARAMETERS
                    blur: sophisticatedAnalysis.blur || 0,
                    shine: sophisticatedAnalysis.shine || 0,
                    humor: sophisticatedAnalysis.humor || 0,
                    voice_intensity: sophisticatedAnalysis.voice_intensity || 1.0,
                    blobiness: sophisticatedAnalysis.blobiness || 1.0,
                    proximity: sophisticatedAnalysis.proximity || 'medium',
                    auto_blob_spacing: sophisticatedAnalysis.auto_blob_spacing || 1.0,
                    
                    // Pattern detection
                    detected_patterns: sophisticatedAnalysis.detected_patterns || [],
                    raw_scores: sophisticatedAnalysis.raw_scores || {},
                    
                    // Visual effects for blobs
                    blobEffect: true,
                    showHumor: true,
                    emotionBlobs: true,
                    dynamicEffects: true,
                    glowEffect: true,
                    particleEffects: true,
                    mirrorMode: true,
                    invertMode: false
                };
                
                Object.assign(visualSettings, advancedSettings);
                
                // ✨ APPLY SOPHISTICATED VISUAL EFFECTS TO BLOBS BASED ON ANALYSIS
                applySophisticatedEffectsToBlobs(sophisticatedAnalysis, analysis);
                
                console.log('✅ Applied SOPHISTICATED blob settings:', advancedSettings);
                console.log('🎭 Humor level:', sophisticatedAnalysis.humor);
                console.log('🌫️ Blur level:', sophisticatedAnalysis.blur);
                console.log('✨ Shine level:', sophisticatedAnalysis.shine);
                console.log('🔊 Voice intensity:', sophisticatedAnalysis.voice_intensity);
                console.log('📊 Detected patterns:', sophisticatedAnalysis.detected_patterns);
            }
            
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        // ✨ APPLY SOPHISTICATED EFFECTS FROM MAIN SYSTEM ANALYSIS TO BLOBS
        function applySophisticatedEffectsToBlobs(sophisticatedAnalysis, fullAnalysis) {
            const humor = sophisticatedAnalysis.humor || 0;
            const blur = sophisticatedAnalysis.blur || 0;
            const shine = sophisticatedAnalysis.shine || 0;
            const voiceIntensity = sophisticatedAnalysis.voice_intensity || 1.0;
            const emotion = fullAnalysis.emotion || 'neutral';
            
            console.log('🎭 Applying sophisticated effects:', { humor, blur, shine, voiceIntensity, emotion });
            
            // 😂 HUMOR EFFECTS - make it noticeable!
            if (humor > 0) {
                const humorIntensity = Math.min(10, Math.max(1, Math.floor(humor * 10)));
                console.log(`😂 HUMOR DETECTED: Level ${humorIntensity}/10`);
                applyAIEmotionEffectsToBlobs('humor', humorIntensity);
            }
            
            // ✨ SHINE EFFECTS - bright and glowing
            if (shine > 0) {
                const shineIntensity = Math.min(10, Math.max(1, Math.floor(shine * 10)));
                console.log(`✨ SHINE DETECTED: Level ${shineIntensity}/10`);
                applyAIEmotionEffectsToBlobs('shine', shineIntensity);
            }
            
            // 🌫️ BLUR EFFECTS - for unclear speech
            if (blur > 0) {
                const blurIntensity = Math.min(10, Math.max(1, Math.floor(blur * 10)));
                console.log(`🌫️ BLUR DETECTED: Level ${blurIntensity}/10 - speech unclear`);
                
                // Blur effects: apply to blobs directly
                if (blobs.length > 0) {
                    blobs.forEach(blob => {
                        blob.setTargetVisuals({
                            blobSizeScale: Math.max(2, blob.blobSizeScale - (blurIntensity * 0.3)),
                            blobStrength: Math.max(300, blob.blobStrength - (blurIntensity * 50)),
                            blobiness: Math.max(0.5, blob.blobiness - (blurIntensity * 0.1)),
                            breathSpeed: Math.max(0.0001, blob.breathSpeed - (blurIntensity * 0.00005))
                        });
                    });
                }
                
                updateWebcamStatus(`🌫️ דיבור לא ברור (רמה ${blurIntensity}/10) - מטושטש`);
            }
            
            // 🔊 VOICE INTENSITY EFFECTS - shouting = bigger blobs
            if (voiceIntensity > 1.5) {
                const shoutLevel = Math.min(5, voiceIntensity - 1);
                console.log(`🔊 SHOUTING DETECTED: Level ${shoutLevel} - making blobs bigger`);
                
                // Shouting: make blobs bigger and more energetic
                if (blobs.length > 0) {
                    blobs.forEach(blob => {
                        blob.setTargetVisuals({
                            blobSizeScale: Math.min(10, blob.blobSizeScale + (shoutLevel * 0.8)),
                            blobStrength: Math.min(2000, blob.blobStrength + (shoutLevel * 200)),
                            breathSpeed: Math.min(0.002, blob.breathSpeed + (shoutLevel * 0.0003)),
                            blobiness: Math.min(3, blob.blobiness + (shoutLevel * 0.2))
                        });
                    });
                }
                
                updateWebcamStatus(`🔊 צעקה זוהתה (עוצמה ${shoutLevel.toFixed(1)}) - בלובים גדולים!`);
            }
            
            // 🎯 EMOTION-SPECIFIC SOPHISTICATED EFFECTS
            const emotionIntensity = fullAnalysis.intensity || 1.0;
            const intensityLevel = Math.min(10, Math.max(1, Math.floor(emotionIntensity * 5)));
            
            if (emotion && emotion !== 'neutral') {
                console.log(`🎭 Applying emotion effects: ${emotion} (intensity ${intensityLevel})`);
                
                // Apply emotion-specific effects with intensity
                const emotionMap = {
                    'שמחה': 'happiness',
                    'אהבה': 'joy', 
                    'כעס': 'anger',
                    'עצב': 'sadness',
                    'סקרנות': 'curiosity',
                    'התרגשות': 'joy',
                    'בלבול': 'confusion',
                    'שעשוע': 'amusement'
                };
                
                const mappedEmotion = emotionMap[emotion] || 'happiness';
                applyEmotionEffectsToBlobs(mappedEmotion, intensityLevel, intensityLevel / 10);
            }
            
            // Update status with all detected effects
            let statusParts = [];
            if (humor > 0) statusParts.push(`😂 הומור ${Math.floor(humor * 10)}/10`);
            if (blur > 0) statusParts.push(`🌫️ טשטוש ${Math.floor(blur * 10)}/10`);
            if (shine > 0) statusParts.push(`✨ ברק ${Math.floor(shine * 10)}/10`);
            if (voiceIntensity > 1.5) statusParts.push(`🔊 צעקה ${voiceIntensity.toFixed(1)}`);
            
            if (statusParts.length > 0) {
                updateWebcamStatus(`🎭 ${emotion}: ${statusParts.join(', ')}`);
            }
        }

        async function startCameraExperience() {
            // Hide voice interface
            document.getElementById('voiceInterface').style.display = 'none';
            
            // Add webcam-active class to hide sidebar
            document.body.classList.add('webcam-active');
            
            // Show processing overlay
            document.getElementById('canvasOverlay').style.display = 'flex';
            
            // Start webcam
            if (typeof startWebcam === 'function') {
                await startWebcam();
            }
            
            // Wait a moment for camera to stabilize
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // Hide processing overlay
            document.getElementById('canvasOverlay').style.display = 'none';
            
            // Take screenshot after a few seconds
            setTimeout(() => {
                takeScreenshot();
            }, 2000);
        }

        function takeScreenshot() {
            const canvas = document.getElementById('webcamCanvas');
            if (!canvas) return;
            
            // Create a temporary canvas for the screenshot
            const screenshotCanvas = document.createElement('canvas');
            screenshotCanvas.width = canvas.width;
            screenshotCanvas.height = canvas.height;
            const screenshotCtx = screenshotCanvas.getContext('2d');
            
            // Copy the current frame
            screenshotCtx.drawImage(canvas, 0, 0);
            
            // Convert to blob and upload
            screenshotCanvas.toBlob((blob) => {
                uploadScreenshot(blob);
            }, 'image/png');
        }

        async function uploadScreenshot(blob) {
            try {
                // Create a FormData object with live camera indication
                const formData = new FormData();
                formData.append('screenshot', blob, `live-conversation-${Date.now()}.png`);
                
                // In a real implementation, you'd upload to your server
                // For now, let's just show success message
                console.log('Live camera screenshot taken and ready for upload');
                
                // Show success message with live camera indication
                updateWebcamStatus('✅ צילום מצלמה חיה נשמר בהצלחה! ניתן לחזור לתבניות');
                
                // Optionally, you could redirect back to grid after some time
                // setTimeout(() => showGrid(), 3000);
                
            } catch (error) {
                console.error('Error uploading live camera screenshot:', error);
                updateWebcamStatus('❌ שגיאה בשמירת הצילום');
            }
        }

        // Check conversation wizard health on load
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize text animations
            initializeTextAnimations();
            
            try {
                const response = await fetch('/api/conversation-wizard/health');
                if (response.ok) {
                    const health = await response.json();
                    console.log('✅ Conversation wizard is healthy:', health);
                } else {
                    console.warn('⚠️ Conversation wizard not responding');
                }
            } catch (error) {
                console.warn('⚠️ Conversation wizard not available:', error.message);
            }
        });
        
        // Add event listener for ASCII blob visualization close button
        document.addEventListener('DOMContentLoaded', function() {
            const closeButton = document.getElementById('closeAsciiBlobVisualization');
            if (closeButton) {
                closeButton.addEventListener('click', stopASCIIBlobVisualization);
            }
        });
    
    </script>

    <!-- Enhanced Conversation Flow Functions -->
    <script>
        let conversationFlowActive = false;
        let conversationData = null;

        // Start the enhanced conversation flow
        async function startConversationFlow() {
            if (conversationFlowActive) return;
            
            console.log('🎤 Starting conversation flow...');
            conversationFlowActive = true;
            
            // Update the existing UI elements to show recording state
            const micIcon = document.getElementById('micIcon');
            const actionButtons = document.getElementById('actionButtons');
            const voiceInputField = document.getElementById('voiceInputField');
            const voiceStatus = document.getElementById('voiceStatus');
            const simpleStatus = document.getElementById('simpleStatus');
            
            // Show recording state
            if (micIcon) micIcon.style.display = 'none';
            if (actionButtons) actionButtons.style.display = 'flex';
            if (voiceInputField) voiceInputField.classList.add('recording');
            if (voiceStatus) voiceStatus.textContent = 'מקליט... ספר על השיחה שלך';
            if (simpleStatus) simpleStatus.textContent = 'מקליט... ספר על השיחה שלך';
            
            // Start actual recording
            try {
                await startRecording();
            } catch (error) {
                console.error('Error starting recording:', error);
                resetConversationFlow();
                if (voiceStatus) voiceStatus.textContent = 'שגיאה בגישה למיקרופון';
                if (simpleStatus) simpleStatus.textContent = 'שגיאה בגישה למיקרופון';
            }
        }

        // Stop the conversation flow recording (triggered by checkmark button)
        async function stopConversationFlow() {
            if (!conversationFlowActive) return;
            
            console.log('✅ Stopping conversation flow - processing audio...');
            
            const voiceStatus = document.getElementById('voiceStatus');
            const simpleStatus = document.getElementById('simpleStatus');
            const micIcon = document.getElementById('micIcon');
            const actionButtons = document.getElementById('actionButtons');
            const voiceInputField = document.getElementById('voiceInputField');
            
            // Update status
            if (voiceStatus) voiceStatus.textContent = 'מעבד הקלטה...';
            if (simpleStatus) simpleStatus.textContent = 'מעבד הקלטה...';
            
            // Hide action buttons and show microphone again
            if (micIcon) micIcon.style.display = 'flex';
            if (actionButtons) actionButtons.style.display = 'none';
            if (voiceInputField) voiceInputField.classList.remove('recording');
            
            // Stop recording and process
            stopRecording();
            conversationFlowActive = false;
        }

        // Reset the conversation flow UI
        function resetConversationFlow() {
            conversationFlowActive = false;
            
            const micIcon = document.getElementById('micIcon');
            const actionButtons = document.getElementById('actionButtons');
            const voiceInputField = document.getElementById('voiceInputField');
            const voiceStatus = document.getElementById('voiceStatus');
            const simpleStatus = document.getElementById('simpleStatus');
            
            // Reset UI to initial state
            if (micIcon) micIcon.style.display = 'flex';
            if (actionButtons) actionButtons.style.display = 'none';
            if (voiceInputField) voiceInputField.classList.remove('recording');
            if (voiceStatus) voiceStatus.textContent = '';
            if (simpleStatus) simpleStatus.textContent = '';
        }

        // Enhanced process audio with inline results
        async function processConversationFlow(audioBlob) {
            const voiceStatus = document.getElementById('voiceStatus');
            const simpleStatus = document.getElementById('simpleStatus');
            const transcriptionPreview = document.getElementById('transcriptionPreview');
            const transcriptionText = document.getElementById('transcriptionText');
            
            try {
                // Step 1: Transcription
                if (voiceStatus) voiceStatus.textContent = '🎧 מתרגם את ההקלטה לטקסט...';
                if (simpleStatus) simpleStatus.textContent = '🎧 מתרגם את ההקלטה לטקסט...';
                
                const transcription = await transcribeAudio(audioBlob);
                
                if (transcription && transcription.transcription) {
                    // Show transcription
                    if (transcriptionText) transcriptionText.textContent = transcription.transcription;
                    if (transcriptionPreview) transcriptionPreview.style.display = 'block';
                    
                    // Step 2: Analysis with current system (temporarily use existing API)
                    if (voiceStatus) voiceStatus.textContent = '🧠 מנתח רגשות בשיחה עם 92 רגשות...';
                    if (simpleStatus) simpleStatus.textContent = '🧠 מנתח רגשות בשיחה עם 92 רגשות...';
                    
                    // Try the full system first, fallback to existing if needed
                    let analysis;
                    try {
                        analysis = await analyzeWithFullSystem(transcription.transcription);
                        console.log('✅ Full system analysis result:', analysis);
                    } catch (error) {
                        console.log('⚠️ Full system failed, using basic analysis:', error);
                        analysis = await analyzeConversation(transcription.transcription);
                        // Convert to our expected format
                        if (analysis) {
                            analysis = {
                                success: true,
                                analysis: {
                                    emotions: analysis.emotions_detected || [analysis.emotion],
                                    primary_emotion: analysis.emotion,
                                    confidence: analysis.confidence,
                                    ...analysis
                                }
                            };
                        }
                    }
                    
                    if (analysis && (analysis.success || analysis.emotion)) {
                        // Store conversation data
                        conversationData = {
                            transcription: transcription.transcription,
                            analysis: analysis.success ? analysis.analysis : analysis,
                            fullAnalysis: analysis,
                            timestamp: new Date().toISOString()
                        };
                        
                        // Show main emotion
                        const primaryEmotion = analysis.success ? 
                            (analysis.analysis.primary_emotion || analysis.analysis.emotions[0]) :
                            (analysis.emotion || 'לא זוהה');
                        const confidence = Math.round(((analysis.success ? analysis.analysis.confidence : analysis.confidence) || 0) * 100);
                        
                        if (voiceStatus) voiceStatus.innerHTML = `✅ רגש עיקרי: <strong>${primaryEmotion}</strong> (${confidence}% ביטחון)`;
                        if (simpleStatus) simpleStatus.innerHTML = `✅ רגש עיקרי: <strong>${primaryEmotion}</strong> (${confidence}% ביטחון)`;
                        
                        // Show visualization directly after 2 seconds
                        setTimeout(() => {
                            showInlineVisualization();
                        }, 2000);
                        
                        // Reset record button
                        resetConversationFlow();
                        
                    } else {
                        throw new Error('Failed to analyze emotions');
                    }
                } else {
                    throw new Error('Failed to transcribe audio');
                }
                
            } catch (error) {
                console.error('Error processing conversation:', error);
                if (voiceStatus) voiceStatus.textContent = '❌ שגיאה בעיבוד השיחה. נסה שוב.';
                if (simpleStatus) simpleStatus.textContent = '❌ שגיאה בעיבוד השיחה. נסה שוב.';
                resetConversationFlow();
            }
        }

        // Use the same analysis system as segments
        async function analyzeWithFullSystem(text) {
            try {
                console.log('🔍 Analyzing with full system:', text);
                
                const response = await fetch('/api/analyze-segment', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        conversation: 'temp_conversation',
                        filename: 'live_recording.mp3',
                        transcript: text,
                        currentEmotions: ['neutral'],
                        speaker: 0,
                        includeVolumeAnalysis: true,
                        advancedParameters: true,
                        preserveExisting: false
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('✅ Full analysis result:', result);
                
                return result;
                
            } catch (error) {
                console.error('Full analysis error:', error);
                throw error;
            }
        }

        // Show inline visualization without modal
        async function showInlineVisualization() {
            console.log('🎨 Starting inline visualization...');
            console.log('🔍 Conversation data:', conversationData);
            
            if (!conversationData) {
                console.error('❌ No conversation data available for visualization');
                return;
            }
            
            // Hide placeholder and show visualization container
            const placeholder = document.getElementById('visualizationPlaceholder');
            const visualizationContainer = document.getElementById('visualization-canvas-container');
            const visualArea = document.getElementById('inlineVisualizationArea');
            
            console.log('🔍 Found elements:', {
                placeholder: !!placeholder,
                visualizationContainer: !!visualizationContainer,
                visualArea: !!visualArea
            });
            
            if (placeholder) {
                placeholder.style.display = 'none';
                console.log('✅ Hidden placeholder');
            }
            
            if (visualizationContainer) {
                visualizationContainer.style.display = 'block';
                visualizationContainer.style.borderRadius = '13px';
                console.log('✅ Shown visualization container');
            }
            
            // Update the visualization area border to show it's active
            if (visualArea) {
                visualArea.style.border = '2px solid #171717';
                visualArea.style.background = '#f7f9f3'; // Use main app background
                console.log('✅ Updated visualization area styling');
                
                // Add a temporary visible indicator
                const indicator = document.createElement('div');
                indicator.id = 'viz-indicator';
                indicator.style.cssText = `
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    background: rgba(0,0,0,0.8);
                    color: white;
                    padding: 10px;
                    border-radius: 5px;
                    font-family: var(--main-font-family);
                    font-size: 14px;
                    z-index: 100;
                    pointer-events: none;
                `;
                indicator.textContent = '🎨 יוצר ויזואליזציה מתקדמת...';
                visualArea.appendChild(indicator);
                
                // Remove indicator after visualization loads
                setTimeout(() => {
                    const ind = document.getElementById('viz-indicator');
                    if (ind) ind.remove();
                }, 3000);
            }
            
            // Force the area to be visible and large enough to see
            if (visualArea) {
                visualArea.style.display = 'block';
                visualArea.style.height = '600px';
                visualArea.style.width = '100%';
                visualArea.style.position = 'relative';
                console.log('🔧 Forced visualization area dimensions');
            }
            
            // Start simplified ASCII-style visualization using p5.js
            console.log('🚀 Starting ASCII-style p5.js visualization...');
            setTimeout(() => {
                console.log('🎭 Creating ASCII-style visualization with:', conversationData.fullAnalysis);
                createASCIIStyleVisualization(conversationData.fullAnalysis);
            }, 500);
        }



        // COMPLETE ASCII VISUALIZATION SYSTEM - Similar to sketch.js
        async function startCompleteASCIIVisualization(analysisData) {
            try {
                console.log('🎨 Starting complete ASCII visualization with:', analysisData);
                
                // Get the p5 container
                const p5Container = document.getElementById('p5-sketch-container');
                if (!p5Container) {
                    console.error('❌ P5 container not found');
                    return;
                }
                
                // Remove any existing p5 instance
                if (window.myp5) {
                    window.myp5.remove();
                    window.myp5 = null;
                }
                
                // Extract analysis data
                const analysis = analysisData.analysis || analysisData;
                const emotions = analysis.emotions || [analysis.primary_emotion || analysis.emotion || 'שמחה'];
                const primaryEmotion = emotions[0];
                
                console.log('🎭 Extracted emotions:', emotions);
                console.log('🎨 Primary emotion:', primaryEmotion);
                
                // Enhanced ASCII character sets (same as sketch.js)
                const emotionCharsets = {
                    'שמחה': ['☀', '★', '✨', '⭐', '💫'],
                    'אהבה': ['💖', '💕', '❤️', '💝', '💗'],
                    'כעס': ['⚡', '💥', '🔥', '⭕', '💢'],
                    'עצב': ['💧', '🌧️', '☔', '💙', '🌊'],
                    'סקרנות': ['?', '!', '※', '◆', '◈'],
                    'התרגשות': ['✦', '✧', '⚡', '💥', '🎉'],
                    'רגוע': ['〜', '～', '~', '◦', '○'],
                    'default': ['○', '●']
                };

                // Regular ASCII background charset
                const backgroundChars = ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '=', '-', '~', '`', '|', '\\', '/', ':', ';', '"', "'", '<', '>', ',', '.', '?', '1', '2', '3'];
                
                // Get emotion colors (same logic as main system)
                const emotionColors = {
                    'שמחה': [255, 215, 0],      // Gold
                    'אהבה': [255, 105, 180],    // Hot pink
                    'כעס': [255, 69, 0],       // Red orange
                    'עצב': [70, 130, 180],     // Steel blue
                    'סקרנות': [255, 0, 255],   // Magenta
                    'התרגשות': [255, 140, 0],  // Orange
                    'רגוע': [144, 238, 144],   // Light green
                    'default': [150, 150, 150] // Gray
                };
                
                // Create the complete ASCII visualization
                const completeASCIISketch = (p) => {
                    let asciiBlobs = [];
                    let asciiGrid = [];
                    let animationTime = 0;
                    const asciiGridSize = 50; // Same resolution as sketch.js
                    
                    // ASCII Blob class (simplified from sketch.js)
                    class ASCIIBlobSimple {
                        constructor(i, emotions, colors) {
                            this.id = i;
                            this.pos = { x: p.width * (0.3 + i * 0.4), y: p.height * 0.5 };
                            this.vel = { x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2 };
                            this.timeOffset = Math.random() * 1000;
                            this.cachedStrength = 1000;
                            this.currentEmotions = emotions;
                            this.displayColors = colors;
                            this.isVisible = true;
                            
                            // Blob parameters (same as defaultBlobVisuals)
                            this.blobStrength = analysis.blur ? Math.max(500, 1000 - analysis.blur * 100) : 1000;
                            this.blobSizeScale = analysis.voice_intensity ? Math.min(8, 3 + analysis.voice_intensity) : 5;
                            this.blobSpreadField = 6.0;
                            this.blobVisibility = 1.0;
                            this.breathSpeed = 0.0003;
                            this.gradientStrength = 15;
                            this.blobiness = analysis.blobiness || 1.5;
                            this.humor = analysis.humor || 0;
                            this.shine = analysis.shine || 0;
                        }
                        
                        update() {
                            animationTime += 0.016;
                            
                            // Simple organic movement
                            const time = animationTime * 0.01 + this.timeOffset;
                            this.vel.x += Math.sin(time) * 0.1;
                            this.vel.y += Math.cos(time * 0.7) * 0.1;
                            
                            // Apply movement
                            this.pos.x += this.vel.x;
                            this.pos.y += this.vel.y;
                            
                            // Damping
                            this.vel.x *= 0.98;
                            this.vel.y *= 0.98;
                            
                            // Keep in bounds
                            if (this.pos.x < 50 || this.pos.x > p.width - 50) this.vel.x *= -1;
                            if (this.pos.y < 50 || this.pos.y > p.height - 50) this.vel.y *= -1;
                            
                            this.pos.x = Math.max(50, Math.min(p.width - 50, this.pos.x));
                            this.pos.y = Math.max(50, Math.min(p.height - 50, this.pos.y));
                            
                            // Breathing effect
                            const breathEffect = Math.sin(animationTime * this.breathSpeed) * 0.5 + 1;
                            this.cachedStrength = this.blobStrength * breathEffect * this.blobVisibility;
                        }
                        
                        strengthAt(x, y) {
                            if (!this.isVisible || this.blobVisibility <= 0) return 0;
                            
                            const dx = x - this.pos.x;
                            const dy = y - this.pos.y;
                            let d2 = dx * dx + dy * dy;
                            if (d2 === 0) d2 = 1;
                            
                            // Add organic distortion
                            const angle = Math.atan2(dy, dx);
                            const t = animationTime * this.breathSpeed;
                            const distortion = Math.sin(angle * 3 + t) * this.blobiness * 0.3 + 1;
                            
                            const influence = (this.cachedStrength * this.blobSizeScale * distortion) / (d2 * this.blobSpreadField + 1e-6);
                            return Math.max(0, influence);
                        }
                    }
                    
                    p.setup = () => {
                        const canvas = p.createCanvas(p5Container.clientWidth || 800, p5Container.clientHeight || 600);
                        canvas.parent(p5Container);
                        
                        console.log('🎨 ASCII canvas created:', p.width, 'x', p.height);
                        
                        // Initialize ASCII grid
                        asciiGrid = [];
                        for (let i = 0; i < asciiGridSize; i++) {
                            asciiGrid[i] = [];
                            for (let j = 0; j < asciiGridSize; j++) {
                                asciiGrid[i][j] = 0;
                            }
                        }
                        
                        // Create blobs for each emotion
                        asciiBlobs = [];
                        emotions.forEach((emotion, i) => {
                            const color = emotionColors[emotion] || emotionColors['default'];
                            const blob = new ASCIIBlobSimple(i, [emotion], [color]);
                            asciiBlobs.push(blob);
                            console.log(`🎭 Created ASCII blob ${i} for emotion: ${emotion} with color [${color.join(', ')}]`);
                        });
                        
                        // If only one emotion, create it centered
                        if (asciiBlobs.length === 1) {
                            asciiBlobs[0].pos.x = p.width / 2;
                            asciiBlobs[0].pos.y = p.height / 2;
                        }
                        
                        console.log('✅ Complete ASCII visualization initialized with', asciiBlobs.length, 'blobs');
                    };
                    
                    p.draw = () => {
                        // Background (same as main app)
                        p.background(247, 249, 243);
                        
                        // Update blobs
                        asciiBlobs.forEach(blob => blob.update());
                        
                        // Draw background ASCII pattern (low intensity)
                        drawBackgroundASCII();
                        
                        // Draw metaball ASCII (same algorithm as sketch.js)
                        drawMetaballASCII();
                        
                        // Draw emotion labels
                        drawEmotionLabels();
                        
                        // Draw title
                        drawVisualizationTitle();
                    };
                    
                    function drawBackgroundASCII() {
                        const stepX = p.width / asciiGridSize;
                        const stepY = p.height / asciiGridSize;
                        
                        p.textAlign(p.CENTER, p.CENTER);
                        p.fill(150, 150, 150, 60); // Light gray background
                        p.textSize(10);
                        
                        for (let x = 0; x < asciiGridSize; x++) {
                            for (let y = 0; y < asciiGridSize; y++) {
                                const gx = x * stepX + stepX / 2;
                                const gy = y * stepY + stepY / 2;
                                
                                // Use noise for organic distribution
                                const noiseValue = p.noise(x * 0.1, y * 0.1, animationTime * 0.001);
                                if (noiseValue > 0.3) {
                                    const charIndex = Math.floor(noiseValue * backgroundChars.length);
                                    const char = backgroundChars[charIndex] || '.';
                                    p.text(char, gx, gy);
                                }
                            }
                        }
                    }
                    
                    function drawMetaballASCII() {
                        const stepX = p.width / asciiGridSize;
                        const stepY = p.height / asciiGridSize;
                        const drawThreshold = 0.001;
                        
                        p.textAlign(p.CENTER, p.CENTER);
                        
                        for (let x = 0; x < asciiGridSize; x++) {
                            for (let y = 0; y < asciiGridSize; y++) {
                                const gx = x * stepX + stepX / 2;
                                const gy = y * stepY + stepY / 2;
                                let maxInfluence = 0;
                                let dominantBlob = null;
                                
                                // Calculate influence from each blob
                                for (const blob of asciiBlobs) {
                                    const influence = blob.strengthAt(gx, gy);
                                    if (influence > maxInfluence) {
                                        maxInfluence = influence;
                                        dominantBlob = blob;
                                    }
                                }
                                
                                // Draw character if influence is strong enough
                                if (maxInfluence > drawThreshold && dominantBlob) {
                                    const intensity = Math.min(1, maxInfluence * 0.001);
                                    
                                    // Get emotion character set
                                    const emotion = dominantBlob.currentEmotions[0];
                                    const chars = emotionCharsets[emotion] || emotionCharsets['default'];
                                    const charIndex = Math.floor(intensity * (chars.length - 1));
                                    const char = chars[charIndex] || chars[0];
                                    
                                    // Get emotion color
                                    const color = dominantBlob.displayColors[0] || [150, 150, 150];
                                    const alpha = Math.min(255, intensity * 400 + 100);
                                    
                                    // Set character size based on intensity and effects
                                    let fontSize = Math.max(8, Math.min(24, intensity * 30 + 12));
                                    
                                    // Apply humor effects (jittery text)
                                    if (dominantBlob.humor > 0) {
                                        fontSize += Math.sin(animationTime * 0.1 + x + y) * dominantBlob.humor * 3;
                                    }
                                    
                                    p.textSize(fontSize);
                                    p.fill(color[0], color[1], color[2], alpha);
                                    
                                    // Apply shine effects (glow)
                                    if (dominantBlob.shine > 0) {
                                        p.drawingContext.shadowColor = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${dominantBlob.shine * 0.5})`;
                                        p.drawingContext.shadowBlur = dominantBlob.shine * 15;
                                    }
                                    
                                    p.text(char, gx, gy);
                                    
                                    // Reset shadow
                                    p.drawingContext.shadowBlur = 0;
                                }
                            }
                        }
                    }
                    
                    function drawEmotionLabels() {
                        asciiBlobs.forEach((blob, i) => {
                            if (blob.isVisible && blob.currentEmotions.length > 0) {
                                const emotion = blob.currentEmotions[0];
                                const color = blob.displayColors[0] || [150, 150, 150];
                                
                                // Draw emotion label above blob center
                                p.fill(255, 255, 255, 200);
                                p.rect(blob.pos.x - 40, blob.pos.y - 60, 80, 25, 5);
                                
                                p.fill(color[0], color[1], color[2]);
                                p.textAlign(p.CENTER, p.CENTER);
                                p.textSize(14);
                                p.text(emotion, blob.pos.x, blob.pos.y - 47);
                            }
                        });
                    }
                    
                    function drawVisualizationTitle() {
                        // Draw title background
                        p.fill(255, 255, 255, 220);
                        p.rect(p.width/2 - 200, 10, 400, 70, 10);
                        
                        // Main title
                        p.fill(50);
                        p.textAlign(p.CENTER, p.CENTER);
                        p.textSize(18);
                        p.text('🎭 ויזואליזציה מתקדמת', p.width/2, 30);
                        
                        // Subtitle with detected emotions
                        p.textSize(12);
                        p.fill(80);
                        const emotionText = emotions.length > 1 ? 
                            `רגשות מזוהים: ${emotions.join(', ')}` :
                            `רגש מזוהה: ${emotions[0]}`;
                        p.text(emotionText, p.width/2, 50);
                        
                        // Analysis parameters
                        if (analysis.voice_intensity > 1.5 || analysis.blur > 0 || analysis.humor > 0 || analysis.shine > 0) {
                            p.textSize(10);
                            p.fill(100);
                            let effectsText = [];
                            if (analysis.voice_intensity > 1.5) effectsText.push(`עוצמה: ${analysis.voice_intensity.toFixed(1)}`);
                            if (analysis.blur > 0) effectsText.push(`טשטוש: ${analysis.blur.toFixed(1)}`);
                            if (analysis.humor > 0) effectsText.push(`הומור: ${analysis.humor.toFixed(1)}`);
                            if (analysis.shine > 0) effectsText.push(`ברק: ${analysis.shine.toFixed(1)}`);
                            
                            if (effectsText.length > 0) {
                                p.text('אפקטים: ' + effectsText.join(' | '), p.width/2, 65);
                            }
                        }
                    }
                    
                    p.windowResized = () => {
                        p.resizeCanvas(p5Container.clientWidth || 800, p5Container.clientHeight || 600);
                    };
                };
                
                // Create the complete ASCII visualization
                window.myp5 = new p5(completeASCIISketch);
                console.log('✅ Complete ASCII visualization created successfully');
                
            } catch (error) {
                console.error('❌ Error in complete ASCII visualization:', error);
                // Fallback to basic blob visualization
                console.log('🔄 Falling back to basic blob visualization...');
                if (typeof initBlobVisualization === 'function') {
                    initBlobVisualization();
                }
            }
        }

        // Simple HTML/CSS visualization that definitely works
        function createSimpleHTMLVisualization() {
            console.log('🎨 Creating simple HTML visualization');
            
            const p5Container = document.getElementById('p5-sketch-container');
            if (!p5Container) {
                console.error('❌ P5 container not found');
                return;
            }
            
            // Clear container
            p5Container.innerHTML = '';
            
            // Create main visualization div
            const vizDiv = document.createElement('div');
            vizDiv.style.cssText = `
                width: 100%;
                height: 100%;
                background: linear-gradient(45deg, #87CEEB, #98FB98, #FFB6C1);
                position: absolute;
                top: 0;
                left: 0;
                z-index: 99999 !important;
                overflow: hidden;
                border-radius: 10px;
                border: 5px solid #FF0000 !important;
            `;
            
            // Create animated emotion blobs using pure CSS
            const blob1 = document.createElement('div');
            blob1.style.cssText = `
                position: absolute;
                width: 120px;
                height: 120px;
                background: radial-gradient(circle, #FFD700, #FFA500);
                border-radius: 50%;
                left: 30%;
                top: 50%;
                transform: translate(-50%, -50%);
                animation: float1 4s ease-in-out infinite;
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
                z-index: 100001 !important;
                border: 3px solid #000000 !important;
            `;
            
            const blob2 = document.createElement('div');
            blob2.style.cssText = `
                position: absolute;
                width: 100px;
                height: 100px;
                background: radial-gradient(circle, #FF8C00, #FF6347);
                border-radius: 50%;
                right: 30%;
                top: 50%;
                transform: translate(50%, -50%);
                animation: float2 3s ease-in-out infinite reverse;
                box-shadow: 0 0 20px rgba(255, 140, 0, 0.6);
                z-index: 100002 !important;
                border: 3px solid #000000 !important;
            `;
            
            // Create text labels
            const label1 = document.createElement('div');
            label1.style.cssText = `
                position: absolute;
                left: 30%;
                top: 30%;
                transform: translate(-50%, -50%);
                font-size: 18px;
                font-weight: bold;
                color: #333;
                text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
                z-index: 10;
            `;
            label1.textContent = 'שמחה';
            
            const label2 = document.createElement('div');
            label2.style.cssText = `
                position: absolute;
                right: 30%;
                top: 30%;
                transform: translate(50%, -50%);
                font-size: 16px;
                font-weight: bold;
                color: #333;
                text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
                z-index: 10;
            `;
            label2.textContent = 'התרגשות';
            
            // Create title
            const title = document.createElement('div');
            title.style.cssText = `
                position: absolute;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                background: #FF0000 !important;
                padding: 15px 25px;
                border-radius: 20px;
                font-size: 20px;
                font-weight: bold;
                color: #FFFFFF !important;
                border: 5px solid #000000 !important;
                z-index: 100003 !important;
                text-shadow: 2px 2px 4px #000000 !important;
            `;
            title.textContent = '🎉 ויזואליזציה HTML עובדת!';
            
            // Add CSS animations
            const style = document.createElement('style');
            style.textContent = `
                @keyframes float1 {
                    0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
                    25% { transform: translate(-40%, -60%) scale(1.1) rotate(90deg); }
                    50% { transform: translate(-60%, -50%) scale(0.9) rotate(180deg); }
                    75% { transform: translate(-50%, -40%) scale(1.05) rotate(270deg); }
                }
                @keyframes float2 {
                    0%, 100% { transform: translate(50%, -50%) scale(1) rotate(0deg); }
                    25% { transform: translate(60%, -40%) scale(0.95) rotate(-90deg); }
                    50% { transform: translate(40%, -50%) scale(1.1) rotate(-180deg); }
                    75% { transform: translate(50%, -60%) scale(0.9) rotate(-270deg); }
                }
            `;
            document.head.appendChild(style);
            
            // Assemble the visualization
            vizDiv.appendChild(blob1);
            vizDiv.appendChild(blob2);
            vizDiv.appendChild(label1);
            vizDiv.appendChild(label2);
            vizDiv.appendChild(title);
            
            p5Container.appendChild(vizDiv);
            
            console.log('✅ Simple HTML visualization created successfully');
        }

        // Simple fallback visualization without p5.js
        function createSimpleFallbackVisualization() {
            console.log('🎨 Creating simple fallback visualization without p5.js');
            
            const p5Container = document.getElementById('p5-sketch-container');
            if (!p5Container) {
                console.error('❌ P5 container not found');
                return;
            }
            
            // Clear container
            p5Container.innerHTML = '';
            
            // Create HTML5 canvas directly
            const canvas = document.createElement('canvas');
            canvas.width = p5Container.clientWidth || 800;
            canvas.height = p5Container.clientHeight || 400;
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.background = 'linear-gradient(45deg, #87CEEB, #98FB98)'; // Sky blue to pale green
            
            const ctx = canvas.getContext('2d');
            
            // Add some animated elements
            let time = 0;
            
            function drawFrame() {
                // Clear with gradient background
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#98FB98');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw animated emotion blobs
                const centerX1 = canvas.width * 0.35 + Math.sin(time) * 20;
                const centerY1 = canvas.height * 0.5 + Math.cos(time * 0.8) * 15;
                const centerX2 = canvas.width * 0.65 + Math.sin(time * 1.2) * 25;
                const centerY2 = canvas.height * 0.5 + Math.cos(time * 0.6) * 10;
                
                // First blob (joy) - gold
                ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(centerX1, centerY1, 60 + Math.sin(time * 3) * 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Second blob (excitement) - orange  
                ctx.fillStyle = 'rgba(255, 140, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(centerX2, centerY2, 50 + Math.cos(time * 2.5) * 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Add emotion text
                ctx.fillStyle = '#333';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('שמחה', centerX1, centerY1 - 80);
                ctx.fillText('התרגשות', centerX2, centerY2 - 70);
                
                // Title
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(canvas.width/2 - 150, 10, 300, 50);
                ctx.fillStyle = '#333';
                ctx.font = 'bold 16px Arial';
                ctx.fillText('🧪 בדיקה מהירה - Fallback Mode', canvas.width/2, 40);
                
                time += 0.02;
                requestAnimationFrame(drawFrame);
            }
            
            p5Container.appendChild(canvas);
            drawFrame();
            
            console.log('✅ Fallback visualization created successfully');
        }

        // Create ASCII-style visualization (simplified, similar to sketch.js)
        function createASCIIStyleVisualization(analysisData) {
            console.log('🎨 Creating ASCII-style visualization with:', analysisData);
            
            const p5Container = document.getElementById('p5-sketch-container');
            if (!p5Container) {
                console.error('❌ P5 container not found');
                return;
            }
            
            // Remove any existing p5 instance
            if (window.myp5) {
                window.myp5.remove();
                window.myp5 = null;
            }
            
            // Extract emotions from analysis
            const emotions = analysisData?.analysis?.emotions || ['שמחה'];
            const primaryEmotion = analysisData?.analysis?.primary_emotion || 'שמחה';
            const transcription = analysisData?.transcription || 'טקסט לדוגמה';
            
            console.log('📊 Visualization data:', { emotions, primaryEmotion, transcription });
            
            // ASCII-style sketch similar to main sketch.js
            const asciiSketch = (p) => {
                let backgroundChars = [];
                let emotionBlobs = [];
                let time = 0;
                
                // ASCII character sets (similar to sketch.js)
                const regularChars = ['·', '∴', '∵', '∶', '∷', '∸', '∹', '∺', '∻', '∼', '∽', '∾', '∿', '≀', '≁'];
                const emotionChars = {
                    'שמחה': ['☆', '★', '✦', '✧', '✩', '✪', '✫', '✬', '✭', '✮', '✯', '✰', '✱', '✲', '✳'],
                    'אהבה': ['♡', '♥', '❤', '💕', '💖', '💗', '💘', '💙', '💚', '💛', '💜', '💝', '💞', '💟', '❣'],
                    'כעס': ['⚡', '✦', '✧', '⚠', '⚡', '💥', '⚡', '✦', '⚡', '💥', '⚡', '✦', '⚡', '💥', '⚡'],
                    'עצב': ['💧', '💦', '💧', '💨', '💧', '💦', '💧', '💨', '💧', '💦', '💧', '💨', '💧', '💦', '💧'],
                    'פחד': ['👻', '💀', '🎭', '👻', '💀', '🎭', '👻', '💀', '🎭', '👻', '💀', '🎭', '👻', '💀', '🎭'],
                    'הפתעה': ['❗', '❓', '‼', '⁉', '❗', '❓', '‼', '⁉', '❗', '❓', '‼', '⁉', '❗', '❓', '‼'],
                    'התרגשות': ['🎉', '🎊', '✨', '🌟', '💫', '⭐', '🎉', '🎊', '✨', '🌟', '💫', '⭐', '🎉', '🎊', '✨']
                };
                
                p.setup = () => {
                    const width = p5Container.clientWidth || 800;
                    const height = p5Container.clientHeight || 600;
                    
                    console.log('🎨 Creating ASCII visualization canvas:', width, 'x', height);
                    const canvas = p.createCanvas(width, height);
                    canvas.parent(p5Container);
                    
                    // Create background ASCII characters
                    for (let i = 0; i < 150; i++) {
                        backgroundChars.push({
                            x: p.random(p.width),
                            y: p.random(p.height),
                            char: p.random(regularChars),
                            alpha: p.random(30, 80),
                            size: p.random(12, 20),
                            drift: p.random(-0.5, 0.5)
                        });
                    }
                    
                    // Create emotion blobs with ASCII characters
                    emotions.forEach((emotion, index) => {
                        const chars = emotionChars[emotion] || emotionChars['שמחה'];
                        const blobChars = [];
                        
                        // Create cluster of ASCII characters for this emotion
                        const centerX = p.width * (0.3 + index * 0.4);
                        const centerY = p.height * 0.5;
                        const radius = 80;
                        
                        for (let i = 0; i < 20; i++) {
                            const angle = p.random(p.TWO_PI);
                            const distance = p.random(radius);
                            blobChars.push({
                                x: centerX + Math.cos(angle) * distance,
                                y: centerY + Math.sin(angle) * distance,
                                char: p.random(chars),
                                size: p.random(16, 28),
                                color: getEmotionColor(emotion),
                                emotion: emotion,
                                baseAngle: angle,
                                baseDistance: distance,
                                centerX: centerX,
                                centerY: centerY
                            });
                        }
                        
                        emotionBlobs.push({
                            emotion: emotion,
                            chars: blobChars,
                            centerX: centerX,
                            centerY: centerY
                        });
                    });
                    
                    console.log('✨ Created ASCII visualization with', backgroundChars.length, 'background chars and', emotionBlobs.length, 'emotion blobs');
                };
                
                p.draw = () => {
                    // Background
                    p.background(247, 249, 243);
                    
                    time += 0.01;
                    
                    // Draw background ASCII characters
                    backgroundChars.forEach(char => {
                        char.x += char.drift;
                        if (char.x > p.width) char.x = 0;
                        if (char.x < 0) char.x = p.width;
                        
                        p.fill(100, 100, 100, char.alpha);
                        p.textAlign(p.CENTER, p.CENTER);
                        p.textSize(char.size);
                        p.text(char.char, char.x, char.y);
                    });
                    
                    // Draw emotion blobs
                    emotionBlobs.forEach(blob => {
                        blob.chars.forEach(char => {
                            // Animated movement
                            const offsetX = Math.sin(time * 2 + char.baseAngle) * 10;
                            const offsetY = Math.cos(time * 1.5 + char.baseAngle) * 8;
                            
                            const x = char.centerX + Math.cos(char.baseAngle) * char.baseDistance + offsetX;
                            const y = char.centerY + Math.sin(char.baseAngle) * char.baseDistance + offsetY;
                            
                            // Glow effect
                            for (let i = 3; i >= 0; i--) {
                                const alpha = (4 - i) * 50;
                                p.fill(char.color[0], char.color[1], char.color[2], alpha);
                                p.textAlign(p.CENTER, p.CENTER);
                                p.textSize(char.size + i * 2);
                                p.text(char.char, x, y);
                            }
                        });
                        
                        // Emotion label
                        p.fill(255, 255, 255, 200);
                        p.rect(blob.centerX - 40, blob.centerY - 120, 80, 30, 5);
                        p.fill(50);
                        p.textAlign(p.CENTER, p.CENTER);
                        p.textSize(16);
                        p.text(blob.emotion, blob.centerX, blob.centerY - 105);
                    });
                    
                    // Title
                    p.fill(255, 255, 255, 220);
                    p.rect(p.width/2 - 200, 10, 400, 70, 10);
                    p.fill(50);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(20);
                    p.text('🎭 ויזואליזציה ASCII של רגשות', p.width/2, 35);
                    p.textSize(14);
                    p.fill(80);
                    p.text('רגשות מזוהים: ' + emotions.join(', '), p.width/2, 55);
                };
                
                p.windowResized = () => {
                    p.resizeCanvas(p5Container.clientWidth || 800, p5Container.clientHeight || 600);
                };
                
                function getEmotionColor(emotion) {
                    const colors = {
                        'שמחה': [255, 215, 0],     // Gold
                        'אהבה': [255, 105, 180],   // Hot pink
                        'כעס': [255, 69, 0],       // Red orange
                        'עצב': [70, 130, 180],     // Steel blue
                        'פחד': [138, 43, 226],     // Blue violet
                        'הפתעה': [255, 140, 0],    // Dark orange
                        'התרגשות': [50, 205, 50],  // Lime green
                        'רגיעה': [135, 206, 250],  // Light sky blue
                        'ביטחון': [46, 139, 87],   // Sea green
                        'אופטימיות': [255, 218, 185] // Peach
                    };
                    return colors[emotion] || [255, 215, 0];
                }
            };
            
            // Create the visualization
            window.myp5 = new p5(asciiSketch);
            console.log('✅ ASCII-style visualization created successfully');
        }

        // Sophisticated P5.js Metaball ASCII Visualization based on sketch.js
        function createSophisticatedP5Visualization() {
            console.log('🎨 Creating sophisticated metaball ASCII visualization like sketch.js');
            
            const p5Container = document.getElementById('p5-sketch-container');
            if (!p5Container) {
                console.error('❌ P5 container not found');
                return;
            }
            
            // Remove any existing p5 instance
            if (window.myp5) {
                console.log('🗑️ Removing existing p5 instance');
                window.myp5.remove();
                window.myp5 = null;
            }
            
            // Clear container
            p5Container.innerHTML = '';
            
            // Emotion-specific character sets matching sketch.js
            const emotionCharsets = {
                'שמחה': ['░', '▒', '▓', '█'],        // joy - block characters like sketch.js
                'שמח': ['░', '▒', '▓', '█'],         // happy - block characters
                'עליזות': ['░', '▒', '▓', '█'],     // joy - block characters
                'התרגשות': ['░', '▒', '▓', '█'],    // excitement - block characters
                'אהבה': ['░', '▒', '▓', '█'],       // love - block characters
                'הפתעה': ['░', '▒', '▓', '█'],      // surprise - block characters
                'כעס': ['░', '▒', '▓', '█'],        // anger - block characters
                'פחד': ['░', '▒', '▓', '█'],        // fear - block characters
                'עצב': ['░', '▒', '▓', '█'],        // sadness - block characters
                'גועל': ['░', '▒', '▓', '█'],       // disgust - block characters
                'סקרנות': ['░', '▒', '▓', '█'],     // curiosity - block characters
                'תסכול': ['░', '▒', '▓', '█'],      // frustration - block characters
                'חרדה': ['░', '▒', '▓', '█'],       // anxiety - block characters
                'תקווה': ['░', '▒', '▓', '█'],      // hope - block characters
                'גאווה': ['░', '▒', '▓', '█'],      // pride - block characters
                'נייטרלי': ['░', '▒', '▓', '█'],    // neutral - block characters
                'ניטרלי': ['░', '▒', '▓', '█'],     // neutral - block characters  
                'default': ['░', '▒', '▓', '█']
            };
            
            // Background charset (regular ASCII like sketch.js)
            const backgroundCharsets = {
                'low': ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '=', '-', '~', '`'],
                'medium': ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '=', '-', '~', '`', '|', '\\', '/', ':', ';', '"', "'", '<', '>', ',', '.', '?'],
                'high': ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '=', '-', '~', '`', '|', '\\', '/', ':', ';', '"', "'", '<', '>', ',', '.', '?', '1', '2', '3', '4', '5']
            };
            
            // Create p5.js instance with metaball system
            window.myp5 = new p5((p) => {
                let time = 0;
                let gridSize = 50; // Grid resolution like sketch.js
                let blobs = [];
                let currentBackgroundCharset = backgroundCharsets.medium;
                
                // Blob parameters matching sketch.js
                const blobParams = {
                    blobiness: 1.5,           // Controls metaball effect strength
                    blobStrength: 300,        // Base blob strength
                    blobSizeScale: 2.5,       // Size multiplier - much bigger
                    coloredCircleCharSize: 1, // Emotion character size
                    regularAsciiCharSize: 1,  // Background character size
                    blur: 0.5,                // Blur effect
                    shine: 2.0,               // Shine effect
                    volumeImpact: 0.3         // Audio impact
                };
                
                // Single centered blob with multiple emotions
                const testEmotions = [
                    { 
                        emotions: ['שמחה', 'התרגשות', 'אהבה'], // Multiple emotions on one blob
                        x: 0.5, y: 0.5, // Centered
                        intensity: 0.8, 
                        colors: [
                            [255, 215, 0],   // שמחה - gold
                            [255, 140, 0],   // התרגשות - orange  
                            [255, 69, 0]     // אהבה - red-orange
                        ],
                        strength: 800,
                        ...blobParams
                    }
                ];
                
                p.setup = () => {
                    const width = p5Container.clientWidth || 800;
                    const height = p5Container.clientHeight || 400;
                    
                    console.log('🎨 Creating metaball ASCII canvas:', width, 'x', height);
                    const canvas = p.createCanvas(width, height);
                    canvas.parent(p5Container);
                    
                    // Create single centered blob with multiple emotions
                    const emotionData = testEmotions[0];
                    blobs.push({
                        id: 0,
                        x: emotionData.x * width,
                        y: emotionData.y * height,
                        emotions: emotionData.emotions,
                        colors: emotionData.colors,
                        charsets: emotionData.emotions.map(emotion => emotionCharsets[emotion] || emotionCharsets.default),
                        strength: emotionData.strength,
                        blobiness: emotionData.blobiness,
                        blobSizeScale: emotionData.blobSizeScale,
                        coloredCircleCharSize: emotionData.coloredCircleCharSize,
                        regularAsciiCharSize: emotionData.regularAsciiCharSize,
                        blur: emotionData.blur,
                        shine: emotionData.shine,
                        audioLevel: emotionData.intensity,
                        timeOffset: 0,
                        noiseOffsetX: p.random(1000),
                        noiseOffsetY: p.random(1000)
                    });
                    
                    console.log('✨ Created metaball system with', blobs.length, 'blobs');
                };
                
                p.draw = () => {
                    time += 0.02;
                    
                    // Completely clear background - pure black
                    p.background(0);
                    
                    // Draw metaball ASCII grid (main visualization)
                    drawMetaballASCIIGrid();
                    
                    // Draw emotion labels ON the blob
                    drawEmotionLabelsOnBlob();
                };
                
                function drawMetaballASCIIGrid() {
                    const stepX = p.width / gridSize;
                    const stepY = p.height / gridSize;
                    
                    p.textAlign(p.CENTER, p.CENTER);
                    
                    // Loop through grid like sketch.js
                    for (let x = 0; x < gridSize; x++) {
                        for (let y = 0; y < gridSize; y++) {
                            const gx = x * stepX + stepX / 2;
                            const gy = y * stepY + stepY / 2;
                            
                            // Calculate metaball influence at this position
                            let totalInfluence = 0;
                            let dominantBlob = null;
                            let maxInfluence = 0;
                            
                            blobs.forEach(blob => {
                                // Animate blob position
                                const animX = blob.x + Math.sin(time + blob.timeOffset) * 15;
                                const animY = blob.y + Math.cos(time * 0.8 + blob.timeOffset) * 12;
                                
                                // Calculate distance and influence
                                const distance = p.dist(gx, gy, animX, animY);
                                const adjustedStrength = blob.strength * blob.blobSizeScale * (1 + blob.blobiness * 0.3);
                                
                                // Metaball formula: influence = strength / distance^2
                                const influence = distance > 0 ? adjustedStrength / (distance * distance) : adjustedStrength;
                                totalInfluence += influence;
                                
                                if (influence > maxInfluence) {
                                    maxInfluence = influence;
                                    dominantBlob = blob;
                                }
                            });
                            
                            // Only draw characters where there's significant influence
                            if (totalInfluence > 0.1) {
                                drawMetaballCharacter(gx, gy, dominantBlob, totalInfluence, x, y);
                            }
                            // No background characters - clean background
                        }
                    }
                }
                
                function drawMetaballCharacter(gx, gy, blob, influence, gridX, gridY) {
                    if (!blob) return;
                    
                    // Multi-emotion character rendering
                    const influenceLevel = Math.min(influence / 2, 1); // Normalize
                    
                    // Cycle through emotions based on position and time
                    const emotionIndex = Math.floor((gridX + gridY + time * 2) % blob.emotions.length);
                    const currentEmotion = blob.emotions[emotionIndex];
                    const currentCharset = blob.charsets[emotionIndex];
                    const currentColor = blob.colors[emotionIndex];
                    
                    // Character selection based on influence strength
                    const charsetIndex = Math.floor(influenceLevel * (currentCharset.length - 1));
                    const char = currentCharset[charsetIndex] || currentCharset[0];
                    
                    // Apply blur effect (opacity reduction)
                    let alpha = p.map(influence, 0.1, 2, 150, 255);
                    if (blob.blur > 0) {
                        const blurReduction = Math.min(blob.blur / 5, 0.7);
                        alpha *= (1 - blurReduction);
                    }
                    alpha = p.constrain(alpha, 80, 255);
                    
                    // Apply shine effect (brightness boost)
                    let r = currentColor[0];
                    let g = currentColor[1];
                    let b = currentColor[2];
                    
                    if (blob.shine > 0) {
                        const shineBoost = 1 + (blob.shine / 10) * 0.5;
                        r = Math.min(255, r * shineBoost);
                        g = Math.min(255, g * shineBoost);
                        b = Math.min(255, b * shineBoost);
                    }
                    
                    // Size based on influence and blob parameters - bigger characters
                    const baseSize = 20;
                    const sizeMultiplier = blob.coloredCircleCharSize * (1.2 + influenceLevel * 0.8);
                    const finalSize = baseSize * sizeMultiplier;
                    
                    // Add movement and distortion like sketch.js
                    const moveTime = time * 0.5;
                    const jitterX = (p.noise(gridX * 0.1 + moveTime, gridY * 0.1) - 0.5) * 2;
                    const jitterY = (p.noise(gridX * 0.1, gridY * 0.1 + moveTime) - 0.5) * 2;
                    
                    // Draw the character
                    p.fill(r, g, b, alpha);
                    p.textSize(finalSize);
                    p.text(char, gx + jitterX, gy + jitterY);
                }
                

                
                function drawEmotionLabelsOnBlob() {
                    const blob = blobs[0]; // Single blob
                    if (!blob) return;
                    
                    const animX = blob.x + Math.sin(time + blob.timeOffset) * 10;
                    const animY = blob.y + Math.cos(time * 0.8 + blob.timeOffset) * 8;
                    
                    // Draw emotion labels scattered around the blob center
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(16);
                    
                    blob.emotions.forEach((emotion, index) => {
                        const angle = (index / blob.emotions.length) * Math.PI * 2 + time * 0.3;
                        const radius = 150 + Math.sin(time + index) * 25;
                        
                        const labelX = animX + Math.cos(angle) * radius;
                        const labelY = animY + Math.sin(angle) * radius;
                        
                        // Use emotion color for label
                        const color = blob.colors[index];
                        p.fill(color[0], color[1], color[2], 220);
                        p.stroke(0, 0, 0, 150);
                        p.strokeWeight(2);
                        p.text(emotion, labelX, labelY);
                        p.noStroke();
                    });
                    
                    // Draw parameters info at bottom
                    const paramText = `Blur: ${blob.blur} | Shine: ${blob.shine} | Blobiness: ${blob.blobiness}`;
                    p.textSize(10);
                    p.fill(255, 255, 255, 120);
                    p.text(paramText, animX, animY + 120);
                }
                
                // Make canvas responsive
                p.windowResized = () => {
                    const width = p5Container.clientWidth || 800;
                    const height = p5Container.clientHeight || 400;
                    p.resizeCanvas(width, height);
                    
                    // Update blob position to stay centered
                    if (blobs[0]) {
                        blobs[0].x = width * 0.5;  // Always centered
                        blobs[0].y = height * 0.5; // Always centered
                    }
                };
                
            }, p5Container);
            
            console.log('✅ Sophisticated metaball ASCII visualization created successfully');
        }

        // Show conversation visualization (kept for compatibility)
        function showConversationVisualization() {
            showInlineVisualization();
        }

        // Start emotion visualization
        async function startEmotionVisualization(analysisData) {
            try {
                console.log('🎨 Starting emotion visualization with:', analysisData);
                
                // Load sketch.js and start visualization
                if (!window.sketchLoaded) {
                    await loadSketchSystem(analysisData);
                } else {
                    initializeSketchWithData(analysisData);
                }
                
                // Update blob visualization with detected emotions  
                if (window.parent && window.parent.emotionBlobController) {
                    const primaryEmotion = analysisData.analysis?.primary_emotion || analysisData.emotion;
                    if (primaryEmotion) {
                        try {
                            window.parent.emotionBlobController.setEmotion(primaryEmotion);
                        } catch (error) {
                            console.warn('⚠️ Could not update parent blob controller:', error);
                        }
                    }
                }
            } catch (error) {
                console.error('❌ Error in startEmotionVisualization:', error);
                // Fallback to basic blob visualization
                console.log('🔄 Falling back to basic blob visualization...');
                if (typeof initBlobVisualization === 'function') {
                    initBlobVisualization();
                } else {
                    console.warn('⚠️ Basic blob visualization not available');
                }
            }
        }

        // Load and initialize sketch system
        async function loadSketchSystem(analysisData) {
            try {
                // Create a temporary emotion data structure like the main system
                window.currentEmotionData = createEmotionDataFromAnalysis(analysisData);
                window.currentConversation = 'temp_conversation';
                window.currentMp3File = 'live_recording.mp3';
                
                // Load emotion colors first
                await loadEmotionColors();
                
                // Ensure p5.js is loaded first
                if (!window.p5) {
                    console.log('🔧 Loading p5.js...');
                    const p5Script = document.createElement('script');
                    p5Script.src = 'https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js';
                    p5Script.onload = () => {
                        console.log('✅ P5.js loaded, disabling audio and loading sketch.js...');
                        
                        // Disable audio functions immediately after p5.js loads
                        if (window.p5) {
                            try {
                                window.p5.prototype.loadSound = function() {
                                    console.log('🔇 Audio loading disabled for visualization-only mode');
                                    return null;
                                };
                                window.p5.disableAudio = true;
                            } catch (error) {
                                console.warn('⚠️ Could not disable p5 audio functions:', error);
                            }
                        }
                        
                        loadSketchFile(analysisData);
                    };
                    p5Script.onerror = () => {
                        console.error('❌ Failed to load p5.js, falling back to basic visualization');
                        // Fallback to our basic blob visualization
                        initBlobVisualization();
                    };
                    document.head.appendChild(p5Script);
                } else {
                    // Disable audio if p5 already exists
                    if (window.p5) {
                        try {
                            // Safe check for existing loadSound function and disabled state
                            const loadSoundExists = window.p5.prototype && 
                                                  typeof window.p5.prototype.loadSound === 'function';
                            const isAlreadyDisabled = loadSoundExists && 
                                                    window.p5.prototype.loadSound.__disabled === true;
                            
                            if (!isAlreadyDisabled) {
                                window.p5.prototype.loadSound = function() {
                                    console.log('🔇 Audio loading disabled for visualization-only mode');
                                    return null;
                                };
                                window.p5.prototype.loadSound.__disabled = true;
                            }
                        } catch (error) {
                            console.warn('⚠️ Could not check/disable p5 audio functions:', error);
                        }
                    }
                    loadSketchFile(analysisData);
                }
            } catch (error) {
                console.error('❌ Error in loadSketchSystem:', error);
                // Fallback to basic blob visualization
                console.log('🔄 Falling back to basic blob visualization...');
                initBlobVisualization();
            }
        }

        // Load sketch.js file
        function loadSketchFile(analysisData) {
            try {
                // Load sketch.js if not already loaded
                if (!document.querySelector('script[src*="sketch.js"]')) {
                    const script = document.createElement('script');
                    script.src = '/frontend/sketch.js';
                    script.onload = () => {
                        console.log('✅ Sketch.js loaded, initializing...');
                        window.sketchLoaded = true;
                        try {
                            setTimeout(() => initializeSketchWithData(analysisData), 100);
                        } catch (error) {
                            console.error('❌ Error initializing sketch with data:', error);
                            // Fallback to basic blob visualization
                            initBlobVisualization();
                        }
                    };
                    script.onerror = () => {
                        console.error('❌ Failed to load sketch.js, falling back to basic visualization');
                        // Fallback to our basic blob visualization
                        initBlobVisualization();
                    };
                    document.head.appendChild(script);
                } else {
                    try {
                        initializeSketchWithData(analysisData);
                    } catch (error) {
                        console.error('❌ Error in existing sketch initialization:', error);
                        // Fallback to basic blob visualization
                        initBlobVisualization();
                    }
                }
            } catch (error) {
                console.error('❌ Error in loadSketchFile:', error);
                // Fallback to basic blob visualization
                initBlobVisualization();
            }
        }

        // Load emotion colors for sketch.js
        async function loadEmotionColors() {
            try {
                const response = await fetch('/config/emotions_config.json');
                const emotionsConfig = await response.json();
                
                // Store emotion colors globally for sketch.js
                window.emotionColors = {};
                window.emotionGlobalColorMap = {};
                
                if (emotionsConfig && emotionsConfig.emotions) {
                    Object.entries(emotionsConfig.emotions).forEach(([emotion, config]) => {
                        if (config && config.color) {
                            window.emotionColors[emotion] = config.color;
                            window.emotionGlobalColorMap[emotion] = config.color;
                        }
                    });
                }
                
                console.log('✅ Emotion colors loaded for sketch.js:', Object.keys(window.emotionColors).length);
                console.log('🎨 Emotion color map created:', window.emotionGlobalColorMap);
                return window.emotionColors;
            } catch (error) {
                console.error('❌ Failed to load emotion colors:', error);
                // Fallback colors
                window.emotionColors = {
                    'שמחה': '#FFD700',
                    'נימוס': '#87CEEB',
                    'אהבה': '#FF69B4',
                    'הפתעה': '#FF4500',
                    'סקרנות': '#20B2AA'
                };
                window.emotionGlobalColorMap = { ...window.emotionColors };
                console.log('🎨 Using fallback emotion colors');
                return window.emotionColors;
            }
        }

        // Initialize sketch with analysis data - FORCE REAL SKETCH.JS
        function initializeSketchWithData(analysisData) {
            console.log('🎨 Initializing sketch with FULL analysis data:', analysisData);
            
            // Setup p5.js container
            const p5Container = document.getElementById('p5-sketch-container');
            console.log('🔧 Container found:', !!p5Container);
            console.log('🔧 Available sketch functions:', {
                createSketch: typeof window.createSketch,
                sketchMain: typeof window.sketchMain,
                p5: typeof window.p5,
                initializeEmotionSketch: typeof window.initializeEmotionSketch
            });
            
            if (p5Container && window.p5) {
                // Clear any existing p5 instances
                if (window.myp5) {
                    window.myp5.remove();
                }
                
                // CRITICAL: Set up ALL global data that sketch.js expects
                window.currentEmotionData = createEmotionDataFromAnalysis(analysisData);
                window.currentConversation = 'temp_conversation';
                window.currentMp3File = 'live_recording.mp3';
                
                // Create the data structure that sketch.js expects
                const tempEmotionData = createEmotionDataFromAnalysis(analysisData);
                
                // Set up conversation data path for sketch.js to load
                window.conversationDataPath = '/api/temp-emotion-data';
                
                // Store the temp data globally so sketch.js can access it
                window.tempVisualizationData = tempEmotionData;
                
                // Set up sketch.js mode flags for proper rendering
                window.isPreviewMode = true;
                window.isPreviewFast = false;
                window.isPreviewInstant = true;
                window.previewNoAudio = true;
                window.previewOptimized = true;
                
                // Disable audio to prevent p.loadSound errors
                window.disableAudio = true;
                window.audioDisabled = true;
                window.p5soundDisabled = true;
                
                // Override p5.sound functions to prevent loading
                if (window.p5) {
                    window.p5.prototype.loadSound = function() {
                        console.log('🔇 Audio loading disabled for visualization-only mode');
                        return null;
                    };
                    
                    // Also disable other audio-related functions
                    window.p5.prototype.playNext = function() {
                        console.log('🔇 Audio play disabled');
                        return;
                    };
                }
                
                // Set URL parameters that sketch.js checks
                if (!window.URLSearchParams) {
                    window.URLSearchParams = function(search) {
                        this.get = function(param) {
                            if (param === 'viewMode') return 'preview';
                            if (param === 'preview') return 'instant';
                            if (param === 'noaudio') return 'true';
                            return null;
                        };
                    };
                }
                
                // Set up message listener to respond to emotion color requests from sketch.js
                window.addEventListener('message', (event) => {
                    if (event.data && event.data.type === 'emotionColorsRequest') {
                        console.log('📨 Received emotion color request from sketch.js');
                        
                        // Send back the emotion colors
                        const response = {
                            type: 'emotionColorsResponse',
                            emotions: window.emotionsConfig || {},
                            emotionColorMap: window.emotionGlobalColorMap || window.emotionColors || {}
                        };
                        
                        console.log('📤 Sending emotion colors to sketch.js:', response);
                        event.source.postMessage(response, '*');
                    }
                });
                
                // Also respond via BroadcastChannel if sketch.js uses it
                if (typeof BroadcastChannel !== 'undefined') {
                    const emotionChannel = new BroadcastChannel('emotionColors');
                    emotionChannel.onmessage = (event) => {
                        if (event.data && event.data.type === 'emotionColorsRequest') {
                            console.log('📻 Received emotion color request via BroadcastChannel');
                            
                            const response = {
                                type: 'emotionColorsResponse',
                                emotions: window.emotionsConfig || {},
                                emotionColorMap: window.emotionGlobalColorMap || window.emotionColors || {}
                            };
                            
                            console.log('📻 Broadcasting emotion colors:', response);
                            emotionChannel.postMessage(response);
                        }
                    };
                }
                
                // Create a mock endpoint response for sketch.js to load
                // Override the loadJSON method temporarily to serve our data
                if (window.p5 && !window.originalLoadJSON) {
                    console.log('🔧 Setting up mock data endpoint for sketch.js...');
                    
                    // Store original loadJSON for later restoration
                    window.originalLoadJSON = window.p5.prototype.loadJSON;
                    
                    // Override loadJSON to serve our temp data
                    window.p5.prototype.loadJSON = function(path, successCallback, errorCallback) {
                        console.log('🔍 loadJSON called with path:', path);
                        
                        if (path.includes('temp-emotion-data') || path.includes('live_recording')) {
                            console.log('✅ Serving temp visualization data to sketch.js');
                            setTimeout(() => {
                                if (successCallback) {
                                    successCallback(window.tempVisualizationData);
                                }
                            }, 10);
                            return;
                        }
                        
                        // For other paths, use original loadJSON
                        return window.originalLoadJSON.call(this, path, successCallback, errorCallback);
                    };
                }
                
                console.log('🎯 Emotion data for sketch.js:', window.currentEmotionData);
                console.log('🎯 Temp visualization data:', window.tempVisualizationData);
                console.log('🎯 Conversation data path set:', window.conversationDataPath);
                
                                // ✨ SINGLE BLOB CONFIGURATION - Force 1 blob instead of 2
                window.forceSingleBlob = true;
                window.singleBlobMode = true;
                window.numBlobs = 1;
                window.forcedBlobCount = 1;
                console.log('🎯 Single blob mode enabled - forcing 1 blob');
                
                // Force visible test mode
                window.forceVisibleTest = true;
                
                // FIRST PRIORITY: Use the real sketch.js p5SketchFunction
                if (typeof window.p5SketchFunction === 'function') {
                    console.log('✅ Using REAL p5SketchFunction from sketch.js');
                    console.log('🔍 P5 container:', p5Container);
                    console.log('🔍 P5 container dimensions:', {
                        width: p5Container.offsetWidth,
                        height: p5Container.offsetHeight,
                        clientWidth: p5Container.clientWidth,
                        clientHeight: p5Container.clientHeight
                    });
                    
                    try {
                        window.myp5 = new p5(window.p5SketchFunction, p5Container);
                        console.log('✅ Real sketch.js visualization started with p5SketchFunction!');
                        console.log('🎨 P5 instance created:', window.myp5);
                        
                        // Force a redraw and debug the canvas
                        setTimeout(() => {
                            if (window.myp5) {
                                if (window.myp5.redraw) {
                                    window.myp5.redraw();
                                    console.log('🔄 Forced p5 redraw');
                                }
                                
                                // EMERGENCY FALLBACK CANVAS DRAWING
                                const emergencyCanvas = document.getElementById('emergencyCanvas');
                                if (emergencyCanvas) {
                                    const ctx = emergencyCanvas.getContext('2d');
                                    
                                    // Clear and set background
                                    ctx.fillStyle = '#222';
                                    ctx.fillRect(0, 0, emergencyCanvas.width, emergencyCanvas.height);
                                    
                                    // Draw bright red blob
                                    ctx.fillStyle = '#ff0000';
                                    ctx.beginPath();
                                    ctx.arc(emergencyCanvas.width/2, emergencyCanvas.height/2, 75, 0, 2 * Math.PI);
                                    ctx.fill();
                                    
                                    // Draw text
                                    ctx.fillStyle = '#ffffff';
                                    ctx.font = '20px Arial';
                                    ctx.textAlign = 'center';
                                    ctx.fillText('בדיקת בלוב חירום', emergencyCanvas.width/2, emergencyCanvas.height/2 - 100);
                                    ctx.fillText('Emergency Blob Test', emergencyCanvas.width/2, emergencyCanvas.height/2 + 120);
                                    
                                    console.log('🚨 EMERGENCY: Drew on fallback canvas');
                                }
                                
                                // EMERGENCY FORCED DRAWING - Always draw something visible  
                                if (window.myp5.background && window.myp5.fill && window.myp5.ellipse) {
                                    window.myp5.background(30); // Dark background
                                    window.myp5.fill(255, 0, 0, 255); // Bright red
                                    window.myp5.noStroke();
                                    window.myp5.ellipse(window.myp5.width/2, window.myp5.height/2, 150, 150);
                                    window.myp5.fill(255);
                                    if (window.myp5.textAlign && window.myp5.textSize && window.myp5.text) {
                                        window.myp5.textAlign(window.myp5.CENTER);
                                        window.myp5.textSize(20);
                                        window.myp5.text('בדיקת בלוב חירום', window.myp5.width/2, window.myp5.height/2 - 100);
                                    }
                                    console.log('🚨 EMERGENCY: Drew bright red blob at center for visibility test');
                                }
                                
                                // Debug the canvas and add visible test elements
                                console.log('🎨 P5 canvas element:', window.myp5.canvas);
                                console.log('🎨 Canvas dimensions:', {
                                    width: window.myp5.width,
                                    height: window.myp5.height
                                });
                                
                                // Force canvas to be visible and properly positioned
                                if (window.myp5.canvas) {
                                    window.myp5.canvas.style.display = 'block !important';
                                    window.myp5.canvas.style.visibility = 'visible !important';
                                    window.myp5.canvas.style.opacity = '1 !important';
                                    window.myp5.canvas.style.zIndex = '1 !important';
                                    window.myp5.canvas.style.position = 'relative !important';
                                    window.myp5.canvas.style.top = '0 !important';
                                    window.myp5.canvas.style.left = '0 !important';
                                    window.myp5.canvas.style.width = '100% !important';
                                    window.myp5.canvas.style.height = '100% !important';
                                    window.myp5.canvas.style.background = '#333 !important';
                                    window.myp5.canvas.style.border = '2px solid #ffff00 !important';
                                    window.myp5.canvas.style.boxSizing = 'border-box !important';
                                    console.log('🔧 Fixed canvas positioning and visibility');
                                    
                                    // Force sketch.js to refresh and draw
                                    if (window.myp5.loop) {
                                        window.myp5.loop(); // Start animation loop
                                        console.log('🔄 Started p5.js animation loop');
                                    }
                                    if (window.myp5.redraw) {
                                        window.myp5.redraw();
                                        console.log('🎨 Forced p5.js redraw');
                                    }
                                    
                                    // Force single blob to be visible and centered
                                    if (window.myp5.blobs) {
                                        // Only work with the first blob in single blob mode
                                        const blob = window.myp5.blobs[0];
                                        if (blob) {
                                            blob.visible = true;
                                            blob.isVisible = true;
                                            // Center the single blob
                                            blob.homeX = window.myp5.width / 2;
                                            blob.homeY = window.myp5.height / 2;
                                            blob.x = blob.homeX;
                                            blob.y = blob.homeY;
                                            console.log('🎭 Single blob centered and made visible');
                                        }
                                        
                                        // Hide any extra blobs if they exist
                                        for (let i = 1; i < window.myp5.blobs.length; i++) {
                                            if (window.myp5.blobs[i]) {
                                                window.myp5.blobs[i].visible = false;
                                                window.myp5.blobs[i].isVisible = false;
                                                console.log(`🙈 Hidden extra blob ${i}`);
                                            }
                                        }
                                    }
                                    
                                    // Override sketch.js draw function to force blob rendering
                                    if (window.myp5.draw) {
                                        const originalDraw = window.myp5.draw;
                                        window.myp5.draw = function() {
                                            // Call original sketch.js draw
                                            if (originalDraw && typeof originalDraw === 'function') {
                                                originalDraw.call(this);
                                            }
                                            
                                            // Force draw visible blobs on top - SINGLE BLOB MODE
                                            if (this.blobs && this.blobs.length > 0) {
                                                // Only draw the first blob (single blob mode)
                                                const blob = this.blobs[0];
                                                if (blob && blob.pos) {
                                                    // Center the blob
                                                    const centerX = this.width / 2;
                                                    const centerY = this.height / 2;
                                                    
                                                    // Draw single centered blob with bright colors
                                                    this.fill(255, 100, 100, 200); // Semi-transparent red
                                                    this.ellipse(blob.pos.x || centerX, blob.pos.y || centerY, 120, 120);
                                                    
                                                    // Draw blob emotions as text above
                                                    this.fill(255);
                                                    if (this.textSize && this.text && blob.currentEmotions) {
                                                        this.textSize(16);
                                                        this.text(blob.currentEmotions.join(' + '), blob.pos.x || centerX, (blob.pos.y || centerY) - 80);
                                                    }
                                                    console.log(`🎭 Drew single blob at (${blob.pos.x || centerX}, ${blob.pos.y || centerY}) with emotions:`, blob.currentEmotions);
                                                }
                                            } else {
                                                // Fallback: draw single test blob at center
                                                const centerX = this.width / 2;
                                                const centerY = this.height / 2;
                                                
                                                this.fill(255, 0, 0, 200); // Red
                                                this.ellipse(centerX, centerY, 120, 120); // Single centered blob
                                                
                                                this.fill(255);
                                                if (this.textSize && this.text) {
                                                    this.textSize(16);
                                                    this.text('שמחה + התרגשות', centerX, centerY - 80);
                                                }
                                                console.log('🎭 Drew fallback single blob with combined emotions');
                                            }
                                        };
                                        console.log('✅ Overrode draw function to force blob visibility');
                                    }
                                }
                                
                                // Force all containers to be visible
                                const containers = ['p5-sketch-container', 'visualization-canvas-container', 'visualizationContainer', 'inlineVisualizationArea'];
                                containers.forEach(id => {
                                    const el = document.getElementById(id);
                                    if (el) {
                                        el.style.display = 'block !important';
                                        el.style.visibility = 'visible !important';
                                        el.style.opacity = '1 !important';
                                        el.style.minHeight = '400px !important';
                                        console.log(`🔧 Forced ${id} to be visible`);
                                    }
                                });
                                
                                                                // Let sketch.js handle its own background and drawing
                                console.log('✅ Ready for sketch.js visualization');
                                
                                                        // Let original sketch.js draw function run without override
                        console.log('✅ Allowing original sketch.js to draw blobs');
                        
                        // Trigger sketch.js blob updates with our emotion data
                        setTimeout(() => {
                            if (window.myp5 && window.myp5.blobs && window.tempVisualizationData) {
                                console.log('🎭 Manually triggering blob updates...');
                                
                                // Try to trigger blob parameter updates using the correct function
                                if (window.myp5.applySegmentParameters && window.tempVisualizationData) {
                                    const segmentData = window.tempVisualizationData['live_recording.mp3'];
                                    if (segmentData) {
                                        window.myp5.applySegmentParameters('live_recording.mp3', segmentData);
                                        console.log('✅ Triggered applySegmentParameters with data:', segmentData);
                                    }
                                }
                                
                                // Force refresh blob colors
                                if (window.myp5.refreshAllBlobColors) {
                                    window.myp5.refreshAllBlobColors();
                                    console.log('✅ Triggered refreshAllBlobColors');
                                }
                                
                                // Make sure blobs are visible
                                if (window.myp5.blobs) {
                                    window.myp5.blobs.forEach((blob, i) => {
                                        if (blob) {
                                            blob.visible = true;
                                            blob.isVisible = true;
                                            console.log(`✅ Made blob ${i} visible`);
                                        }
                                    });
                                }
                            }
                        }, 2000);
                            }
                        }, 1000);
                        
                        return;
                    } catch (error) {
                        console.error('❌ p5SketchFunction failed:', error);
                    }
                }
                
                // Try other sketch.js functions as backup
                if (typeof window.initializeEmotionSketch === 'function') {
                    console.log('✅ Using real initializeEmotionSketch function');
                    try {
                        window.initializeEmotionSketch(p5Container, window.currentEmotionData);
                        console.log('✅ Real sketch.js visualization started!');
                        return;
                    } catch (error) {
                        console.error('❌ Real sketch failed:', error);
                    }
                }
                
                // Try direct sketch instantiation with the exact pattern sketch.js uses
                if (typeof window.createSketch === 'function') {
                    console.log('✅ Using real createSketch function');
                    try {
                        window.myp5 = new p5(window.createSketch, p5Container);
                        console.log('✅ Real sketch.js visualization started via createSketch!');
                        return;
                    } catch (error) {
                        console.error('❌ createSketch failed:', error);
                    }
                }
                
                // LAST RESORT: Create a comprehensive visualization that uses all the analysis parameters
                console.log('🔧 Creating comprehensive parameter-based visualization...');
                const analysis = analysisData.analysis || {};
                
                const sketchFunction = (p) => {
                    let time = 0;
                    
                    p.setup = () => {
                        p.createCanvas(p5Container.offsetWidth, p5Container.offsetHeight);
                        console.log('✅ Comprehensive visualization created with full parameters');
                        console.log('📊 Analysis parameters:', {
                            emotions: analysis.emotions,
                            blur: analysis.blur,
                            shine: analysis.shine,
                            humor: analysis.humor,
                            voice_intensity: analysis.voice_intensity,
                            blobiness: analysis.blobiness,
                            proximity: analysis.proximity
                        });
                    };
                    
                    p.draw = () => {
                        time += 0.01;
                        
                        // Use blur parameter for background opacity
                        const bgAlpha = Math.max(5, (analysis.blur || 0) * 50 + 20);
                        p.background(0, bgAlpha);
                        
                        // Get emotions and colors
                        const emotions = analysis.emotions || ['שמחה'];
                        const emotionColors = window.emotionGlobalColorMap || window.emotionColors || {};
                        
                        emotions.forEach((emotion, i) => {
                            // Use voice_intensity for size
                            const baseSize = (analysis.voice_intensity || 1) * 80;
                            
                            // Use blobiness for shape distortion
                            const blobiness = analysis.blobiness || 1;
                            const distortion = blobiness * 20;
                            
                            // Use proximity for positioning
                            const proximity = analysis.proximity || 'medium';
                            let spread = 150;
                            if (proximity === 'close') spread = 80;
                            if (proximity === 'far') spread = 250;
                            
                            // Position based on emotion index
                            const angle = (i / emotions.length) * Math.PI * 2 + time;
                            const x = p.width/2 + Math.cos(angle) * spread;
                            const y = p.height/2 + Math.sin(angle) * spread * 0.6;
                            
                            // Get emotion color
                            const emotionColor = emotionColors[emotion] || '#FFD700';
                            p.fill(emotionColor);
                            
                            // Use shine for glow effect
                            if (analysis.shine > 0) {
                                p.drawingContext.shadowBlur = analysis.shine * 30;
                                p.drawingContext.shadowColor = emotionColor;
                            }
                            
                            // Create blob shape with blobiness distortion
                            p.beginShape();
                            for (let a = 0; a < Math.PI * 2; a += 0.1) {
                                const r = baseSize + Math.sin(a * 3 + time * 2) * distortion;
                                const bx = x + Math.cos(a) * r;
                                const by = y + Math.sin(a) * r;
                                p.vertex(bx, by);
                            }
                            p.endShape(p.CLOSE);
                            
                            // Reset shadow
                            p.drawingContext.shadowBlur = 0;
                            
                            // Add humor indicator (sparkles/particles)
                            if (analysis.humor > 0) {
                                for (let j = 0; j < analysis.humor * 5; j++) {
                                    const px = x + Math.random() * 100 - 50;
                                    const py = y + Math.random() * 100 - 50;
                                    p.fill(255, 200);
                                    p.ellipse(px, py, 3);
                                }
                            }
                            
                            // Emotion label
                            p.fill(255);
                            p.textAlign(p.CENTER, p.CENTER);
                            p.textSize(16);
                            p.text(emotion, x, y);
                        });
                    };
                };
                
                // Create comprehensive visualization
                window.myp5 = new p5(sketchFunction, p5Container);
                console.log('✅ Comprehensive parameter-based visualization created successfully');
                
            } else {
                console.log('⚠️ P5 container not found or p5.js not loaded');
            }
        }

        // Create emotion data structure compatible with sketch.js
        function createEmotionDataFromAnalysis(analysisData) {
            console.log('🔧 Creating emotion data from analysis:', analysisData);
            
            const analysis = analysisData.analysis || {};
            const emotions = analysis.emotions || [analysis.primary_emotion || 'שמחה'];
            const primaryEmotion = analysis.primary_emotion || emotions[0] || 'שמחה';
            
            // Ensure all visual parameters are properly structured for sketch.js
            const visualParams = {
                emotions: emotions,
                primary_emotion: primaryEmotion,
                transcript: conversationData?.transcription || 'תיאור שיחה',
                speaker: analysis.speaker || 0,
                intensity: analysis.intensity || analysis.voice_intensity || 5,
                confidence: analysis.confidence || 0.8,
                analysis_method: analysis.analysis_method || 'ai_analysis',
                
                // Critical visual parameters - ensure they're numbers, with enhanced defaults
                blur: typeof analysis.blur === 'number' ? analysis.blur : (emotions.includes('בלבול') ? 2 : 0),
                shine: typeof analysis.shine === 'number' ? analysis.shine : (emotions.includes('שמחה') ? 1 : 0),
                humor: typeof analysis.humor === 'number' ? analysis.humor : (emotions.includes('שעשוע') ? 2 : 0),
                voice_intensity: typeof analysis.voice_intensity === 'number' ? analysis.voice_intensity : 1.0,
                blobiness: typeof analysis.blobiness === 'number' ? analysis.blobiness : (emotions.length > 1 ? 2 : 1),
                proximity: analysis.proximity || 'close',
                auto_blob_spacing: analysis.auto_blob_spacing || 'close',
                character_sizing: analysis.character_sizing || 'medium',
                grid_resolution: analysis.grid_resolution || 40,
                speaker_position: analysis.speaker_position || 'מרכז שמאל',
                
                // Include any other analysis parameters
                ...analysis
            };
            
            const emotionData = {
                'live_recording.mp3': visualParams
            };
            
            console.log('✅ Created emotion data structure:', emotionData);
            console.log('🎨 Visual parameters check:', {
                blur: visualParams.blur,
                shine: visualParams.shine,
                humor: visualParams.humor,
                voice_intensity: visualParams.voice_intensity,
                blobiness: visualParams.blobiness,
                proximity: visualParams.proximity,
                emotions: visualParams.emotions
            });
            
            return emotionData;
        }

        // Test visualization function
        async function testVisualization() {
            console.log('🧪 Testing visualization with sample data...');
            
            // DEBUG: Check p5.js availability
            console.log('🔍 DEBUG: p5 available?', typeof p5 !== 'undefined');
            console.log('🔍 DEBUG: p5 object:', window.p5);
            console.log('🔍 DEBUG: window object keys containing p5:', Object.keys(window).filter(k => k.includes('p5')));
            
            // Add a visible indicator that test has started
            const statusElement = document.getElementById('voiceStatus') || document.getElementById('simpleStatus');
            if (statusElement) {
                statusElement.textContent = '🧪 מריץ בדיקה מהירה...';
                statusElement.style.color = '#4CAF50';
            }
            
            // Show visualization container immediately for test
            const testPlaceholder = document.getElementById('visualizationPlaceholder');
            const testVisualizationContainer = document.getElementById('visualization-canvas-container');
            const testP5Container = document.getElementById('p5-sketch-container');
            
            console.log('🔍 Container elements found:', {
                placeholder: !!testPlaceholder,
                visualizationContainer: !!testVisualizationContainer,
                p5Container: !!testP5Container
            });
            
            if (testPlaceholder) {
                testPlaceholder.style.display = 'none';
                console.log('✅ Hidden placeholder for test');
            }
            
            if (testVisualizationContainer) {
                testVisualizationContainer.style.display = 'block';
                testVisualizationContainer.style.borderRadius = '13px';
                console.log('✅ Shown visualization container for test');
            }
            
            if (testP5Container) {
                testP5Container.style.display = 'block';
                testP5Container.style.width = '100%';
                testP5Container.style.height = '100%';
                testP5Container.style.minHeight = '400px';
                console.log('✅ Prepared p5 container for test');
            }
            
            // Use sophisticated p5.js visualization based on sketch.js
            console.log('🎯 Creating sophisticated p5.js visualization like sketch.js');
            createSophisticatedP5Visualization();
            return;
            
            // Make sure visualization is initialized first
            if (!isBlobVisualizationRunning || !window.myp5) {
                console.log('🔄 Initializing visualization first...');
                initBlobVisualization();
                
                // Wait a moment for initialization
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            // Create test conversation data
            const testTranscription = 'בדיקה - אני מרגיש שמח וקצת נרגש היום, זו בדיקה של המערכת החדשה';
            const testAnalysis = {
                emotions: ['שמחה', 'התרגשות'],
                primary_emotion: 'שמחה',
                confidence: 0.95,
                blur: 1,
                shine: 2,
                humor: 1,
                voice_intensity: 1.5,
                blobiness: 2,
                proximity: 'close',
                auto_blob_spacing: 'close',
                speaker: 0,
                analysis_method: 'test_mode'
            };
            
            // Set up test data
            conversationData = {
                transcription: testTranscription,
                fullAnalysis: {
                    analysis: testAnalysis,
                    transcription: testTranscription,
                    success: true
                }
            };
            
            console.log('🧪 Test data created:', conversationData);
            
            // Show test transcription
            const transcriptionText = document.getElementById('transcriptionText');
            const transcriptionPreview = document.getElementById('transcriptionPreview');
            if (transcriptionText) transcriptionText.textContent = testTranscription;
            if (transcriptionPreview) transcriptionPreview.style.display = 'block';
            
            // Update the p5 visualization with test emotions
            if (window.myp5 && window.myp5.updateEmotions) {
                window.myp5.updateEmotions(testAnalysis.emotions);
            } else {
                // Create or recreate with enhanced blobs
                console.log('🎨 Creating enhanced test visualization...');
                
                // Remove existing p5 instance if it exists
                if (window.myp5) {
                    console.log('🗑️ Removing existing p5 instance');
                    window.myp5.remove();
                    window.myp5 = null;
                }
                
                // Clear the container completely
                if (testP5Container) {
                    console.log('🧹 Clearing p5 container completely');
                    testP5Container.innerHTML = '';
                    
                    // Add a visible test element to confirm container is working
                    const testDiv = document.createElement('div');
                    testDiv.style.cssText = `
                        position: absolute;
                        top: 10px;
                        left: 10px;
                        background: yellow;
                        color: black;
                        padding: 10px;
                        z-index: 9999;
                        font-weight: bold;
                        border: 2px solid black;
                    `;
                    testDiv.textContent = '🧪 TEST: Container is working!';
                    testP5Container.appendChild(testDiv);
                    console.log('🔍 Added test element to container');
                }
                
                const enhancedSketch = (p) => {
                    let blobs = [];
                    let time = 0;
                    
                    p.setup = () => {
                        const container = document.getElementById('p5-sketch-container');
                        
                        // Ensure container has proper dimensions
                        if (container) {
                            container.style.width = '100%';
                            container.style.height = '100%';
                            container.style.minHeight = '400px';
                            container.style.display = 'block';
                        }
                        
                        const width = container ? (container.clientWidth || 800) : 800;
                        const height = container ? (container.clientHeight || 600) : 600;
                        
                        console.log('🎨 Creating test canvas:', width, 'x', height);
                        const canvas = p.createCanvas(width, height);
                        canvas.parent(container || 'p5-sketch-container');
                        
                        // Make sure canvas is visible and on top
                        if (canvas && canvas.canvas) {
                            console.log('🔧 Setting canvas styles for visibility');
                            canvas.canvas.style.position = 'absolute';
                            canvas.canvas.style.top = '0';
                            canvas.canvas.style.left = '0';
                            canvas.canvas.style.zIndex = '100';
                            canvas.canvas.style.width = '100%';
                            canvas.canvas.style.height = '100%';
                            console.log('✅ Canvas styled for maximum visibility');
                        }
                        
                        // Create enhanced test blobs based on emotions
                        blobs = [
                            {
                                x: p.width * 0.35,
                                y: p.height * 0.5,
                                size: Math.min(120, p.width * 0.15),
                                color: [255, 215, 0], // Gold for שמחה
                                emotion: 'שמחה',
                                intensity: 1.5,
                                glow: true,
                                pulse: 0
                            },
                            {
                                x: p.width * 0.65,
                                y: p.height * 0.5,
                                size: Math.min(100, p.width * 0.12),
                                color: [255, 140, 0], // Orange for התרגשות
                                emotion: 'התרגשות',
                                intensity: 1.2,
                                glow: true,
                                pulse: Math.PI
                            }
                        ];
                        
                        console.log('✨ Created test blobs:', blobs.map(b => `${b.emotion} at (${Math.round(b.x)}, ${Math.round(b.y)}) size ${b.size}`));
                        
                        console.log('✨ Enhanced test visualization created with emotions:', testAnalysis.emotions);
                    };
                    
                    p.draw = () => {
                        // Background - use bright color to be clearly visible  
                        p.background(120, 180, 255);  // Bright blue instead of gray
                        
                        time += 0.02;
                        
                        // Draw enhanced blobs
                        blobs.forEach((blob, i) => {
                            // More dynamic animation for test
                            const offsetX = Math.sin(time + i * 2) * 15;
                            const offsetY = Math.cos(time * 0.8 + i) * 12;
                            const sizeVar = Math.sin(time * 3 + i) * (blob.intensity * 15);
                            
                            // Enhanced glow effect
                            for (let r = blob.size + 30; r > 0; r -= 6) {
                                const alpha = (1 - (r / (blob.size + 30))) * (blob.glow ? 150 : 80);
                                p.fill(blob.color[0], blob.color[1], blob.color[2], alpha);
                                p.noStroke();
                                p.ellipse(
                                    blob.x + offsetX, 
                                    blob.y + offsetY, 
                                    r + sizeVar
                                );
                            }
                            
                            // Emotion text with background
                            p.fill(255, 255, 255, 200);
                            p.rect(blob.x + offsetX - 30, blob.y + offsetY - blob.size - 40, 60, 25, 5);
                            
                            p.fill(50);
                            p.textAlign(p.CENTER, p.CENTER);
                            p.textSize(14);
                            p.text(blob.emotion, blob.x + offsetX, blob.y + offsetY - blob.size - 27);
                        });
                        
                        // Enhanced title
                        p.fill(255, 255, 255, 220);
                        p.rect(p.width/2 - 150, 10, 300, 60, 10);
                        
                        p.fill(50);
                        p.textAlign(p.CENTER, p.CENTER);
                        p.textSize(18);
                        p.text('🧪 בדיקה מהירה - Test Mode', p.width/2, 30);
                        
                        p.textSize(12);
                        p.fill(80);
                        p.text('מציג רגשות מזוהים: ' + testAnalysis.emotions.join(', '), p.width/2, 50);
                    };
                    
                    p.windowResized = () => {
                        const container = document.getElementById('p5-sketch-container');
                        p.resizeCanvas(container.clientWidth || 600, container.clientHeight || 400);
                    };
                };
                
                window.myp5 = new p5(enhancedSketch);
            }
            
            // Visualization container is already shown above
            console.log('✅ Visualization container already prepared for test');
            
            // Force show the visualization container for the test
            const quickTestVisualizationContainer = document.getElementById('visualization-canvas-container');
            const quickTestPlaceholder = document.getElementById('visualizationPlaceholder');
            
            if (quickTestPlaceholder) {
                quickTestPlaceholder.style.display = 'none';
                console.log('✅ Hidden placeholder for test');
            }
            
            if (quickTestVisualizationContainer) {
                quickTestVisualizationContainer.style.display = 'block';
                console.log('✅ Shown visualization container for test');
            }
            
            // Update status to show test completed successfully 
            if (statusElement) {
                statusElement.textContent = '✅ בדיקה מהירה הושלמה - ויזואליזציה מוצגת';
                statusElement.style.color = '#4CAF50';
            }
            
            console.log('✅ Quick test visualization completed successfully');
        }

        // Override the existing processAudioRecording to ALWAYS use enhanced flow
        const originalProcessAudioRecording = window.processAudioRecording;
        window.processAudioRecording = async function(audioBlob) {
            console.log('🎯 processAudioRecording called, conversationFlowActive:', conversationFlowActive);
            
            // ALWAYS use our enhanced flow now
            await processConversationFlow(audioBlob);
        };

        // Enhanced return to recording function
        function returnToRecording() {
            console.log('🔄 Returning to recording interface...');
            
            const placeholder = document.getElementById('visualizationPlaceholder');
            const visualizationContainer = document.getElementById('visualization-canvas-container');
            const transcriptionPreview = document.getElementById('transcriptionPreview');
            const visualArea = document.getElementById('inlineVisualizationArea');
            
            // Hide visualization and show placeholder
            if (visualizationContainer) visualizationContainer.style.display = 'none';
            if (placeholder) placeholder.style.display = 'flex';
            
            // Reset visualization area to initial state
            if (visualArea) {
                visualArea.style.border = '2px dashed #BFC4C0';
                visualArea.style.background = '#f7f9f3';
            }
            
            // Hide transcription
            if (transcriptionPreview) transcriptionPreview.style.display = 'none';
            
            // Stop any running visualization
            if (window.myp5) {
                window.myp5.remove();
                window.myp5 = null;
            }
            
            // 🎵 CLEANUP AUDIO PLAYBACK
            if (window.playbackAudio) {
                window.playbackAudio.pause();
                window.playbackAudio = null;
            }
            
            // Hide audio controls
            const audioControls = document.getElementById('audioPlaybackControls');
            const manualPlayButton = document.getElementById('manualPlayButton');
            if (audioControls) audioControls.style.display = 'none';
            if (manualPlayButton) manualPlayButton.style.display = 'none';
            
            // Cleanup audio URL to free memory
            if (window.recordedAudioUrl) {
                URL.revokeObjectURL(window.recordedAudioUrl);
                window.recordedAudioUrl = null;
            }
            window.recordedAudioBlob = null;
            
            // Reset conversation data for new recording
            conversationData = null;
            resetConversationFlow();
            
            console.log('✅ Returned to recording interface');
        }

        // Missing function to fix the error
        async function applyConversationParametersToBlobs(transcription, analysis) {
            console.log('🎨 Applying conversation parameters to blobs:', analysis);
            
            // Update parent window blobs if available
            if (window.parent && window.parent.emotionBlobController) {
                const primaryEmotion = analysis.emotion || analysis.primary_emotion;
                if (primaryEmotion) {
                    window.parent.emotionBlobController.setEmotion(primaryEmotion);
                }
            }
            
            // Apply any additional blob effects here if needed
            return Promise.resolve();
        }

        // Auto-focus on enhanced microphone when page loads
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                const enhancedContainer = document.getElementById('enhancedMicContainer');
                if (enhancedContainer) {
                    enhancedContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 500);
        });
        
        // 🎵 AUDIO PLAYBACK CONTROL FUNCTIONS
        function showAudioPlaybackControls() {
            const controls = document.getElementById('audioPlaybackControls');
            if (controls) {
                controls.style.display = 'flex';
                
                // Update controls based on current playback state
                if (window.playbackAudio) {
                    window.playbackAudio.addEventListener('ended', () => {
                        document.getElementById('playPauseBtn').textContent = '▶️';
                        document.getElementById('audioStatus').textContent = 'ההקלטה הסתיימה';
                    });
                    
                    window.playbackAudio.addEventListener('pause', () => {
                        document.getElementById('playPauseBtn').textContent = '▶️';
                        document.getElementById('audioStatus').textContent = 'ההקלטה מושהית';
                    });
                    
                    window.playbackAudio.addEventListener('play', () => {
                        document.getElementById('playPauseBtn').textContent = '⏸️';
                        document.getElementById('audioStatus').textContent = 'מנגן את ההקלטה...';
                    });
                }
            }
        }
        
        function showManualPlayButton() {
            const manualButton = document.getElementById('manualPlayButton');
            if (manualButton) {
                manualButton.style.display = 'block';
            }
        }
        
        function toggleAudioPlayback() {
            if (window.playbackAudio) {
                if (window.playbackAudio.paused) {
                    window.playbackAudio.play();
                } else {
                    window.playbackAudio.pause();
                }
            }
        }
        
        function replayAudio() {
            if (window.playbackAudio) {
                window.playbackAudio.currentTime = 0;
                window.playbackAudio.play();
            }
        }
        
        function startManualPlayback() {
            if (window.playbackAudio) {
                window.playbackAudio.play().then(() => {
                    document.getElementById('manualPlayButton').style.display = 'none';
                    showAudioPlaybackControls();
                }).catch(error => {
                    console.error('Failed to start manual playback:', error);
                });
            }
        }

        // Auto-initialize blob visualization when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🎭 DOM loaded, preparing blob visualization...');
            
            // Wait a moment for all elements and p5.js to be ready
            setTimeout(() => {
                if (typeof initBlobVisualization === 'function') {
                    console.log('🎭 Auto-initializing blob visualization...');
                    initBlobVisualization();
                } else {
                    console.log('⚠️ initBlobVisualization not ready, will retry when needed');
                }
            }, 1000);
        });
        
        // Also initialize when entering questionnaire mode
        window.addEventListener('load', () => {
            console.log('🎭 Window loaded, ensuring blob visualization is ready...');
            
            // Initialize immediately if we're in questionnaire mode
            const questionnairePage = document.getElementById('questionnairePage');
            if (questionnairePage && questionnairePage.classList.contains('active')) {
                setTimeout(() => {
                    if (typeof initBlobVisualization === 'function') {
                        console.log('🎭 Auto-initializing blob visualization for active questionnaire...');
                        initBlobVisualization();
                    }
                }, 500);
            }
        });
        
        // ✨ ENHANCED WIZARD VISUALIZATION INTEGRATION
        
        // Load emotion colors for the sketch
        let emotionColors = {};
        
        async function loadEmotionColors() {
            try {
                const response = await fetch('/config/emotions_config.json');
                if (response.ok) {
                    emotionColors = await response.json();
                    console.log('✅ Emotion colors loaded:', Object.keys(emotionColors).length, 'emotions');
                    
                    // Set up listener for emotion color requests from sketch
                    window.addEventListener('message', (event) => {
                        if (event.data.type === 'requestEmotionColors') {
                            console.log('📨 Sketch requested emotion colors, providing:', Object.keys(emotionColors).length, 'emotions');
                            event.source?.postMessage({
                                type: 'emotionColorsUpdate',
                                emotions: emotionColors,
                                timestamp: Date.now()
                            }, '*');
                        }
                    });
                    
                    return emotionColors;
                } else {
                    console.error('❌ Failed to load emotion colors');
                    return {};
                }
            } catch (error) {
                console.error('❌ Error loading emotion colors:', error);
                return {};
            }
        }
        
        // Load visualization scripts like in visualization.html
        function loadVisualizationScripts() {
            console.log('🎨 Loading visualization scripts for wizard...');
            
            // First load emotion colors, then sketch.js
            loadEmotionColors().then(() => {
                // Load sketch.js
                const sketchScript = document.createElement('script');
                sketchScript.src = '/frontend/sketch.js';
                sketchScript.onload = () => {
                    console.log('✅ sketch.js loaded successfully');
                    initializeWizardVisualization();
                };
                sketchScript.onerror = () => {
                    console.error('❌ Failed to load sketch.js');
                };
                document.head.appendChild(sketchScript);
            });
        }
        
        // Initialize wizard visualization
        function initializeWizardVisualization() {
            console.log('🎭 Setting up wizard visualization...');
            
            // Set wizard-specific configuration
            window.isWizardMode = true;
            window.noSidepanel = true;
            window.currentConversationFolder = 'wizard_live';
            window.isLiveMode = true;
            
            // Create a mock conversation structure for live recording
            window.emotionData = {};
            window.segmentDurations = {};
            window.totalDuration = 0;
            window.currentSegmentIndex = 0;
            window.liveSegments = [];
            
            console.log('✅ Wizard visualization initialized');
        }
        
        // Initialize full visualization in emergency canvas after recording analysis
        async function initializeEmergencyVisualization(analysis, transcript) {
            console.log('🎨 Creating FULL visualization.html interface in emergency canvas...');
            
            try {
                // Get the emergency canvas
                const emergencyCanvas = document.getElementById('emergencyCanvas');
                if (!emergencyCanvas) {
                    console.error('❌ Emergency canvas not found');
                    return;
                }
                
                console.log('✅ Emergency canvas found, creating conversation with FULL analysis format...');
                
                // Create conversation data with FULL format (same as upload & analyze)
                const conversationData = {
                    transcript: transcript || 'תמליל לא זמין',
                    emotions: analysis?.emotions || ['ניטרלי'],
                    blur: analysis?.blur || 0,
                    shine: analysis?.shine || 0,
                    humor: analysis?.humor || 0,
                    blobSize: analysis?.blobSize || 3,
                    blobStrength: analysis?.blobStrength || 1000,
                    gridResolution: analysis?.gridResolution || 60,
                    blobHomeRegion: analysis?.blobHomeRegion || 'center-left',
                    confidence: analysis?.confidence || 0.95,
                    ai_analyzed: analysis?.ai_analyzed || true,
                    audio_volume: analysis?.audio_volume || 0.5,
                    audio_energy: analysis?.audio_energy || 0.5,
                    audio_duration: analysis?.audio_duration || 1.0,
                    primary_emotion: analysis?.primary_emotion,
                    detected_emotions_original: analysis?.detected_emotions_original,
                    duration: window.recordingDuration || 0
                };
                
                // Save the conversation first with FULL format
                const response = await fetch('/api/create-conversation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(conversationData)
                });
                
                if (!response.ok) {
                    throw new Error('Failed to create conversation');
                }
                
                const result = await response.json();
                console.log('💾 Conversation saved with full format:', result);
                
                // Make emergency canvas visible and styled like main visualization
                emergencyCanvas.style.display = 'block';
                emergencyCanvas.style.position = 'absolute';
                emergencyCanvas.style.top = '0';
                emergencyCanvas.style.left = '0';
                emergencyCanvas.style.width = '100%';
                emergencyCanvas.style.height = '100%';
                emergencyCanvas.style.zIndex = '100';
                emergencyCanvas.style.border = '1px solid #9f9f9f';
                emergencyCanvas.style.background = '#f7f9f3';
                
                // Initialize p5.js sketch on emergency canvas (like visualization.html)
                console.log('🎭 Setting up p5.js visualization on emergency canvas...');
                
                // Set global variables for the visualization
                window.currentConversationFolder = result.conversation_folder;
                window.emergencyMode = true;
                window.currentVisualizationData = conversationData;
                
                // Create p5 instance for emergency canvas (same as visualization.html)
                const p5Instance = new p5((sketch) => {
                    // Global variables for sketch
                    let emotionBlobs = [];
                    let blobColors = {};
                    
                    sketch.setup = function() {
                        // Create canvas that fills emergency canvas
                        const canvas = sketch.createCanvas(emergencyCanvas.width, emergencyCanvas.height);
                        canvas.parent(emergencyCanvas.parentElement);
                        canvas.style('position', 'absolute');
                        canvas.style('top', '0');
                        canvas.style('left', '0');
                        canvas.style('z-index', '101');
                        
                        console.log('🎨 Emergency p5.js canvas initialized');
                        
                        // Initialize emotion colors (from emotions config)
                        blobColors = emotionColors || {
                            'ניטרלי': '#cccccc',
                            'שמחה': '#ffeb3b',
                            'עצב': '#2196f3',
                            'כעס': '#f44336',
                            'פחד': '#9c27b0',
                            'הפתעה': '#ff9800'
                        };
                        
                        // Create blobs for each emotion
                        const emotions = conversationData.emotions || ['ניטרלי'];
                        emotions.forEach((emotion, index) => {
                            emotionBlobs.push({
                                x: sketch.width / 2 + (index - emotions.length/2) * 80,
                                y: sketch.height / 2,
                                radius: 40 + conversationData.blobSize * 5,
                                emotion: emotion,
                                color: blobColors[emotion] || '#cccccc',
                                targetX: sketch.width / 2 + (index - emotions.length/2) * 80,
                                targetY: sketch.height / 2,
                                blur: conversationData.blur || 0,
                                shine: conversationData.shine || 0,
                                strength: conversationData.blobStrength || 1000
                            });
                        });
                    };
                    
                    sketch.draw = function() {
                        // Background (same as visualization.html)
                        sketch.background(247, 249, 243); // #f7f9f3
                        
                        // Apply blur effect if needed
                        if (conversationData.blur > 0) {
                            sketch.drawingContext.filter = `blur(${conversationData.blur}px)`;
                        }
                        
                        // Draw emotion blobs with animation
                        emotionBlobs.forEach((blob, index) => {
                            // Animate blob movement
                            blob.x = sketch.lerp(blob.x, blob.targetX, 0.05);
                            blob.y = sketch.lerp(blob.y, blob.targetY, 0.05);
                            
                            // Apply shine effect
                            if (conversationData.shine > 0) {
                                sketch.push();
                                sketch.translate(blob.x, blob.y);
                                sketch.rotate(sketch.frameCount * 0.01);
                                sketch.fill(255, 255, 255, conversationData.shine * 10);
                                sketch.ellipse(0, 0, blob.radius * 1.2, blob.radius * 1.2);
                                sketch.pop();
                            }
                            
                            // Draw main blob
                            sketch.fill(blob.color);
                            sketch.noStroke();
                            sketch.ellipse(blob.x, blob.y, blob.radius, blob.radius);
                            
                            // Draw emotion text
                            sketch.fill(50);
                            sketch.textAlign(sketch.CENTER, sketch.CENTER);
                            sketch.textSize(12);
                            sketch.text(blob.emotion, blob.x, blob.y);
                        });
                        
                        // Reset blur
                        if (conversationData.blur > 0) {
                            sketch.drawingContext.filter = 'none';
                        }
                        
                        // Draw transcript at bottom (same as visualization.html)
                        sketch.fill(50);
                        sketch.textAlign(sketch.CENTER);
                        sketch.textSize(14);
                        sketch.text(conversationData.transcript.substring(0, 100) + '...', 
                                   sketch.width/2, sketch.height - 50);
                        
                        // Draw title at top
                        sketch.fill(50);
                        sketch.textAlign(sketch.CENTER);
                        sketch.textSize(18);
                        sketch.text('ויזואליזציה של השיחה המוקלטת', sketch.width/2, 30);
                        
                        // Draw confidence indicator
                        sketch.fill(100);
                        sketch.textAlign(sketch.LEFT);
                        sketch.textSize(12);
                        sketch.text(`דיוק: ${Math.round(conversationData.confidence * 100)}%`, 20, 30);
                    };
                }, emergencyCanvas.parentElement);
                
                console.log('✅ Full visualization.html interface initialized successfully in emergency canvas');
                
            } catch (error) {
                console.error('❌ Error initializing emergency visualization:', error);
            }
        }
        
        // Function to add live segment data (called during recording)
        function addLiveSegment(segmentData) {
            const segmentId = `live_${window.currentSegmentIndex}.mp3`;
            window.liveSegments.push(segmentData);
            
            // Add to emotion data structure
            window.emotionData[segmentId] = {
                emotions: segmentData.emotions || ['ציפייה'],
                speaker: segmentData.speaker || 0,
                transcript: segmentData.transcript || '',
                blur: segmentData.blur || 0,
                shine: segmentData.shine || 0,
                humor: segmentData.humor || 0,
                ai_analyzed: true,
                ai_analysis_date: new Date().toISOString()
            };
            
            // Update visualization with new data
            if (window.p5Instance && window.blobs) {
                const speaker = segmentData.speaker || 0;
                if (window.blobs[speaker]) {
                    window.blobs[speaker].setEmotions(segmentData.emotions || ['ציפייה']);
                    console.log(`🎭 Updated blob ${speaker} with emotions:`, segmentData.emotions);
                }
            }
            
            window.currentSegmentIndex++;
        }
        
        // Function to process live microphone analysis (same as upload & analyze)
        async function processLiveMicrophoneAnalysis(audioBlob, transcript) {
            console.log('🎯 Processing live microphone analysis with full format...');
            
            try {
                // Use the same analyze-segment endpoint as upload & analyze with JSON
                const analysisData = {
                    conversation: 'wizard_live',
                    mp3File: `live_${Date.now()}.mp3`,
                    transcript: transcript,
                    currentEmotions: ['ניטרלי'],
                    speaker: 0,
                    auto_save: false // Don't auto-save during live recording
                };
                
                console.log('📤 Sending analysis request:', analysisData);
                
                // Send to analysis endpoint with JSON (same as upload & analyze)
                const response = await fetch('/api/analyze-segment', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(analysisData)
                });
                
                if (response.ok) {
                    const analysisResult = await response.json();
                    console.log('✅ Full live analysis result:', analysisResult);
                    
                    // Add the segment to visualization with FULL format (same as upload & analyze)
                    addLiveSegment({
                        transcript: transcript,
                        emotions: analysisResult.emotions || ['ניטרלי'],
                        speaker: 0, // Default to speaker 0 for live recording
                        blur: analysisResult.blur || 0,
                        shine: analysisResult.shine || 0,
                        humor: analysisResult.humor || 0,
                        blobSize: analysisResult.blobSize || 3,
                        blobStrength: analysisResult.blobStrength || 1000,
                        gridResolution: analysisResult.gridResolution || 60,
                        blobHomeRegion: analysisResult.blobHomeRegion || 'center-left',
                        confidence: analysisResult.confidence || 0.95,
                        ai_analyzed: true,
                        ai_analysis_date: new Date().toISOString(),
                        audio_volume: analysisResult.audio_volume || 0.5,
                        audio_energy: analysisResult.audio_energy || 0.5,
                        audio_duration: analysisResult.audio_duration || 1.0,
                        primary_emotion: analysisResult.primary_emotion,
                        detected_emotions_original: analysisResult.detected_emotions_original
                    });
                    
                    return analysisResult;
                } else {
                    console.error('❌ Analysis failed:', response.statusText);
                    
                    // Fallback: add segment with neutral emotion but full format
                    addLiveSegment({
                        transcript: transcript,
                        emotions: ['ניטרלי'],
                        speaker: 0,
                        blur: 0,
                        shine: 0,
                        humor: 0,
                        blobSize: 3,
                        blobStrength: 1000,
                        gridResolution: 60,
                        blobHomeRegion: 'center-left',
                        confidence: 0.5,
                        ai_analyzed: false
                    });
                    
                    return null;
                }
            } catch (error) {
                console.error('❌ Error in live analysis:', error);
                
                // Fallback: add segment with neutral emotion but full format
                addLiveSegment({
                    transcript: transcript,
                    emotions: ['ניטרלי'],
                    speaker: 0,
                    blur: 0,
                    shine: 0,
                    humor: 0,
                    blobSize: 3,
                    blobStrength: 1000,
                    gridResolution: 60,
                    blobHomeRegion: 'center-left',
                    confidence: 0.5,
                    ai_analyzed: false
                });
                
                return null;
            }
        }
        
        // Enhanced microphone recording that triggers analysis
        let liveRecordingAudioChunks = [];
        let liveMediaRecorder = null;
        let liveRecordingStream = null;
        
        // Override the existing recording functions to include live analysis
        const originalStartConversationFlow = window.startConversationFlow;
        window.startConversationFlow = function() {
            console.log('🎤 Starting enhanced conversation flow with live analysis...');
            
            // Start microphone
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    liveRecordingStream = stream;
                    liveMediaRecorder = new MediaRecorder(stream);
                    liveRecordingAudioChunks = [];
                    
                    liveMediaRecorder.ondataavailable = event => {
                        liveRecordingAudioChunks.push(event.data);
                    };
                    
                    liveMediaRecorder.onstop = async () => {
                        console.log('🎤 Recording stopped, processing...');
                        
                        // Create audio blob
                        const audioBlob = new Blob(liveRecordingAudioChunks, { type: 'audio/mp3' });
                        
                        // Show processing state
                        const status = document.getElementById('simpleStatus');
                        if (status) status.textContent = 'מתמלל ומנתח...';
                        
                        try {
                            // First transcribe the audio (like upload process)
                            const transcript = await transcribeAudioBlob(audioBlob);
                            console.log('📝 Transcribed:', transcript);
                            
                            // Then analyze it (like admin panel)
                            const analysis = await processLiveMicrophoneAnalysis(audioBlob, transcript);
                            
                                                         // Update UI
                             if (status) {
                                 if (analysis) {
                                     status.textContent = `ניתוח הושלם: ${analysis.emotions?.join(', ') || 'ניטרלי'}`;
                                 } else {
                                     status.textContent = 'הניתוח הושלם';
                                 }
                             }
                             
                             // Show save button after first analysis
                             const saveBtn = document.getElementById('saveConversationBtn');
                             if (saveBtn && window.liveSegments.length > 0) {
                                 saveBtn.style.display = 'block';
                             }
                             
                             // Hide placeholder, show visualization
                             const placeholder = document.getElementById('visualizationPlaceholder');
                             if (placeholder) {
                                 placeholder.style.display = 'none';
                             }
                             
                             // 🎨 Initialize full visualization in emergency canvas after analysis
                             console.log('🎨 Initializing emergency canvas visualization...');
                             setTimeout(() => {
                                 initializeEmergencyVisualization(analysis, transcript);
                             }, 500);
                            
                        } catch (error) {
                            console.error('❌ Error processing recording:', error);
                            if (status) status.textContent = 'שגיאה בעיבוד ההקלטה';
                        }
                    };
                    
                    // Start recording
                    liveMediaRecorder.start();
                    
                    // Update UI
                    const status = document.getElementById('simpleStatus');
                    if (status) status.textContent = 'מקליט...';
                    
                    // Show stop button
                    const micIcon = document.getElementById('micIcon');
                    const actionButtons = document.getElementById('actionButtons');
                    if (micIcon) micIcon.style.display = 'none';
                    if (actionButtons) actionButtons.style.display = 'flex';
                    
                })
                .catch(error => {
                    console.error('❌ Error accessing microphone:', error);
                    const status = document.getElementById('simpleStatus');
                    if (status) status.textContent = 'שגיאה בגישה למיקרופון';
                });
        };
        
        const originalStopConversationFlow = window.stopConversationFlow;
        window.stopConversationFlow = function() {
            console.log('🛑 Stopping conversation flow...');
            
            if (liveMediaRecorder && liveMediaRecorder.state === 'recording') {
                liveMediaRecorder.stop();
            }
            
            if (liveRecordingStream) {
                liveRecordingStream.getTracks().forEach(track => track.stop());
                liveRecordingStream = null;
            }
            
            // Reset UI
            const micIcon = document.getElementById('micIcon');
            const actionButtons = document.getElementById('actionButtons');
            if (micIcon) micIcon.style.display = 'flex';
            if (actionButtons) actionButtons.style.display = 'none';
        };
        
        // Transcribe audio blob (like upload process)
        async function transcribeAudioBlob(audioBlob) {
            const formData = new FormData();
            formData.append('audio', audioBlob, `live_${Date.now()}.mp3`);
            formData.append('method', 'openai_fast'); // Use fast transcription
            
            const response = await fetch('/api/transcribe-audio', {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                const result = await response.json();
                return result.transcript || '';
            } else {
                throw new Error('Transcription failed');
            }
        }
        
        // Function to save the conversation (like creating new conversation)
        async function saveWizardConversation() {
            console.log('💾 Saving wizard conversation...');
            
            if (window.liveSegments.length === 0) {
                alert('אין מקטעים לשמירה');
                return;
            }
            
            try {
                // Create conversation data structure
                const conversationData = {
                    title: `שיחה חיה ${new Date().toLocaleDateString('he-IL')}`,
                    date: new Date().toISOString().split('T')[0],
                    participants: ['משתמש'],
                    segments: window.liveSegments,
                    emotion_data: window.emotionData
                };
                
                // Send to server to create new conversation
                const response = await fetch('/api/create-conversation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(conversationData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('✅ Conversation saved:', result);
                    
                    // Navigate to the new conversation
                    window.location.href = `/visualization.html?folder=${result.folder}`;
                } else {
                    throw new Error('Failed to save conversation');
                }
                
            } catch (error) {
                console.error('❌ Error saving conversation:', error);
                alert('שגיאה בשמירת השיחה');
            }
        }
        
        // Load visualization scripts when entering questionnaire mode
        const originalShowQuestionnaire = window.showQuestionnaire;
        window.showQuestionnaire = function() {
            // Call original function
            if (originalShowQuestionnaire) {
                originalShowQuestionnaire();
            }
            
            // Load visualization scripts
            setTimeout(() => {
                loadVisualizationScripts();
            }, 500);
        };
    </script>

</body>
</html>