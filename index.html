

<html lang="he" dir="rtl" style="height: 100%;">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Emotion Visualizer</title>
  <link rel="icon" href="data:,">


  <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.indigo-pink.min.css">
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Miriam+Libre:wght@400;700&display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap">
  <script src="https://code.getmdl.io/1.3.0/material.min.js"></script>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  
  
  
  <script>
                     // Initialize responsive VIDEO PREVIEW sizing on page load
          if (typeof updateResponsiveBlockSizes !== 'undefined') {
              // Expose functions globally
              window.updateResponsiveBlockSizes = updateResponsiveBlockSizes;
              window.calculateOptimalBlockSize = calculateOptimalBlockSize;
              
              // Test function for FULL-SCREEN video preview responsiveness
              window.testVideoPreviewResponsiveness = function() {
                  console.log('ğŸ¬ Testing FULL-SCREEN Video Preview Responsiveness...');
                  const containers = document.querySelectorAll('.conversation-grid-item-container');
                  console.log(`ğŸ“Š Found ${containers.length} video preview containers`);
                  
                  if (containers.length > 0) {
                      const currentSize = containers[0].style.width || 'unknown';
                      console.log(`ğŸ“ Current video preview size: ${currentSize}`);
                      updateResponsiveBlockSizes(true);
                      setTimeout(() => {
                          const newSize = containers[0].style.width || 'unknown';
                          console.log(`ğŸ“ Updated video preview size: ${newSize}`);
                          console.log('âœ… FULL-SCREEN video preview test complete');
                      }, 200);
                  } else {
                      console.log('âš ï¸ No video preview containers found yet');
                  }
              };
              
              // Initialize on page load
              document.addEventListener('DOMContentLoaded', () => {
                  setTimeout(() => {
                      console.log('ğŸ¬ Initializing FULL-SCREEN Video Preview Responsive System...');
                      updateResponsiveBlockSizes(true);
                      // Initialize zoom-responsive grid system
                      if (typeof initializeZoomResponsiveGrid !== 'undefined') {
                          initializeZoomResponsiveGrid();
                      }
                      // Initialize intersection observer for performance optimization
                      initConversationIntersectionObserver();
                      console.log('ğŸ‘€ Intersection observer initialized for lazy loading optimization');
                  }, 100); // Earlier initialization to prevent 60px flash
              });
              
              // Also initialize on conversation data load
              if (window.originalConversationData && window.originalConversationData.length > 0) {
                  updateResponsiveBlockSizes(true);
              }
          }
    
    // Auto-scaling configuration for FULL-SCREEN video previews
    let autoScalingConfig = {
        enabled: true,
        minBlockSize: 250,     // Much larger minimum for better visibility
        maxBlockSize: 1200,    // Even larger maximum for big screens
        densityFactor: 0.85,   // Use 85% of screen space for better spacing
        aspectRatio: 1,        // Maintain square aspect ratio
        padding: 20,           // More padding between larger blocks
        lastCalculatedSize: null,
        debounceTimeout: null
    };

    // Calculate optimal conversation VIDEO PREVIEW block size - PEOPLE VIEW OPTIMIZED
    function calculateOptimalBlockSize(conversationCount, containerWidth, containerHeight, layoutType = 'timeline') {
        if (!autoScalingConfig.enabled || conversationCount === 0) {
            return autoScalingConfig.lastCalculatedSize || 300;
        }

        console.log(`ğŸ¬ Calculating optimal VIDEO PREVIEW size for ${conversationCount} blocks in ${layoutType} view`);

        // Use almost the full screen width and height
        const availableWidth = containerWidth * 0.98;
        const availableHeight = (containerHeight - 100) * 0.95;

        let optimalSize;
        
        if (layoutType === 'people') {
            // PEOPLE VIEW: Optimize to show ALL people and their conversations
            // Assume typical people view has ~5-15 different people, each with 1-10 conversations
            
            // Estimate number of people groups (assume average 3 conversations per person)
            const estimatedPeopleCount = Math.max(3, Math.ceil(conversationCount / 3));
            
            // Calculate optimal size to fit all people rows on screen
            const peopleRowHeight = 80; // Space needed for person name + conversations
            const totalRowsNeeded = estimatedPeopleCount;
            
            // Size based on fitting all people vertically
            const maxSizeByHeight = Math.min(
                (availableHeight / totalRowsNeeded) * 0.7, // 70% of row height for conversations
                120 // Don't go below readable size
            );
            
            // Size based on fitting ~8-12 conversations per row horizontally
            const conversationsPerRow = Math.min(12, Math.max(6, Math.floor(availableWidth / 80)));
            const maxSizeByWidth = (availableWidth / conversationsPerRow) - 15;
            
            // Use the smaller of the two to ensure everything fits
            optimalSize = Math.min(maxSizeByHeight, maxSizeByWidth);
            
            console.log(`ğŸ‘¥ People view: ${estimatedPeopleCount} people, ${conversationsPerRow} convos/row, size: ${Math.round(optimalSize)}px`);
            
        } else {
            // TIMELINE/EMOTIONS: Organized grid layout for better visibility
            if (conversationCount <= 4) {
                const cols = Math.min(2, conversationCount);
                const rows = Math.ceil(conversationCount / cols);
                optimalSize = Math.min(
                    availableWidth / cols - 40,
                    availableHeight / rows - 40,
                    120 // Max size for organization
                );
            } else if (conversationCount <= 16) {
                const cols = Math.min(4, Math.ceil(Math.sqrt(conversationCount)));
                const rows = Math.ceil(conversationCount / cols);
                optimalSize = Math.min(
                    availableWidth / cols - 30,
                    availableHeight / rows - 30,
                    100 // Max size for organization
                );
            } else {
                const aspectRatio = availableWidth / availableHeight;
                const cols = Math.ceil(Math.sqrt(conversationCount * aspectRatio));
                const rows = Math.ceil(conversationCount / cols);
                
                optimalSize = Math.min(
                    availableWidth / cols - 20,
                    availableHeight / rows - 20,
                    80 // Max size for dense organization
                );
            }
        }

        // Apply constraints - ORGANIZED SIZES
        const minSize = layoutType === 'people' ? 60 : 60; // Consistent organized minimum
        const maxSize = layoutType === 'people' ? 120 : 100; // Organized maximum for proper spacing
        
        optimalSize = Math.max(minSize, Math.min(maxSize, optimalSize));

        // Apply zoom factor
        optimalSize *= currentZoomLevel;

        // Cache the result
        autoScalingConfig.lastCalculatedSize = Math.round(optimalSize);
        
        console.log(`ğŸ¬ ${layoutType} view: ${conversationCount} blocks, optimal size: ${autoScalingConfig.lastCalculatedSize}px`);
        
        return autoScalingConfig.lastCalculatedSize;
    }

    // Update all VIDEO PREVIEW conversation block sizes responsively
    function updateResponsiveBlockSizes(forceRecalculate = false) {
        clearTimeout(autoScalingConfig.debounceTimeout);
        autoScalingConfig.debounceTimeout = setTimeout(() => {
            const layoutCanvas = document.getElementById('layout-canvas');
            if (!layoutCanvas || !window.originalConversationData) return;

            const conversationCount = window.originalConversationData.length;
            const containerWidth = layoutCanvas.offsetWidth || window.innerWidth;
            const containerHeight = layoutCanvas.offsetHeight || window.innerHeight;
            const currentLayout = window.activeLayout || 'timeline';

            const newOptimalSize = calculateOptimalBlockSize(
                conversationCount, 
                containerWidth, 
                containerHeight, 
                currentLayout
            );

            // Only update if size changed significantly or forced
            if (forceRecalculate || !autoScalingConfig.lastCalculatedSize || 
                Math.abs(newOptimalSize - autoScalingConfig.lastCalculatedSize) > 5) {
                
                console.log(`ğŸ¬ Updating VIDEO PREVIEW sizes to ${newOptimalSize}px for ${conversationCount} conversation blocks`);
                
                // Update CSS custom properties specifically for video preview containers
                const sizeVariables = [
                    '--timeline-item-size',
                    '--timeline-square-size', 
                    '--people-square-size',
                    '--conversation-block-size'
                ];

                sizeVariables.forEach(varName => {
                    document.documentElement.style.setProperty(varName, `${newOptimalSize}px`);
                });

                // Directly update all conversation video preview containers
                const conversationContainers = document.querySelectorAll('.conversation-grid-item-container');
                conversationContainers.forEach(container => {
                    // Update container size
                    container.style.width = `${newOptimalSize}px`;
                    container.style.height = `${newOptimalSize}px`;
                    
                    // Update video wrapper if it exists
                    const videoWrapper = container.querySelector('.video-container-wrapper');
                    if (videoWrapper) {
                        videoWrapper.style.width = `${newOptimalSize}px`;
                        videoWrapper.style.height = `${newOptimalSize}px`;
                    }
                    
                    // Update video element sizing
                    const video = container.querySelector('.conversation-video-preview');
                    if (video) {
                        video.style.width = `${newOptimalSize}px`;
                        video.style.height = `${newOptimalSize}px`;
                    }
                });

                console.log(`âœ… Updated ${conversationContainers.length} video preview blocks to ${newOptimalSize}px`);
                
                // Trigger layout recalculation if we have a significant size change
                if (window.renderNewLayout && (forceRecalculate || 
                    Math.abs(newOptimalSize - (autoScalingConfig.lastCalculatedSize || 0)) > 20)) {
                    setTimeout(() => {
                        window.renderNewLayout(false);
                    }, 100);
                }
            }
        }, 150); // Debounce rapid calls
    }
    
    // Detect zoom level changes
    function detectZoomLevel() {
        // Method 1: Using window.devicePixelRatio (most reliable)
        const pixelRatio = window.devicePixelRatio || 1;
        
        // Method 2: Using window dimensions vs screen dimensions
        const widthZoom = window.outerWidth / window.innerWidth;
        const heightZoom = window.outerHeight / window.innerHeight;
        
        // Method 3: Create a test element to measure zoom
        const testElement = document.createElement('div');
        testElement.style.cssText = 'position: absolute; left: 0; top: 0; width: 100px; height: 100px; visibility: hidden;';
        document.body.appendChild(testElement);
        const rect = testElement.getBoundingClientRect();
        document.body.removeChild(testElement);
        
        const elementZoom = rect.width / 100;
        
        // Use the most reliable zoom detection method
        let detectedZoom = elementZoom;
        
        // Fallback methods if element zoom fails
        if (Math.abs(detectedZoom - 1) < 0.01) {
            detectedZoom = Math.max(widthZoom, heightZoom);
        }
        
        // Clamp zoom level to reasonable bounds
        return Math.max(0.25, Math.min(5, detectedZoom));
    }
    
    // Simplified grid system - no longer needed since grids are removed
    function initializeZoomResponsiveGrid() {
        console.log('ğŸ” Grid system disabled - using solid backgrounds');
    }
    


    // Initialize on page load
    document.addEventListener('DOMContentLoaded', initializeZoomResponsiveGrid);
    
    // --- Ensure Static Background Grid Function ---
    function ensureStaticBackgroundGrid() {
        // Grid background disabled - just ensure solid background color
        document.body.style.background = '#f7f9f3';
        document.body.style.backgroundImage = 'none';
        console.log('âœ… Grid background disabled - using solid background');
    }
    
    // --- Global Variables ---
    let camera = { x: 0, y: 0, zoom: 1 };
    window.activeLayout = 'timeline';
    let layoutPositions = { timeline: null, people: null, emotions: null };
    
    // Global layout state variables - promote to window for consistency
    window.isLayoutRendering = false;
    window.layoutRenderTimeout = null;
    window.peopleViewStabilityCheck = null;
    window.layoutPositions = layoutPositions;
    let targetPositions = null;
    
    // Timeline state reset function for consistency issues
    window.resetTimelineState = function() {
        console.log('ğŸ”„ Resetting timeline state for consistency...');
        
        // Clear all timeouts
        if (window.layoutRenderTimeout) {
            clearTimeout(window.layoutRenderTimeout);
            window.layoutRenderTimeout = null;
        }
        if (window.peopleViewStabilityCheck) {
            clearTimeout(window.peopleViewStabilityCheck);
            window.peopleViewStabilityCheck = null;
        }
        
        // Reset flags
        window.isLayoutRendering = false;
        
        // Clear cached positions except timeline (keep timeline as base)
        if (window.layoutPositions) {
            window.layoutPositions.people = null;
            window.layoutPositions.emotions = null;
        }
        
        // Clean up DOM classes and elements
        const layoutCanvas = document.getElementById('layout-canvas');
        const gridContainer = document.getElementById('timeline-axes-container');
        
        if (layoutCanvas) {
            layoutCanvas.classList.remove('isotope-transitioning', 'isotope-switching');
            
            // Clean up emotions view specific elements that might interfere
            const emotionLabels = layoutCanvas.querySelectorAll('.emotion-cluster-label, .emotion-circle-label, .emotion-circle-background, .emotion-inner-circle, .emotion-count-badge');
            emotionLabels.forEach(el => el.remove());
            console.log(`ğŸ§¹ Removed ${emotionLabels.length} emotions view elements`);
        }
        
        if (gridContainer) {
            gridContainer.classList.remove('isotope-transitioning', 'isotope-switching');
            // Ensure proper layout class
            gridContainer.className = `layout-${window.activeLayout}`;
        }
        
        // COMPREHENSIVE BODY CLASS RESET: Clear all layout classes
        document.body.classList.remove('layout-timeline', 'layout-people', 'layout-emotions');
        
        // Set proper body class for current layout
        if (window.activeLayout === 'timeline') {
            document.body.className = 'layout-timeline';
        } else if (window.activeLayout === 'people') {
            document.body.className = 'layout-people';
        } else if (window.activeLayout === 'emotions') {
            document.body.className = 'layout-emotions';
        } else {
            document.body.className = '';
        }
        
        console.log(`ğŸ—ï¸ Reset body class to: ${document.body.className || '(empty)'}`)
        
        console.log('âœ… Timeline state reset complete');
    };
    
    // Emotions view cleanup function for smooth transitions
    window.cleanupEmotionsView = function() {
        console.log('ğŸ­ Cleaning up emotions view for transition...');
        
        const layoutCanvas = document.getElementById('layout-canvas');
        const gridContainer = document.getElementById('timeline-axes-container');
        
        if (layoutCanvas) {
            // Remove all emotions-specific elements
            const emotionsElements = layoutCanvas.querySelectorAll(
                '.emotion-cluster-label, .emotion-circle-label, .emotion-circle-background, ' +
                '.emotion-inner-circle, .emotion-count-badge, .emotion-line-background'
            );
            emotionsElements.forEach(el => el.remove());
            console.log(`ğŸ§¹ Removed ${emotionsElements.length} emotions view elements`);
            
            // Clear emotions-specific canvas classes
            layoutCanvas.classList.remove('emotions-active');
            
            // Clear emotions-specific styles and positioning
            layoutCanvas.style.removeProperty('background');
            layoutCanvas.style.removeProperty('background-color');
            layoutCanvas.style.removeProperty('position');
            layoutCanvas.style.removeProperty('top');
            layoutCanvas.style.removeProperty('left');
            layoutCanvas.style.removeProperty('right');
            layoutCanvas.style.removeProperty('bottom');
            layoutCanvas.style.removeProperty('width');
            layoutCanvas.style.removeProperty('height');
            layoutCanvas.style.removeProperty('padding');
            layoutCanvas.style.removeProperty('overflow');
        }
        
        // Clear emotions body class specifically
        document.body.classList.remove('layout-emotions');
        
        // Clear emotions cache to prevent stale positions
        if (window.layoutPositions) {
            window.layoutPositions.emotions = null;
            console.log('ğŸ—‘ï¸ Cleared emotions layout cache');
        }
        
        // CRITICAL: Clear CSS custom properties set by emotions view
        // This prevents emotions view sizing from interfering with timeline view calculations
        document.documentElement.style.removeProperty('--timeline-square-size');
        document.documentElement.style.removeProperty('--timeline-item-size');
        document.documentElement.style.removeProperty('--people-square-size');
        document.documentElement.style.removeProperty('--visual-conversation-size');
        console.log('ğŸ§¹ Cleared emotions view CSS custom properties');
        
        console.log('âœ… Emotions view cleanup complete');
    };
    
    // Timeline validation function to check for consistency issues
    window.validateTimelineState = function() {
        console.log('ğŸ” Validating timeline state...');
        
        const issues = [];
        const layoutCanvas = document.getElementById('layout-canvas');
        const gridContainer = document.getElementById('timeline-axes-container');
        
        // Check if containers exist
        if (!layoutCanvas) issues.push('layout-canvas missing');
        if (!gridContainer) issues.push('timeline-axes-container missing');
        
        // Check layout consistency
        if (gridContainer && window.activeLayout) {
            const expectedClass = `layout-${window.activeLayout}`;
            if (!gridContainer.classList.contains(expectedClass)) {
                issues.push(`Missing layout class: ${expectedClass}`);
            }
        }
        
        // Check for stale transition classes
        if (gridContainer) {
            if (gridContainer.classList.contains('isotope-transitioning')) {
                issues.push('Stale isotope-transitioning class');
            }
            if (gridContainer.classList.contains('isotope-switching')) {
                issues.push('Stale isotope-switching class');
            }
        }
        
        // Check rendering state
        if (window.isLayoutRendering) {
            issues.push('Layout rendering stuck');
        }
        
        // Check for orphaned timeouts
        if (window.layoutRenderTimeout) {
            issues.push('Active layout render timeout');
        }
        if (window.peopleViewStabilityCheck) {
            issues.push('Active people view stability check');
        }
        
        // Check for emotions view remnants
        if (layoutCanvas) {
            const emotionElements = layoutCanvas.querySelectorAll('.emotion-cluster-label, .emotion-circle-label, .emotion-circle-background');
            if (emotionElements.length > 0 && window.activeLayout !== 'emotions') {
                issues.push(`${emotionElements.length} orphaned emotions elements found`);
            }
        }
        
        // Check body class consistency
        const bodyClassConsistent = 
            (window.activeLayout === 'timeline' && document.body.classList.contains('layout-timeline')) ||
            (window.activeLayout === 'people' && document.body.classList.contains('layout-people')) ||
            (window.activeLayout === 'emotions' && document.body.classList.contains('layout-emotions')) ||
            (window.activeLayout && !document.body.className);
            
        if (!bodyClassConsistent) {
            issues.push(`Body class mismatch: layout=${window.activeLayout}, body="${document.body.className}"`);
        }
        
        if (issues.length > 0) {
            console.warn('âš ï¸ Timeline state issues detected:', issues);
            return { valid: false, issues: issues };
        } else {
            console.log('âœ… Timeline state is consistent');
            return { valid: true, issues: [] };
        }
    };
    
    // Zoom variables
    let currentZoomLevel = 1.0; // Default zoom level (100%)
    window.hebrewMonths = ["×™× ×•××¨", "×¤×‘×¨×•××¨", "××¨×¥", "××¤×¨×™×œ", "×××™", "×™×•× ×™", "×™×•×œ×™", "××•×’×•×¡×˜", "×¡×¤×˜××‘×¨", "××•×§×˜×•×‘×¨", "× ×•×‘××‘×¨", "×“×¦××‘×¨"];
    window.peopleData = null; // Store loaded people data
    
    // Hebrew emotion translation mapping - used throughout the application
    window.EMOTION_HEBREW_MAP = {
        'anger': '×›×¢×¡',
        'confusion': '×‘×œ×‘×•×œ', 
        'contentment': '×©×‘×™×¢×•×ª ×¨×¦×•×Ÿ',
        'curiosity': '×¡×§×¨× ×•×ª',
        'excitement': '×”×ª×¨×’×©×•×ª',
        'fear': '×¤×—×“',
        'happiness': '×©××—×”',
        'interest': '×¢× ×™×™×Ÿ',
        'neutral': '× ×™×™×˜×¨×œ×™',
        'sadness': '×¢×¦×‘',
        'surprise': '×”×¤×ª×¢×”'
    };
    
    // --- UNIFIED MP4 PREVIEW COMPONENT SYSTEM ---
    const MP4_PREVIEW_CONFIG = {
    videoStyles: {
        objectFit: 'contain', // FIT: Show entire video without cropping
        objectPosition: 'center center',
        display: 'block',
        visibility: 'visible',
        opacity: '1',
        width: '100%',
        height: '100%',
        margin: '0',
        padding: '0',
        border: 'none',
        borderRadius: '0',
        position: 'absolute',
        top: '0',
        left: '0',
        transition: 'transform 0.3s ease',
        background: '#f7f9f3',
        filter: 'none',
        boxShadow: 'none',
        transform: 'scale(1)',
        maxWidth: '100%',
        maxHeight: '100%'
    },

    containerStyles: {
        position: 'absolute',
        boxSizing: 'border-box',
        padding: '0',
        margin: '0px', // Remove margins for maximum space utilization
        display: 'block',
        overflow: 'hidden',
        borderRadius: '0',
        cursor: 'pointer',
        transition: 'transform 0.3s ease, box-shadow 0.3s ease',
        border: 'none',
        background: '#f7f9f3',
        zIndex: '2',
        transformOrigin: 'center center',
        aspectRatio: '1 / 1',
        contain: 'layout style paint',
        backfaceVisibility: 'hidden',
        perspective: '1000px',
        isolation: 'isolate',
        width: '100%',
        height: '100%',
        transform: 'scale(1)',
        boxShadow: 'none'
    },

    hoverEffects: {
        container: {
            transform: 'scale(1.35)',
            zIndex: '10'
        },
        video: {
            filter: 'none',
            boxShadow: 'none'
        }
    }
};

    
    // Helper function to get EXACT Timeline square size
    function getTimelineSquareSize(conversations, container) {
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const totalConversations = conversations.length;
        
        // Use EXACT same calculation as Timeline view
        const padding = 10;
        const availableWidth = containerWidth - (2 * padding);
        const availableHeight = containerHeight - (2 * padding);
        const gapBetweenSquares = 1;
        const totalGapWidth = (totalConversations - 1) * gapBetweenSquares;
        const availableForSquares = availableWidth - totalGapWidth;
        const maxSquareSize = availableForSquares / totalConversations;
        const finalSquareSize = Math.min(maxSquareSize, availableHeight);
        
        return finalSquareSize;
    }
    
    // UNIFIED MP4 PREVIEW COMPONENT CREATOR
    function createMP4PreviewComponent(conv, index) {
        const itemCell = document.createElement('div');
        itemCell.className = 'conversation-grid-item-container';
        itemCell.id = `conv-item-${conv.folder}`;
        
        // Apply unified container styles
        Object.assign(itemCell.style, MP4_PREVIEW_CONFIG.containerStyles);
        
        // Add data attributes
        const properName = conv.metadata?.name || conv.displayName || conv.participants || conv.id;
        itemCell.setAttribute('data-conversation', properName);
        itemCell.style.order = index;
        
        // Add emotion data attribute for emotions view styling
        if (conv.metadata?.mainEmotions && conv.metadata.mainEmotions.length > 0) {
            itemCell.setAttribute('data-emotion', conv.metadata.mainEmotions[0]);
        } else {
            itemCell.setAttribute('data-emotion', 'neutral');
        }
        
        // Create video container wrapper for better centering
        const videoContainer = document.createElement('div');
        videoContainer.className = 'video-container-wrapper';
        videoContainer.style.cssText = `
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            background: transparent;
            border-radius: 0;
        `;
        
        // Create simple image element for PNG preview
        const video = document.createElement('img');
        video.id = `video-preview-${conv.folder}`;
        video.className = 'conversation-video-preview';
        video.src = `videos/${conv.folder}.png`;
        video.loading = 'lazy';
        video.alt = `Preview of ${conv.folder}`;
        
        // Simple styling
        video.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: center;
            background: linear-gradient(135deg, #f7f9f3 0%, #e8f4f8 100%);
        `;
        
        // Simple error handling - show placeholder if PNG not found
        video.addEventListener('error', function() {
            console.log(`ğŸ“· PNG not found for ${conv.folder}, showing placeholder`);
            video.style.display = 'none';
            
            const placeholder = document.createElement('div');
            placeholder.style.cssText = `
                width: 100%; height: 100%; 
                background: linear-gradient(135deg, #f7f9f3 0%, #e8f4f8 100%);
                display: flex; align-items: center; justify-content: center;
                color: #888; font-size: 12px; text-align: center;
                border: 1px solid rgba(229, 230, 226, 0.5);
            `;
            
            const conversationName = conv.metadata?.name || conv.displayName || conv.folder;
            const mainEmotion = conv.metadata?.mainEmotions?.[0] || 'neutral';
            const emotionIcon = getEmotionIcon(mainEmotion);
            
            placeholder.innerHTML = `
                <div>
                    <div style="font-size: 24px; margin-bottom: 8px;">${emotionIcon}</div>
                    <div style="font-size: 10px; margin-bottom: 4px;">${conversationName}</div>
                    <div style="font-size: 8px; color: #aaa;">No preview image</div>
                </div>
            `;
            
            videoContainer.appendChild(placeholder);
        });
        
        // Add conversation label (removed weird ×© letter)
        const label = document.createElement('div');
        label.className = 'conversation-label';
        label.textContent = ''; // Empty - no weird letters
        
        // Assemble component with proper nesting
        videoContainer.appendChild(video);
        itemCell.appendChild(videoContainer);
        itemCell.appendChild(label);
        itemCell.classList.add('video-preview-item');
        
        // Add unified event handlers only for video elements
        if (video.tagName === 'VIDEO') {
            addMP4PreviewEventHandlers(itemCell, conv, video);
        }
        
        // Add click and hover events to the itemCell itself
        addConversationItemEventHandlers(itemCell, conv);
        
        // Add to intersection observer for performance optimization
        if (conversationObserver) {
            conversationObserver.observe(itemCell);
        }
        
        return itemCell;
    }
    
    // Emotion to icon mapping for static previews
    function getEmotionIcon(emotion) {
        const emotionIcons = {
            'joy': 'ğŸ˜Š',
            'happiness': 'ğŸ˜„',
            'excitement': 'ğŸ‰',
            'love': 'â¤ï¸',
            'sadness': 'ğŸ˜¢',
            'fear': 'ğŸ˜¨',
            'anger': 'ğŸ˜ ',
            'disgust': 'ğŸ¤¢',
            'surprise': 'ğŸ˜²',
            'neutral': 'ğŸ˜',
            'curiosity': 'ğŸ¤”',
            'confusion': 'ğŸ˜•',
            'frustration': 'ğŸ˜¤',
            'anxiety': 'ğŸ˜°',
            'calm': 'ğŸ˜Œ',
            'tired': 'ğŸ˜´',
            'bored': 'ğŸ˜‘',
            'default': 'ğŸ’­'
        };
        return emotionIcons[emotion?.toLowerCase()] || emotionIcons['default'];
    }

    // Intersection Observer for performance optimization
    let conversationObserver;
    
    function initConversationIntersectionObserver() {
        if (conversationObserver) {
            conversationObserver.disconnect();
        }
        
        conversationObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                const itemCell = entry.target;
                if (entry.isIntersecting) {
                    // Enable hover events when in viewport
                    itemCell.setAttribute('data-viewport-visible', 'true');
                } else {
                    // Disable hover events and cleanup when out of viewport
                    itemCell.removeAttribute('data-viewport-visible');
                    
                    // Clean up any loaded iframes to save memory
                    const videoContainer = itemCell.querySelector('.video-container-wrapper');
                    if (videoContainer) {
                        const placeholder = videoContainer.querySelector('.lazy-iframe-placeholder');
                        const iframe = videoContainer.querySelector('iframe');
                        
                        if (placeholder && iframe && placeholder.getAttribute('data-iframe-loaded') === 'true') {
                            console.log(`ğŸ§¹ Cleaning up iframe for ${itemCell.id} (out of viewport)`);
                            iframe.remove();
                            placeholder.style.display = 'flex';
                            placeholder.removeAttribute('data-iframe-loaded');
                        }
                        
                        // Reset video preload for performance
                        const video = videoContainer.querySelector('.conversation-video-preview');
                        if (video && video.tagName === 'VIDEO') {
                            video.pause();
                            video.preload = 'none';
                        }
                    }
                }
            });
        }, {
            root: null,
            rootMargin: '50px', // Start loading slightly before coming into view
            threshold: 0.1
        });
    }

    // UNIFIED EVENT HANDLERS for Conversation Items
    function addConversationItemEventHandlers(itemCell, conv) {
        // Click handler with zoom effect
        itemCell.addEventListener('click', (e) => {
            console.log(`ğŸ¯ Clicked on conversation: ${conv.folder}`);
            e.preventDefault();
            itemCell.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            itemCell.style.transform = 'scale(1.3)';
            itemCell.style.zIndex = '100';
            
            setTimeout(() => {
                console.log(`ğŸš€ Opening visualization for: ${conv.folder}`);
                openVisualizationInModal(conv.folder);
                setTimeout(() => {
                    itemCell.style.transform = 'scale(1)';
                    itemCell.style.zIndex = '2';
                    setTimeout(() => {
                        itemCell.style.transition = 'all 1.8s cubic-bezier(0.165, 0.84, 0.44, 1)';
                    }, 400);
                }, 100);
            }, 200);
        });
        
        // Simplified hover handlers - let CSS handle visual effects
        itemCell.addEventListener('mouseenter', () => {
            // Only show hover panel, let CSS handle visual styling
            showHoverPanel(conv);
        });
        
        itemCell.addEventListener('mouseleave', () => {
            // Only hide hover panel, let CSS handle visual styling
            hideHoverPanel(true);
        });
    }
    
    // UNIFIED EVENT HANDLERS for MP4 Preview Components
    function addMP4PreviewEventHandlers(itemCell, conv, video) {
        // Only add video event handlers if this is actually a video element
        if (video.tagName !== 'VIDEO') {
            console.log(`ğŸ“· Skipping video handlers for ${conv.folder} - element is ${video.tagName}`);
            return;
        }
        
        // Video loading handlers
        video.addEventListener('loadstart', () => {
            console.log(`ğŸ¬ Loading video for ${conv.folder} - src: ${video.src}`);
        });
        
        video.addEventListener('canplay', () => {
            console.log(`âœ… Video ready for ${conv.folder} - duration: ${video.duration}`);
        });
        
        video.addEventListener('loadeddata', () => {
            console.log(`ğŸ’¾ Video data loaded for ${conv.folder} - ensuring first frame is visible`);
            // Ensure the first frame is visible
            video.currentTime = 0;
        });
        
        video.addEventListener('loadedmetadata', () => {
            console.log(`ğŸ“Š Video metadata loaded for ${conv.folder} - ${video.videoWidth}x${video.videoHeight}`);
            Object.assign(video.style, {
                display: 'block',
                visibility: 'visible',
                opacity: '1'
            });
            
            // ISOTOPE READY: Prepare video content for smooth transitions
            video.currentTime = 0.1; // Use 0.1 to ensure frame is loaded
            
            // Make video ready for isotope animations - show actual content
            const prepareVideoForTransitions = () => {
                // Brief play to load the frame, then pause for static display
                video.play().then(() => {
                    setTimeout(() => {
                        video.pause();
                        video.currentTime = 0.1; // Keep at first frame for isotope transitions
                        console.log(`ğŸ¬ Video ready for isotope transitions: ${conv.folder}`);
                        
                        // Mark video as ready for smooth view transitions
                        video.setAttribute('data-isotope-ready', 'true');
                    }, 80); // Quick frame load for responsiveness
                }).catch(e => {
                    // If autoplay is blocked, just seek to frame
                    video.currentTime = 0.1;
                    video.setAttribute('data-isotope-ready', 'true');
                    console.log(`ğŸ¯ Video frame set for isotope: ${conv.folder}`);
                });
            };
            
            // Prepare immediately if video is ready
            if (video.readyState >= 2) {
                prepareVideoForTransitions();
            } else {
                // Wait for video to be ready
                video.addEventListener('canplay', prepareVideoForTransitions, { once: true });
            }
        });
        
        video.addEventListener('error', () => {
            console.warn(`âŒ Video failed for ${conv.folder}`, video.error);
            const errorOverlay = document.createElement('div');
            errorOverlay.style.cssText = `
                position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(255, 0, 0, 0.1); border: 2px solid red;
                display: flex; align-items: center; justify-content: center;
                color: red; font-size: 12px; font-weight: bold; text-align: center; z-index: 100;
            `;
            errorOverlay.textContent = `Video Error\n${conv.folder}`;
            itemCell.style.position = 'relative';
            itemCell.appendChild(errorOverlay);
        });
        
        // Click handler with zoom effect
        itemCell.addEventListener('click', (e) => {
            console.log(`ğŸ¯ Clicked on conversation: ${conv.folder}`);
            e.preventDefault();
            itemCell.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            itemCell.style.transform = 'scale(1.3)';
            itemCell.style.zIndex = '100';
            
            setTimeout(() => {
                console.log(`ğŸš€ Opening visualization for: ${conv.folder}`);
                openVisualizationInModal(conv.folder);
                setTimeout(() => {
                    itemCell.style.transform = 'scale(1)';
                    itemCell.style.zIndex = '2';
                    setTimeout(() => {
                        itemCell.style.transition = 'all 1.8s cubic-bezier(0.165, 0.84, 0.44, 1)';
                    }, 400);
                }, 100);
            }, 200);
        });
        
        // Simplified hover handlers - let CSS handle visual effects
        itemCell.addEventListener('mouseenter', () => {
            // Only show hover panel, let CSS handle visual styling
            showHoverPanel(conv);
        });
        
        itemCell.addEventListener('mouseleave', () => {
            // Only hide hover panel, let CSS handle visual styling
            hideHoverPanel(true);
        });
    }
    
    // UNIFIED HOVER PANEL FUNCTIONS
    // Store emotions config for hover panel
    let hoverEmotionsConfig = null;
    
    // Load emotions config for hover panel
    async function loadHoverEmotionsConfig() {
        if (!hoverEmotionsConfig) {
            try {
                const response = await fetch('/config/emotions_config.json');
                hoverEmotionsConfig = await response.json();
            } catch (error) {
                console.error('Failed to load emotions config for hover:', error);
                hoverEmotionsConfig = {};
            }
        }
        return hoverEmotionsConfig;
    }
    
    // Get emotion data for hover panel
    function getEmotionDataForHover(emotion) {
        const defaultData = {
            hebrew: emotion,
            color: '#9B9B9B',
            emoji: 'ğŸ˜'
        };
        
        if (!hoverEmotionsConfig) {
            return defaultData;
        }
        
        // Since emotions config now uses Hebrew keys, try direct lookup first
        if (hoverEmotionsConfig[emotion]) {
            return {
                hebrew: emotion, // The key itself is Hebrew
                color: hoverEmotionsConfig[emotion].color || '#9B9B9B',
                emoji: hoverEmotionsConfig[emotion].emoji || 'ğŸ˜'
            };
        }
        
        // For backward compatibility, try English variations and lookup by English field
        const variations = [
            emotion,
            emotion.toLowerCase(),
            emotion.charAt(0).toUpperCase() + emotion.slice(1).toLowerCase(),
            emotion.charAt(0).toLowerCase() + emotion.slice(1)
        ];
        
        // Try variations as keys
        for (const variant of variations) {
            if (hoverEmotionsConfig[variant]) {
                return {
                    hebrew: hoverEmotionsConfig[variant].hebrew || emotion,
                    color: hoverEmotionsConfig[variant].color || '#9B9B9B',
                    emoji: hoverEmotionsConfig[variant].emoji || 'ğŸ˜'
                };
            }
        }
        
        // Search by English field if emotion is English
        for (const [hebrewKey, emotionData] of Object.entries(hoverEmotionsConfig)) {
            if (emotionData.english === emotion || emotionData.english === emotion.toLowerCase()) {
                return {
                    hebrew: hebrewKey, // Use the Hebrew key as display name
                    color: emotionData.color || '#9B9B9B',
                    emoji: emotionData.emoji || 'ğŸ˜'
                };
            }
        }
        
        return defaultData;
    }


    
    // Hover panel management with timeout to prevent race conditions
    let hoverPanelTimeout = null;
    let currentHoveredConversation = null;
    
    function showHoverPanel(conv) {
        const hoverPanel = document.getElementById('hover-info-panel');
        if (!hoverPanel) return;
        
        // Clear any pending hide timeout
        if (hoverPanelTimeout) {
            clearTimeout(hoverPanelTimeout);
            hoverPanelTimeout = null;
        }
        
        // Track currently hovered conversation
        currentHoveredConversation = conv.folder || conv.displayName;
        
        const metadata = conv.metadata || {};
        const emotions = conv.mainEmotions?.length ? conv.mainEmotions : conv.summaryFeelings.split(',').map(e => e.trim());
        
        const tagsHTML = emotions.map(e => {
            const emotionData = getEmotionDataForHover(e.trim());
            return `<div class="hover-info-tag">
                <span>${emotionData.hebrew}</span>
                <div class="emotion-color-square" style="background-color: ${emotionData.color}"></div>
            </div>`;
        }).join('');
        
        const date = new Date(conv.date);
        const monthNames = ['×™× ×•', '×¤×‘×¨', '××¨×¥', '××¤×¨', '×××™', '×™×•× ', '×™×•×œ', '××•×’', '×¡×¤×˜', '××•×§', '× ×•×‘', '×“×¦×'];
        const formattedDate = `${date.getDate()} ${monthNames[date.getMonth()]}`;
        
        const statusIcons = [];
        if (conv.isImportant) statusIcons.push('<span style="color: #f44336;" title="×©×™×—×” ×—×©×•×‘×”">â­</span>');
        if (conv.isPrivate) statusIcons.push('<span style="color: #9c27b0;" title="×©×™×—×” ×¤×¨×˜×™×ª">ğŸ”’</span>');
        if (conv.needsReview) statusIcons.push('<span style="color: #ff9800;" title="×“×•×¨×© ×‘×“×™×§×”">âš ï¸</span>');
        
        const additionalInfo = [];
        if (metadata.totalWords) additionalInfo.push(`${metadata.totalWords} ××™×œ×™×`);
        if (conv.mp3_count) additionalInfo.push(`${conv.mp3_count} ×§×˜×¢×™×`);
        if (metadata.emotionalIntensity) additionalInfo.push(`×¢×•×¦××”: ${metadata.emotionalIntensity}/10`);
        
        const additionalInfoHTML = additionalInfo.length > 0 
            ? `<div class="hover-info-additional">${additionalInfo.join(' | ')}</div>` 
            : '';
        
        const tagsHtml = metadata.tags?.length 
            ? `<div class="hover-info-metadata-tags">ğŸ·ï¸ ${metadata.tags.join(', ')}</div>`
            : '';
        
        hoverPanel.innerHTML = `
            <div class="hover-info-header">
                <div class="hover-info-title">
                    ${conv.displayName || '×©×™×—×” ×¢× × ×××œ'}
                    ${statusIcons.join(' ')}
                </div>
                <div class="hover-info-date">${formattedDate}</div>
            </div>
            <div class="hover-info-speakers">${conv.participants}</div>
            <div class="hover-info-divider"></div>
            <div class="hover-info-emotions-section">
                <div class="hover-info-section-title">×¨×’×©×•×ª:</div>
                <div class="hover-info-tags">${tagsHTML}</div>
            </div>
        `;
        
        // Show panel immediately
        hoverPanel.classList.add('visible');
    }
    
    function hideHoverPanel(immediate = false) {
        const hoverPanel = document.getElementById('hover-info-panel');
        if (!hoverPanel) return;
        
        // Clear current conversation tracking
        currentHoveredConversation = null;
        
        if (immediate) {
            // Clear any pending timeout and hide immediately
            if (hoverPanelTimeout) {
                clearTimeout(hoverPanelTimeout);
                hoverPanelTimeout = null;
            }
            hoverPanel.classList.remove('visible');
        } else {
            // Use a small delay to prevent flickering when moving between elements
            if (hoverPanelTimeout) {
                clearTimeout(hoverPanelTimeout);
            }
            hoverPanelTimeout = setTimeout(() => {
                hoverPanel.classList.remove('visible');
                hoverPanelTimeout = null;
            }, 50);
        }
    }
    
    // Initialize hover panel event listeners (called once on page load)
    function initializeHoverPanel() {
        const hoverPanel = document.getElementById('hover-info-panel');
        if (!hoverPanel) return;
        
        // No additional hover panel event listeners needed - 
        // panel should only be visible when hovering over conversations
    }
    
    // TOOLTIP CONTROL SYSTEM - Ensure tooltips only appear on conversation items
    function initializeTooltipControl() {
        console.log('ğŸ”§ Initializing tooltip control system...');
        
        // Disable tooltips on all non-conversation elements
        const disableTooltipsOnElements = [
            '.view-toggle-btn',
            '.nav-link', 
            '.hover-info-tag',
            '.hover-info-topic-tag',
            '.person-name-label',
            '.emotion-separator',
            '.zoom-btn',
            '.timeline-track',
            '.bottom-controls-container *',
            '.app-header *',
            '.about-page *'
        ];
        
        // Remove title attributes from non-conversation elements
        disableTooltipsOnElements.forEach(selector => {
            document.querySelectorAll(selector).forEach(element => {
                element.removeAttribute('title');
                // Prevent any hover info panels from showing
                element.addEventListener('mouseenter', (e) => {
                    e.stopPropagation();
                });
            });
        });
        
        // Ensure only conversation grid items can show hover panels
        document.addEventListener('mouseover', (e) => {
            const target = e.target;
            
            // Check if the target or its parent is a conversation item (exclude hover panel itself)
            const conversationItem = target.closest('.conversation-grid-item-container') || 
                                   target.closest('[id^="conv-item-"]');
            
            if (!conversationItem) {
                // If not hovering over a conversation, hide panel immediately
                hideHoverPanel(true);
            } else {
                // Check if we're hovering over a different conversation
                const conversationId = conversationItem.id || conversationItem.getAttribute('data-conversation');
                if (currentHoveredConversation && conversationId && 
                    currentHoveredConversation !== conversationId) {
                    // Switching to a different conversation, hide current panel immediately
                    hideHoverPanel(true);
                }
            }
        }, true);
        
        // Also hide hover panel when moving mouse outside of layout canvas
        const layoutCanvas = document.getElementById('layout-canvas');
        if (layoutCanvas) {
            layoutCanvas.addEventListener('mouseleave', () => {
                hideHoverPanel();
            });
        }
        
        // Add CSS to prevent tooltips on non-conversation elements
        const tooltipControlStyle = document.createElement('style');
        tooltipControlStyle.textContent = `
            /* Disable tooltips on all elements except conversation items */
            *:not(.conversation-grid-item-container):not([id^="conv-item-"]) {
                pointer-events: auto !important;
            }
            
            /* Prevent title tooltips on specific UI elements */
            .view-toggle-btn[title],
            .nav-link[title],
            .hover-info-tag[title],
            .hover-info-topic-tag[title],
            .person-name-label[title],
            .emotion-separator[title],
            .zoom-btn[title],
            .timeline-track[title],
            .bottom-controls-container *[title],
            .app-header *[title],
            .about-page *[title] {
                position: relative;
            }
            
            .view-toggle-btn[title]:hover::after,
            .nav-link[title]:hover::after,
            .hover-info-tag[title]:hover::after,
            .hover-info-topic-tag[title]:hover::after,
            .person-name-label[title]:hover::after,
            .emotion-separator[title]:hover::after,
            .zoom-btn[title]:hover::after,
            .timeline-track[title]:hover::after,
            .bottom-controls-container *[title]:hover::after,
            .app-header *[title]:hover::after,
            .about-page *[title]:hover::after {
                display: none !important;
                content: none !important;
            }
        `;
        document.head.appendChild(tooltipControlStyle);
        
        console.log('âœ… Tooltip control system initialized');
    }

    // GLOBAL MP4 PREVIEW CONFIGURATION UPDATER
    // Use this function to update styling across ALL views at once
    window.updateMP4PreviewConfig = function(newConfig) {
        // Merge new configuration with existing
        if (newConfig.videoStyles) {
            Object.assign(MP4_PREVIEW_CONFIG.videoStyles, newConfig.videoStyles);
        }
        if (newConfig.containerStyles) {
            Object.assign(MP4_PREVIEW_CONFIG.containerStyles, newConfig.containerStyles);
        }
        if (newConfig.hoverEffects) {
            Object.assign(MP4_PREVIEW_CONFIG.hoverEffects, newConfig.hoverEffects);
        }
        
        // Apply updated styles to all existing MP4 preview components
        const allVideoElements = document.querySelectorAll('.conversation-video-preview');
        const allContainerElements = document.querySelectorAll('.conversation-grid-item-container');
        
        allVideoElements.forEach(video => {
            Object.assign(video.style, MP4_PREVIEW_CONFIG.videoStyles);
        });
        
        allContainerElements.forEach(container => {
            Object.assign(container.style, MP4_PREVIEW_CONFIG.containerStyles);
        });
        
        console.log('âœ… MP4 Preview configuration updated globally across all views');
        return MP4_PREVIEW_CONFIG;
    };
    
    // Function to reset all conversation containers to default state
    window.resetAllConversationContainers = function() {
        const allContainerElements = document.querySelectorAll('.conversation-grid-item-container');
        const allVideoElements = document.querySelectorAll('.conversation-video-preview');
        const allVideoContainers = document.querySelectorAll('.video-container-wrapper');
        
        allContainerElements.forEach(container => {
            Object.assign(container.style, {
                transform: 'scale(1)',
                zIndex: '2',
                boxShadow: 'none',
                background: 'transparent',
                border: 'none',
                borderRadius: '0',
                margin: '0px', // Remove margins for maximum space utilization
                width: '100%',
                height: '100%',
                transition: 'transform 0.3s ease, box-shadow 0.3s ease'
            });
        });
        
        allVideoElements.forEach(video => {
            Object.assign(video.style, {
                filter: 'none',
                boxShadow: 'none',
                transform: 'scale(1)'
            });
        });
        
        allVideoContainers.forEach(container => {
            Object.assign(container.style, {
                transform: 'scale(1)'
            });
        });
        
        console.log('âœ… All conversation containers reset to default state');
    };
    
    // EXAMPLE: How to update MP4 preview styling globally
    // window.updateMP4PreviewConfig({
    //     videoStyles: {
    //         borderRadius: '8px',
    //         filter: 'contrast(1.2) brightness(1.1) saturate(1.2)'
    //     },
    //     containerStyles: {
    //         borderRadius: '8px',
    //         boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)'
    //     }
    // });
    
    // --- Layout Calculation Functions ---
    
    function getTimelineLayoutPositions(conversations, container, preservedXPositions = {}) {
        console.log(`ğŸ“… TIMELINE VIEW: getTimelineLayoutPositions called for ${conversations.length} conversations`);
        const positions = {};

        const layoutCanvas = document.getElementById('layout-canvas');
        const useContainer = layoutCanvas && window.activeLayout === 'timeline' ? layoutCanvas : container;
        const containerWidth = useContainer.offsetWidth || 1200; 
        const containerHeight = useContainer.clientHeight || 800;
        
        const totalConversations = conversations.length;
        
        // CENTERED TIMELINE: Center conversations horizontally and use FULL height
        const horizontalPadding = 4; // 4px padding as requested
        const verticalPadding = 4; // 4px padding as requested
        const availableWidth = containerWidth - (2 * horizontalPadding); // Account for padding
        const availableHeight = containerHeight - (2 * verticalPadding); // Use most of screen height
        
        // Sort conversations by date first
        const sortedConversations = conversations.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // Group conversations by date (YYYY-MM-DD format)
        const dateGroups = {};
        sortedConversations.forEach(conv => {
            const dateKey = conv.date ? conv.date.split('T')[0] : 'unknown';
            if (!dateGroups[dateKey]) {
                dateGroups[dateKey] = [];
            }
            dateGroups[dateKey].push(conv);
        });
        
        const dateKeys = Object.keys(dateGroups).sort(); // Ensure chronological order
        const totalDateGroups = dateKeys.length;
        
        console.log(`ğŸ“… CENTERED Timeline: ${totalConversations} conversations centered layout`);
        console.log(`ğŸ“… DATE GROUPS DEBUG: Found ${totalDateGroups} date groups:`, dateGroups);
        console.log(`ğŸ“… DATE KEYS DEBUG:`, dateKeys);
        dateKeys.forEach(date => {
            console.log(`  ğŸ“… ${date}: ${dateGroups[date].length} conversations ${dateGroups[date].length > 1 ? '(centered stack)' : '(single)'}`);
        });
        
        // DYNAMIC SIZING: Calculate item size first before using it - ORGANIZED
        const maxItemSize = 100; // Organized maximum for proper spacing
        const minItemSize = 60; // Compact minimum for visibility
        
        // Find the maximum conversations in any single date group
        const maxConversationsInGroup = Math.max(...dateKeys.map(key => dateGroups[key].length));
        
        // FULL HEIGHT DISTRIBUTION: Use entire screen height for conversations
        const bottomMargin = 10; // Minimal margin from bottom  
        const topMargin = 120; // More top margin to move conversations down from header
        const availableVerticalSpace = Math.max(400, containerHeight - bottomMargin - topMargin); // Use nearly full height
        const containerBaselineY = 50; // 50% of container height (since we'll use percentage positioning)
        
        // Calculate item size first - use fixed gap for initial calculation
        const baseStackGap = 15; // Fixed gap for initial calculation
        const totalGapsNeeded = Math.max(maxConversationsInGroup - 1, 0) * baseStackGap;
        const optimalVerticalSize = Math.min((availableVerticalSpace - totalGapsNeeded) / Math.max(maxConversationsInGroup, 1), maxItemSize);
        let itemSize = Math.max(minItemSize, Math.min(maxItemSize, optimalVerticalSize));
        
        // CONSISTENT GAPS: 2px gap everywhere for visual consistency
        const uniformGap = 2; // 2px gap everywhere for visual consistency
        const stackGap = 2; // 2px gap between conversations in the same column
        const columnMargin = 2; // 2px gap between columns
        
        // AUTOMATIC COLUMN SIZE CALCULATION: Maximize conversation size aggressively
        const totalGaps = (totalDateGroups - 1) * columnMargin; // Total space needed for gaps between columns
        const availableForColumns = availableWidth - totalGaps; // Space available for actual columns
        const optimalColumnWidth = Math.floor(availableForColumns / totalDateGroups); // Optimal column width
        const fixedColumnWidth = optimalColumnWidth; // Use full optimal size - no artificial minimum
        
        // AGGRESSIVE SIZING: Check if we can squeeze out more pixels by using remaining space
        const usedWidth = (totalDateGroups * fixedColumnWidth) + totalGaps;
        const remainingWidth = availableWidth - usedWidth;
        const extraPerColumn = Math.floor(remainingWidth / totalDateGroups);
        let finalColumnWidth = fixedColumnWidth + extraPerColumn; // Add any remaining pixels
        
        // FORCE MINIMUM SIZE: Ensure conversations are reasonably sized
        const minimumSize = 69; // Force minimum 70px for good visibility
        finalColumnWidth = Math.max(finalColumnWidth, minimumSize);
        
        const totalColumnsWidth = (totalDateGroups * finalColumnWidth) + totalGaps; // Total width needed for all columns including margins
        const centeredStartX = horizontalPadding + ((availableWidth - totalColumnsWidth) / 2); // Center within padded area
        const dateColumnWidth = Math.min(finalColumnWidth * 0.9, 150); // Organized column width for better spacing
        
        console.log(`ğŸ“ BASELINE LAYOUT: itemSize=${itemSize}px, maxStack=${maxConversationsInGroup}, tallestHeight=${Math.round(maxConversationsInGroup * itemSize + (maxConversationsInGroup - 1) * stackGap)}px, availableV=${availableVerticalSpace}px`);
        
        // Set CSS custom properties for container-relative baseline timeline styling  
        const visualConversationSize = finalColumnWidth; // Use exact column width to maintain proper margins
        document.documentElement.style.setProperty('--timeline-item-size', `${visualConversationSize}px`);
        document.documentElement.style.setProperty('--timeline-column-spacing', `${finalColumnWidth + columnMargin}px`);
        document.documentElement.style.setProperty('--visual-conversation-size', `${visualConversationSize}px`);
        document.documentElement.style.setProperty('--timeline-stack-gap', `${stackGap}px`);
        document.documentElement.style.setProperty('--timeline-baseline-y', `50%`);
        
        // INVISIBLE COLUMN TIMELINE POSITIONING: Column logic without visual elements
        let globalOrder = 0;
        const firstColumnCenterX = centeredStartX + (finalColumnWidth / 2); // Center of first column
        
        // NO visual elements - but keep structure for rendering metadata
        positions._dateLabels = [];
        positions._dateSeparators = [];
        positions._dateColumns = [];
        positions._timelineBaseline = null; // Remove baseline completely
        
        dateKeys.forEach((dateKey, groupIndex) => {
            const groupConversations = dateGroups[dateKey];
            console.log(`ğŸ“… PROCESSING DATE GROUP: ${dateKey} (index ${groupIndex}) with ${groupConversations.length} conversations`);
            
            // Create date label for this column (MM/DD format)
            const dateObj = new Date(dateKey);
            const month = String(dateObj.getMonth() + 1).padStart(2, '0');
            const day = String(dateObj.getDate()).padStart(2, '0');
            const formattedDate = `${month}/${day}`;
            console.log(`ğŸ“… FORMATTED DATE: "${formattedDate}" from "${dateKey}"`);
            
            // UPWARD BASELINE POSITIONING: Calculate baseline position for this date group
            const containerHeight = availableVerticalSpace; // Use actual container height
            const fixedItemHeight = finalColumnWidth; // Match the column width for square items
            const fixedVerticalGap = stackGap; // 2px gap between conversations in the same column
            
            // Calculate baseline position so the tallest column is centered on screen
            const tallestColumnHeight = maxConversationsInGroup * fixedItemHeight + (maxConversationsInGroup - 1) * fixedVerticalGap;
            const screenCenterY = containerHeight / 2; // Center of screen
            // Add offset to move timeline higher up on the canvas
            const centeringOffset = -60; // Move conversations up higher on the canvas
            const commonBaseline = screenCenterY + (tallestColumnHeight / 2) + centeringOffset; // Position baseline higher
            
            // CONSISTENT POSITIONING: Same calculations for every conversation
            groupConversations.forEach((conv, stackIndex) => {
                // RIGHT-TO-LEFT X POSITION: Use preserved X if available, otherwise calculate from right side
                const x = preservedXPositions[conv.folder] !== undefined ? 
                         preservedXPositions[conv.folder] : 
                         centeredStartX + ((totalDateGroups - 1 - groupIndex) * (finalColumnWidth + columnMargin));
                
                // All conversations stack upward TO the common baseline (highest stackIndex reaches baseline)
                const reverseStackIndex = groupConversations.length - 1 - stackIndex; // Reverse the stacking order
                const y = commonBaseline - (reverseStackIndex * (fixedItemHeight + fixedVerticalGap)); // Stack upward to baseline
                
                console.log(`  ğŸ“ Upward baseline: screenCenter=${Math.round(screenCenterY)}px, tallestColumn=${Math.round(tallestColumnHeight)}px, commonBaseline=${Math.round(commonBaseline)}px (offset=${centeringOffset}px), conversation ${stackIndex + 1} (reverse=${reverseStackIndex}) at Y=${Math.round(y)}px`)
                
                // No adjustments - use exact calculated positions for consistency
                const finalX = x;
                const finalY = y;
                
                positions[conv.folder] = {
                    left: finalX,
                    top: finalY,
                    width: fixedItemHeight,
                    height: fixedItemHeight,
                    gridOrder: globalOrder,
                    flexOrder: globalOrder,
                    dateGroup: dateKey,
                    formattedDate: formattedDate,
                    stackIndex: stackIndex,
                    groupIndex: groupIndex,
                    // Upward baseline positioning indicators
                    isTopOfStack: stackIndex === groupConversations.length - 1, // Last item reaches the baseline (top)
                    isOnBaseline: stackIndex === groupConversations.length - 1, // Last item sits on the common baseline
                    isBottomOfStack: stackIndex === 0, // First item is at the bottom
                    totalInStack: groupConversations.length,
                    isOnlyInStack: groupConversations.length === 1,
                    isConsistentLayout: true,
                    uniformSize: itemSize
                };
                
                console.log(`  ğŸ“ ${conv.folder} (${formattedDate}): Column ${groupIndex + 1} (RTL pos ${totalDateGroups - groupIndex}), X=${Math.round(finalX)}, Y=${Math.round(finalY)}, UPWARD stack ${stackIndex + 1}/${groupConversations.length} â†’ baseline (commonBaseline=${Math.round(commonBaseline)}px)`);
                globalOrder++;
            });
            
            // ADD DATE LABEL UNDER EACH COLUMN - Use actual conversation positions
            // Use ACTUAL conversation positions to find the real column center
            let actualConversationCenterX = 0;
            groupConversations.forEach((conv, stackIndex) => {
                const actualX = positions[conv.folder] ? positions[conv.folder].left : 0;
                const actualWidth = positions[conv.folder] ? positions[conv.folder].width : finalColumnWidth;
                const actualCenterX = actualX + (actualWidth / 2);
                actualConversationCenterX = actualCenterX; // All conversations in this column have same center
            });
            
            console.log(`ğŸ“… COLUMN POSITIONING: "${formattedDate}" group ${groupIndex}/${totalDateGroups}`);
            console.log(`   Using ACTUAL conversation center: ${Math.round(actualConversationCenterX)}`);
            
            // Calculate position below the bottom conversation in this column
            // Use ACTUAL conversation positions, not theoretical calculations
            let actualBottomMostY = 0;
            
            groupConversations.forEach((conv, stackIndex) => {
                // Get the actual Y position that was stored for this conversation
                const actualConversationTop = positions[conv.folder] ? positions[conv.folder].top : 0;
                const actualConversationBottom = actualConversationTop + fixedItemHeight;
                actualBottomMostY = Math.max(actualBottomMostY, actualConversationBottom);
            });
            
            const dateLabelY = actualBottomMostY + 30  ; // 30px below the actual bottom-most conversation
            
            console.log(`ğŸ“… Y POSITIONING: "${formattedDate}" - actualBottomMostY=${Math.round(actualBottomMostY)}, labelY=${Math.round(dateLabelY)}`);
            
            const dateLabelHeight = 50;
            
            console.log(`ğŸ“… CREATING DATE LABEL: "${formattedDate}" for group ${groupIndex}/${totalDateGroups} at actualCenterX=${Math.round(actualConversationCenterX)}, dateLabelY=${Math.round(dateLabelY)}, conversations=${groupConversations.length}`);
            
            // Position text DIRECTLY at ACTUAL conversation center using transform translateX(-50%)
            const labelWidth = 100; // Fixed width for consistent appearance
            const labelX = actualConversationCenterX; // Position at exact ACTUAL conversation center
            
            positions._dateLabels.push({
                name: formattedDate,
                fullDate: dateKey,
                x: labelX,
                y: dateLabelY,
                width: labelWidth,
                height: dateLabelHeight,
                groupIndex: groupIndex,
                conversationCount: groupConversations.length,
                rtlPosition: totalDateGroups - groupIndex
            });
            
            console.log(`ğŸ“… STORED DATE LABEL: "${formattedDate}" at final position (${Math.round(labelX)}, ${Math.round(dateLabelY)})`);
            console.log(`   ğŸ“ Label positioned at ACTUAL conversation center: ${Math.round(actualConversationCenterX)}`);
            console.log(`   ğŸ“ Label will use transform translateX(-50%) to center the text`);
            
            console.log(`  ğŸ“… Date label "${formattedDate}" at ACTUAL X=${Math.round(actualConversationCenterX)}, Y=${dateLabelY} (under column ${groupIndex + 1})`);
        });
        
        console.log(`ğŸ“… TIMELINE LAYOUT: Created ${positions._dateLabels.length} date labels for timeline view`);

        // RENDER DATE LABELS: Create date labels directly in layout function  
        console.log(`ğŸ“… DOM RENDERING: Starting date label rendering for ${positions._dateLabels?.length || 0} labels`);
        
        // Clear any existing timeline date labels first
        const existingLabels = document.querySelectorAll('.timeline-date-label-protected');
        const existingDebugElements = document.querySelectorAll('.debug-center-dot, .debug-column-center');
        existingLabels.forEach(label => label.remove());
        existingDebugElements.forEach(el => el.remove());
        console.log(`ğŸ“… CLEANUP: Removed ${existingLabels.length} existing timeline date labels and ${existingDebugElements.length} debug elements`);
        
        // ALWAYS render if we have date labels, regardless of other conditions
        if (positions._dateLabels && positions._dateLabels.length > 0) {
                         positions._dateLabels.forEach((labelData, index) => {
                                 const labelElement = document.createElement('div');
                labelElement.className = 'timeline-date-label-protected';
                labelElement.setAttribute('data-timeline-date', 'true');
                
                // Simple date text only - no conversation count
                labelElement.textContent = labelData.name;
               
                // Perfect center alignment using CSS transform
                labelElement.style.cssText = `
                    position: absolute;
                    left: ${labelData.x}px;
                    top: ${labelData.y}px;
                    transform: translate(-50%, -50%) !important;
                    z-index: 2;
                    font-family: var(--main-font-family);
                    font-size: 14px;
                    font-weight: normal;
                    color: #333;
                    text-align: center !important;
                    width: ${labelData.width}px;
                    height: ${labelData.height}px;
                    line-height: ${labelData.height}px !important;
                    background: none !important;
                    border: none !important;
                    box-shadow: none !important;
                    padding: 0 !important;
                    margin: 0 !important;
                    direction: ltr !important;
                    box-sizing: border-box !important;
                    white-space: nowrap !important;
                    overflow: visible !important;
                `;
                
                console.log(`ğŸ“… Created date label "${labelData.name}" at position (${labelData.x}, ${labelData.y}) with size ${labelData.width}x${labelData.height}`);
                
                                 // Add to layout-canvas to ensure proper positioning relative to conversations
                 const layoutCanvas = document.getElementById('layout-canvas');
                 if (layoutCanvas) {
                     layoutCanvas.appendChild(labelElement);
                 } else {
                     document.body.appendChild(labelElement);
                 }
             });
             console.log(`ğŸ“… âœ… Successfully rendered ${positions._dateLabels.length} date labels for timeline`);
             
             // DEBUG: Check if elements are being removed and when
             const checkLabels = () => {
                 const renderedLabels = document.querySelectorAll('.timeline-date-label-protected');
                 console.log(`ğŸ“… DOM CHECK: Found ${renderedLabels.length} protected date labels in BODY at ${Date.now()}`);
                 return renderedLabels.length;
             };
             
             // Check immediately
             console.log(`ğŸ“… IMMEDIATE CHECK: ${checkLabels()} labels found right after creation`);
             
             // Check after delays to see when they disappear
             setTimeout(() => checkLabels(), 50);
             setTimeout(() => checkLabels(), 100);
             setTimeout(() => checkLabels(), 200);
             setTimeout(() => checkLabels(), 500);
             setTimeout(() => checkLabels(), 1000);
         }

        // Common baseline timeline debug info
        console.log(`ğŸ“… UPWARD BASELINE Timeline (RIGHT-TO-LEFT): ${totalConversations} conversations across ${totalDateGroups} date columns, all stacking up to top baseline`);
        console.log(`ğŸ¯ Layout: ${containerWidth}x${containerHeight}px, base item: ${Math.round(itemSize)}px, uniform spacing`);
        console.log(`ğŸ“Š Upward baseline positioning - all columns stack upward to same top baseline, overall layout centered`);
        console.log(`ğŸ“… Date labels: ${dateKeys.length} labels positioned at bottom of columns`);
        console.log(`ğŸ“ MAXIMIZED LAYOUT: ${totalDateGroups} columns Ã— ${finalColumnWidth}px + ${uniformGap}px gaps = ${Math.round(totalColumnsWidth)}px, Available: ${availableWidth}px, Padding: ${horizontalPadding}px`);
        console.log(`ğŸ” AGGRESSIVE SIZING: Container=${containerWidth}px, Padding=${horizontalPadding*2}px, Available=${availableWidth}px, Gaps=${totalGaps}px, For Columns=${availableForColumns}px, Base=${fixedColumnWidth}px, Extra=${extraPerColumn}px, Final=${finalColumnWidth}px`);
        console.log(`ğŸ’ COLUMN SPACING: ${finalColumnWidth + columnMargin}px (${finalColumnWidth}px + ${columnMargin}px gap)`);
        console.log(`ğŸ¯ CONVERSATION SIZE: ${visualConversationSize}px Ã— ${visualConversationSize}px (maintains proper margins)`);
        console.log(`ğŸ“ UPWARD BASELINE: All conversations stack upward to same top baseline, positioned for centered overall layout`);
        
        // Store container baseline timeline metadata for rendering
        positions._meta = {
            layout: 'upward-baseline-timeline',
            dateGroups: dateGroups,
            dateKeys: dateKeys,
            totalDateGroups: totalDateGroups,
            maxConversationsInGroup: maxConversationsInGroup,
            baseItemSize: itemSize,
            maxItemSize: maxItemSize,
            minItemSize: minItemSize,
            fixedColumnWidth: finalColumnWidth,
            columnMargin: columnMargin,
            uniformGap: uniformGap,
            dateColumnWidth: dateColumnWidth,
            stackGap: stackGap,
            containerBaselineY: containerBaselineY,
            bottomMargin: bottomMargin,
            topMargin: topMargin,
            availableVerticalSpace: availableVerticalSpace,
            centeredStartX: centeredStartX,
            firstColumnCenterX: firstColumnCenterX,
            totalColumnsWidth: totalColumnsWidth,
            isCenteredTimeline: true,
            // Date labels are now included in _dateLabels array
            dateLabels: positions._dateLabels,
            timelineBaseline: null,
            dateSeparators: [],
            dateColumns: []
        };
        
        // BASELINE POSITIONING: Conversations are already positioned relative to baseline
        // No additional centering needed - conversations should stay on their baseline positions
        console.log(`âœ… Conversations positioned on baseline - no additional centering applied`);
        
        return positions;
    }

    function getPeopleViewPositions(conversations, container) {
        console.log(`ğŸ‘¥ PEOPLE VIEW: getPeopleViewPositions called for ${conversations.length} conversations`);
        const positions = {};
        
        // Use layout canvas dimensions for proper sizing
        const layoutCanvas = document.getElementById('layout-canvas');
        const useContainer = layoutCanvas ? layoutCanvas : container;
        const containerWidth = useContainer.offsetWidth || 1200;
        const containerHeight = useContainer.clientHeight || 800;
        
        console.log(`ğŸ“ People view using layout canvas dimensions: ${containerWidth}x${containerHeight}`);
        
        // If container dimensions are invalid, return empty positions
        if (containerWidth < 100 || containerHeight < 100) {
            console.warn(`âš ï¸ Invalid container dimensions: ${containerWidth}x${containerHeight} - skipping People view layout`);
            return {};
        }
        
        // BUILD PEOPLE GROUPS FROM CONVERSATION METADATA (not people_data.json)
        const peopleGroups = {};
        
        conversations.forEach(conv => {
            // Get participant from conversation metadata
            let participant = '×¢×“×Ÿ'; // Default fallback
            
            if (conv.metadata) {
                if (conv.metadata.customParticipantName) {
                    participant = conv.metadata.customParticipantName;
                } else if (conv.metadata.participants && conv.metadata.participants.length > 0) {
                    participant = conv.metadata.participants[0];
                } else if (conv.metadata.mainParticipant && conv.metadata.mainParticipant !== 'custom') {
                    participant = conv.metadata.mainParticipant;
                }
            }
            
            if (!peopleGroups[participant]) {
                peopleGroups[participant] = [];
            }
            peopleGroups[participant].push(conv.folder);
        });
        
        console.log('ğŸ‘¥ People groups from conversation metadata:', peopleGroups);
        
        // ğŸ” DEBUG: Detailed logging for ×˜×œ ××§×œ×¨ conversations
        console.log('ğŸ” DEBUGGING ×˜×œ ××§×œ×¨ conversations:');
        conversations.forEach(conv => {
            if (conv.metadata && (
                (conv.metadata.mainParticipant && conv.metadata.mainParticipant.includes('×˜×œ ××§×œ×¨')) ||
                (conv.metadata.customParticipantName && conv.metadata.customParticipantName.includes('×˜×œ ××§×œ×¨'))
            )) {
                console.log(`  ğŸ“ ${conv.folder}:`);
                console.log(`    - customParticipantName: "${conv.metadata.customParticipantName}"`);
                console.log(`    - mainParticipant: "${conv.metadata.mainParticipant}"`);
                console.log(`    - participants: [${conv.metadata.participants?.join(', ')}]`);
                console.log(`    - name: "${conv.metadata.name}"`);
            }
        });
        
        // Show which group each conversation ended up in
        Object.entries(peopleGroups).forEach(([person, convos]) => {
            if (person.includes('×˜×œ ××§×œ×¨')) {
                console.log(`ğŸ¯ "${person}" group has ${convos.length} conversations: [${convos.join(', ')}]`);
            }
        });
        
        if (Object.keys(peopleGroups).length === 0) {
            console.warn('âš ï¸ No people groups found - returning empty positions');
            return {};
        }
        
        // GRID LAYOUT SETTINGS - ORIGINAL SIZE TO FIT ALL ON SCREEN
        const conversationSize = 60; // Original size so all conversations fit without scrolling
        const conversationsPerRow = 15; // 11 conversations per row like in the image
        const conversationGap = 2; // 2px gap between conversations to match timeline view
        const rowHeight = 1; // Further reduced height for each person's row section - tighter spacing
        const personNameWidth = 120; // Width reserved for person names (increased to prevent overlapping)
        const horizontalPadding = 2;
        const verticalPadding = 1; // Further reduced vertical padding for tighter spacing
        
        console.log(`ğŸ‘¥ PEOPLE VIEW: Using original size=${conversationSize}px (compact to fit all on screen), ConversationsPerRow=${conversationsPerRow}, Gap=${conversationGap}px`);
        
        // Calculate layout dimensions
        const availableWidth = containerWidth - (2 * horizontalPadding) - personNameWidth - 2; // 2px gap between conversations and names
        const conversationRowWidth = (conversationsPerRow * conversationSize) + ((conversationsPerRow - 1) * conversationGap);
        
        // Calculate total height needed for all people to center them vertically
        const peopleNames = Object.keys(peopleGroups);
        let totalHeight = 0;
        peopleNames.forEach((personName) => {
            const personConversations = peopleGroups[personName];
            const totalRows = Math.ceil(personConversations.length / conversationsPerRow);
            totalHeight += (totalRows * (conversationSize + conversationGap)) + 0; // Include 0px gap between people
        });
        
        // Align with emotions view: start at top like emotions view (not centered)
        const availableHeight = containerHeight - 120; // Account for header/footer
        const topMargin = 60; // Same top margin as emotions view
        const startY = topMargin; // Start at same position as emotions view baseline
        let currentY = startY;
        
        // Calculate person name alignment position (right-aligned on screen)
        // Position person names on the right side of the screen, not based on logo
        const rightMargin = 20; // Margin from right edge
        const globalPersonNameStartX = containerWidth - rightMargin - personNameWidth; // Right-aligned position
        console.log(`ğŸ“ Positioning all person names at RIGHT side: ${globalPersonNameStartX}px (container: ${containerWidth}px, margin: ${rightMargin}px, width: ${personNameWidth}px)`);
        
        // Position conversations for each person
        peopleNames.forEach((personName, personIndex) => {
            const personConversations = peopleGroups[personName];
            const totalRows = Math.ceil(personConversations.length / conversationsPerRow);
            
            console.log(`ğŸ‘¤ ${personName}: ${personConversations.length} conversations in ${totalRows} row(s)`);
            
            // Position person name label first (aligned with emotion labels position)
            const personLabelY = currentY + ((totalRows * (conversationSize + conversationGap)) / 2) - (conversationSize / 2);
            
            // Use the global person name position calculated outside the loop
            const personNameX = globalPersonNameStartX;
            
            // Position conversations to the left of the person name
            personConversations.forEach((convFolder, convIndex) => {
                const conversation = conversations.find(c => c.folder === convFolder);
                if (!conversation) return;
                
                const rowIndex = Math.floor(convIndex / conversationsPerRow);
                const colIndex = convIndex % conversationsPerRow;
                
                // Calculate conversations starting to the LEFT of person name and flowing left
                // Small gap to prevent overlap with person name
                const conversationsEndX = personNameX - 10; // Just 10px gap to prevent overlap
                const convX = conversationsEndX - ((colIndex + 1) * (conversationSize + conversationGap));
                const convY = currentY + (rowIndex * (conversationSize + conversationGap));
                
                positions[convFolder] = {
                    left: convX,
                    top: convY,
                    width: conversationSize,
                    height: conversationSize,
                    personName: personName,
                    personIndex: personIndex,
                    rowIndex: rowIndex,
                    colIndex: colIndex
                };
                
                console.log(`  ğŸ“ ${convFolder}: row ${rowIndex + 1}, col ${colIndex + 1} at (${Math.round(convX)}, ${Math.round(convY)}) [personNameX: ${Math.round(personNameX)}, conversationsEndX: ${Math.round(conversationsEndX)}, gap: ${Math.round(personNameX - conversationsEndX)}px]`);
            });
            
            if (!positions._personNames) positions._personNames = [];
            positions._personNames.push({
                name: personName,
                x: personNameX,
                y: personLabelY,
                width: personNameWidth,
                height: conversationSize,
                personIndex: personIndex,
                conversationCount: personConversations.length,
                totalRows: totalRows
            });
            
            // Move to next person's section (add space between people)
            currentY += (totalRows * (conversationSize + conversationGap)) + 2; // 2px gap between people for consistent spacing
        });
        
                         // Set CSS custom property for people view only
        document.documentElement.style.setProperty('--people-conversation-size', `${conversationSize}px`);
        
        console.log(`âœ… People view layout complete: ${peopleNames.length} people, positioned ${Object.keys(positions).length - 1} conversations`);
        console.log(`ğŸ¯ PEOPLE VIEW FINAL SIZE: ${conversationSize}px Ã— ${conversationSize}px (original compact size to fit all on screen)`);
         
        return positions;
    }

    function getEmotionsViewPositions(conversations, container) {
        const positions = {};
        
        console.log(`ğŸ­ EMOTIONS VIEW: getEmotionsViewPositions called for ${conversations.length} conversations`);
        
        // Use layout canvas dimensions for proper sizing
        const layoutCanvas = document.getElementById('layout-canvas');
        const useContainer = layoutCanvas ? layoutCanvas : container;
        const containerWidth = useContainer.offsetWidth || 1200;
        const containerHeight = useContainer.clientHeight || 800;
        
        console.log(`ğŸ­ Emotions view using layout canvas dimensions: ${containerWidth}x${containerHeight}`);
        
        // If container dimensions are invalid, return empty positions
        if (containerWidth < 100 || containerHeight < 100) {
            console.warn(`âš ï¸ Invalid container dimensions: ${containerWidth}x${containerHeight} - skipping Emotions view layout`);
            return {};
        }
        
        // USE SAME SIZE AS TIMELINE VIEWS for consistency 
        const timelineSquareSize = 80; // Fixed size for emotions view (independent of people view)
        const emotionGap = 2; // 2px gap like timeline and people view
        const headerSpace = 62; // 60px header + 2px padding
        const footerSpace = 62; // 60px footer + 2px padding
        
        // ğŸ­ TETRIS-STYLE EMOTIONS VIEW: Group conversations by main emotion from metadata
        const emotionGroups = {};
        
        // Group conversations by their main emotions from conversation management metadata
        // Each conversation has only ONE main emotion (as set in management tab)
        conversations.forEach(conv => {
            const mainEmotions = conv.metadata?.mainEmotions || ['neutral'];
            
            // Take the first (and should be only) emotion since each conversation now has single emotion
            const selectedEmotion = mainEmotions[0];
            
            // Skip undefined/invalid emotions
            if (!selectedEmotion || selectedEmotion === 'undefined') {
                console.warn(`âš ï¸ Skipping conversation ${conv.folder} with invalid emotion: ${selectedEmotion}`);
                return;
            }
            
            if (!emotionGroups[selectedEmotion]) {
                emotionGroups[selectedEmotion] = [];
            }
            emotionGroups[selectedEmotion].push(conv.folder);
        });
        
        const emotionTypes = Object.keys(emotionGroups);
        const emotionCount = emotionTypes.length;
        
        console.log(`ğŸ­ Emotion Groups (Tetris style): ${emotionCount} different emotions found`, emotionGroups);
        
        // Define emotion cluster positions spread across viewport for visibility
        // Added more positions to handle up to 15 different emotions without overlap
        // VERTICAL STACKING PYRAMID: Group emotions by conversation count and stack vertically
        // First, sort emotions by conversation count (most conversations = bottom of pyramid)
        const emotionWithCounts = emotionTypes.map(emotion => ({
            emotion: emotion,
            count: emotionGroups[emotion].length
        })).sort((a, b) => a.count - b.count); // Sort ascending (fewest conversations first = top of pyramid)
        
        console.log(`ğŸ”º PYRAMID SORTING: Sorted ${emotionWithCounts.length} emotions by conversation count:`, 
                   emotionWithCounts.map(e => `${e.emotion}: ${e.count}`));
        
        // GROUP BY CONVERSATION COUNT: Stack emotions with same count vertically
        const emotionCountGroups = {};
        emotionWithCounts.forEach(emotionData => {
            const count = emotionData.count;
            if (!emotionCountGroups[count]) {
                emotionCountGroups[count] = [];
            }
            emotionCountGroups[count].push(emotionData);
        });
        
        const conversationCounts = Object.keys(emotionCountGroups).map(Number).sort((a, b) => a - b); // Sort counts ascending
        console.log(`ğŸ”º GROUPED BY COUNT: ${conversationCounts.length} different conversation counts:`, conversationCounts);
        
        // Generate cluster configs with baseline alignment like timeline
        const clusterConfigs = [];
        
        // BASELINE CALCULATION: Position emotions at the top for immediate visibility (no scrolling needed)
        const topMargin = 30; // Reduced header space for better visibility
        const bottomMargin = 60; // Reduced bottom space
        const availableVerticalSpace = Math.max(400, containerHeight - topMargin - bottomMargin);
        
        // Position emotions at the very top (just below header) for immediate visibility
        const emotionsBaselinePercent = 0; // Start emotions immediately at top (0% down from top)
        const baselineY = topMargin; // Start right after header, no additional offset
        
        let currentY = baselineY; // Start from the timeline baseline
        const lineHeight = timelineSquareSize + emotionGap; // Dynamic size + 2px gap between emotion rows
        const centerLeft = 50; // Center everything horizontally
        
        console.log(`ğŸ“ EMOTION BASELINE: Positioned at ${baselineY}px (${emotionsBaselinePercent}% of ${availableVerticalSpace}px available space)`);
        console.log(`ğŸ“ Available space: ${availableVerticalSpace}px, Top margin: ${topMargin}px, Container: ${containerWidth}x${containerHeight}px`);
        
        conversationCounts.forEach(count => {
            const emotionsWithThisCount = emotionCountGroups[count];
            console.log(`ğŸ”º Processing ${emotionsWithThisCount.length} emotions with ${count} conversations each`);
            
            emotionsWithThisCount.forEach((emotionData, stackIndex) => {
                clusterConfigs.push({
                    position: { 
                        top: currentY + (stackIndex * lineHeight), // Stack vertically with pixel positioning
                        left: centerLeft // Center all emotions at 50%
                    },
                    gridType: 'pyramid',
                    emotionData: emotionData,
                    conversationCount: count,
                    stackIndex: stackIndex
                });
                console.log(`  ğŸ“ ${emotionData.emotion} (${count} conversations) stacked at position ${stackIndex} - ${currentY + (stackIndex * lineHeight)}px, 50%`);
            });
            
            // Move to next group with 2px spacing
            currentY += (emotionsWithThisCount.length * lineHeight) + emotionGap; // 2px gap between groups
        });
        
        console.log(`ğŸ”º VERTICAL PYRAMID COMPLETE: Created ${clusterConfigs.length} stacked positions`);
        
        // Find neutral emotion position for label alignment
        let neutralLabelX = null;
        
        // ALIGN ALL LABELS TO THE RIGHT SIDE OF SCREEN
        const labelWidth = 150;
        const rightMargin = 20; // 20px margin from right edge
        neutralLabelX = containerWidth - labelWidth - rightMargin;
        console.log(`ğŸ¯ RIGHT ALIGNMENT: All emotion labels positioned at ${neutralLabelX}px (right-aligned with ${rightMargin}px margin)`)
        
        // PYRAMID POSITIONING: Process emotions in sorted order (fewest to most conversations)
        emotionWithCounts.forEach((emotionData, index) => {
            const emotion = emotionData.emotion;
            const conversations = emotionGroups[emotion];
            const conversationCount = conversations.length;
            
            if (conversationCount === 0 || index >= clusterConfigs.length) return;
            
            // Get the specific cluster configuration for this emotion's stacked pyramid position
            const config = clusterConfigs[index];
            console.log(`ğŸ”º Stacked emotion "${emotion}" (${conversationCount} conversations) at ${config.position.top}%, centered at ${config.position.left}%`);
            
            // Calculate cluster position in pixels (all use left positioning now)
            const clusterX = containerWidth * config.position.left / 100;
            const clusterY = config.position.top; // Use pixel positioning directly
            console.log(`ğŸ“ Emotion "${emotion}" calculated position: (${clusterX.toFixed(2)}, ${clusterY.toFixed(2)}) from container ${containerWidth}x${containerHeight}`);
            
            // PYRAMID HORIZONTAL LINES: Each emotion is displayed as a single horizontal line
            const cols = conversationCount; // ALL conversations in a single horizontal line
            const rows = 1; // Always single row (horizontal line)
            const squareSize = 80; // Fixed size for emotions people view (independent of people layout)
            const minGap = 2; // 4px gap between conversations for emotions view
            const spacing = squareSize + minGap; // Total spacing (dynamic size + 2px gap)
            const titleHeight = 20; // Compact space for emotion title
            const titleGap = 5; // Small gap between line and title
            const gridHeight = rows * spacing; // Calculate total line height (always single row height)
             
            console.log(`ğŸ¯ Emotion "${emotion}" positioning: baseline=${currentY}px, conversations=${conversationCount}, line width will be ${conversationCount * spacing}px`);
             
            console.log(`ğŸ”º Emotion "${emotion}": Creating horizontal line with ${cols} conversations (${conversationCount} total)`);
             
            switch(config.gridType) {
                case 'pyramid':
                default:
                    // Pyramid layout: Each emotion is a horizontal line of conversation squares
                    // cols = conversationCount, rows = 1 (always horizontal line)
                    break;
            }
            
            // Position conversations in Tetris-like grid
            // Position conversation line on the left side, leaving space for right-aligned labels
            // Leave enough space for emotion labels on the right side
            const labelGap = 30; // Gap between conversations and labels
            const labelSpace = labelWidth + 20; // Space needed for labels (width + margin)
            const maxLineWidth = containerWidth - labelSpace - labelGap; // Leave space for labels on right
            const actualSpacing = Math.max(squareSize + minGap, Math.min(spacing, maxLineWidth / conversationCount)); // Use 4px gap as requested
            const totalLineWidth = conversationCount * actualSpacing;
            const startX = Math.max(50, (maxLineWidth - totalLineWidth) / 2); // Position conversations on left side, centered in available space
             
            console.log(`ğŸ”º Line width: ${conversationCount} conversations Ã— ${actualSpacing.toFixed(1)}px = ${totalLineWidth.toFixed(1)}px (max: ${maxLineWidth.toFixed(1)}px)`);
            console.log(`   Spacing details: squareSize=${squareSize}px, minGap=${minGap}px, actualSpacing=${actualSpacing.toFixed(1)}px`);
            
            conversations.forEach((convFolder, index) => {
                const col = index; // All conversations in a single row (horizontal line)
                const row = 0; // Always row 0 (single horizontal line)
                
                const x = startX + (col * actualSpacing); // Horizontal positioning for the line
                const y = clusterY; // Single row at the pyramid position
                
                positions[convFolder] = {
                    left: x,
                    top: y,
                    width: timelineSquareSize,
                    height: timelineSquareSize,
                    emotionGroup: emotion,
                    gridConfig: config,
                    isEmotionCluster: true,
                    clusterPosition: { x: clusterX, y: clusterY },
                    gridPosition: { row, col },
                    isHorizontalLine: true,
                    lineLength: conversationCount
                };
                
                console.log(`  ğŸ“¦ Conversation ${index + 1}/${conversationCount} at (${Math.round(x)}, ${Math.round(y)})`);
            });
             
            // Store emotion label for rendering - position near conversations in staggered "stairs" style
            const hebrewEmotion = window.EMOTION_HEBREW_MAP[emotion] || emotion;
             
            // Calculate staggered position for "stairs" effect
            const conversationCenterY = clusterY + (timelineSquareSize / 2); // Vertical center of the conversation line
            
            // Position label near the conversations with consistent spacing (no stairs effect)
            const staggerOffset = 0; // Remove stairs effect - consistent spacing for all labels
            const labelLeftX = startX + totalLineWidth + 15; // Position after conversations with 15px gap (no stagger)
             
            positions[`emotion_label_${emotion}`] = {
                left: labelLeftX, // Position near conversations with consistent spacing
                top: conversationCenterY - (titleHeight / 2), // Center vertically with conversations
                width: labelWidth, // Use consistent label width
                height: titleHeight,
                isEmotionLabel: true,
                emotion: emotion,
                hebrewEmotion: hebrewEmotion,
                count: conversationCount,
                clusterConfig: config,
                isHorizontalLine: true,
                isRightAligned: true // New flag for right alignment
            };
             
            console.log(`ğŸ·ï¸ Label for "${emotion}" positioned with consistent spacing at (${Math.round(labelLeftX)}, ${Math.round(conversationCenterY - (titleHeight / 2))}px)`);
        });
        
        console.log(`ğŸ­ Baseline-Aligned Emotions Layout: ${emotionCount} emotion clusters created with ${Object.keys(positions).length - emotionCount} conversations`);
        console.log(`ğŸ“ BASELINE SUMMARY: All emotions positioned higher at ${baselineY}px (${emotionsBaselinePercent}% down from top)`);
        
        // Store metadata for rendering and transitions
        positions._meta = { 
            layout: 'tetris-emotions',
            emotionGroups,
            clusterConfigs,
            itemSize: timelineSquareSize,
            containerWidth,
            containerHeight,
            totalEmotions: emotionCount,
            totalConversations: conversations.length,
            // BASELINE METADATA: Emotions positioned higher for better visibility
            emotionsBaselinePercent: emotionsBaselinePercent,
            baselineY: baselineY,
            bottomMargin: bottomMargin,
            topMargin: topMargin,
            availableVerticalSpace: availableVerticalSpace,
            isEmotionsHighAligned: true
        };
        
        return positions;
    }

    // --- Core Rendering and State Management ---
    let layoutRenderTimeout;
    let isLayoutRendering = false;
    
            window.renderNewLayout = function(isInitial = false) {
        console.log(`ğŸ“… DEBUG: renderNewLayout called, activeLayout = ${window.activeLayout}, isInitial = ${isInitial}`);
        
        // Ensure we have a default layout if none is set
        if (!window.activeLayout) {
            console.log(`ğŸ”„ Setting default timeline layout`);
            window.activeLayout = 'timeline';
        }
        
        // Prevent multiple simultaneous renders
        if (window.isLayoutRendering) {
            console.log('âš ï¸ Layout render already in progress, skipping...');
            return;
        }
        
        // Improved debouncing with shorter timeout for better responsiveness
        clearTimeout(window.layoutRenderTimeout);
        window.layoutRenderTimeout = setTimeout(() => {
            window.isLayoutRendering = true;
            
            const gridContainer = document.getElementById('timeline-axes-container');
            const layoutCanvas = document.getElementById('layout-canvas');
            if (!gridContainer || !layoutCanvas) {
                isLayoutRendering = false;
                return;
            }
            
            // STATIC BACKGROUND GRID: Ensure it exists before any layout operations
            ensureStaticBackgroundGrid();
            
            const conversations = window.originalConversationData || [];
            
            // If no conversations data is available, don't proceed with layout
            if (!conversations || conversations.length === 0) {
                console.log('âŒ No conversations data available for layout rendering');
                window.isLayoutRendering = false;
                return;
            }
            
            // ISOTOPE ANIMATION: Capture current positions before layout change
            const currentPositions = {};
            conversations.forEach((conv) => {
                const itemCell = document.getElementById(`conv-item-${conv.folder}`);
                if (itemCell) {
                    const rect = itemCell.getBoundingClientRect();
                    const canvasRect = layoutCanvas.getBoundingClientRect();
                    currentPositions[conv.folder] = {
                        left: rect.left - canvasRect.left,
                        top: rect.top - canvasRect.top,
                        width: rect.width,
                        height: rect.height
                    };
                    console.log(`ğŸ“¸ Captured ${conv.folder} at (${Math.round(currentPositions[conv.folder].left)}, ${Math.round(currentPositions[conv.folder].top)})`);
                }
            });
            
            // CRITICAL: Clear all previous CSS classes and styles first
            layoutCanvas.className = '';
            gridContainer.className = '';
            
            // Force reflow to clear previous styles
            layoutCanvas.offsetHeight;
            gridContainer.offsetHeight;
            
            // Apply new CSS classes AFTER clearing previous ones
            gridContainer.className = 'layout-' + window.activeLayout;
            
            // Force immediate reflow to ensure CSS classes are applied
            gridContainer.offsetHeight;
            
            console.log(`ğŸ§¹ Cleared previous CSS, applied new layout class: ${gridContainer.className}`);
            
            // Add isotope-switching class for transition effects
            if (!isInitial && Object.keys(currentPositions).length > 0) {
                gridContainer.classList.add('isotope-switching');
                console.log('ğŸ¬ Added isotope-switching class for smooth transitions');
                
                // Remove isotope-switching class after animations complete
                setTimeout(() => {
                    gridContainer.classList.remove('isotope-switching');
                    console.log('âœ… Removed isotope-switching class - transitions complete');
                }, 800); // After all animations should be done
            }
            
            // TIMELINE VIEW: Use cached positions if available, otherwise calculate fresh
            if (window.activeLayout === 'timeline') {
                console.log('ğŸ”„ TIMELINE VIEW: Checking for cached positions');
                console.log(`ğŸ“… DEBUG: In timeline branch, conversations.length = ${conversations.length}`);
                
                // Check if we have valid cached timeline positions
                const hasCachedTimeline = layoutPositions.timeline && 
                                        Object.keys(layoutPositions.timeline).length > 0 &&
                                        conversations.every(conv => layoutPositions.timeline[conv.folder]);
                
                if (hasCachedTimeline) {
                    console.log('âœ… USING CACHED TIMELINE POSITIONS - No recalculation needed');
                    targetPositions = layoutPositions.timeline;
                    
                    // Apply cached positions immediately
                    conversations.forEach((conv) => {
                        const cachedPos = layoutPositions.timeline[conv.folder];
                        if (cachedPos) {
                            const itemCell = document.getElementById(`conv-item-${conv.folder}`);
                            if (itemCell) {
                                itemCell.style.transition = 'none';
                                itemCell.style.position = 'absolute';
                                itemCell.style.left = `${cachedPos.left}px`;
                                itemCell.style.top = `${cachedPos.top}px`;
                                itemCell.style.width = `${cachedPos.width}px`;
                                itemCell.style.height = `${cachedPos.height}px`;
                                itemCell.offsetHeight; // Force reflow
                                itemCell.style.transition = ''; // Re-enable transitions
                                console.log(`ğŸ“ Applied cached position for ${conv.folder}: (${cachedPos.left}, ${cachedPos.top})`);
                            }
                        }
                    });
                    
                    // CRITICAL: Always recreate date labels to ensure proper positioning
                    console.log('ğŸ“… DEBUG: Using cached positions - recreating date labels for proper alignment');
                    const existingLabels = document.querySelectorAll('.timeline-date-label-protected');
                    
                    // Always remove existing labels and recreate them
                    const existingDebugElements = document.querySelectorAll('.debug-center-dot, .debug-column-center');
                    existingLabels.forEach(label => label.remove());
                    existingDebugElements.forEach(el => el.remove());
                    console.log(`ğŸ“… FORCE CLEANUP: Removed ${existingLabels.length} existing timeline date labels and ${existingDebugElements.length} debug elements for fresh positioning`);
                    
                    if (targetPositions._dateLabels) {
                        console.log('ğŸ“… DEBUG: No existing labels found, recreating from cached data');
                        console.log(`ğŸ“… DOM RENDERING: Starting date label rendering for ${targetPositions._dateLabels.length} cached labels`);
                        
                        // Clear any existing timeline date labels first
                        const oldLabels = document.querySelectorAll('.timeline-date-label-protected');
                        oldLabels.forEach(label => label.remove());
                        console.log(`ğŸ“… CLEANUP: Removed ${oldLabels.length} existing timeline date labels`);
                        
                        // Recreate labels from cached data
                        targetPositions._dateLabels.forEach((labelData, index) => {
                            const labelElement = document.createElement('div');
                            labelElement.className = 'timeline-date-label-protected';
                            labelElement.setAttribute('data-timeline-date', 'true');
                            
                            // Simple date text only - no conversation count
                            labelElement.textContent = labelData.name;
                           
                            // Perfect center alignment using CSS transform
                            labelElement.style.cssText = `
                                position: absolute;
                                left: ${labelData.x}px;
                                top: ${labelData.y}px;
                                transform: translate(-50%, -50%) !important;
                                z-index: 2;
                                font-family: var(--main-font-family);
                                font-size: 14px;
                                font-weight: normal;
                                color: #333;
                                text-align: center !important;
                                width: ${labelData.width}px;
                                height: ${labelData.height}px;
                                line-height: ${labelData.height}px !important;
                                background: none !important;
                                border: none !important;
                                box-shadow: none !important;
                                padding: 0 !important;
                                margin: 0 !important;
                                direction: ltr !important;
                                box-sizing: border-box !important;
                                white-space: nowrap !important;
                                overflow: visible !important;
                            `;
                            
                            console.log(`ğŸ“… Created cached date label "${labelData.name}" at position (${labelData.x}, ${labelData.y})`);
                            
                            // Add to layout-canvas to ensure proper positioning relative to conversations
                            const layoutCanvas = document.getElementById('layout-canvas');
                            if (layoutCanvas) {
                                layoutCanvas.appendChild(labelElement);
                            } else {
                                document.body.appendChild(labelElement);
                            }
                        });
                        console.log(`ğŸ“… âœ… Successfully rendered ${targetPositions._dateLabels.length} date labels from cache`);
                    } else {
                        console.log(`ğŸ“… WARNING: No _dateLabels found in cached positions`);
                    }
                } else {
                    console.log('ğŸ†• CALCULATING FRESH TIMELINE POSITIONS - First time or cache invalid');
                    console.log(`ğŸ“… DEBUG: About to call getTimelineLayoutPositions with ${conversations.length} conversations`);
                    layoutPositions.timeline = getTimelineLayoutPositions(conversations, gridContainer);
                    targetPositions = layoutPositions.timeline;
                    console.log('âœ… Fresh timeline positions calculated and cached');
                    console.log(`ğŸ“… DEBUG: Timeline positions result:`, layoutPositions.timeline);
                }
            } else {
                // For non-timeline views, always calculate fresh
                console.log(`ğŸ”„ Calculating fresh positions for ${window.activeLayout} view`);
                // Calculate initial positions for all views (only once for timeline)
                if (!layoutPositions.timeline || Object.keys(layoutPositions.timeline).length === 0) {
                    console.log('ğŸ†• INITIAL: Calculating timeline positions for first time');
                    layoutPositions.timeline = getTimelineLayoutPositions(conversations, gridContainer);
                }
                
                // Calculate positions specific to the active layout
                if (window.activeLayout === 'people') {
                    console.log('ğŸ‘¥ CALCULATING SIMPLIFIED PEOPLE VIEW positions');
                    layoutPositions.people = getPeopleViewPositions(conversations, gridContainer);
                } else if (window.activeLayout === 'emotions') {
                    console.log('ğŸ­ FORCE REFRESH: Recalculating emotions view positions');
                    layoutPositions.emotions = getEmotionsViewPositions(conversations, gridContainer);
                }
                targetPositions = layoutPositions[window.activeLayout];
            }
            
            // CRITICAL: Ensure people view positioning is used when people layout is active
            if (window.activeLayout === 'people') {
                console.log(`ğŸ‘¥ ENFORCING PEOPLE VIEW POSITIONS`);
                console.log(`ğŸ“Š People view positions available:`, Object.keys(layoutPositions.people || {}).length);
                
                // Force people view positions even if they might be empty
                if (!targetPositions || Object.keys(targetPositions).length === 0) {
                    console.warn(`âš ï¸ People view positions empty, recalculating...`);
                    layoutPositions.people = getPeopleViewPositions(conversations, gridContainer);
                    targetPositions = layoutPositions.people;
                }
                
                // Verify people view positions are actually being used
                if (targetPositions && Object.keys(targetPositions).length > 0) {
                    console.log(`âœ… Using people view positions: ${Object.keys(targetPositions).length} conversations`);
                } else {
                    console.error(`âŒ People view positions failed, falling back to timeline`);
                    targetPositions = layoutPositions.timeline;
                }
            }
            
            // Set layout canvas class based on active layout
            if (window.activeLayout === 'emotions') {
                layoutCanvas.className = ''; // Clear canvas class to prevent double grid effects
                
                // COMPREHENSIVE BODY CLASS MANAGEMENT: Clear all layout classes first
                document.body.classList.remove('layout-timeline', 'layout-people', 'layout-emotions');
                document.body.className = 'layout-emotions';
                console.log('ğŸ—ï¸ Set body class to layout-emotions');
                
                // FORCE CLEAR EMOTIONS CACHE: Clear any cached emotions positions to force fresh calculation
                if (window.layoutPositions && window.layoutPositions.emotions) {
                    console.log('ğŸ—‘ï¸ Clearing cached emotions positions to force refresh');
                    window.layoutPositions.emotions = {};
                }
                
                // SET EMOTIONS VIEW SQUARE SIZE - MATCH LAYOUT CALCULATION
                const emotionsSquareSize = 80; // Match timelineSquareSize from layout calculation (80px)
                document.documentElement.style.setProperty('--timeline-square-size', `${emotionsSquareSize}px`);
                document.documentElement.style.setProperty('--timeline-item-size', `${emotionsSquareSize}px`);
                document.documentElement.style.setProperty('--people-square-size', `${emotionsSquareSize}px`);
                document.documentElement.style.setProperty('--visual-conversation-size', `${emotionsSquareSize}px`);
                console.log(`ğŸ“ Set emotions view square size to ${emotionsSquareSize}px (matches layout calculation)`);
            } else if (window.activeLayout === 'people') {
                // CRITICAL: Set both canvas class AND body class for people view
                layoutCanvas.className = 'people-active';
                
                // COMPREHENSIVE BODY CLASS MANAGEMENT: Clear all layout classes first
                document.body.classList.remove('layout-timeline', 'layout-people', 'layout-emotions');
                document.body.className = 'layout-people';
                console.log('ğŸ—ï¸ Set body class to layout-people');
                
                // ULTRA-AGGRESSIVE canvas height fixing for people view
                layoutCanvas.style.removeProperty('height');
                layoutCanvas.style.removeProperty('max-height');  
                layoutCanvas.style.removeProperty('min-height');
                layoutCanvas.style.setProperty('height', 'calc(100vh - 120px)', 'important');
                layoutCanvas.style.setProperty('min-height', '800px', 'important');
                layoutCanvas.style.setProperty('max-height', 'none', 'important');
                layoutCanvas.style.setProperty('overflow', 'hidden', 'important');
                
                // Force multiple reflows to ensure height sticks
                layoutCanvas.offsetHeight;
                layoutCanvas.offsetHeight;
                
                console.log(`ğŸ”§ PEOPLE VIEW: Ultra-aggressive canvas height fix applied`);
                console.log(`ğŸ”§ Canvas dimensions: ${layoutCanvas.offsetWidth}x${layoutCanvas.offsetHeight}`);
                
                // SET PEOPLE VIEW SQUARE SIZE - ORIGINAL SIZE TO FIT ALL ON SCREEN
                const peopleSquareSize = 60; // Original size so all conversations fit without scrolling
                document.documentElement.style.setProperty('--people-square-size', `${peopleSquareSize}px`);
                console.log(`ğŸ“ Set people view square size to ${peopleSquareSize}px (original compact size)`);
                
                            // CRITICAL FIX: For People view, recalculate positions AFTER CSS classes are applied
            // This ensures the container has the correct dimensions from the CSS
            setTimeout(async () => {
                if (window.activeLayout === 'people') {
                    console.log('ğŸ”„ Recalculating People view positions after CSS application');
                    
                    // Force another reflow
                    gridContainer.offsetHeight;
                    
                    // SET PEOPLE VIEW SQUARE SIZE - ORIGINAL SIZE TO FIT ALL ON SCREEN
                    const peopleSquareSize = 60; // Original size so all conversations fit without scrolling
                    document.documentElement.style.setProperty('--people-square-size', `${peopleSquareSize}px`);
                    console.log(`ğŸ“ Set people view square size to ${peopleSquareSize}px (original compact size - recalc)`);
                    
                    // Force CSS variables to apply immediately
                    console.log(`ğŸ“ Force set --people-square-size to ${peopleSquareSize}px for consistency`);
                    
                                                // Recalculate positions with the correct container dimensions
                            const updatedPositions = getPeopleViewPositions(conversations, gridContainer);
                            if (Object.keys(updatedPositions).length > 0) {
                                targetPositions = updatedPositions;
                                layoutPositions.people = updatedPositions;
                            
                            // Re-apply positions to existing elements
                            conversations.forEach((conv) => {
                                const pos = targetPositions[conv.folder];
                                if (pos) {
                                    const itemCell = document.getElementById(`conv-item-${conv.folder}`);
                                    if (itemCell) {
                                        itemCell.style.left = `${pos.left}px`;
                                        itemCell.style.top = `${pos.top}px`;
                                        itemCell.style.width = `${pos.width}px`;
                                        itemCell.style.height = `${pos.height}px`;
                                        console.log(`ğŸ”„ Updated ${conv.folder} position: (${Math.round(pos.left)}, ${Math.round(pos.top)})`);
                                    }
                                }
                            });
                            
                            // Clean up existing labels for all views
                            const existingPersonLabels = layoutCanvas.querySelectorAll('.person-name-label');
                            const existingDateLabels = layoutCanvas.querySelectorAll('.timeline-date-label, .timeline-date-label-immediate');
                            const existingBodyDateLabels = document.querySelectorAll('.timeline-date-label-protected'); // Check body for protected labels
                            const existingDebugMsg = layoutCanvas.querySelector('.people-debug-message');
                            const existingTestMsg = layoutCanvas.querySelector('.people-test-indicator');
                            existingPersonLabels.forEach(label => label.remove());
                            existingDateLabels.forEach(label => label.remove());
                            // Only clean up timeline labels if NOT in timeline view
                            if (window.activeLayout !== 'timeline') {
                                existingBodyDateLabels.forEach(label => label.remove()); // Clean up timeline labels
                                console.log(`ğŸ“… CLEANUP: Removed ${existingBodyDateLabels.length} timeline date labels from cleanup logic`);
                            }
                            if (existingDebugMsg) existingDebugMsg.remove();
                            if (existingTestMsg) existingTestMsg.remove();

                            // NEW PEOPLE VIEW: Render all elements for the new structure
                            if (window.activeLayout === 'people' && targetPositions) {
                                console.log(`ğŸ‘¥ NEW PEOPLE VIEW: Rendering early elements`);
                                
                                // Render header
                                if (targetPositions._header) {
                                    const header = targetPositions._header;
                                    const headerElement = document.createElement('div');
                                    headerElement.className = 'people-view-header';
                                    headerElement.textContent = header.text;
                                    headerElement.style.cssText = `
                                        position: absolute;
                                        left: ${header.left}px;
                                        top: ${header.top}px;
                                        width: ${header.width}px;
                                        height: ${header.height}px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        font-family: '80k', 'Arial', sans-serif;
                                        font-size: 20px;
                                        font-weight: bold;
                                        color: #333;
                                        text-align: center;
                                        direction: rtl;
                                        z-index: 3;
                                        border-bottom: 2px solid #e0e0e0;
                                    `;
                                    layoutCanvas.appendChild(headerElement);
                                }
                                
                                // Render person names from _personNames structure
                                const personNameData = targetPositions._personNames || [];
                                console.log(`ğŸ‘¥ Rendering ${personNameData.length} people name labels`);
                                
                                personNameData.forEach(nameData => {
                                    const labelElement = document.createElement('div');
                                    labelElement.className = 'person-name-label';
                                    
                                    // Create inner div with padding for the name
                                    const nameDiv = document.createElement('div');
                                    nameDiv.className = 'person-name-content';
                                    nameDiv.textContent = nameData.name;
                                    nameDiv.style.cssText = `
                                        padding: 0 8px !important;
                                        text-align: right !important;
                                        direction: rtl !important;
                                        width: 100% !important;
                                        box-sizing: border-box !important;
                                    `;
                                    
                                    labelElement.appendChild(nameDiv);
                                    labelElement.style.cssText = `
                                        position: absolute !important;
                                        left: ${nameData.x}px !important;
                                        top: ${nameData.y}px !important;
                                        width: ${nameData.width}px !important;
                                        height: ${nameData.height}px !important;
                                        z-index: 5 !important;
                                        display: flex !important;
                                        align-items: center !important;
                                    `;
                                    
                                    layoutCanvas.appendChild(labelElement);
                                    console.log(`ğŸ‘¤ Added padded label for ${nameData.name} at (${nameData.x}, ${nameData.y})`);
                                });
                             }
                             
                             // Date labels are now rendered directly in the timeline layout function
                             
                             // Show debug message if people view is active but no data
                             if (targetPositions._debugMessage && window.activeLayout === 'people') {
                                 const debugMsg = targetPositions._debugMessage;
                                 const debugElement = document.createElement('div');
                                 debugElement.className = 'people-debug-message';
                                 debugElement.innerHTML = `
                                     <div style="text-align: center; color: #666; font-family: '80k', sans-serif;">
                                         <h3>×ª×¦×•×’×ª ×× ×©×™× ×¤×¢×™×œ×”</h3>
                                         <p>×œ× × ××¦××• ×©×™×—×•×ª ×ª×•×××•×ª ×œ×× ×©×™×</p>
                                         <p style="font-size: 12px;">×‘×“×•×§ ×‘×§×•× ×¡×•×œ ×œ×¤×¨×˜×™× × ×•×¡×¤×™×</p>
                                     </div>
                                 `;
                                 debugElement.style.cssText = `
                                     position: absolute;
                                     left: ${debugMsg.left}px;
                                     top: ${debugMsg.top}px;
                                     width: ${debugMsg.width}px;
                                     height: ${debugMsg.height}px;
                                     background: rgba(255, 255, 255, 0.9);
                                     border: 2px solid #667eea;
                                     border-radius: 12px;
                                     display: flex;
                                     align-items: center;
                                     justify-content: center;
                                     z-index: 10;
                                 `;
                                 layoutCanvas.appendChild(debugElement);
                             }
                             
                             // Show test indicator - should ALWAYS appear in people view
                             if (targetPositions._testIndicator && window.activeLayout === 'people') {
                                 const testMsg = targetPositions._testIndicator;
                                 const testElement = document.createElement('div');
                                 testElement.className = 'people-test-indicator';
                                 testElement.innerHTML = `
                                     <div style="
                                         background: rgba(40, 167, 69, 0.95);
                                         color: white;
                                         padding: 12px;
                                         border-radius: 8px;
                                         text-align: center;
                                         font-size: 13px;
                                         border: 2px solid #28a745;
                                         font-weight: bold;
                                     ">
                                         ${testMsg.message || 'TEST MESSAGE'}
                                     </div>
                                 `;
                                 testElement.style.cssText = `
                                     position: absolute;
                                     left: ${testMsg.left}px;
                                     top: ${testMsg.top}px;
                                     width: ${testMsg.width}px;
                                     height: ${testMsg.height}px;
                                     z-index: 1001;
                                     pointer-events: none;
                                 `;
                                 layoutCanvas.appendChild(testElement);
                                 console.log(`ğŸ”§ Added people view test indicator at (${testMsg.left}, ${testMsg.top})`);
                             }
                        }
                    }
                }, 50); // Small delay to ensure CSS has fully applied
            } else {
                layoutCanvas.className = '';
                
                // COMPREHENSIVE BODY CLASS MANAGEMENT: Always clear and set proper class
                // Clear all layout-specific body classes first
                document.body.classList.remove('layout-timeline', 'layout-people', 'layout-emotions');
                
                // Set proper body class for current layout
                if (window.activeLayout === 'timeline') {
                    document.body.className = 'layout-timeline';
                    console.log('ğŸ—ï¸ Set body class to layout-timeline');
                } else {
                    document.body.className = '';
                    console.log('ğŸ—ï¸ Cleared body class for non-timeline view');
                }
                
                // CRITICAL FIX: For Timeline view, ensure CSS variables are set
                if (window.activeLayout === 'timeline') {
                    const timelineSquareSize = getTimelineSquareSize(conversations, gridContainer);
                    document.documentElement.style.setProperty('--timeline-square-size', `${timelineSquareSize}px`);
                    console.log(`ğŸ“ Set --timeline-square-size to ${timelineSquareSize}px for Timeline view`);
                    
                    // Timeline view uses cached positions - no recalculation needed
                    if (window.activeLayout === 'timeline') {
                        console.log('âœ… Timeline view: Using cached positions, no recalculation needed');
                    }
                }
            }
        
        // Update wrapper background for people view - Remove redundant class application
        const timelineWrapper = document.getElementById('timeline-grid-wrapper');
        if (timelineWrapper) {
            // Only set class on main container, not wrapper to prevent double CSS application
            timelineWrapper.className = ''; // Clear class to prevent conflicts
        }
        
        console.log(`ğŸ—ï¸ Layout updated: gridContainer="${gridContainer.className}", canvas="${layoutCanvas.className}", wrapper="${timelineWrapper?.className}"`);
        // Remove old people view elements, timeline elements, and emotion circle labels
        Array.from(layoutCanvas.querySelectorAll('.people-view-header, .people-view-row-item, .person-header, .vertical-line, .people-row-separator, .person-name-label, .timeline-baseline, .timeline-date-separator, .timeline-date-label, .timeline-date-label-immediate, .emotion-circle-label, .emotion-circle-background, .emotion-inner-circle, .emotion-count-badge, .people-debug-message, .people-test-indicator')).forEach(el => el.remove());
        
        // Clean up timeline date labels only when switching away from timeline view
        if (window.activeLayout !== 'timeline') {
            Array.from(document.querySelectorAll('.timeline-date-label-protected')).forEach(el => el.remove());
            console.log(`ğŸ“… CLEANUP: Removed timeline date labels (not in timeline view)`);
        }

        // Static elements will be created inside setTimeout where metaData is available
        setTimeout(() => {
            // Keep meta data for debugging, will be cleaned up later
            const metaData = targetPositions._meta;
            if (targetPositions._meta) delete targetPositions._meta;
            

            
            // Debug: Log positions for people view
            if (window.activeLayout === 'people') {
                console.log('ğŸ¯ People view positions:', targetPositions);
                console.log('ğŸ“ Container dimensions:', gridContainer.clientWidth, 'x', gridContainer.clientHeight);
                console.log('ğŸ‘¥ Groups:', metaData?.peopleGroups);
                console.log('ğŸ·ï¸ Person labels:', metaData?.personLabels?.length);
                console.log('ğŸ” Layout canvas dimensions:', layoutCanvas.clientWidth, 'x', layoutCanvas.clientHeight);
                console.log('ğŸ” Layout canvas position:', layoutCanvas.getBoundingClientRect());
            }
            
            const hoverPanel = document.getElementById('hover-info-panel');
            let hideTimeout;



            // Clear canvas and use ABSOLUTE POSITIONING for ALL layouts
            // NO BACKGROUND ELEMENTS: Body handles all background - clear everything
            if (!layoutCanvas) {
                console.error('âŒ Layout canvas not found!');
                return;
            }
            console.log(`ğŸ¯ Layout canvas found:`, layoutCanvas);
            // CREATE OR REUSE TIMELINE CONTAINER DIV: Check before clearing to preserve animations
            let timelineContainer = null;
            if (window.activeLayout === 'timeline') {
                // Try to reuse existing timeline container to preserve isotope animations
                timelineContainer = document.getElementById('timeline-conversations-container');
                
                if (!timelineContainer) {
                    // Preserve timeline date labels when clearing
                    const existingLabels = layoutCanvas.querySelectorAll('.timeline-date-label-protected');
                    const savedLabels = Array.from(existingLabels).map(label => label.cloneNode(true));
                    
                    // Clear existing content and create new container
                    layoutCanvas.innerHTML = '';
                    
                    // Restore timeline date labels
                    savedLabels.forEach(label => layoutCanvas.appendChild(label));
                    
                    timelineContainer = document.createElement('div');
                    timelineContainer.id = 'timeline-conversations-container';
                    timelineContainer.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        overflow: visible;
                        z-index: 2;
                    `;
                    layoutCanvas.appendChild(timelineContainer);
                    console.log(`ğŸ“¦ Created new timeline container div for isotope animations`);
                } else {
                    // Keep existing container but clear conversation items only for regeneration
                    const existingItems = timelineContainer.querySelectorAll('.conversation-grid-item-container');
                    console.log(`ğŸ”„ Reusing existing timeline container, found ${existingItems.length} existing items`);
                }
            } else {
                // Clear existing content for non-timeline views
                layoutCanvas.innerHTML = '';
            }
            
            // ENSURE STATIC BACKGROUND GRID: Verify body background is set
            ensureStaticBackgroundGrid();
            
            // People view: use taller height to accommodate all conversations without overlapping
            if (window.activeLayout === 'people') {
                layoutCanvas.style.height = 'calc(100vh - 120px)';
                layoutCanvas.style.minHeight = '800px';
                layoutCanvas.style.overflowY = 'auto';
                layoutCanvas.style.overflow = 'auto';
                
                // FORCE PROPER DIMENSIONS: Sometimes CSS conflicts cause issues
                layoutCanvas.style.width = '100%';
                layoutCanvas.style.position = 'fixed';
                layoutCanvas.style.top = '60px';
                layoutCanvas.style.left = '0';
                layoutCanvas.style.right = '0';
                layoutCanvas.style.bottom = '60px';
                
                console.log(`ğŸ“ People view: set proper height for scrollable content`);
                console.log(`ğŸ” PEOPLE VIEW Canvas dimensions after setting:`, layoutCanvas.getBoundingClientRect());
                console.log(`ğŸ” PEOPLE VIEW Canvas computed styles:`, window.getComputedStyle(layoutCanvas).height, window.getComputedStyle(layoutCanvas).width);
            } else {
                layoutCanvas.style.height = 'calc(100vh - 120px)';
                layoutCanvas.style.overflowY = 'hidden';
            }
            
            // ISOTOPE ANIMATION: Universal layout for all views with smooth transitions
            console.log(`ğŸ¬ Creating ${conversations.length} conversation elements...`);
            console.log(`ğŸ¯ Target positions:`, targetPositions);
            
            // EMERGENCY FALLBACK: If no target positions, create simple grid positions
            if (!targetPositions || Object.keys(targetPositions).length === 0) {
                console.warn('âš ï¸ No target positions available, creating emergency grid positions');
                targetPositions = {};
                conversations.forEach((conv, index) => {
                    const row = Math.floor(index / 4);
                    const col = index % 4;
                    const fallbackSize = 200;
                    const fallbackGap = 20;
                    targetPositions[conv.folder] = {
                        left: 50 + (col * (fallbackSize + fallbackGap)),
                        top: 50 + (row * (fallbackSize + fallbackGap)),
                        width: fallbackSize,
                        height: fallbackSize,
                        gridOrder: index
                    };
                });
            }
            
            conversations.forEach((conv, index) => {
                let pos = targetPositions[conv.folder];
                
                // PEOPLE VIEW: Skip conversations that aren't assigned to people
                if (window.activeLayout === 'people' && !pos) {
                    console.log(`ğŸ‘¥ Skipping unassigned conversation ${conv.folder} in people view`);
                    // Hide the element if it exists
                    const existingElement = document.getElementById(`conv-item-${conv.folder}`);
                    if (existingElement) {
                        existingElement.style.display = 'none';
                    }
                    return; // Skip this conversation entirely
                }
                
                // For timeline view, ensure ALL conversations are shown with positioning
                if (!pos) {
                    console.warn(`âŒ No position found for ${conv.folder}, using emergency position`);
                    // Create emergency position for this conversation with compact sizing
                    const row = Math.floor(index / 15); // More columns to fit more conversations
                    const col = index % 15;
                    const emergencyItemSize = 60; // Match compact timeline item size
                    const emergencyGap = 1; // Match minimal gap
                    pos = {
                        left: 50 + (col * (emergencyItemSize + emergencyGap)),
                        top: 150 + (row * (emergencyItemSize + emergencyGap)),
                        width: emergencyItemSize,
                        height: emergencyItemSize,
                        gridOrder: index,
                        isEmergencyPosition: true
                    };
                    console.log(`ğŸš¨ Emergency position created for ${conv.folder} at (${pos.left}, ${pos.top})`);
                }
                console.log(`âœ… Creating conversation ${conv.folder} at position (${Math.round(pos.left)}, ${Math.round(pos.top)})`);
                let itemCell = document.getElementById(`conv-item-${conv.folder}`);
                if (!itemCell) {
                    // CREATE UNIFIED MP4 PREVIEW COMPONENT
                    console.log(`ğŸ¬ Creating MP4 preview component for ${conv.folder}...`);
                    itemCell = createMP4PreviewComponent(conv, index);
                    
                    // Append to timeline container if in timeline view, otherwise to layout canvas
                    if (window.activeLayout === 'timeline' && timelineContainer) {
                        timelineContainer.appendChild(itemCell);
                    } else {
                        layoutCanvas.appendChild(itemCell);
                    }
                    
                    console.log(`âœ… Created unified MP4 preview component for ${conv.folder}`);
                } else {
                    console.log(`ğŸ”„ Reusing existing component for ${conv.folder}`);
                    // Ensure element is visible (in case it was hidden in people view)
                    itemCell.style.display = 'flex';
                }
                
                const currentPos = currentPositions[conv.folder];
                const isRepositioning = currentPos && !isInitial;
                
                // Apply SMOOTH ISOTOPE-STYLE POSITIONING with ENHANCED ANIMATIONS
                console.log(`ğŸ¬ ${isRepositioning ? 'Animating' : 'Positioning'} ${conv.folder} from (${currentPos ? Math.round(currentPos.left) : 'new'}, ${currentPos ? Math.round(currentPos.top) : 'new'}) to (${Math.round(pos.left)}, ${Math.round(pos.top)})`);
                
                // Set isotope-style CSS custom property for staggered animation
                itemCell.style.setProperty('--item-index', index);
                
                // Set absolute positioning
                itemCell.style.position = 'absolute';
                itemCell.style.order = index;
                itemCell.style.zIndex = '10'; // Higher z-index during animation
                itemCell.style.display = 'flex';
                itemCell.style.visibility = 'visible';
                
                // Handle timeline layout with isotope animations
                if (window.activeLayout === 'timeline') {
                    // TIMELINE WITH ISOTOPE: Use same animation system as other views
                    if (isRepositioning) {
                        // Animate from current position to new position with isotope effects
                        itemCell.style.transition = 'none';
                        itemCell.style.position = 'absolute';
                        itemCell.style.left = `${currentPos.left}px`;
                        itemCell.style.top = `${currentPos.top}px`;
                        itemCell.style.width = `${currentPos.width}px`;
                        itemCell.style.height = `${currentPos.height}px`;
                        itemCell.style.transform = 'scale(1)';
                        itemCell.style.opacity = '1';
                        
                        // Add isotope transition class for timeline
                        itemCell.classList.add('isotope-transitioning');
                        
                        // Force reflow
                        itemCell.offsetHeight;
                        
                        // Timeline isotope transitions
                        const delay = index * 0.03;
                        itemCell.style.transition = `
                            left 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            top 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            width 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            height 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            transform 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            opacity 0.3s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s
                        `;
                        
                        // Animate to new position with isotope effects
                        requestAnimationFrame(() => {
                            itemCell.style.left = `${pos.left}px`;
                            itemCell.style.top = `${pos.top}px`;
                            itemCell.style.width = `${pos.width}px`;
                            itemCell.style.height = `${pos.height}px`;
                            itemCell.style.transform = 'scale(1.05) rotateY(5deg)'; // Isotope effect
                            
                            // Final settle animation
                            setTimeout(() => {
                                if (itemCell.classList.contains('isotope-transitioning')) {
                                    itemCell.style.transform = 'scale(1) rotateY(0deg)';
                                    itemCell.style.zIndex = '10';
                                    
                                    // Remove transition class
                                    setTimeout(() => {
                                        itemCell.classList.remove('isotope-transitioning');
                                    }, 100);
                                }
                            }, (delay * 1000) + 800);
                        });
                        
                        console.log(`ğŸ¬ TIMELINE ISOTOPE: ${conv.folder} animating from (${Math.round(currentPos.left)}, ${Math.round(currentPos.top)}) to (${Math.round(pos.left)}, ${Math.round(pos.top)})`);
                    } else {
                        // Initial positioning for timeline (still with some animation)
                        itemCell.style.position = 'absolute';
                        itemCell.style.order = pos.gridOrder || index;
                        itemCell.style.flex = 'none';
                        itemCell.style.zIndex = '10';
                        
                        // Add entrance animation delay for staggered effect
                        const delay = index * 0.03;
                        itemCell.style.transition = `
                            left 0.6s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            top 0.6s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            width 0.6s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            height 0.6s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            transform 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            opacity 0.3s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s
                        `;
                        
                        // Set positions with entrance animation
                        itemCell.style.left = `${pos.left}px`;
                        itemCell.style.top = `${pos.top}px`;
                        itemCell.style.width = `${pos.width}px`;
                        itemCell.style.height = `${pos.height}px`;
                        itemCell.style.opacity = '1';
                        itemCell.style.transform = 'scale(1)';
                        
                        console.log(`ğŸ“… TIMELINE ENTRANCE: ${conv.folder} positioned at X=${Math.round(pos.left)}, Y=${Math.round(pos.top)} with ${delay}s delay`);
                    }
                    
                } else if (isRepositioning) {
                    // ISOTOPE ANIMATION: Start from current position, animate to new position
                    
                    // Temporarily disable transitions to snap to current position
                    itemCell.style.transition = 'none';
                    itemCell.style.position = 'absolute';
                    itemCell.style.left = `${currentPos.left}px`;
                    itemCell.style.top = `${currentPos.top}px`;
                    itemCell.style.width = `${currentPos.width}px`;
                    itemCell.style.height = `${currentPos.height}px`;
                    itemCell.style.transform = 'scale(1)';
                    itemCell.style.opacity = '1';
                    
                    // Add isotope transition class
                    itemCell.classList.add('isotope-transitioning');
                    
                    // Force reflow
                    itemCell.offsetHeight;
                    
                    // OPTIMIZED: Fast, smooth transitions with minimal delay
                    const delay = index * 0.02; // Reduced staggered delay
                    itemCell.style.transition = `
                        left 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        top 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        width 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        height 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        opacity 0.3s ease-out ${delay}s
                    `;
                    
                    // OPTIMIZED: Smooth position and size transitions with simple animation
                    requestAnimationFrame(() => {
                        itemCell.style.left = `${pos.left}px`;
                        itemCell.style.top = `${pos.top}px`;
                        itemCell.style.width = `${pos.width}px`;
                        itemCell.style.height = `${pos.height}px`;
                        itemCell.style.transform = 'scale(1.01)'; // Subtle scale during animation
                        
                        // Final settle animation
                        setTimeout(() => {
                            if (itemCell.classList.contains('isotope-transitioning')) {
                                itemCell.style.transform = 'scale(1)';
                                itemCell.style.zIndex = '2'; // Reset z-index after animation
                                
                                // Remove transition class after animation
                                setTimeout(() => {
                                    itemCell.classList.remove('isotope-transitioning');
                                }, 100);
                            }
                        }, (delay * 1000) + 600); // After main animation completes
                    });
                    
                } else {
                    // ABSOLUTE POSITIONING: Fast initial positioning with minimal animation
                    itemCell.style.position = 'absolute';
                    itemCell.style.transition = `
                        left 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                        top 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                        width 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                        height 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                        transform 0.3s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.01}s,
                        opacity 0.2s ease-out ${index * 0.01}s
                    `;
                    
                    // OPTIMIZED: Fast position and size transitions for initial positioning
                    requestAnimationFrame(() => {
                        itemCell.style.left = `${pos.left}px`;
                        itemCell.style.top = `${pos.top}px`;
                        itemCell.style.width = `${pos.width}px`;
                        itemCell.style.height = `${pos.height}px`;
                        itemCell.style.opacity = '1';
                        itemCell.style.transform = 'scale(1)';
                        itemCell.style.zIndex = '2';
                    });
                }
                
                // Add isotope-style entrance effect
                itemCell.classList.add('isotope-positioned');
            });
            
            /// Create enhanced person name labels and row separators for People view
            if (window.activeLayout === 'people' && metaData?.personLabels) {
                // Create row separators for visual clarity
                if (metaData.rowSeparators) {
                    metaData.rowSeparators.forEach(separator => {
                        const separatorElement = document.createElement('div');
                        separatorElement.className = 'people-row-separator';
                        separatorElement.style.cssText = `
                            position: absolute;
                            left: ${separator.x}px;
                            top: ${separator.y}px;
                            width: ${separator.width}px;
                            height: ${separator.height}px;
                            background: rgba(0, 0, 0, 0.1);
                            z-index: 0;
                        `;
                        layoutCanvas.appendChild(separatorElement);
                    });
                }
                
                // Create right-aligned person name labels  
                metaData.personLabels.forEach(label => {
                    const labelElement = document.createElement('div');
                    labelElement.className = 'person-name-label';
                    
                    // Minimal styling - just position and text
                    labelElement.style.cssText = `
                        position: absolute;
                        left: ${label.x}px;
                        top: ${label.y}px;
                        z-index: 2;
                    `;
                    
                    // Just show the person's name
                    labelElement.textContent = label.name;
                    
                    layoutCanvas.appendChild(labelElement);
                });
            }
            
            /// NO visual elements for bottom-up timeline
            if (window.activeLayout === 'timeline' && metaData?.isBottomUpTimeline) {
                console.log(`ğŸ“… Bottom-up timeline - conversations stacked from baseline with dynamic sizing`);
                console.log(`âœ… Bottom-up timeline ready - ${metaData.totalDateGroups} date columns, dynamic sizes, stacked from bottom`);
            }
            
            // EMOTION CIRCLES CODE COMPLETELY REMOVED - Using only Tetris-style layout
            
            // Force reflow to ensure all items are positioned correctly
            layoutCanvas.offsetHeight;
            
            // Log final positions for debugging
            console.log(`âœ… Layout complete for ${window.activeLayout} view with ${conversations.length} conversations positioned`);
            let createdCount = 0;
            conversations.forEach((conv, index) => {
                const itemCell = document.getElementById(`conv-item-${conv.folder}`);
                if (itemCell) {
                    createdCount++;
                    const rect = itemCell.getBoundingClientRect();
                    console.log(`ğŸ“ ${conv.folder}: positioned at (${itemCell.style.left}, ${itemCell.style.top}) with size ${itemCell.style.width}x${itemCell.style.height}`);
                } else {
                    console.warn(`âŒ Missing element for ${conv.folder}`);
                }
            });
            console.log(`ğŸ“Š Created ${createdCount}/${conversations.length} conversation elements`);

            /// Create person name labels for People view
            if (window.activeLayout === 'people' && metaData?.personLabels) {
                metaData.personLabels.forEach(label => {
                    const labelElement = document.createElement('div');
                    labelElement.className = 'person-name-label';
                    labelElement.style.cssText = `
                        position: absolute;
                        left: ${label.x}px;
                        top: ${label.y}px;
                        z-index: 1;
                    `;
                    labelElement.textContent = label.name;
                    layoutCanvas.appendChild(labelElement);
                });
            }
            
            /// Create emotion labels for Emotions view (Tetris style)
            if (window.activeLayout === 'emotions' && targetPositions) {
                // Clear any existing emotion labels first
                const existingLabels = layoutCanvas.querySelectorAll('.emotion-cluster-label, .emotion-circle-label, .emotion-count-badge, .emotion-circle-background, .emotion-inner-circle');
                existingLabels.forEach(label => label.remove());
                console.log(`ğŸ§¹ Cleared ${existingLabels.length} existing emotion labels`);
                
                // Count how many emotion labels we're about to create
                const labelKeysToCreate = Object.keys(targetPositions).filter(key => key.startsWith('emotion_label_'));
                console.log(`ğŸ“ About to create ${labelKeysToCreate.length} new emotion labels: ${labelKeysToCreate.map(k => k.replace('emotion_label_', '')).join(', ')}`);
                
                // Find and render emotion labels
                Object.keys(targetPositions).forEach(key => {
                    if (key.startsWith('emotion_label_')) {
                        const labelData = targetPositions[key];
                        if (labelData.isEmotionLabel) {
                            // Create emotion label element
                            const labelElement = document.createElement('div');
                            labelElement.className = 'emotion-cluster-label';
                            labelElement.style.cssText = `
                                position: absolute;
                                left: ${labelData.left}px;
                                top: ${labelData.top}px;
                                width: ${labelData.width}px;
                                height: ${labelData.height}px;
                                z-index: 10;
                                font-family: 'Miriam Libre', serif;
                                font-size: 16px;
                                font-weight: normal;
                                color: #333;
                                display: flex;
                                align-items: center;
                                justify-content: ${labelData.isRightAligned ? 'flex-start' : 'flex-end'};
                                text-align: ${labelData.isRightAligned ? 'left' : 'right'};
                                direction: rtl;
                                pointer-events: none;
                                background: transparent;
                                border: none;
                                box-shadow: none;
                                padding: 0;
                            `;
                            
                            // Emotion name in Hebrew only (no count)
                            labelElement.innerHTML = `
                                ${labelData.hebrewEmotion}
                            `;
                            
                            layoutCanvas.appendChild(labelElement);
                            console.log(`ğŸ·ï¸ Created emotion label "${labelData.hebrewEmotion}" (${labelData.emotion}) at position (${labelData.left}, ${labelData.top}) with ${labelData.count} conversations - stairs offset: ${labelData.staggerOffset}px (index: ${labelData.globalEmotionIndex})`);
                        }
                    }
                });
            }
        }, 0);
        
        // Render all previews after layout is complete
        setTimeout(() => {
            // Iframe previews load automatically - no need to render manually
            console.log('âœ… Layout complete - iframe previews will load automatically');
            
            // Debug conversation visibility after layout
            if (window.debugConversationVisibility) {
                const debugResult = window.debugConversationVisibility();
                console.log('ğŸ” Layout Debug Result:', debugResult);
            }
            
            // Reset the rendering flag and cleanup
            window.isLayoutRendering = false;
            
            // CONSISTENCY CHECK: Ensure layout classes are properly applied
            const finalGridContainer = document.getElementById('timeline-axes-container');
            const finalLayoutCanvas = document.getElementById('layout-canvas');
            
            if (finalGridContainer && window.activeLayout) {
                // Ensure the layout class is properly set
                if (!finalGridContainer.classList.contains(`layout-${window.activeLayout}`)) {
                    finalGridContainer.classList.add(`layout-${window.activeLayout}`);
                    console.log(`ğŸ”§ Applied missing layout class: layout-${window.activeLayout}`);
                }
                
                // Remove any stale isotope classes
                finalGridContainer.classList.remove('isotope-transitioning', 'isotope-switching');
            }
            
            if (finalLayoutCanvas) {
                // Ensure canvas classes match layout
                if (window.activeLayout === 'people' && !finalLayoutCanvas.classList.contains('people-active')) {
                    finalLayoutCanvas.classList.add('people-active');
                    console.log('ğŸ”§ Applied missing people-active class to canvas');
                }
                
                // Remove transitioning classes
                finalLayoutCanvas.classList.remove('isotope-transitioning');
            }
            
            console.log(`âœ… Layout consistency check complete for ${window.activeLayout} view`);
        }, 150); // Increased timeout for better stability
        
        }, 30); // Reduced debounce timeout for better responsiveness
    }

    // Add responsive window resize handler
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            console.log('ğŸ”„ Window resized, updating layout...');
            
            // Update responsive block sizes first
            if (window.updateResponsiveBlockSizes) {
                window.updateResponsiveBlockSizes(true);
            }
            
            if (window.renderNewLayout) {
                window.renderNewLayout();
                
                // Special handling for People view to ensure consistency
                if (window.activeLayout === 'people') {
                    // Clear any existing stability check
                    if (window.peopleViewStabilityCheck) {
                        clearTimeout(window.peopleViewStabilityCheck);
                    }
                    
                    window.peopleViewStabilityCheck = setTimeout(() => {
                        if (window.renderNewLayout && window.activeLayout === 'people') {
                            console.log('ğŸ”„ People view resize stabilization...');
                            window.renderNewLayout(false);
                        }
                    }, 150);
                }
            }
        }, 300); // Debounce resize events
    });

    // Force layout recalculation after page load to fix initial positioning
    window.addEventListener('load', () => {
        setTimeout(() => {
            console.log('ğŸ”„ Page loaded, forcing layout recalculation...');
            if (window.renderNewLayout) {
                window.renderNewLayout();
                
                // Special handling for People view on page load
                if (window.activeLayout === 'people') {
                    // Clear any existing stability check
                    if (window.peopleViewStabilityCheck) {
                        clearTimeout(window.peopleViewStabilityCheck);
                    }
                    
                    window.peopleViewStabilityCheck = setTimeout(() => {
                        if (window.renderNewLayout && window.activeLayout === 'people') {
                            console.log('ğŸ”„ People view page load stabilization...');
                            window.renderNewLayout(false);
                        }
                    }, 300);
                }
            }
        }, 500); // Wait for DOM to be fully ready
    });

    window.switchLayout = function(newLayout, forceRefresh = true) {
        if (newLayout === window.activeLayout && !forceRefresh) return;
        
        const previousLayout = window.activeLayout;
        
        console.log(`ğŸ¬ ENHANCED SWITCH: ${previousLayout} â†’ ${newLayout}`);
        
        // CLEANUP: Clear all pending layout operations to prevent race conditions
        if (window.layoutRenderTimeout) {
            clearTimeout(window.layoutRenderTimeout);
            window.layoutRenderTimeout = null;
        }
        if (window.peopleViewStabilityCheck) {
            clearTimeout(window.peopleViewStabilityCheck);
            window.peopleViewStabilityCheck = null;
        }
        
        // RESET: Clear layout rendering lock
        window.isLayoutRendering = false;
        
        // SET NEW LAYOUT EARLY: Ensure consistent state
        window.activeLayout = newLayout;
        
        // SPECIFIC CLEANUP FOR EMOTIONS VIEW TRANSITIONS
        if (previousLayout === 'emotions' && newLayout !== 'emotions') {
            console.log('ğŸ­ Detected transition FROM emotions view - performing cleanup');
            window.cleanupEmotionsView();
        }
        
        // CLEAR CACHED POSITIONS: Force fresh calculation for all views except timeline
        if (previousLayout !== newLayout) {
            // SPECIAL CASE: Always clear all positions when coming FROM emotions view
            if (previousLayout === 'emotions' && window.layoutPositions) {
                console.log('ğŸ­ EMOTION EXIT: Clearing ALL cached positions due to emotions view exit');
                window.layoutPositions.timeline = null;
                window.layoutPositions.people = null;
                window.layoutPositions.emotions = null;
            } else if (newLayout !== 'timeline' && window.layoutPositions) {
                // Keep timeline cache but clear others to force recalculation
                console.log(`ğŸ—‘ï¸ Clearing cached positions for fresh ${newLayout} calculation`);
                if (newLayout !== 'people') window.layoutPositions.people = null;
                if (newLayout !== 'emotions') window.layoutPositions.emotions = null;
            }
        }
        
        // CRITICAL: Pre-fix canvas height before any other operations
        const layoutCanvas = document.getElementById('layout-canvas');
        if (layoutCanvas) {
            // Clean up ALL CSS classes and styles first
            layoutCanvas.className = '';
            layoutCanvas.style.cssText = '';
            
            // Aggressively preserve height during view switching
            layoutCanvas.style.setProperty('height', 'calc(100vh - 120px)', 'important');
            layoutCanvas.style.setProperty('min-height', '800px', 'important');
            layoutCanvas.style.setProperty('overflow-y', 'auto', 'important');
            layoutCanvas.style.setProperty('overflow-x', 'hidden', 'important');
            layoutCanvas.style.setProperty('scrollbar-width', 'none', 'important');
            layoutCanvas.style.setProperty('-ms-overflow-style', 'none', 'important');
            
            // Force immediate reflow
            layoutCanvas.offsetHeight;
            console.log(`ğŸ”§ Pre-fixed canvas height for ${newLayout}: ${layoutCanvas.offsetHeight}px`);
        }
        
        // CLEANUP: Reset grid container classes
        const gridContainer = document.getElementById('timeline-axes-container');
        if (gridContainer) {
            gridContainer.className = '';
            gridContainer.style.cssText = '';
            gridContainer.offsetHeight; // Force reflow
        }
        
        // Reset all conversation containers to default state before layout change
        if (window.resetAllConversationContainers) {
            window.resetAllConversationContainers();
        }
        
        // Add visual feedback for view switching
        const viewButtons = document.querySelectorAll('.view-toggle-btn');
        viewButtons.forEach(btn => {
            btn.style.pointerEvents = 'none'; // Disable during transition
        });
        
        // Re-enable buttons after transition
        setTimeout(() => {
            viewButtons.forEach(btn => {
                btn.style.pointerEvents = 'auto';
            });
        }, 800);

        const timelineTrack = document.querySelector('.timeline-track-wrapper');
        const playgroundContainer = document.getElementById('playground-container');
        const timelineWrapper = document.getElementById('timeline-grid-wrapper');
        
        if (newLayout === 'playground') {
            // Show playground mode
            if (playgroundContainer) playgroundContainer.style.display = 'flex';
            if (timelineWrapper) timelineWrapper.style.display = 'none';
            if (timelineTrack) timelineTrack.style.visibility = 'hidden';
            
            // Start playground sketch
            if (typeof window.startPlaygroundSketch === 'function') {
                window.startPlaygroundSketch();
            }
        } else {
            // Show normal layout modes
            if (playgroundContainer) playgroundContainer.style.display = 'none';
            if (timelineWrapper) timelineWrapper.style.display = 'block';
            if (timelineTrack) {
                timelineTrack.style.visibility = (newLayout === 'timeline') ? 'visible' : 'hidden';
            }
            
            // Stop playground sketch
            if (typeof window.stopPlaygroundSketch === 'function') {
                window.stopPlaygroundSketch();
            }
            
            if (typeof window.resetCamera === 'function') {
                window.resetCamera();
            }
            
            // ENHANCED ISOTOPE ANIMATIONS: Add smooth morphing between views
            console.log(`ğŸ¬ Switching from ${window.activeLayout || 'initial'} to ${newLayout} with isotope-style animation`);
            
            // Add isotope transitioning class for enhanced animations
            const gridContainer = document.getElementById('timeline-axes-container');
            
            // CRITICAL: Maintain canvas height during transitions
            if (layoutCanvas) {
                layoutCanvas.classList.add('isotope-transitioning');
                layoutCanvas.style.transition = 'all 0.6s cubic-bezier(0.23, 1, 0.32, 1)';
                
                // RE-ENFORCE canvas height after adding classes
                layoutCanvas.style.setProperty('height', 'calc(100vh - 120px)', 'important');
                layoutCanvas.style.setProperty('min-height', '800px', 'important');
                layoutCanvas.style.setProperty('overflow-y', 'auto', 'important');
                layoutCanvas.style.setProperty('overflow-x', 'hidden', 'important');
                layoutCanvas.style.setProperty('scrollbar-width', 'none', 'important');
                layoutCanvas.style.setProperty('-ms-overflow-style', 'none', 'important');
                console.log(`ğŸ”§ Re-enforced canvas height during transition: ${layoutCanvas.offsetHeight}px`);
            }
            
            if (gridContainer) {
                gridContainer.classList.add('isotope-transitioning');
            }
            
            // Add isotope transitioning to timeline track for consistent animations
            if (timelineTrack) {
                timelineTrack.classList.add('isotope-transitioning');
                timelineTrack.style.transition = 'all 0.6s cubic-bezier(0.23, 1, 0.32, 1)';
            }
            
            // Add isotope transitioning to timeline conversations container
            const timelineConversationsContainer = document.getElementById('timeline-conversations-container');
            if (timelineConversationsContainer) {
                timelineConversationsContainer.classList.add('isotope-transitioning');
                timelineConversationsContainer.style.transition = 'all 0.6s cubic-bezier(0.23, 1, 0.32, 1)';
            }
            
            // ISOTOPE-STYLE SMOOTH VIDEO TRANSITIONS: Show videos moving to new positions
            const allContainers = document.querySelectorAll('.conversation-grid-item-container');
            
            // TIMELINE-SPECIFIC: Ensure timeline containers get proper isotope treatment
            if (newLayout === 'timeline' || previousLayout === 'timeline') {
                allContainers.forEach((container) => {
                    container.style.willChange = 'transform, left, top, width, height, opacity';
                    container.style.backfaceVisibility = 'hidden';
                    container.style.perspective = '1000px';
                    // Add extra transition properties for timeline
                    container.style.transformStyle = 'preserve-3d';
                    container.style.transformOrigin = 'center center';
                });
                console.log(`ğŸ¬ Enhanced timeline containers for isotope animations (${previousLayout} â†’ ${newLayout})`);
            }
            
            // Phase 1: Prepare containers for smooth isotope animation
            allContainers.forEach((container, index) => {
                container.classList.add('transitioning');
                
                const video = container.querySelector('.conversation-video-preview');
                if (video) {
                    // Keep videos playing during transition for smooth movement effect
                    const wasPlaying = !video.paused;
                    
                    // Show first frame if video isn't playing to ensure content is visible
                    if (!wasPlaying && video.readyState >= 2) {
                        video.currentTime = 0.1;
                    }
                    
                    // Enable smooth video transitions during layout change
                    video.style.transition = 'transform 0.3s ease-out, filter 0.3s ease-out';
                    video.style.willChange = 'transform';
                }
                
                // Add smooth isotope-style transition with fast delays
                container.style.transition = `
                    left 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.03}s,
                    top 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.03}s,
                    width 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.03}s,
                    height 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.03}s,
                    transform 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                    opacity 0.3s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.01}s
                `;
                
                // Add subtle entrance animation for isotope effect
                container.style.transform = `scale(0.96) translateY(10px)`;
                container.style.opacity = '0.85';
                
                // Restore to normal state with staggered timing for organic feel
                setTimeout(() => {
                    container.style.transform = 'scale(1) translateY(0px)';
                    container.style.opacity = '1';
                }, 50 + (index * 30));
                
                // Clean up transition state after animation completes
                setTimeout(() => {
                    container.classList.remove('transitioning');
                    
                    // Reset video transitions to normal hover behavior
                    if (video) {
                        video.style.transition = 'filter 0.3s ease-out';
                        video.style.willChange = 'auto';
                    }
                    
                    // Reset container transitions to normal
                    container.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                }, 2000 + (index * 100)); // Allow time for all animations to complete
            });
            
            // CRITICAL FIX: For People view, ensure proper container dimensions before layout
            if (newLayout === 'people') {
                // Clear any existing stability checks
                if (window.peopleViewStabilityCheck) {
                    clearTimeout(window.peopleViewStabilityCheck);
                }
                
                // FORCE FIX: Ensure timeline-grid-wrapper is visible for people view
                const timelineWrapper = document.getElementById('timeline-grid-wrapper');
                if (timelineWrapper) {
                    timelineWrapper.style.cssText = `
                        position: absolute !important;
                        top: 60px !important;
                        left: 0px !important;
                        right: 0px !important;
                        bottom: 0px !important;
                        width: 100vw !important;
                        height: calc(100vh - 60px) !important;
                        min-width: 1200px !important;
                        min-height: 600px !important;
                        display: block !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                        overflow: visible !important;
                        z-index: 0 !important;
                        background: transparent !important;
                        padding: 0px !important;
                        margin: 0px !important;
                    `;
                    console.log('ğŸ”§ FORCED timeline-grid-wrapper to be visible for people view');
                }
                
                // SET TIMELINE SQUARE SIZE CSS VARIABLE for People view consistency
                const gridContainer = document.getElementById('timeline-axes-container') || timelineWrapper;
                const timelineSquareSize = getTimelineSquareSize(window.originalConversationData || [], gridContainer);
                document.documentElement.style.setProperty('--timeline-square-size', `${timelineSquareSize}px`);
                console.log(`ğŸ“ Set --timeline-square-size to ${timelineSquareSize}px for People view`);
                
                // Force immediate layout update to set CSS classes with isotope animations
                window.renderNewLayout(false);
                
                // Then wait for container to stabilize and recalculate
                window.peopleViewStabilityCheck = setTimeout(() => {
                    const gridContainer = document.getElementById('timeline-axes-container');
                    
                    if (!gridContainer) return;
                    
                    // Force a reflow to ensure DOM is ready
                    gridContainer.offsetHeight;
                    
                    const currentWidth = gridContainer.clientWidth;
                    const currentHeight = gridContainer.clientHeight;
                    
                    console.log(`ğŸ”§ People view container stabilization: ${currentWidth}x${currentHeight}`);
                    
                    // Check if dimensions are stable (not zero and reasonable)
                    if (currentWidth > 100 && currentHeight > 100) {
                        console.log(`ğŸ”„ People view STABLE dimensions detected: ${currentWidth}x${currentHeight} - recalculating layout`);
                        
                        if (window.renderNewLayout && window.activeLayout === 'people') {
                            window.renderNewLayout(false);
                        }
                    } else {
                        console.warn(`âš ï¸ People view dimensions not stable: ${currentWidth}x${currentHeight} - retrying...`);
                        
                        // Retry after another short delay if dimensions aren't stable
                        setTimeout(() => {
                            if (window.renderNewLayout && window.activeLayout === 'people') {
                                console.log(`ğŸ”„ People view retry layout calculation`);
                                window.renderNewLayout(false);
                            }
                        }, 200);
                    }
                }, 150); // Increased delay to ensure CSS has applied
            } else {
                // For other layouts, render immediately with isotope transitions
                if (newLayout === 'timeline') {
                    // TIMELINE SPECIAL: Delay rendering to allow isotope animations to start
                    setTimeout(() => {
                        window.renderNewLayout(false);
                        console.log(`ğŸ¬ Triggered isotope animations for ${newLayout} view (delayed for timeline)`);
                    }, 100); // Small delay to let isotope animations start first
                } else {
                    // SPECIAL CASE: When transitioning FROM timeline, add slight delay for smooth isotope
                    if (previousLayout === 'timeline') {
                        setTimeout(() => {
                            window.renderNewLayout(false);
                            console.log(`ğŸ¬ Triggered isotope animations for ${newLayout} view (delayed from timeline)`);
                        }, 50); // Smaller delay when transitioning FROM timeline
                    } else {
                        window.renderNewLayout(false);
                        console.log(`ğŸ¬ Triggered isotope animations for ${newLayout} view`);
                    }
                }
                
                // Add completion callback for isotope transitions
                setTimeout(() => {
                    console.log(`âœ… Isotope transition to ${newLayout} view completed`);
                    
                    // Clean up isotope transitioning classes
                    if (layoutCanvas) {
                        layoutCanvas.classList.remove('isotope-transitioning');
                    }
                    if (gridContainer) {
                        gridContainer.classList.remove('isotope-transitioning');
                    }
                    const timelineTrack = document.querySelector('.timeline-track-wrapper');
                    if (timelineTrack) {
                        timelineTrack.classList.remove('isotope-transitioning');
                    }
                    const timelineConversationsContainer = document.getElementById('timeline-conversations-container');
                    if (timelineConversationsContainer) {
                        timelineConversationsContainer.classList.remove('isotope-transitioning');
                    }
                }, 600); // Match isotope transition duration
            }
            
            // ENHANCED: Global cleanup for isotope classes after all transitions
            setTimeout(() => {
                const allContainers = document.querySelectorAll('.conversation-grid-item-container');
                allContainers.forEach((container, index) => {
                    // Clean up isotope classes
                    container.classList.remove('isotope-positioned', 'transitioning');
                    
                    // Reset transition delays
                    container.style.transitionDelay = '';
                    
                    // Ensure final position is stable
                    container.style.transform = 'scale(1) rotateY(0deg) rotateX(0deg)';
                    
                    // Reset to normal transition for hover effects
                    setTimeout(() => {
                        container.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    }, index * 10);
                });
                
                if (layoutCanvas) {
                    layoutCanvas.classList.remove('isotope-transitioning');
                }
                if (gridContainer) {
                    gridContainer.classList.remove('isotope-transitioning');
                }
                const timelineTrack = document.querySelector('.timeline-track-wrapper');
                if (timelineTrack) {
                    timelineTrack.classList.remove('isotope-transitioning');
                }
                const timelineConversationsContainer = document.getElementById('timeline-conversations-container');
                if (timelineConversationsContainer) {
                    timelineConversationsContainer.classList.remove('isotope-transitioning');
                }
                
                console.log(`âœ¨ Isotope transition to ${newLayout} view completed with enhanced animations`);
            }, 1000); // Fast cleanup to allow all animations to finish
        }
    }

    function openVisualizationInModal(folder) {
        console.log(`ğŸ” openVisualizationInModal called for: ${folder}`);
        const modalContainer = document.getElementById('visualization-modal-container');
        if (!modalContainer) {
            console.error(`âŒ Modal container not found for: ${folder}`);
            return;
        }
        console.log(`âœ… Modal container found for: ${folder}`);
        
        // Check if we already have an iframe for this folder
        const existingIframe = modalContainer.querySelector(`iframe[data-folder="${folder}"]`);
        
        if (existingIframe) {
            // If iframe already exists, just show it
            console.log(`â™»ï¸ Reusing existing visualization for ${folder}`);
            modalContainer.style.display = 'flex';
            setTimeout(() => modalContainer.classList.add('visible'), 10);
            return;
        }
        
        // IMPORTANT: Always stop all audio and clear content when switching conversations
        const currentFolder = modalContainer.querySelector('iframe')?.getAttribute('data-folder');
        if (currentFolder && currentFolder !== folder) {
            // Stop all audio in the current iframe before switching
            const currentIframe = modalContainer.querySelector('iframe');
            if (currentIframe && currentIframe.contentWindow) {
                try {
                    // Send message to stop all audio
                    currentIframe.contentWindow.postMessage({
                        type: 'stop-all-audio',
                        reason: 'conversation-switch'
                    }, '*');
                } catch (e) {
                    console.warn('Could not send stop-audio message to iframe:', e);
                }
            }
            
            // Clear the modal and wait a moment for audio to stop
            modalContainer.innerHTML = '';
            console.log(`ğŸ”‡ Stopped audio for ${currentFolder}, switching to ${folder}`);
        }
        
        // Create iframe with enhanced cache-busting (with delay if switching conversations)
        const createNewIframe = () => {
            const iframe = document.createElement('iframe');
            iframe.setAttribute('data-folder', folder);
            
            // Force reload with timestamp to ensure fresh data
            const timestamp = Date.now();
            const randomId = Math.random().toString(36).substr(2, 9);
            iframe.src = `visualization.html?folder=${encodeURIComponent(folder)}&viewMode=iframe&t=${timestamp}&r=${randomId}&force=true`;
            
            return iframe;
        };
        
        // Add delay if we just switched conversations to ensure audio cleanup
        const shouldDelay = currentFolder && currentFolder !== folder;
        
        const setupIframe = () => {
            const iframe = createNewIframe();
            
            // Styles are now handled by CSS, no need to set them here
            iframe.style.backgroundColor = '#f7f9f3';
            
            iframe.onload = () => {
                console.log(`âœ… Visualization iframe loaded for ${folder} with cache-busting`);
                // Hide loading indicator if present
                const loadingIndicator = document.getElementById('loading-indicator');
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'none';
                }
                
                // Send message to iframe to ensure emotion data is loaded
                setTimeout(() => {
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({ 
                            type: 'ensure-emotion-data',
                            folder: folder,
                            timestamp: Date.now()
                        }, '*');
                    }
                }, 500);
                
                // Send multiple color reload messages to ensure latest colors are used
                setTimeout(() => {
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'reloadEmotionColors',
                            timestamp: Date.now()
                        }, '*');
                        console.log(`ğŸ¨ Sent emotion color reload to iframe for ${folder}`);
                    }
                }, 1500);
                
                // Send a second reload after more time to be extra sure
                setTimeout(() => {
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'forceVisualRefresh',
                            timestamp: Date.now()
                        }, '*');
                        console.log(`ğŸ”„ Sent force visual refresh to iframe for ${folder}`);
                    }
                }, 2500);
                
                // Try direct function call if available
                setTimeout(() => {
                    try {
                        if (iframe.contentWindow && iframe.contentWindow.forceUpdateAllBlobColors) {
                            iframe.contentWindow.forceUpdateAllBlobColors();
                            console.log(`ğŸ¨ Called forceUpdateAllBlobColors directly on iframe for ${folder}`);
                        }
                    } catch (e) {
                        console.log(`ğŸ¨ Direct function call not available for ${folder}:`, e.message);
                    }
                }, 3500);
                
                // Also set up a periodic check to ensure colors stay updated
                const colorUpdateInterval = setInterval(() => {
                    if (!iframe.parentNode) {
                        // iframe was removed, clear interval
                        clearInterval(colorUpdateInterval);
                        return;
                    }
                    
                    try {
                        if (iframe.contentWindow) {
                            iframe.contentWindow.postMessage({
                                type: 'reloadEmotionColors',
                                timestamp: Date.now(),
                                source: 'periodic-update'
                            }, '*');
                            console.log(`ğŸ”„ Sent periodic color update to ${folder}`);
                        }
                    } catch (e) {
                        console.log(`ğŸ”„ Periodic update failed for ${folder}:`, e.message);
                    }
                }, 30000); // Every 30 seconds
            };
            
            modalContainer.appendChild(iframe);
            modalContainer.style.display = 'flex';
            setTimeout(() => modalContainer.classList.add('visible'), 10);
        };
        
        if (shouldDelay) {
            // Wait 300ms for audio to stop before creating new iframe
            console.log(`â±ï¸ Waiting for audio cleanup before loading ${folder}`);
            setTimeout(setupIframe, 300);
        } else {
            setupIframe();
        }
    }
    

    
    // Audio interaction function removed
    
    // Listen for messages from iframe about loading state
    window.addEventListener('message', (event) => {
        if (event.data && (event.data.type === 'close-visualization-modal' || 
                          event.data.type === 'closeVisualization' || 
                          event.data.action === 'closeModal')) {
            closeVisualizationModal();
        } else if (event.data && event.data.type === 'loading-progress') {
            const loadingIndicator = document.getElementById('loading-indicator');
            const loadingText = document.getElementById('loading-text');
            const loadingDetails = document.getElementById('loading-details');
            
            if (event.data.show && loadingIndicator) {
                loadingIndicator.style.display = 'block';
                if (loadingText) loadingText.textContent = event.data.message || '';
                if (loadingDetails) loadingDetails.textContent = event.data.details || '';
            } else if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
        } else if (event.data && event.data.type === 'conversation-deleted') {
            // Handle conversation deletion notification from admin panel
            console.log('ğŸ—‘ï¸ Received conversation deletion notification:', event.data.folder);
            
            // Immediately refresh conversations to sync with admin changes
            setTimeout(async () => {
                await loadConversationConfig(true);
            }, 1000); // Small delay to ensure backend has finished processing
        } else if (event.data && event.data.type === 'refresh-conversations') {
            // Handle general refresh request from admin panel
            console.log('ğŸ”„ Received conversation refresh request from admin panel');
            
            setTimeout(async () => {
                await loadConversationConfig(true);
            }, 500);
        } else if (event.data && event.data.type === 'force-config-reload') {
            // Handle forced config reload (e.g., after conversation name change)
            console.log('ğŸ”„ Received force config reload request from admin panel');
            
            // Clear any cached data
            window.conversationDataGlobal = [];
            window.lastConfigUpdate = Date.now();
            
            setTimeout(async () => {
                await loadConversationConfig(true);
                console.log('âœ… Forced conversation config reload completed');
                
                // Force re-render the current layout to show updated names
                if (typeof window.renderNewLayout === 'function') {
                    console.log('ğŸ”„ Re-rendering layout with updated conversation names...');
                    await window.renderNewLayout(true);
                    console.log('âœ… Layout re-rendered with updated names');
                }
            }, 300);
        } else if (event.data && event.data.type === 'update-conversation-title') {
            // Handle specific conversation title update from admin panel
            console.log('ğŸ·ï¸ Received conversation title update from admin panel:', event.data);
            
            // Update conversation data in memory and refresh grid
            if (event.data.metadata && event.data.metadata.name && event.data.conversation) {
                console.log(`ğŸ”„ Updating conversation data for ${event.data.conversation} with name: ${event.data.metadata.name}`);
                
                // Update the conversation data in memory
                const conversationToUpdate = window.conversationDataGlobal.find(conv => conv.folder === event.data.conversation);
                if (conversationToUpdate) {
                    conversationToUpdate.displayName = event.data.metadata.name;
                    conversationToUpdate.metadata = { ...conversationToUpdate.metadata, ...event.data.metadata };
                    console.log(`âœ… Updated conversation data in memory for ${event.data.conversation}`);
                }
                
                // Update the data-conversation attribute for the grid item
                const gridItem = document.getElementById(`conv-item-${event.data.conversation}`);
                if (gridItem) {
                    gridItem.setAttribute('data-conversation', event.data.metadata.name);
                    console.log(`âœ… Updated grid item data-conversation attribute for ${event.data.conversation}`);
                }
                
                // If there's a currently visible hover panel for this conversation, update it
                const hoverPanel = document.getElementById('hover-info-panel');
                if (hoverPanel && hoverPanel.classList.contains('visible')) {
                    const titleElement = hoverPanel.querySelector('.hover-info-title');
                    if (titleElement && conversationToUpdate) {
                        // Update hover panel if it's showing this conversation
                        const panelText = titleElement.textContent;
                        if (panelText.includes(event.data.conversation) || panelText.includes(conversationToUpdate.displayName)) {
                            showHoverPanel(conversationToUpdate);
                            console.log(`âœ… Updated visible hover panel for ${event.data.conversation}`);
                        }
                    }
                }
                
                console.log(`âœ… Conversation title update completed for ${event.data.conversation}`);
            }
        } else if (event.data && (event.data.type === 'updateEmotions' || 
                                   event.data.type === 'reloadEmotionColors' || 
                                   event.data.type === 'forceVisualRefresh' ||
                                   event.data.type === 'emotionColorsUpdated')) {
            
            console.log('ğŸ¨ Received emotion color update from admin panel:', event.data.type);
            
            // Use the working test function that we know works
            setTimeout(() => {
                const success = window.testConversationColorUpdate();
                if (success) {
                    console.log('âœ… Successfully triggered conversation color update');
                } else {
                    console.log('â„¹ï¸ No conversations open to update');
                }
            }, 100);
        }
    });

    // ğŸ§ª TEST FUNCTION: Test ×˜×œ ××§×œ×¨ conversations grouping
    window.testTalMaklerGrouping = async function() {
        console.log('ğŸ§ª TESTING ×˜×œ ××§×œ×¨ conversations grouping...');
        
        try {
            // Force reload configuration
            console.log('ğŸ”„ Force reloading conversation config...');
            await loadConversationConfig(true);
            
            // Check ×˜×œ ××§×œ×¨ conversations
            const talMaklerConvos = window.conversationDataGlobal.filter(conv => 
                conv.metadata && (
                    (conv.metadata.mainParticipant && conv.metadata.mainParticipant.includes('×˜×œ ××§×œ×¨')) ||
                    (conv.metadata.customParticipantName && conv.metadata.customParticipantName.includes('×˜×œ ××§×œ×¨'))
                )
            );
            
            console.log(`ğŸ” Found ${talMaklerConvos.length} ×˜×œ ××§×œ×¨ conversations:`);
            talMaklerConvos.forEach(conv => {
                console.log(`  ğŸ“ ${conv.folder}: customParticipantName="${conv.metadata.customParticipantName}", mainParticipant="${conv.metadata.mainParticipant}"`);
            });
            
            // Test people view grouping
            if (talMaklerConvos.length > 0) {
                console.log('ğŸ¯ Testing people view grouping...');
                const positions = getPeopleViewPositions(window.conversationDataGlobal, document.getElementById('layout-canvas'));
                
                const talMaklerGroups = Object.entries(positions._personNames || []).filter(([name, data]) => 
                    name.includes('×˜×œ ××§×œ×¨') || data.name.includes('×˜×œ ××§×œ×¨')
                );
                
                console.log(`ğŸ‘¥ Found ${talMaklerGroups.length} ×˜×œ ××§×œ×¨ groups in people view`);
                talMaklerGroups.forEach(([name, data]) => {
                    console.log(`  ğŸ¯ Group "${data.name}": ${data.conversationCount} conversations`);
                });
            }
            
            return talMaklerConvos.length;
            
        } catch (error) {
            console.error('âŒ TEST FAILED:', error);
            return 0;
        }
    };

    // ğŸ§ª TEST FUNCTION: Test conversation name updates in index.html
    window.testIndexConversationNameUpdate = async function(conversationFolder = 'convo1', testName = null) {
        const uniqueTestName = testName || `Index Test ${Date.now()}`;
        console.log(`ğŸ§ª INDEX TEST: Testing conversation name update for ${conversationFolder} with name: "${uniqueTestName}"`);
        
        try {
            // Step 1: Find the conversation in memory
            const conversationToTest = window.conversationDataGlobal.find(conv => conv.folder === conversationFolder);
            if (!conversationToTest) {
                console.error(`âŒ Conversation ${conversationFolder} not found in conversationDataGlobal`);
                return false;
            }
            
            const originalName = conversationToTest.displayName;
            console.log(`ğŸ“ Original name: "${originalName}"`);
            
            // Step 2: Update the conversation data in memory
            conversationToTest.displayName = uniqueTestName;
            conversationToTest.metadata = { ...conversationToTest.metadata, name: uniqueTestName };
            
            // Step 3: Update the grid item data attribute
            const gridItem = document.getElementById(`conv-item-${conversationFolder}`);
            if (gridItem) {
                gridItem.setAttribute('data-conversation', uniqueTestName);
                console.log(`âœ… Updated grid item data attribute`);
            } else {
                console.warn(`âš ï¸ Grid item conv-item-${conversationFolder} not found`);
            }
            
            // Step 4: Test hover panel by simulating hover
            if (gridItem) {
                console.log(`ğŸ”„ Testing hover panel update...`);
                
                // Simulate mouseover to show hover panel
                const event = new MouseEvent('mouseover', { bubbles: true });
                gridItem.dispatchEvent(event);
                
                // Check if hover panel shows updated name
                setTimeout(() => {
                    const hoverPanel = document.getElementById('hover-info-panel');
                    if (hoverPanel && hoverPanel.classList.contains('visible')) {
                        const titleElement = hoverPanel.querySelector('.hover-info-title');
                        if (titleElement && titleElement.textContent.includes(uniqueTestName)) {
                            console.log(`âœ… Hover panel shows updated name: "${titleElement.textContent}"`);
                        } else {
                            console.error(`âŒ Hover panel does not show updated name. Shows: "${titleElement?.textContent}"`);
                        }
                    } else {
                        console.warn(`âš ï¸ Hover panel not visible`);
                    }
                    
                    // Hide hover panel
                    hideHoverPanel();
                    
                    // Step 5: Restore original name
                    conversationToTest.displayName = originalName;
                    conversationToTest.metadata = { ...conversationToTest.metadata, name: originalName };
                    if (gridItem) {
                        gridItem.setAttribute('data-conversation', originalName);
                    }
                    console.log(`âœ… Restored original name: "${originalName}"`);
                    console.log(`ğŸ‰ INDEX TEST COMPLETED`);
                }, 500);
                
                return true;
            } else {
                console.error(`âŒ Could not test hover panel - grid item not found`);
                return false;
            }
            
        } catch (error) {
            console.error('âŒ INDEX TEST FAILED:', error);
            return false;
        }
    };

    // Function to force update all open conversation visualizations
    // Test function that can be called from browser console
    window.testConversationColorUpdate = function() {
        console.log('ğŸ§ª TESTING: Conversation color update from console...');
        return window.forceUpdateAllConversationColors();
    };

    window.forceUpdateAllConversationColors = function() {
        console.log('ğŸ¨ FORCING UPDATE OF ALL CONVERSATION COLORS...');
        
        const modalContainer = document.getElementById('visualization-modal-container');
        if (modalContainer) {
            const iframe = modalContainer.querySelector('iframe');
            if (iframe && iframe.contentWindow) {
                try {
                    // Send multiple update messages
                    const messages = [
                        { type: 'reloadEmotionColors', timestamp: Date.now() },
                        { type: 'forceVisualRefresh', timestamp: Date.now() + 100 },
                        { type: 'forceCompleteReload', timestamp: Date.now() + 200 }
                    ];
                    
                    messages.forEach((message, index) => {
                        setTimeout(() => {
                            iframe.contentWindow.postMessage(message, '*');
                            console.log(`ğŸ“¤ Sent ${message.type} to conversation iframe`);
                        }, index * 300);
                    });
                    
                    // Try direct function call
                    setTimeout(() => {
                        try {
                            if (iframe.contentWindow.forceUpdateAllBlobColors) {
                                iframe.contentWindow.forceUpdateAllBlobColors();
                                console.log('ğŸ¨ Called forceUpdateAllBlobColors directly');
                            }
                        } catch (e) {
                            console.log('ğŸ¨ Direct function call failed:', e.message);
                        }
                    }, 1000);
                    
                    return true;
                } catch (e) {
                    console.warn('Could not update conversation iframe:', e);
                    return false;
                }
            } else {
                console.log('âŒ No conversation iframe found to update');
                return false;
            }
        } else {
            console.log('âŒ No modal container found');
            return false;
        }
    };

    // Listen for emotion color updates via BroadcastChannel
    try {
        const emotionBroadcastChannel = new BroadcastChannel('emotion-updates');
        emotionBroadcastChannel.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'emotionColorsUpdated') {
                console.log('ğŸ“» Received emotion color update via BroadcastChannel');
                
                // Automatically run the color update that we know works
                setTimeout(() => {
                    const success = window.testConversationColorUpdate();
                    if (success) {
                        console.log('âœ… Automatically updated conversation colors');
                    } else {
                        console.log('â„¹ï¸ No conversation open to update');
                    }
                }, 500);
            }
        });
        console.log('ğŸ“» BroadcastChannel listener setup for emotion updates');
    } catch (e) {
        console.log('ğŸ“» BroadcastChannel not available, using only postMessage');
    }

    function closeVisualizationModal() {
        const modalContainer = document.getElementById('visualization-modal-container');
        if (!modalContainer) return;
        
        // Prevent double closing
        if (modalContainer.dataset.closing === 'true') return;
        modalContainer.dataset.closing = 'true';
        
        // Get the currently open conversation folder from iframe
        const iframe = modalContainer.querySelector('iframe');
        let currentFolder = null;
        if (iframe) {
            const src = iframe.src;
            const folderMatch = src.match(/folder=([^&]+)/);
            if (folderMatch) {
                currentFolder = decodeURIComponent(folderMatch[1]);
            }
            
            // IMPORTANT: Stop all audio in the iframe before closing
            if (iframe.contentWindow) {
                try {
                    iframe.contentWindow.postMessage({
                        type: 'stop-all-audio',
                        reason: 'modal-close'
                    }, '*');
                    console.log(`ğŸ”‡ Stopping audio for ${currentFolder} before closing modal`);
                } catch (e) {
                    console.warn('Could not send stop-audio message to iframe on close:', e);
                }
            }
        }
        
        modalContainer.classList.remove('visible');
        hideExitTooltip(); // Hide tooltip when closing
        
        // Add zoom-out effect to the conversation item
        if (currentFolder) {
            const conversationItem = document.querySelector(`[id*="${currentFolder}"]`);
            if (conversationItem) {
                conversationItem.style.transition = 'transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                conversationItem.style.transform = 'scale(0.8)';
                conversationItem.style.zIndex = '100';
                
                setTimeout(() => {
                    conversationItem.style.transform = 'scale(1)';
                    conversationItem.style.zIndex = '2';
                    // Restore original transition
                    setTimeout(() => {
                        conversationItem.style.transition = 'all 1.8s cubic-bezier(0.165, 0.84, 0.44, 1)';
                    }, 500);
                }, 100);
            }
        }
        
        setTimeout(() => {
            modalContainer.style.display = 'none';
            modalContainer.innerHTML = '';
            modalContainer.dataset.closing = 'false';
        }, 150);
    }
    
    // Show exit tooltip
    function showExitTooltip() {
        const exitTooltip = document.getElementById('exit-tooltip');
        if (exitTooltip) {
            exitTooltip.classList.add('show');
        }
    }
    
    // Hide exit tooltip
    function hideExitTooltip() {
        const exitTooltip = document.getElementById('exit-tooltip');
        if (exitTooltip) {
            exitTooltip.classList.remove('show');
        }
    }
    
    // Add hover detection for modal container
    document.addEventListener('DOMContentLoaded', () => {
        const modalContainer = document.getElementById('visualization-modal-container');
        if (modalContainer) {
            let hoverTimeout;
            
            // Show tooltip when hovering on the dark overlay (not the iframe)
            modalContainer.addEventListener('mousemove', (event) => {
                // Check if mouse is on the overlay (not on the iframe)
                if (event.target === modalContainer) {
                    clearTimeout(hoverTimeout);
                    showExitTooltip();
                    
                    // Move modal down slightly when hovering outside
                    const iframe = modalContainer.querySelector('iframe');
                    if (iframe) {
                        iframe.style.transform = 'translateY(20px)';
                    }
                } else {
                    // Mouse is over the iframe
                    hideExitTooltip();
                    
                    // Reset modal position
                    const iframe = modalContainer.querySelector('iframe');
                    if (iframe) {
                        iframe.style.transform = 'translateY(0)';
                    }
                }
            });
            
            // Hide tooltip when leaving modal container
            modalContainer.addEventListener('mouseleave', () => {
                hideExitTooltip();
                
                // Reset modal position
                const iframe = modalContainer.querySelector('iframe');
                if (iframe) {
                    iframe.style.transform = 'translateY(0)';
                }
            });
        }
    });
    
    // Add escape key handler
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
            const modalContainer = document.getElementById('visualization-modal-container');
            if (modalContainer && modalContainer.classList.contains('visible')) {
                closeVisualizationModal();
            }
        }
    });
    
    // Add click handler to close modal when clicking outside
    document.addEventListener('click', (event) => {
        const modalContainer = document.getElementById('visualization-modal-container');
        if (modalContainer && modalContainer.classList.contains('visible')) {
            // Check if click is directly on the modal container (not its children)
            if (event.target === modalContainer) {
                closeVisualizationModal();
            }
        }
    });

    // Page switching functions
    function showConversationsPage() {
        document.getElementById('playground-container').style.display = 'none';
        document.getElementById('timeline-grid-wrapper').style.display = 'block';
        
        console.log('ğŸ“„ Switched to conversations page');
    }
    
    // Open live visualization in new window/tab
    function openLiveVisualization() {
        console.log('ğŸ¬ Opening Live Visualization...');
        
        // Open in new window for better performance
        const liveVizWindow = window.open(
            'live_visualization.html',
            'LiveVisualization',
            'width=1200,height=800,scrollbars=no,resizable=yes,status=no,toolbar=no,menubar=no'
        );
        
        if (liveVizWindow) {
            // Send start message after window loads
            setTimeout(() => {
                try {
                    liveVizWindow.postMessage({ type: 'start-live-visualization' }, '*');
                } catch (error) {
                    console.log('Could not send start message to live visualization window');
                }
            }, 1000);
        } else {
            // Fallback: open in same window if popup blocked
            window.location.href = 'live_visualization.html';
        }
    }
    
    // Make function globally available
    window.openLiveVisualization = openLiveVisualization;
    
        // Conversation Wizard functions
    function showConversationWizardAndStartRecording() {
        try {
            console.log('ğŸ”„ Starting showConversationWizardAndStartRecording...');
            
            // First show the conversation wizard
            showConversationWizard();
            
            // Wait for the iframe to load, then show the grid first
            setTimeout(() => {
                const wizardIframe = document.getElementById('conversation-wizard-iframe');
                if (wizardIframe && wizardIframe.contentWindow) {
                    try {
                        // Call the showGrid function in the iframe to show the placeholder grid
                        wizardIframe.contentWindow.showGrid();
                        console.log('âœ… Started with grid page in wizard');
                    } catch (error) {
                        console.error('âŒ Error showing grid in wizard:', error);
                    }
                } else {
                    console.error('âŒ Wizard iframe not ready yet');
                }
            }, 1000); // Wait 1 second for iframe to load
            
        } catch (error) {
            console.error('âŒ Error in showConversationWizardAndStartRecording:', error);
        }
    }
    
    function showConversationWizardAndGoToMicrophone() {
        try {
            console.log('ğŸ”„ Starting showConversationWizardAndGoToMicrophone...');
            
            // First show the conversation wizard
            showConversationWizard();
            
            // Wait for the iframe to load, then go directly to microphone interface
            setTimeout(() => {
                const wizardIframe = document.getElementById('conversation-wizard-iframe');
                if (wizardIframe && wizardIframe.contentWindow) {
                    try {
                        // Call the showQuestionnaire function in the iframe to go directly to microphone
                        wizardIframe.contentWindow.showQuestionnaire();
                        console.log('âœ… Started with microphone interface in wizard');
                    } catch (error) {
                        console.error('âŒ Error starting microphone interface:', error);
                    }
                } else {
                    console.error('âŒ Wizard iframe not ready yet');
                }
            }, 1000); // Wait 1 second for iframe to load
            
        } catch (error) {
            console.error('âŒ Error in showConversationWizardAndGoToMicrophone:', error);
        }
    }
    
    function showConversationWizard() {
        try {
            console.log('ğŸ”„ Starting showConversationWizard...');
            
            const wizardPage = document.getElementById('conversation-wizard-page');
            const wizardIframe = document.getElementById('conversation-wizard-iframe');
            const aboutPage = document.getElementById('about-page');
            const emotionsPage = document.getElementById('emotions-page');
            const mainContent = document.getElementById('timeline-grid-wrapper');
            const bottomControls = document.getElementById('bottom-controls-container');
            
            // Reset conversation wizard to grid page
            if (wizardIframe && wizardIframe.contentWindow && typeof wizardIframe.contentWindow.showGrid === 'function') {
                try {
                    console.log('ğŸ”„ Resetting conversation wizard to grid page...');
                    wizardIframe.contentWindow.showGrid();
                } catch (error) {
                    console.log('âš ï¸ Could not reset wizard state (iframe not ready):', error.message);
                }
            }
            
            console.log('ğŸ” Element check:');
            console.log('  - wizardPage:', !!wizardPage);
            console.log('  - wizardIframe:', !!wizardIframe);
            console.log('  - aboutPage:', !!aboutPage);
            console.log('  - mainContent:', !!mainContent);
            console.log('  - bottomControls:', !!bottomControls);
            
            // Hide other pages
            if (aboutPage && aboutPage.style.display === 'block') {
                aboutPage.style.display = 'none';
                console.log('âœ… Hidden about page');
            }
            
            if (emotionsPage && emotionsPage.style.display === 'block') {
                emotionsPage.style.display = 'none';
                console.log('âœ… Hidden emotions page');
            }
            
            if (mainContent) {
                mainContent.style.display = 'none';
                console.log('âœ… Hidden main content');
            } else {
                console.error('âŒ Main content element not found');
            }
            
            if (bottomControls) {
                bottomControls.style.display = 'none';
                bottomControls.style.visibility = 'hidden';
                console.log('âœ… Hidden bottom controls');
            } else {
                console.error('âŒ Bottom controls element not found');
            }
            
            // Show wizard page
            if (wizardPage && wizardIframe) {
                console.log('ğŸ“¦ Showing wizard page...');
                wizardPage.style.display = 'block';
                
                // Check current iframe src
                console.log('ğŸ”— Current iframe src:', wizardIframe.src);
                
                // Load the wizard iframe if not already loaded
                const expectedSrc = window.location.origin + '/frontend/conversation_wizard.html';
                if (!wizardIframe.src || wizardIframe.src === '' || wizardIframe.src !== expectedSrc) {
                    console.log('ğŸ“¡ Loading conversation wizard iframe:', expectedSrc);
                    wizardIframe.src = expectedSrc;
                    
                    // Add load event listener
                    wizardIframe.onload = function() {
                        console.log('âœ… Wizard iframe loaded successfully');
                        // Ensure wizard starts in grid state
                        setTimeout(() => {
                            if (wizardIframe.contentWindow && typeof wizardIframe.contentWindow.showGrid === 'function') {
                                try {
                                    console.log('ğŸ”„ Ensuring wizard starts in grid state...');
                                    wizardIframe.contentWindow.showGrid();
                                } catch (error) {
                                    console.log('âš ï¸ Could not reset wizard state on load:', error.message);
                                }
                            }
                        }, 100);
                    };
                    
                    wizardIframe.onerror = function() {
                        console.error('âŒ Wizard iframe failed to load');
                    };
                } else {
                    console.log('ğŸ“¡ Wizard iframe already loaded');
                }
                
                console.log('âœ… Shown conversation wizard container');
            } else {
                console.error('âŒ Conversation wizard elements not found - wizardPage:', !!wizardPage, 'wizardIframe:', !!wizardIframe);
                return;
            }
            
            // Update navigation active state
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active-nav');
            });
            // Find and activate the wizard navigation link
            const wizardLink = document.querySelector('.nav-link[onclick*="showConversationWizard"]');
            if (wizardLink) {
                wizardLink.classList.add('active-nav');
                console.log('âœ… Updated navigation to conversation wizard');
            } else {
                console.error('âŒ Conversation wizard navigation link not found');
            }
            
            // Show the new conversation button
            const newConversationBtn = document.getElementById('new-conversation-btn');
            if (newConversationBtn) {
                newConversationBtn.style.display = 'block';
                console.log('âœ… Showed new conversation button');
            } else {
                console.error('âŒ New conversation button not found');
            }
            
            console.log('âœ… showConversationWizard completed successfully');
        } catch (error) {
            console.error('âŒ Error in showConversationWizard:', error);
            console.error('âŒ Error stack:', error.stack);
        }
    }

    // About page functions
    function showAboutPage() {
        try {
            console.log('ğŸ”„ Showing about page...');
            const aboutPage = document.getElementById('about-page');
            const wizardPage = document.getElementById('conversation-wizard-page');
            const emotionsPage = document.getElementById('emotions-page');
            const mainContent = document.getElementById('timeline-grid-wrapper');
            const bottomControls = document.getElementById('bottom-controls-container');
            
            // Hide wizard page if it's visible
            if (wizardPage && wizardPage.style.display === 'block') {
                wizardPage.style.display = 'none';
                console.log('âœ… Hidden conversation wizard');
            }
            
            // Hide emotions page if it's visible
            if (emotionsPage && emotionsPage.style.display === 'block') {
                emotionsPage.style.display = 'none';
                console.log('âœ… Hidden emotions page');
            }
            
            if (aboutPage) {
                aboutPage.style.display = 'block';
                console.log('âœ… Shown about page');
                
                if (mainContent) {
                    mainContent.style.display = 'none';
                    console.log('âœ… Hidden main content');
                } else {
                    console.error('âŒ Main content element not found');
                }
                
                if (bottomControls) {
                    bottomControls.style.display = 'none';
                    bottomControls.style.visibility = 'hidden';
                    console.log('âœ… Hidden bottom controls');
                } else {
                    console.error('âŒ Bottom controls element not found');
                }
                
                // Keep navigation visible by not hiding the header
                // The header will remain visible since we're not hiding it
                
                // Update navigation active state
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active-nav');
                });
                // Find and activate the about page navigation link
                const aboutLink = document.querySelector('.nav-link[onclick*="showAboutPage"]');
                if (aboutLink) {
                    aboutLink.classList.add('active-nav');
                    console.log('âœ… Updated navigation to about page');
                } else {
                    console.error('âŒ About page navigation link not found');
                }
                
                // Hide the new conversation button
                const newConversationBtn = document.getElementById('new-conversation-btn');
                if (newConversationBtn) {
                    newConversationBtn.style.display = 'none';
                    console.log('âœ… Hidden new conversation button');
                }
                console.log('âœ… About page shown successfully');
            } else {
                console.error('âŒ About page element not found');
            }
        } catch (error) {
            console.error('âŒ Error in showAboutPage:', error);
        }
    }
    

    

    

    
    // Function to recalculate emotions grid layout on resize
    function recalculateEmotionsGrid() {
        const emotionsGrid = document.getElementById('emotions-grid');
        const emotionsPageContainer = document.getElementById('emotions-page');
        
        if (!emotionsGrid || !emotionsPageContainer || emotionsPageContainer.style.display === 'none') {
            return;
        }
        
        const emotionCards = emotionsGrid.querySelectorAll('.emotion-emoji-card');
        if (emotionCards.length === 0) return;
        
        // Get available dimensions
        const containerHeight = emotionsPageContainer.clientHeight - 20;
        const gridContainer = emotionsGrid.parentElement;
        const gridWidth = gridContainer.clientWidth - 10;
        const gridHeight = containerHeight;
        
        // Calculate optimal grid configuration
        const emotionCount = emotionCards.length;
        const aspectRatio = gridWidth / gridHeight;
        
        // Find optimal columns and rows to fit all emotions
        let optimalCols = Math.ceil(Math.sqrt(emotionCount * aspectRatio));
        let optimalRows = Math.ceil(emotionCount / optimalCols);
        
        // Ensure grid fits within available space
        const minItemSize = 25;
        const maxItemSize = 50;
        
        const itemSizeByWidth = Math.min(maxItemSize, Math.max(minItemSize, (gridWidth - (optimalCols - 1) * 2) / optimalCols));
        const itemSizeByHeight = Math.min(maxItemSize, Math.max(minItemSize, (gridHeight - (optimalRows - 1) * 2) / optimalRows));
        
        const finalItemSize = Math.min(itemSizeByWidth, itemSizeByHeight);
        
        // Recalculate columns based on final item size
        optimalCols = Math.floor(gridWidth / (finalItemSize + 2));
        optimalRows = Math.ceil(emotionCount / optimalCols);
        
        // Ensure we don't exceed available height
        while (optimalRows * (finalItemSize + 2) > gridHeight && optimalCols < emotionCount) {
            optimalCols++;
            optimalRows = Math.ceil(emotionCount / optimalCols);
        }
        
        // Apply calculated grid layout
        emotionsGrid.style.gridTemplateColumns = `repeat(${optimalCols}, ${finalItemSize}px)`;
        emotionsGrid.style.gridTemplateRows = `repeat(${optimalRows}, ${finalItemSize}px)`;
        
        // Update emotion card sizes
        emotionCards.forEach(card => {
            card.style.width = `${finalItemSize}px`;
            card.style.height = `${finalItemSize}px`;
            card.style.minHeight = `${finalItemSize}px`;
            card.style.fontSize = `${Math.max(12, finalItemSize * 0.4)}px`;
        });
        
        // Also adjust emotions labels list to fit without scrolling
        const emotionsLabels = document.getElementById('emotions-labels');
        const emotionsLabelsList = document.getElementById('emotions-labels-list');
        if (emotionsLabels && emotionsLabelsList) {
            const labelItems = emotionsLabelsList.querySelectorAll('.emotion-label-item');
            if (labelItems.length > 0) {
                const availableHeight = emotionsLabels.clientHeight - 50; // Account for header
                const itemsCount = labelItems.length;
                const maxItemHeight = Math.max(30, Math.floor(availableHeight / itemsCount) - 2); // 2px for gap
                
                labelItems.forEach(item => {
                    if (maxItemHeight < 40) {
                        // Compact mode for many emotions
                        item.style.padding = '4px 8px';
                        item.style.fontSize = '10px';
                        const spans = item.querySelectorAll('span');
                        spans.forEach((span, index) => {
                            if (index === 0) span.style.fontSize = '12px'; // emoji
                            if (index === 1) span.style.fontSize = '10px'; // Hebrew text
                        });
                    } else {
                        // Normal mode
                        item.style.padding = '8px 12px';
                        item.style.fontSize = '12px';
                    }
                });
            }
        }
    }
    
    // Function to show emotion sidebar with detailed information
    function showEmotionSidebar(emotionKey, emotionConfig, popularityData) {
        const sidebar = document.getElementById('emotions-sidebar');
        const title = document.getElementById('emotion-sidebar-title');
        const subtitle = document.getElementById('emotion-sidebar-subtitle');
        
        if (!sidebar || !title || !subtitle) return;
        
        // Store current emotion for use in other functions
        currentSelectedEmotion = emotionKey;
        
        // Update header
        title.innerHTML = `${emotionConfig.emoji} ${emotionConfig.hebrew}`;
        subtitle.innerHTML = popularityData ? `×“×™×¨×•×’ ${popularityData.rank} ××ª×•×š ${Object.keys(emotionAnalysisData.emotions).length}` : '×œ×œ× × ×ª×•× ×™×';
        
        // Show sidebar
        sidebar.style.display = 'flex';
        
        // Hide the emotions labels panel when detailed sidebar is shown
        const emotionsLabels = document.getElementById('emotions-labels');
        if (emotionsLabels) {
            emotionsLabels.style.display = 'none';
        }
        
        // Adjust main pyramid container to full width when sidebar is shown
        const emotionsPyramidContainer = document.querySelector('#emotions-page > div > div:first-child');
        if (emotionsPyramidContainer) {
            emotionsPyramidContainer.style.maxWidth = '100%';
            emotionsPyramidContainer.style.paddingRight = '35%';
        }
        
        // Reset to stats tab
        document.querySelectorAll('.emotion-sidebar-tab').forEach(t => {
            t.classList.remove('active');
            t.style.color = '#6c757d';
            t.style.borderBottomColor = 'transparent';
            t.style.fontWeight = '500';
        });
        document.querySelectorAll('.emotion-tab-content').forEach(content => {
            content.style.display = 'none';
        });
        
        // Activate stats tab
        const statsTab = document.querySelector('.emotion-sidebar-tab[data-tab="stats"]');
        const statsContent = document.getElementById('emotion-stats-content');
        if (statsTab && statsContent) {
            statsTab.classList.add('active');
            statsTab.style.color = '#2c3e50';
            statsTab.style.borderBottomColor = '#171717';
            statsTab.style.fontWeight = '600';
            statsContent.style.display = 'block';
        }
        
        // Load initial tab content
        loadEmotionStats(emotionKey, emotionConfig, popularityData);
        
        console.log('âœ… Emotion sidebar shown for:', emotionKey);
    }
    
    // Function to set up sidebar event handlers
    function setupEmotionSidebar() {
        // Tab switching
        document.querySelectorAll('.emotion-sidebar-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs
                document.querySelectorAll('.emotion-sidebar-tab').forEach(t => {
                    t.classList.remove('active');
                    t.style.color = '#6c757d';
                    t.style.borderBottomColor = 'transparent';
                    t.style.fontWeight = '500';
                });
                
                // Hide all tab contents
                document.querySelectorAll('.emotion-tab-content').forEach(content => {
                    content.style.display = 'none';
                });
                
                // Activate clicked tab
                tab.classList.add('active');
                tab.style.color = '#2c3e50';
                tab.style.borderBottomColor = '#171717';
                tab.style.fontWeight = '600';
                
                // Show corresponding content
                const tabId = tab.getAttribute('data-tab');
                const content = document.getElementById(`emotion-${tabId}-content`);
                if (content) {
                    content.style.display = 'block';
                }
                
                // Load tab-specific content
                const activeEmotion = document.getElementById('emotion-sidebar-title').textContent.split(' ').slice(1).join(' ');
                loadEmotionTabContent(tabId, activeEmotion);
            });
        });
        
        // Close button
        const closeBtn = document.getElementById('emotions-sidebar-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                const sidebar = document.getElementById('emotions-sidebar');
                if (sidebar) {
                    sidebar.style.display = 'none';
                    
                    // Restore emotions labels panel
                    const emotionsLabels = document.getElementById('emotions-labels');
                    if (emotionsLabels) {
                        emotionsLabels.style.display = 'block';
                    }
                    
                    // Restore pyramid container to original state
                    const emotionsPyramidContainer = document.querySelector('#emotions-page > div > div:first-child');
                    if (emotionsPyramidContainer) {
                        emotionsPyramidContainer.style.maxWidth = '60%';
                        emotionsPyramidContainer.style.paddingRight = '0';
                    }
                }
            });
        }
    }
    
    // Function to load emotion statistics
    function loadEmotionStats(emotionKey, emotionConfig, popularityData) {
        const statsContainer = document.getElementById('emotion-stats-data');
        if (!statsContainer) return;
        
        if (!popularityData) {
            statsContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">××™×Ÿ × ×ª×•× ×™× ×–××™× ×™×</div>';
            return;
        }
        
        const totalEmotions = emotionAnalysisData.totalEmotions;
        const totalConversations = emotionAnalysisData.totalConversations;
        
        statsContainer.innerHTML = `
            <div style="text-align: center; margin-bottom: 20px;">
                <div style="font-size: 32px; margin-bottom: 10px;">${emotionConfig.emoji}</div>
                <div style="font-size: 18px; font-weight: 600; color: #2c3e50; margin-bottom: 5px;">${emotionConfig.hebrew}</div>
                <div style="font-size: 14px; color: #6c757d;">×“×™×¨×•×’ ${popularityData.rank}</div>
            </div>
            
            <div style="background: white; border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid #e0e0e0;">
                <div style="font-size: 14px; font-weight: 600; color: #2c3e50; margin-bottom: 10px;">×¡×˜×˜×™×¡×˜×™×§×•×ª ×›×œ×œ×™×•×ª</div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span style="color: #6c757d;">×¡×”"×› ×”×•×¤×¢×•×ª:</span>
                    <span style="font-weight: 600;">${popularityData.count}</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span style="color: #6c757d;">××—×•×– ××›×œ×œ ×”×¨×’×©×•×ª:</span>
                    <span style="font-weight: 600;">${popularityData.percentage}%</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #6c757d;">×©×™×—×•×ª ×¢× ×”×¨×’×©:</span>
                    <span style="font-weight: 600;">${popularityData.conversationCount} ××ª×•×š ${totalConversations}</span>
                </div>
            </div>
            
            <div style="background: white; border-radius: 8px; padding: 15px; border: 1px solid #e0e0e0;">
                <div style="font-size: 14px; font-weight: 600; color: #2c3e50; margin-bottom: 10px;">×”×ª×¤×œ×’×•×ª</div>
                <div style="background: #f8f9fa; border-radius: 4px; padding: 10px;">
                    <div style="width: 100%; height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden;">
                        <div style="width: ${popularityData.percentage}%; height: 100%; background: ${emotionConfig.color}; transition: width 0.3s ease;"></div>
                    </div>
                    <div style="font-size: 12px; color: #6c757d; margin-top: 5px; text-align: center;">${popularityData.percentage}% ××›×œ×œ ×”×¨×’×©×•×ª</div>
                </div>
            </div>
        `;
    }
    
    // Function to load tab-specific content
    function loadEmotionTabContent(tabId, emotionHebrew) {
        if (tabId === 'conversations') {
            loadEmotionConversations(emotionHebrew);
        } else if (tabId === 'insights') {
            loadEmotionInsights(emotionHebrew);
        }
    }
    
    // Global variable to store current selected emotion for sidebar
    let currentSelectedEmotion = null;
    
    // Function to load conversations containing this emotion
    function loadEmotionConversations(emotionHebrew) {
        const conversationsContainer = document.getElementById('emotion-conversations-data');
        if (!conversationsContainer || !emotionAnalysisData || !currentSelectedEmotion) return;
        
        const emotionData = emotionAnalysisData.emotions[currentSelectedEmotion.toLowerCase()];
        
        if (!emotionData) {
            conversationsContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">×œ× × ××¦××• ×©×™×—×•×ª</div>';
            return;
        }
        
        const conversations = emotionData.conversations || [];
        
        if (conversations.length === 0) {
            conversationsContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">×œ× × ××¦××• ×©×™×—×•×ª</div>';
            return;
        }
        
        let conversationsHtml = '';
        conversations.forEach(convoId => {
            const details = emotionAnalysisData.conversationDetails[convoId];
            const title = details?.participants || convoId;
            const date = details?.date || '×œ× ×™×“×•×¢';
            
            conversationsHtml += `
                <div style="background: white; border-radius: 8px; padding: 15px; margin-bottom: 10px; border: 1px solid #e0e0e0; cursor: pointer;" onclick="openConversation('${convoId}')">
                    <div style="font-weight: 600; color: #2c3e50; margin-bottom: 5px;">${title}</div>
                    <div style="font-size: 12px; color: #6c757d;">×ª××¨×™×š: ${date}</div>
                    <div style="font-size: 12px; color: #6c757d;">××–×”×”: ${convoId}</div>
                </div>
            `;
        });
        
        conversationsContainer.innerHTML = conversationsHtml;
    }
    
    // Function to load emotion insights
    function loadEmotionInsights(emotionHebrew) {
        const insightsContainer = document.getElementById('emotion-insights-data');
        if (!insightsContainer) return;
        
        // Generate insights based on emotion data
        insightsContainer.innerHTML = `
            <div style="background: white; border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid #e0e0e0;">
                <div style="font-size: 14px; font-weight: 600; color: #2c3e50; margin-bottom: 10px;">×ª×•×‘× ×•×ª ×¢×œ ×”×¨×’×©</div>
                <div style="font-size: 13px; color: #555; line-height: 1.5;">
                    ×”×¨×’×© "${emotionHebrew}" ××•×¤×™×¢ ×‘×“×¤×•×¡×™× ××¢× ×™×™× ×™× ×‘××”×œ×š ×”×©×™×—×•×ª. 
                    × ×™×ª×Ÿ ×œ×¨××•×ª ××ª ×”×”×©×¤×¢×” ×©×œ×• ×¢×œ ×”×“×™× ××™×§×” ×”×›×œ×œ×™×ª ×©×œ ×”×©×™×—×”.
                </div>
            </div>
            
            <div style="background: white; border-radius: 8px; padding: 15px; border: 1px solid #e0e0e0;">
                <div style="font-size: 14px; font-weight: 600; color: #2c3e50; margin-bottom: 10px;">×”××œ×¦×•×ª</div>
                <div style="font-size: 13px; color: #555; line-height: 1.5;">
                    â€¢ ×©×™××• ×œ×‘ ×œ×ª×“×™×¨×•×ª ×”×•×¤×¢×ª ×”×¨×’×©<br>
                    â€¢ ×‘×“×§×• ×§×©×¨×™× ×œ×¨×’×©×•×ª ××—×¨×™×<br>
                    â€¢ × ×ª×—×• ××ª ×”×”×§×©×¨ ×©×œ ×”×©×™×—×•×ª
                </div>
            </div>
        `;
    }
    
    // Function to open a specific conversation
    function openConversation(convoId) {
        // Close the emotions page and open the conversation
        hideEmotionsPage();
        
        // Navigate to the specific conversation in the main view
        if (typeof window.loadConversation === 'function') {
            window.loadConversation(convoId);
        } else {
            console.log('ğŸ“– Open conversation:', convoId);
        }
    }
    
    // Function to hide emotions page and return to main view
    function hideEmotionsPage() {
        const emotionsPage = document.getElementById('emotions-page');
        const mainContent = document.getElementById('timeline-grid-wrapper');
        const bottomControls = document.getElementById('bottom-controls-container');
        
        if (emotionsPage) {
            emotionsPage.style.display = 'none';
            console.log('âœ… Hidden emotions page');
        }
        
            if (mainContent) {
                mainContent.style.display = 'block';
            console.log('âœ… Shown main content');
            }
            
            if (bottomControls) {
                bottomControls.style.display = 'flex';
                bottomControls.style.visibility = 'visible';
            console.log('âœ… Shown bottom controls');
        }
        
        // Update navigation active state back to conversations
        document.querySelectorAll('.nav-link').forEach(link => {
            link.classList.remove('active-nav');
        });
        const conversationsLink = document.querySelector('.nav-link[onclick*="showConversationsPage"]');
        if (conversationsLink) {
            conversationsLink.classList.add('active-nav');
            console.log('âœ… Updated navigation back to conversations');
        }
    }
    
    // Function to set up navigation event handlers for emotions page
    function setupEmotionsPageNavigation() {
        console.log('ğŸ”„ Emotions page navigation setup - using main header navigation');
        // Since we removed the bottom navigation buttons from emotions page,
        // navigation now happens through the main header navigation
        // No additional setup needed - main navigation handlers will work
        console.log('âœ… Emotions page navigation relies on main header navigation');
    }
    
    // Function to show timeline view
    function showTimelineView() {
        console.log('ğŸ”„ Switching to timeline view');
        const previousLayout = window.activeLayout;
        window.activeLayout = 'timeline';
        console.log(`ğŸ“… DEBUG: activeLayout set to ${window.activeLayout}`);
        
        // CONDITIONAL FIX: Only clear timeline cache when switching FROM other views TO timeline
        // This preserves timeline layout integrity when already in timeline view
        if (previousLayout && previousLayout !== 'timeline' && layoutPositions && layoutPositions.timeline) {
            console.log(`ğŸ—‘ï¸ Clearing cached timeline positions due to switch from ${previousLayout} to timeline`);
            layoutPositions.timeline = null;
        } else if (previousLayout === 'timeline') {
            console.log('âœ… Already in timeline view - preserving cached positions');
        }
        
        // Reset isotope instances only when coming from other views
        if (previousLayout && previousLayout !== 'timeline') {
            const layoutCanvas = document.getElementById('layout-canvas');
            if (layoutCanvas && layoutCanvas.isotope) {
                console.log('ğŸ§¹ Destroying isotope instance before timeline view');
                layoutCanvas.isotope.destroy();
            }
        }
        
        // Update view toggle buttons
        document.querySelectorAll('.view-toggle-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.getElementById('timeline-view-btn')?.classList.add('active');
        
        // Trigger layout rendering with small delay to ensure CSS classes are applied
        setTimeout(() => {
            // ADDITIONAL CLEANUP: Ensure body classes are clean before timeline calculation
            if (previousLayout === 'emotions') {
                document.body.classList.remove('layout-emotions');
                document.body.className = 'layout-timeline';
                console.log('ğŸ­â¡ï¸ğŸ“… Final body class cleanup for emotionsâ†’timeline transition');
                
                // Force another reflow after body class change
                const layoutCanvas = document.getElementById('layout-canvas');
                if (layoutCanvas) {
                    layoutCanvas.offsetHeight;
                    console.log(`ğŸ“ Post-cleanup canvas dimensions: ${layoutCanvas.offsetWidth}x${layoutCanvas.offsetHeight}`);
                }
            }
            
            // Ensure conversation data is loaded before rendering timeline
            if (!window.originalConversationData || window.originalConversationData.length === 0) {
                console.log('ğŸ“… Timeline view: Waiting for conversation data to load...');
                
                // Wait for data to be loaded
                const waitForData = () => {
                    if (window.originalConversationData && window.originalConversationData.length > 0) {
                        console.log('ğŸ“… Timeline view: Conversation data loaded, rendering layout');
                        if (typeof window.renderNewLayout === 'function') {
                            window.renderNewLayout(false);
                        }
                    } else {
                        setTimeout(waitForData, 100); // Check again in 100ms
                    }
                };
                waitForData();
            } else {
                if (typeof window.renderNewLayout === 'function') {
                    window.renderNewLayout(false);
                }
            }
            
            // Ensure timeline date labels exist after render
            setTimeout(() => {
                const existingLabels = document.querySelectorAll('.timeline-date-label-protected');
                if (existingLabels.length === 0 && window.activeLayout === 'timeline') {
                    console.log('ğŸ“… Timeline labels missing after view switch - forcing re-render');
                    if (layoutPositions && layoutPositions.timeline) {
                        layoutPositions.timeline = null; // Clear cache to force recreation
                    }
                    if (window.originalConversationData && window.originalConversationData.length > 0) {
                        window.renderNewLayout(false); // Re-render to recreate labels
                    }
                }
            }, 200);
        }, 50); // Small delay to ensure CSS has fully applied
    }
    
    // Function to show people view
    function showPeopleView() {
        console.log('ğŸ”„ Switching to people view');
        window.activeLayout = 'people';
        
        // Update view toggle buttons
        document.querySelectorAll('.view-toggle-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.getElementById('people-view-btn')?.classList.add('active');
        
        // Trigger layout rendering
        if (typeof window.renderNewLayout === 'function') {
            window.renderNewLayout(false);
        }
    }
    
    // Reusable function to reset conversations to fresh state
    async function resetConversationsToFreshState() {
        console.log('ğŸ”„ Resetting conversations to fresh state like page refresh...');
        
        // Reset to timeline view (default state)
        window.activeLayout = 'timeline';
        
        // Reset view toggle buttons to timeline
        document.querySelectorAll('.view-toggle-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.getElementById('timeline-view-btn')?.classList.add('active');
        
        // Reset camera/zoom state
        if (typeof window.resetCamera === 'function') {
            window.resetCamera();
        }
        
        // Complete reset of all state variables
        if (window.layoutPositions) {
            window.layoutPositions = {
                timeline: {},
                people: {},
                emotions: {}
            };
        }
        
        // FORCE CLEAR EMOTIONS CACHE: Ensure emotions layout is always fresh
        console.log('ğŸ­ Clearing emotions cache for fresh layout calculation');
        
        // Reset layout rendering flag
        if (typeof window.isLayoutRendering !== 'undefined') {
            window.isLayoutRendering = false;
        }
        
        // Clear any timeouts
        if (window.layoutRenderTimeout) {
            clearTimeout(window.layoutRenderTimeout);
            window.layoutRenderTimeout = null;
        }
        
        // Reset body classes
        document.body.className = '';
        
        // Reset layout canvas completely
        const layoutCanvas = document.getElementById('layout-canvas');
        if (layoutCanvas) {
            // Preserve timeline date labels if we're in timeline view
            const existingLabels = layoutCanvas.querySelectorAll('.timeline-date-label-protected');
            const savedLabels = Array.from(existingLabels).map(label => label.cloneNode(true));
            
            // Clear all styles and classes
            layoutCanvas.className = '';
            layoutCanvas.style.cssText = '';
            layoutCanvas.innerHTML = '';
            
            // Restore timeline date labels if we were preserving them
            if (window.activeLayout === 'timeline') {
                savedLabels.forEach(label => layoutCanvas.appendChild(label));
            }
            
            // Force proper canvas height
            layoutCanvas.style.setProperty('height', 'calc(100vh - 120px)', 'important');
            layoutCanvas.style.setProperty('min-height', '800px', 'important');
            layoutCanvas.style.setProperty('overflow-y', 'auto', 'important');
            layoutCanvas.style.setProperty('overflow-x', 'hidden', 'important');
            layoutCanvas.style.setProperty('scrollbar-width', 'none', 'important');
            layoutCanvas.style.setProperty('-ms-overflow-style', 'none', 'important');
            layoutCanvas.style.setProperty('position', 'relative', 'important');
            
            // Force reflow
            layoutCanvas.offsetHeight;
        }
        
        // Reset grid container classes
        const gridContainer = document.getElementById('timeline-axes-container');
        if (gridContainer) {
            gridContainer.className = '';
        }
        
        // CRITICAL: Use populateConversationGrid like initial page load
        if (window.populateConversationGrid) {
            console.log('ğŸ¬ Running complete conversation grid population like page load...');
            setTimeout(async () => {
                try {
                    await window.populateConversationGrid();
                    console.log('âœ… Fresh conversation grid populated successfully');
                } catch (error) {
                    console.error('âŒ Error during conversation grid population:', error);
                    // Fallback to renderNewLayout
                    if (window.renderNewLayout) {
                        window.renderNewLayout(true);
                    }
                }
            }, 100);
        } else if (window.renderNewLayout) {
            console.log('ğŸ¬ Fallback: Using renderNewLayout...');
            setTimeout(() => {
                window.renderNewLayout(true);
            }, 100);
        }
        
        console.log('âœ… Conversations reset to fresh state initiated');
    }

    async function hideAboutPage() {
        console.log('ğŸ”„ Hiding about page and returning to conversations...');
        // Simply call showConversationsPage which will handle everything
        await showConversationsPage();
    }
    
    // Enhanced showConversationsPage function with fresh state reset
    async function showConversationsPage() {
        try {
            console.log('ğŸ”„ Starting showConversationsPage...');
            
            const aboutPage = document.getElementById('about-page');
            const wizardPage = document.getElementById('conversation-wizard-page');
            const mainContent = document.getElementById('timeline-grid-wrapper');
            const bottomControls = document.getElementById('bottom-controls-container');
            
            // Hide about page if it's visible
            if (aboutPage && aboutPage.style.display === 'block') {
                aboutPage.style.display = 'none';
                console.log('âœ… Hidden about page');
            }
            
            // Hide wizard page if it's visible
            if (wizardPage && wizardPage.style.display === 'block') {
                wizardPage.style.display = 'none';
                console.log('âœ… Hidden conversation wizard');
            }
            
            // Hide about page if it's visible
            if (aboutPage && aboutPage.style.display === 'block') {
                aboutPage.style.display = 'none';
                console.log('âœ… Hidden about page');
            }
            
            // Show main content
            if (mainContent) {
                mainContent.style.display = 'block';
                console.log('âœ… Shown main content from showConversationsPage');
            } else {
                console.error('âŒ Main content element not found');
            }
            
            if (bottomControls) {
                bottomControls.style.display = 'flex';
                bottomControls.style.visibility = 'visible';
                console.log('âœ… Shown bottom controls from showConversationsPage');
            } else {
                console.error('âŒ Bottom controls element not found');
            }
            
            // Update navigation active state first
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active-nav');
            });
            // Find and activate the conversations navigation link
            const conversationsLink = document.querySelector('.nav-link[onclick*="showConversationsPage"]');
            if (conversationsLink) {
                conversationsLink.classList.add('active-nav');
                console.log('âœ… Updated navigation state');
            } else {
                console.error('âŒ Conversations navigation link not found');
            }
            
            // Hide the new conversation button
            const newConversationBtn = document.getElementById('new-conversation-btn');
            if (newConversationBtn) {
                newConversationBtn.style.display = 'none';
                console.log('âœ… Hidden new conversation button');
            }
            
            // RESET TO FRESH STATE: Do this asynchronously to not block navigation
            setTimeout(async () => {
                try {
                    await resetConversationsToFreshState();
                    console.log('âœ… Background reset completed');
                } catch (error) {
                    console.error('âŒ Error in background reset:', error);
                }
            }, 100);
            
            console.log('âœ… showConversationsPage completed successfully');
        } catch (error) {
            console.error('âŒ Error in showConversationsPage:', error);
        }
    }
    
    // Debug function for testing navigation
    function debugNavigation() {
        console.log('ğŸ” DEBUG: Navigation Elements Check');
        
        const aboutPage = document.getElementById('about-page');
        const wizardPage = document.getElementById('conversation-wizard-page');
        const mainContent = document.getElementById('timeline-grid-wrapper');
        const bottomControls = document.getElementById('bottom-controls-container');
        const conversationsLink = document.querySelector('.nav-link[onclick*="showConversationsPage"]');
        const wizardLink = document.querySelector('.nav-link[onclick*="showConversationWizard"]');
        const aboutLink = document.querySelector('.nav-link[onclick*="showAboutPage"]');
        
        console.log('ğŸ“„ About Page Element:', aboutPage ? 'âœ… Found' : 'âŒ Missing', aboutPage);
        console.log('ğŸ“„ Wizard Page Element:', wizardPage ? 'âœ… Found' : 'âŒ Missing', wizardPage);
        console.log('ğŸ“„ Main Content Element:', mainContent ? 'âœ… Found' : 'âŒ Missing', mainContent);
        console.log('ğŸ“„ Bottom Controls Element:', bottomControls ? 'âœ… Found' : 'âŒ Missing', bottomControls);
        console.log('ğŸ”— Conversations Link:', conversationsLink ? 'âœ… Found' : 'âŒ Missing', conversationsLink);
        console.log('ğŸ”— Wizard Link:', wizardLink ? 'âœ… Found' : 'âŒ Missing', wizardLink);
        console.log('ğŸ”— About Link:', aboutLink ? 'âœ… Found' : 'âŒ Missing', aboutLink);
        
        if (aboutPage) {
            console.log('ğŸ“„ About Page Display:', aboutPage.style.display);
        }
        if (wizardPage) {
            console.log('ğŸ“„ Wizard Page Display:', wizardPage.style.display);
        }
        if (mainContent) {
            console.log('ğŸ“„ Main Content Display:', mainContent.style.display);
        }
        if (bottomControls) {
            console.log('ğŸ“„ Bottom Controls Display:', bottomControls.style.display);
        }
        
        // Test functions
        console.log('ğŸ”§ Available Functions:');
        console.log('  - showAboutPage:', typeof window.showAboutPage);
        console.log('  - showConversationWizard:', typeof window.showConversationWizard);
        console.log('  - showConversationsPage:', typeof window.showConversationsPage);
        console.log('  - resetConversationsToFreshState:', typeof window.resetConversationsToFreshState);
        
        return {
            aboutPage: !!aboutPage,
            wizardPage: !!wizardPage,
            mainContent: !!mainContent,
            bottomControls: !!bottomControls,
            conversationsLink: !!conversationsLink,
            wizardLink: !!wizardLink,
            aboutLink: !!aboutLink,
            functionsAvailable: {
                showAboutPage: typeof window.showAboutPage === 'function',
                showConversationWizard: typeof window.showConversationWizard === 'function',
                showConversationsPage: typeof window.showConversationsPage === 'function',
                resetConversationsToFreshState: typeof window.resetConversationsToFreshState === 'function'
            }
        };
    }

    // Test function for conversation wizard
    function testConversationWizard() {
        console.log('ğŸ§ª TESTING: Conversation wizard access...');
        
        // Test if file exists
        fetch('/frontend/conversation_wizard.html')
            .then(response => {
                console.log('ğŸ“ Wizard file response status:', response.status);
                if (response.ok) {
                    console.log('âœ… Conversation wizard file found');
                    return response.text();
                } else {
                    console.error('âŒ Conversation wizard file not found');
                    throw new Error(`HTTP ${response.status}`);
                }
            })
            .then(html => {
                console.log('ğŸ“„ Wizard HTML length:', html.length);
                console.log('âœ… Wizard file loaded successfully');
            })
            .catch(error => {
                console.error('âŒ Error loading wizard file:', error);
            });
    }

    // Simple version for testing - just does the basic navigation without reset
    function simpleShowConversations() {
        console.log('ğŸ”„ SIMPLE: Starting simpleShowConversations...');
        
        const aboutPage = document.getElementById('about-page');
        const emotionsPage = document.getElementById('emotions-page');
        const mainContent = document.getElementById('timeline-grid-wrapper');
        const bottomControls = document.getElementById('bottom-controls-container');
        
        // Hide about page
        if (aboutPage) {
            aboutPage.style.display = 'none';
            console.log('âœ… SIMPLE: Hidden about page');
        }
        
        // Hide emotions page
        if (emotionsPage) {
            emotionsPage.style.display = 'none';
            console.log('âœ… SIMPLE: Hidden emotions page');
        }
        
        // Hide about page
        if (aboutPage) {
            aboutPage.style.display = 'none';
            console.log('âœ… SIMPLE: Hidden about page');
        }
        
        // Show main content
        if (mainContent) {
            mainContent.style.display = 'block';
            console.log('âœ… SIMPLE: Shown main content');
        }
        
        // Show bottom controls
        if (bottomControls) {
            bottomControls.style.display = 'flex';
            bottomControls.style.visibility = 'visible';
            console.log('âœ… SIMPLE: Shown bottom controls');
        }
        
        // Update navigation
        document.querySelectorAll('.nav-link').forEach(link => {
            link.classList.remove('active-nav');
        });
        const conversationsLink = document.querySelector('.nav-link[onclick*="showConversationsPage"]');
        if (conversationsLink) {
            conversationsLink.classList.add('active-nav');
            console.log('âœ… SIMPLE: Updated navigation');
        }
        
        console.log('âœ… SIMPLE: Navigation completed successfully');
    }
    
    // Make functions globally available
    window.showAboutPage = showAboutPage;
    window.hideAboutPage = hideAboutPage;
    window.showConversationsPage = showConversationsPage;
    window.showConversationWizard = showConversationWizard;
    window.testConversationWizard = testConversationWizard;
    window.resetConversationsToFreshState = resetConversationsToFreshState;
    window.debugNavigation = debugNavigation;
    window.simpleShowConversations = simpleShowConversations;





    // Initialize animated emotion separators with random emotions
    function initializeEmotionSeparators() {
        const emotionChars = ['â—', 'â—‰', 'â—‹', 'â—¯', 'â¬¢', 'â¬¡', 'â—Š', 'â—ˆ', 'â˜…', 'â˜†', 'âœ¨', 'â™¥', 'â—¦', 'â€¢', 'âˆ˜', 'âŠ™', 'âŠš', 'âŠ›'];
        const emotionColors = ['#FFD700', '#FF69B4', '#FF8C00', '#87CEEB', '#FFA500', '#DC143C', '#8B008B', '#228B22'];
        
        const separators = document.querySelectorAll('.emotion-separator');
        
        function updateEmotionChar(separator, index) {
            const randomChar = emotionChars[Math.floor(Math.random() * emotionChars.length)];
            const randomColor = emotionColors[Math.floor(Math.random() * emotionColors.length)];
            separator.textContent = randomChar;
            separator.style.color = randomColor;
        }
        
        // Initial setup
        separators.forEach((separator, index) => {
            updateEmotionChar(separator, index);
            
            // Change emotion character every 3-8 seconds randomly
            const interval = 3000 + Math.random() * 5000;
            setInterval(() => updateEmotionChar(separator, index), interval);
        });
    }

    // Initialize emotion separators when page loads
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(initializeEmotionSeparators, 1000); // Wait for page to load
        setTimeout(initializeHeaderEmotionCircles, 1500); // Wait for header to load
        
        // Ensure People view is properly initialized on DOM ready
        setTimeout(() => {
            if (window.activeLayout === 'people' && window.renderNewLayout) {
                // Clear any existing stability check
                if (window.peopleViewStabilityCheck) {
                    clearTimeout(window.peopleViewStabilityCheck);
                }
                
                window.peopleViewStabilityCheck = setTimeout(() => {
                    if (window.renderNewLayout && window.activeLayout === 'people') {
                        console.log('ğŸ”„ DOM ready - ensuring People view is properly initialized...');
                        window.renderNewLayout(false);
                    }
                }, 100);
            }
        }, 2000); // Wait for all initialization to complete
    });
    
    // Initialize header logo emotion circles with random emotions
    function initializeHeaderEmotionCircles() {
        const emotionChars = ['â—', 'â—‰', 'â—‹', 'â—¯', 'â¬¢', 'â¬¡', 'â—Š', 'â—ˆ', 'â˜…', 'â˜†', 'âœ¨', 'â™¥', 'â—¦', 'â€¢', 'âˆ˜', 'âŠ™', 'âŠš', 'âŠ›'];
        const emotionColors = ['#FFD700', '#FF69B4', '#FF8C00', '#87CEEB', '#FFA500', '#DC143C', '#8B008B', '#228B22'];
        
        const logoCircles = document.querySelectorAll('.logo-emotion-circle');
        
        function updateHeaderEmotionChar(circle, index) {
            const randomChar = emotionChars[Math.floor(Math.random() * emotionChars.length)];
            const randomColor = emotionColors[Math.floor(Math.random() * emotionColors.length)];
            circle.textContent = randomChar;
            circle.style.color = randomColor;
        }
        
        // Initial setup
        logoCircles.forEach((circle, index) => {
            updateHeaderEmotionChar(circle, index);
            
            // Change emotion character every 2-6 seconds randomly
            const interval = 2000 + Math.random() * 4000;
            setInterval(() => updateHeaderEmotionChar(circle, index), interval);
        });
        
        console.log('âœ¨ Header emotion circles initialized');
    }
  </script>
  
  <style>
    /* Font Definitions */
    @font-face { font-family: '80k'; src: url('assets/Fonts/80kb_desk/80-kb-Sharp.otf') format('opentype'); font-weight: 400; }
    @font-face { font-family: '80k'; src: url('assets/Fonts/80kb_desk/80-kb-SharpBold.otf') format('opentype'); font-weight: 700; }
    
    /* CSS Variables */
    :root { 
        --main-font-family: 'Miriam Libre', sans-serif;
        --main-bg-color: #f7f9f3;
    }
    
    /* Global font rule - apply Miriam Libre to all elements except logo */
    * {
        font-family: var(--main-font-family) !important;
    }
    
    /* Exception for logo - use Miriam Libre */
    #logo-text {
        font-family: 'Miriam Libre', sans-serif !important;
    }
    
    /* Global Transparency Rules - Consolidated */
    #timeline-grid-wrapper,
    #timeline-axes-container,
    #layout-canvas,
    .layout-timeline #timeline-grid-wrapper,
    .layout-timeline #timeline-axes-container,
    .layout-timeline #layout-canvas,
    .layout-emotions #timeline-grid-wrapper,
    .layout-emotions #timeline-axes-container,
    .layout-people #timeline-grid-wrapper,
    .layout-people #timeline-axes-container,
    .conversation-grid-item-container:hover,
    .person-name-label:hover {
        background: transparent !important;
        background-color: transparent !important;
        background-image: none !important;
    }
    
    /* Global Background Color Rules - Consolidated */
    #splash-screen,
    .mdl-progress > .progressbar,
    .progress-line,
    .analysis-section,
    .control-buttons,
    .loading-indicator {
        background: var(--main-bg-color);
        background-color: var(--main-bg-color);
    }
    /* Base HTML and Body Styles */
    html, body { 
        height: 100%; 
        margin: 0; 
        padding: 0; 
        background: var(--main-bg-color);
        font-family: var(--main-font-family); 
        color: #222; 
        font-size: 14px; 
        overflow: hidden;
    }
    /* Header Styles */
    .app-header { 
        width: 100%; 
        background: var(--main-bg-color); 
        padding: 15px 30px; 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        z-index: 1001; 
        position: fixed; 
        top: 0; 
        left: 0; 
        right: 0; 
        box-sizing: border-box; 
        height: 60px; 
        border-bottom: 1px solid rgba(128, 128, 128, 0.2) !important;
    }
    
    /* Bottom Controls - Zoom LEFT, Views RIGHT */
    #bottom-controls-container { 
        position: fixed; 
        bottom: 0; 
        left: 0; 
        right: 0; 
        background: var(--main-bg-color); 
        z-index: 1001 !important; 
        height: 60px !important; 
        display: flex !important; 
        align-items: center !important; 
        justify-content: space-between !important; /* Space between left and right items */
        box-sizing: border-box !important; 
        border-top: 1px solid rgba(128, 128, 128, 0.2) !important;
        padding: 0 20px !important;
    }
    
    /* Ensure child elements in bottom controls are properly styled and visible */
    #bottom-controls-container * {
        z-index: inherit !important;
        position: relative !important;
    }
    
    /* Style view toggle buttons to be visible on top of grid */
    .view-toggle-buttons {
        display: flex !important;
        align-items: center !important;
        gap: 15px !important;
        z-index: 1002 !important;
    }
    

    
    .view-toggle-btn {
        background: transparent !important;
        padding: 8px 16px !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        font-family: var(--main-font-family) !important;
        font-size: 14px !important;
        z-index: 1002 !important;
    }
    

    
    /* Zoom Controls Styling */
    .zoom-controls {
        display: flex !important;
        align-items: center !important;
        gap: 10px !important;
        z-index: 1002 !important;
        background: #F7F9F2 !important;
        padding: 6px 12px !important;
        border: 1px solid #E5E6E2 !important;
    }
    
    .zoom-btn {
        background: transparent !important;
        border: none !important;
        width: 28px !important;
        height: 28px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        font-size: 12px !important;
        font-weight: 100 !important;
        transition: all 0.2s ease !important;
        color: #333 !important;
        z-index: 1002 !important;
    }
    
    .zoom-btn:hover {
        background: rgba(0,0,0,0.05) !important;
    }
    
    .zoom-indicator {
        font-size: 12px !important;
        color: #666 !important;
        font-weight: 500 !important;
        min-width: 40px !important;
        text-align: center !important;
        z-index: 1002 !important;
    }
    
    /* Ensure all UI panels and overlays stay on top of the grid */
    .retranscribe-panel,
    .mdl-dialog,
    .mdl-tooltip,
    #playground-container,
    #live-visualization-container {
        z-index: 2000 !important;
    }
    .header-title { display: flex; align-items: center; font-size: 24px; font-weight: 400; }
    .header-nav { display: flex; align-items: center; gap: 20px; }
    .nav-link { cursor: pointer; color: #999; padding-bottom: 2px; text-decoration: none; font-size: 14px; border-bottom: 2px solid transparent; transition: color 0.2s, border-bottom-color 0.2s; font-weight: 400; }
    .nav-link:hover { color: #666; }
    .nav-link.active-nav { 
        color: #000 !important; 
        border-bottom: none; 
        position: relative; 
        font-weight: 500;
    }
    .nav-link.active-nav::before { 
        content: '['; 
        margin-right: 3px; 
        color: #000;
        font-weight: normal;
    }
    .nav-link.active-nav::after { 
        content: ']'; 
        margin-left: 3px; 
        color: #000;
        font-weight: normal;
    }
    #timeline-grid-wrapper { position: absolute; top: 60px; left: 0; right: 0; bottom: 0; background: transparent !important; overflow: hidden; display: flex; flex-direction: column; box-sizing: border-box; }
    
    /* Fix timeline-grid-wrapper in people view to prevent double containers */
    body.layout-people #timeline-grid-wrapper {
        position: absolute !important;
        top: 60px !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        background-color: transparent !important;
        overflow: visible !important; /* Change to visible instead of hidden */
        display: block !important; /* Change from flex to block */
        padding: 0 !important;
        margin: 0 !important;
        z-index: 0 !important; /* Behind the layout-canvas */
        width: 100vw !important;
        height: calc(100vh - 60px) !important;
        min-width: 1200px !important;
        min-height: 600px !important;
    }
    #timeline-axes-container { 
        position: relative; 
        flex-grow: 1; 
        min-height: calc(100vh - 120px); /* Use full viewport height minus header/footer */
        height: calc(100vh - 120px); /* Ensure full height */
        padding: 10px; /* Reduced padding for more space */
        box-sizing: border-box; 
        overflow-y: auto;
        overflow-x: hidden;
        /* Hide scrollbar while keeping functionality */
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* Internet Explorer 10+ */
        background: transparent !important; /* Transparent to show body grid */
        background-image: none !important; /* No background patterns */
        background-color: transparent !important; /* Transparent to show body grid */
    }
    
    /* Hide scrollbar for webkit browsers */
    #timeline-axes-container::-webkit-scrollbar {
        display: none;
    }
    
    /* Hide scrollbar for layout canvas webkit browsers */
    #layout-canvas::-webkit-scrollbar {
        display: none;
    }
    
    /* Fix timeline-axes-container in people view to prevent conflicts */
    .layout-people #timeline-axes-container {
        position: relative !important;
        padding: 0 !important; /* Remove padding to prevent positioning conflicts */
        overflow: hidden !important; /* No scrollbar */
        height: 100% !important;
        width: 100% !important;
        background: transparent !important;
        z-index: 0 !important; /* Behind the layout-canvas */
    }

    /* Single Row Grid System - 12 videos in one row with square cells */
    #layout-canvas { 
        position: fixed;
        top: 60px;
        left: 0;
        right: 0;
        bottom: 60px;
        width: 100%;
        height: calc(100vh - 120px);
        display: block; /* Block layout for absolute positioning - prevents overlaps */
        padding-left: 24px !important;
        padding-right: 24px !important;
        box-sizing: border-box;
        background: transparent !important; /* Transparent so body grid shows through */
        border: none;
        border-radius: 0;
        overflow: hidden;
        box-shadow: none;
        /* Ensure conversations stay within padding boundaries */
        max-width: calc(100% - 48px) !important; /* Account for 24px padding on each side */
        margin: 0 auto !important; /* Center the content */
    }
    
    /* PEOPLE VIEW: Force proper height and layout */
    body.layout-people #layout-canvas {
        display: block !important;
        position: fixed !important;
        top: 60px !important; /* Below header */
        left: 0 !important;
        right: 0 !important;
        bottom: 60px !important; /* Above footer */
        width: 100vw !important;
        height: calc(100vh - 120px) !important;
        min-height: calc(100vh - 120px) !important;
        max-height: none !important;
        overflow: hidden !important; /* Remove scrollbar */
        padding: 20px !important;
        padding-top: 10px !important; /* Reduced top padding to minimize empty space */
        box-sizing: border-box !important;
        background: transparent !important;
        z-index: 500 !important; /* Higher z-index but below header */
    }
    
    /* Set CSS custom properties for horizontal line layout */
    #layout-canvas {
        --video-size: 150px;
        /* Calculate block size to fill width with 24px padding */
        --conversation-block-size: calc((100vw - 48px - 20px) / 6); /* 100vw - 48px padding - 20px margins - LARGER BLOCKS */
        --timeline-item-size: 60px; /* Compact timeline items to fit more */
    }

    /* FULL-SCREEN VIDEO PREVIEW containers - Large conversation blocks that fill screen width */
    .conversation-grid-item-container { 
        position: absolute; 
        box-sizing: border-box; 
        padding: 0; 
        margin: 5px !important; /* Slightly larger margin for big blocks */
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden !important; /* CRITICAL: Prevent video overflow */
        border-radius: 12px; /* Larger rounded corners for big blocks */
        cursor: pointer;
        transition: transform 0.3s ease, box-shadow 0.3s ease, width 0.3s ease, height 0.3s ease !important; /* Smooth transitions for responsive sizing */
        background: transparent !important; /* Transparent to show grid behind */
        border: none;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1); /* Subtle shadow for large blocks */
        z-index: 2;
        will-change: transform, box-shadow, width, height !important; /* Enable smooth responsive sizing */
        transform-origin: center center;
        /* FULL-SCREEN: Large video preview blocks - perfect square, fills screen width */
        aspect-ratio: 1 / 1;
        /* Dynamic sizing that fills screen width based on conversation count */
        width: var(--conversation-block-size, 300px) !important;
        height: var(--conversation-block-size, 300px) !important;
        /* Performance optimizations for large blocks */
        contain: layout style paint;
        backface-visibility: hidden;
        perspective: 1000px;
        isolation: isolate;
    }

    /* RESPONSIVE Video container wrapper for video preview blocks */
    .video-container-wrapper {
        width: 100% !important;
        height: 100% !important;
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        position: relative !important;
        overflow: hidden !important;
        background: transparent !important;
        border-radius: 0 !important;
        margin: 0 !important;
        padding: 0 !important;
        /* Responsive sizing support */
        max-width: var(--conversation-block-size, 100px) !important;
        max-height: var(--conversation-block-size, 100px) !important;
        /* Ensure perfect centering */
        place-items: center !important;
        place-content: center !important;
        /* Performance optimizations */
        contain: layout style paint !important;
        backface-visibility: hidden !important;
        will-change: transform, width, height !important; /* Enable responsive sizing */
        transition: transform 0.3s ease, width 0.3s ease, height 0.3s ease !important; /* Smooth responsive transitions */
    }
    
    /* Grid cell inner div container - ULTRA ENHANCED */
    .grid-cell-content {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: transparent;
        border-radius: 0;
        overflow: hidden;
        position: relative;
        text-align: center;
        place-items: center;
        /* ULTRA ENHANCED: Maximum cropping and visual quality */
        aspect-ratio: 1 / 1;
        /* Enhanced visual masking for better focus */
        mask: radial-gradient(circle at center, black 85%, transparent 100%);
        -webkit-mask: radial-gradient(circle at center, black 85%, transparent 100%);
        /* Improved rendering */
        will-change: transform !important; /* Enable will-change for smooth animations */
        contain: layout style paint;
        transition: transform 0.3s ease !important; /* Smooth transitions for hover effects */
    }

    .conversation-grid-item-container:hover { 
        border: 1px solid #000000 !important; /* Simple black border on hover */
        transition: border 0.2s ease !important; /* Fast, smooth border transition */
    }
    
    .conversation-grid-item-container:hover .grid-cell-content {
        border-radius: 0;
    }

    /* Enhanced hover effects for video container wrapper */
    .conversation-grid-item-container:hover .video-container-wrapper {
        transform: scale(1) !important; /* NO scaling - keep same size */
        background: transparent !important;
        border-radius: 0 !important;
        width: 100% !important; /* MAINTAIN CONSISTENT WIDTH */
        height: 100% !important; /* MAINTAIN CONSISTENT HEIGHT */
        margin: 0 !important; /* MAINTAIN CONSISTENT MARGIN */
    }

    /* CRITICAL: Ensure video preview containers have NO backdrop effects */
    .video-preview-item, 
    .video-preview-item:hover {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
    }

    /* Video wrapper styles removed - videos now display directly */
    
    /* SIMPLIFIED Video styling - Direct and efficient */
    /* RESPONSIVE Video preview elements - auto-scaling based on conversation count */
    .conversation-video-preview { 
        object-fit: cover !important; /* FILL: Cover entire container, may crop content */
        object-position: center center;
        display: block; 
        width: 100%; 
        height: 100%; 
        border: none; 
        border-radius: 0; /* No border radius */
        margin: 0;
        padding: 0;
        position: absolute;
        top: 0;
        left: 0;
        transition: none !important; /* Remove image scaling transitions */
        background: #f7f9f3; /* Match visualization background */
        /* Responsive sizing - adapts to conversation count and viewport */
        max-width: var(--conversation-block-size, 140px);
        max-height: var(--conversation-block-size, 140px);
        /* Performance optimization for responsive scaling */
        will-change: transform, width, height;
        /* Prevent image scaling on hover */
        transform: scale(1) !important;
    }
    
    /* CLEAN hover effects - Simple and non-blocking */
    .conversation-grid-item-container:hover .conversation-video-preview {
        opacity: 1.0 !important; /* Keep full opacity, no fade effect */
        transform: scale(1) !important; /* NO scaling - keep image same size while container grows */
    }
    
    /* Removed conflicting hover styles that caused white background duplication */

    /* Hide video error overlays */
    .conversation-grid-item-container div[style*="Video Error"] {
        display: none !important;
    }

    /* Lazy iframe placeholder styles */
    .lazy-iframe-placeholder {
        transition: background 0.3s ease, transform 0.3s ease !important;
        will-change: transform, background;
    }

    /* Removed placeholder hover background that caused glow effect */

    /* Removed scaling effect that contributed to hover duplication */

    /* Responsive adjustments - Optimized for People view visibility */
    @media (max-width: 1400px) {
        #layout-canvas {
            padding-left: 24px !important;
            padding-right: 24px !important;
        }
        /* Calculate block size to fill width with 24px padding */
        :root {
            --conversation-block-size: calc((100vw - 48px - 20px) / 6);
        }
    }

    @media (max-width: 1200px) {
        #layout-canvas {
            padding-left: 24px !important;
            padding-right: 24px !important;
        }
        /* Calculate block size to fill width with 24px padding */
        :root {
            --conversation-block-size: calc((100vw - 48px - 20px) / 6);
        }
    }

    @media (max-width: 800px) {
        #layout-canvas {
            padding-left: 24px !important;
            padding-right: 24px !important;
        }
        /* Calculate block size to fill width with 24px padding */
        :root {
            --conversation-block-size: calc((100vw - 48px - 20px) / 6);
        }
    }

    @media (min-width: 1800px) {
        /* Large screens - calculate block size to fill width with 24px padding */
        :root {
            --conversation-block-size: calc((100vw - 48px - 20px) / 6);
        }
    }

    @media (min-width: 2400px) {
        /* Ultra-wide screens - calculate block size to fill width with 24px padding */
        :root {
            --conversation-block-size: calc((100vw - 48px - 20px) / 6);
        }
    }

    @media (max-width: 768px) {
        #layout-canvas {
            padding-left: 24px !important;
            padding-right: 24px !important;
        }
        /* Mobile: 2 larger blocks per row */
        :root {
            --conversation-block-size: calc((100vw - 48px) / 2);
        }
    }

    @media (max-width: 480px) {
        #layout-canvas {
            padding-left: 24px !important;
            padding-right: 24px !important;
        }
        /* Small mobile: 1 large block per row for best visibility */
        :root {
            --conversation-block-size: calc(100vw - 48px);
        }
    }

    /* People view styles are handled above */

    /* People view - Column layout with person names and conversation previews - BOTTOM ALIGNED */
    body.layout-people #layout-canvas,
    .layout-people #layout-canvas {
        display: block !important;
        padding: 24px !important; /* 24px padding as requested */
        padding-top: 10px !important; /* Reduced top padding to align content to top */
        overflow: hidden auto !important; /* Clean overflow management */
        max-width: none !important;
        margin: 0 !important;
        position: fixed !important; /* Use fixed positioning like other views */
        top: 60px !important; /* Standard header offset */
        left: 0 !important;
        right: 0 !important;
        bottom: 60px !important; /* Standard footer offset */
        width: 100vw !important;
        height: calc(100vh - 120px) !important;
        min-height: 600px !important;
        background: transparent !important; /* Transparent to show body grid background */
        box-sizing: border-box !important;
        z-index: 1 !important; /* Ensure proper layering */
    }

    /* People view name labels - Base styles */
    .layout-people .person-name-label {
        cursor: pointer;
        user-select: none;
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: flex-end;
    }
    
    .layout-people .person-name-content {
        text-align: right;
        direction: rtl;
        width: 100%;
        box-sizing: border-box;
        padding: 0 8px;
    }
    
    .layout-people .person-name-label .person-info {
        text-align: right;
        direction: rtl;
        width: 100%;
    }
    
    .layout-people .person-name-label .person-name {
        font-size: 18px;
        font-weight: bold;
        color: #333;
        margin-bottom: 4px;
        line-height: 1.2;
        white-space: nowrap; /* Prevent line breaking */
        overflow: hidden; /* Hide overflow if name is too long */
        text-overflow: ellipsis; /* Add ... if name is too long */
    }
    
    .layout-people .person-name-label .person-stats {
        font-size: 12px;
        color: #666;
        margin-bottom: 2px;
        opacity: 0.8;
    }
    
    .layout-people .person-name-label .person-description {
        font-size: 11px;
        color: #888;
        opacity: 0.7;
        line-height: 1.1;
    }

    /* Timeline view date labels - Perfect center alignment */
    .layout-timeline .timeline-date-label,
    .timeline-date-label-protected {
        cursor: default;
        user-select: none;
        position: absolute !important;
        background: none !important;
        border: none !important;
        border-radius: 0 !important;
        box-shadow: none !important;
        padding: 0 !important;
        margin: 0 !important;
        direction: ltr !important;
        text-align: center !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        box-sizing: border-box !important;
        z-index: 2;
    }
    
    .layout-timeline .timeline-date-content,
    .timeline-date-label-protected .timeline-date-content {
        text-align: center !important;
        direction: ltr !important;
        width: 100%;
        box-sizing: border-box;
        padding: 0 !important;
    }
    
    .layout-timeline .timeline-date-label .date-info,
    .timeline-date-label-protected .date-info {
        text-align: center !important;
        direction: ltr !important;
        width: 100%;
    }
    
    .layout-timeline .timeline-date-label .date-name,
    .timeline-date-label-protected .date-name {
        font-size: 16px;
        font-weight: bold;
        color: #333;
        margin-bottom: 4px;
        line-height: 1.2;
    }
    
    .layout-timeline .timeline-date-label .date-stats,
    .timeline-date-label-protected .date-stats {
        font-size: 11px;
        color: #666;
        margin-bottom: 2px;
        opacity: 0.8;
    }

    /* People view containers - ORIGINAL COMPACT SIZE LIKE REFERENCE IMAGE */
    .layout-people .conversation-grid-item-container {
        /* Compact size matching the original reference image */
        position: absolute !important;
        box-sizing: border-box !important;
        padding: 0 !important;
        margin: 0 !important; /* No margin to ensure perfect alignment */
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        background: transparent !important;
        border: 1px solid #E5E6E2 !important; /* Navigation color border */
        border-radius: 0 !important; /* No corner radius */
        overflow: hidden !important;
        cursor: pointer !important;
        box-shadow: none !important; /* No shadow like original */
        z-index: 2 !important;
        transform-origin: center center !important;
        aspect-ratio: 1 / 1 !important;
        contain: layout style paint !important;
        backface-visibility: hidden !important;
        perspective: 1000px !important;
        isolation: isolate !important;
        /* LARGER CONTAINER for better conversation preview visibility */
        width: var(--timeline-square-size, 150px) !important;
        height: var(--timeline-square-size, 150px) !important;
        min-width: var(--timeline-square-size, 150px) !important;
        min-height: var(--timeline-square-size, 150px) !important;
        max-width: var(--timeline-square-size, 150px) !important;
        max-height: var(--timeline-square-size, 150px) !important;
        /* Smooth transitions for isotope animations */
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1) !important;
        /* Ensure perfect alignment with person names */
        transform: translateZ(0) !important; /* Force hardware acceleration */
    }

    .layout-people .conversation-grid-item-container:hover {
        /* NO SCALING - keep same size */
        transform: scale(1) !important; /* NO scaling */
        z-index: 10 !important;
        box-shadow: none !important; /* No shadow like original */
        border: 1px solid #000000 !important; /* Black border on hover - same thickness */
        border-radius: 0 !important; /* No border radius like original */
        /* Keep original size during hover */
        width: 100% !important;
        height: 100% !important;
        /* Smooth transition for hover state */
        transition: border 0.3s ease !important;
    }

    /* Ensure ALL image previews use FILL behavior - cover entire container */
    .conversation-video-preview {
        object-fit: cover !important; /* FILL: Cover entire container, may crop content */
        object-position: center center !important;
        transform: scale(1) !important; /* Prevent image scaling on hover */
    }

    /* People view specific image sizing - FILL images to cover entire container */
    .layout-people .conversation-video-preview {
        width: 100% !important;
        height: 100% !important;
        max-width: 100% !important;
        max-height: 100% !important;
        object-fit: cover !important; /* FILL: Cover entire container, may crop content */
        transform: scale(1) !important; /* No scaling - prevent image zoom on hover */
        transform-origin: center center !important;
    }

    /* Person name labels */
    /* Person name labels - NO STYLING */
.person-name-label {
    /* No background, no border, no fill, no stroke - just text */
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    padding: 0 !important;
    margin: 0 !important;
    border-radius: 0 !important;
    /* Keep only essential positioning */
    z-index: 10 !important;
    /* Prevent line breaking */
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
}

.person-name-content {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    margin: 0 !important;
    border-radius: 0 !important;
}

/* No hover effects */
.person-name-label:hover {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    transform: none !important;
}

.person-name-content:hover {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    transform: none !important;
}

    /* Hide conversation labels in People view - we use person name labels instead */
    .layout-people .conversation-label {
        display: none !important;
    }

    /* Emotions view layout canvas - Optimized for visibility without scrolling */
    body.layout-emotions #layout-canvas,
    .layout-emotions #layout-canvas {
        display: block !important;
        padding: 10px !important; /* Minimal padding for maximum space */
        padding-top: 10px !important; /* Minimal top padding */
        overflow: visible !important; /* No scrolling needed - emotions positioned at top */
        max-width: none !important;
        margin: 0 !important;
        position: fixed !important; /* Use fixed positioning like people view */
        top: 60px !important; /* Standard header offset */
        left: 0 !important;
        right: 0 !important;
        bottom: 60px !important; /* Standard footer offset */
        width: 100vw !important;
        height: calc(100vh - 120px) !important;
        min-height: 700px !important; /* Increased min-height for better emotion visibility */
        background: transparent !important; /* Transparent to show body grid background */
        box-sizing: border-box !important;
        z-index: 1 !important; /* Ensure proper layering */
    }

    .layout-emotions .conversation-grid-item-container {
        /* EMOTIONS VIEW - Match timeline/people view styling with navigation color borders */
        position: absolute !important;
        box-sizing: border-box !important;
        padding: 0 !important;
        margin: 0px !important; /* REMOVE MARGINS FOR MAXIMUM SPACE */
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1) !important; /* Same smooth transitions as other views */
        background: #f7f9f3 !important; /* Match visualization background */
        border: 1px solid #E5E6E2 !important; /* Navigation color border */
        border-radius: 0 !important; /* No corner radius */
        overflow: hidden !important;
        cursor: pointer !important;
        box-shadow: none !important;
        z-index: 2 !important;
        transform-origin: center center !important;
        aspect-ratio: 1 / 1 !important;
        contain: layout style paint !important;
        backface-visibility: hidden !important;
        perspective: 1000px !important;
        isolation: isolate !important;
        /* SAME SIZE AS PEOPLE AND TIMELINE VIEWS - USE CSS VARIABLE */
        width: var(--visual-conversation-size, 40px) !important;
        height: var(--visual-conversation-size, 40px) !important;
        min-width: var(--visual-conversation-size, 40px) !important;
        min-height: var(--visual-conversation-size, 40px) !important;
        max-width: var(--visual-conversation-size, 40px) !important;
        max-height: var(--visual-conversation-size, 40px) !important;
        transform: translateZ(0) !important; /* Force hardware acceleration */
    }
    
    .layout-emotions .conversation-grid-item-container:hover {
        /* NO SCALING - keep same size */
        transform: scale(1) !important; /* NO scaling */
        z-index: 10 !important;
        box-shadow: none !important;
        border: 1px solid #000000 !important; /* Black border on hover - same thickness */
        transition: border 0.3s ease !important;
    }
    
    /* Match video styling with timeline/people views */
    .layout-emotions .conversation-video-preview {
        object-fit: cover !important; /* FILL: Cover entire container, may crop content */
        object-position: center center !important;
        display: block !important;
        width: 100% !important;
        height: 100% !important;
        border: none !important;
        border-radius: 0 !important;
        margin: 0 !important;
        padding: 0 !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        transition: none !important; /* Remove image scaling transitions */
        background: #f7f9f3 !important; /* Match visualization background */
        filter: none !important;
        box-shadow: none !important;
        transform: scale(1) !important; /* Prevent image scaling on hover */
    }
    
    .layout-emotions .video-container-wrapper {
        width: 100% !important;
        height: 100% !important;
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        position: relative !important;
        overflow: hidden !important;
        background: transparent !important;
        border-radius: 0 !important;
        border: none !important;
        margin: 0 !important;
        padding: 0 !important;
    }
    
    /* Emotion cluster labels - Simple text labels with consistent spacing - EMOTIONS VIEW ONLY */
    body.layout-emotions .emotion-cluster-label {
        font-family: 'Miriam Libre', serif !important;
        font-size: 14px !important;
        font-weight: normal !important;
        color: #333 !important;
        text-align: left !important;
        direction: ltr !important;
        pointer-events: none !important;
        z-index: 10 !important;
        background: none !important; /* Remove background */
        border: none !important; /* Remove border */
        border-radius: 0 !important; /* Remove border radius */
        box-shadow: none !important; /* Remove shadow */
        padding: 0 !important; /* Remove padding */
        position: absolute !important;
        display: flex !important;
        align-items: center !important;
        justify-content: flex-start !important;
        white-space: nowrap !important;
        transition: none !important; /* Remove transitions */
        min-width: auto !important; /* Auto width */
    }
    
    /* Remove all decorative styles - keep only plain text labels */
    
    /* Emotions view background - solid background without grid */
    body.layout-emotions {
        background: #f7f9f3 !important;
    }
    
    /* Disable animations in emotions view but allow isotope transitions and zoom */
    .layout-emotions *:not(#layout-canvas):not(.conversation-grid-item-container) {
        animation: none !important;
    }
    
    /* Allow isotope transitions for conversation items but no other animations */
    .layout-emotions .conversation-grid-item-container {
        animation: none !important;
    }
    
    /* Allow zoom transforms on the main layout canvas */
    .layout-emotions #layout-canvas {
        transform-origin: center center !important;
        animation: none !important;
    }

    /* Hebrew Splash Screen Styles */
    #splash-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f7f9f3;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        overflow: hidden;
        z-index: 9999;
        transition: opacity 0.5s ease-out;
    }
    #splash-screen.hidden { opacity: 0; pointer-events: none; }
    
    /* Animated background dots */
    .background-dots {
        position: absolute;
        width: 100%;
        height: 100%;
        opacity: 0.3;
    }
    
    .dot {
        position: absolute;
        width: 2px;
        height: 2px;
        background: #667eea;
        border-radius: 50%;
        animation: twinkle 3s infinite ease-in-out;
    }
    
    @keyframes twinkle {
        0%, 100% { opacity: 0.2; }
        50% { opacity: 0.8; }
    }
    
    /* Main loading container */
    .loading-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 100;
        width: 100%;
    }
    
    .loading-text {
        color: #333;
        font-size: 20px;
        font-weight: 400;
        letter-spacing: 3px;
        margin-bottom: 30px;
        white-space: nowrap;
        text-align: center;
    }
    
    /* Loading bar container - Clean style */
    .loading-bar-container {
        width: 480px;
        height: 12px;
        background: #e0e0e0;
        border: 1px solid #333;
        position: relative;
        overflow: hidden;
        z-index: 101;
        margin: 0 auto;
    }
    
    .loading-bar {
        height: 100%;
        background: #333;
        width: 0%;
        animation: loadProgress 2.5s ease-in-out forwards;
        position: relative;
    }
    
    @keyframes loadProgress {
        0% { width: 0%; }
        50% { width: 60%; }
        80% { width: 85%; }
        100% { width: 100%; }
    }
    
    @keyframes shine {
        0% { left: -100%; }
        100% { left: 100%; }
    }
    
    /* Preview windows */
    .preview-window {
        position: absolute;
        border: none;
        background: transparent;
        overflow: hidden;
        opacity: 0;
        animation: floatUp 15s linear infinite, fadeInOut 15s ease-in-out infinite;
        z-index: 1;
    }
    
    .preview-window video {
        width: 100%;
        height: 100%;
        object-fit: contain;
        pointer-events: none;
    }
    
    @keyframes floatUp {
        0% { transform: translateY(100vh); }
        100% { transform: translateY(-200px); }
    }
    
    @keyframes fadeInOut {
        0% { opacity: 0; }
        10% { opacity: 0.7; }
        90% { opacity: 0.7; }
        100% { opacity: 0; }
    }
    
    .preview-1 {
        left: 10%;
        width: 160px;
        height: 120px;
        animation-delay: 0s;
    }
    
    .preview-2 {
        left: 80%;
        width: 150px;
        height: 115px;
        animation-delay: -3s;
    }
    
    .preview-3 {
        left: 20%;
        width: 170px;
        height: 130px;
        animation-delay: -6s;
    }
    
    .preview-4 {
        left: 70%;
        width: 155px;
        height: 120px;
        animation-delay: -9s;
    }
    
    .preview-5 {
        left: 40%;
        width: 165px;
        height: 125px;
        animation-delay: -12s;
    }
    
    .preview-6 {
        left: 85%;
        width: 145px;
        height: 110px;
        animation-delay: -2s;
    }
    
    /* Retro scanlines effect */
    .scanlines {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
            0deg,
            transparent,
            transparent 2px,
            rgba(139, 115, 85, 0.05) 2px,
            rgba(139, 115, 85, 0.05) 4px
        );
        pointer-events: none;
    }
    
    /* Loading percentage */
    .loading-percentage {
        color: #333;
        font-size: 16px;
        margin-top: 15px;
        opacity: 0.8;
        text-align: center;
    }
    #visualization-modal-container { 
      position: fixed; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      background-color: rgba(0, 0, 0, 0.8); 
      backdrop-filter: blur(5px); 
      z-index: 5000; 
      display: none; 
      align-items: center; 
      justify-content: center; 
      opacity: 0; 
      transition: opacity 0.15s ease-in-out; 
      padding: 20px; 
      margin: 0; 
      box-sizing: border-box;
    }
    #visualization-modal-container.visible { 
      display: flex; 
      opacity: 1; 
    }
    #visualization-modal-container iframe { 
      width: 95vw; 
      height: 92vh; 
      max-width: none; 
      max-height: none; 
      border: none; 
      border-radius: 0 !important; 
      box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
      background-color: #f7f9f3;
      transition: transform 0.3s ease;
    }
    
    /* Exit Tooltip Styles */
    .exit-tooltip {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 12px 24px;
        border-radius: 0;
        font-size: 12px;
        font-family: var(--main-font-family);
        z-index: 5001;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s, visibility 0.3s;
        pointer-events: none;
        direction: rtl;
    }
    
    .exit-tooltip.show {
        opacity: 1;
        visibility: visible;
    }
    .nav-slash-style .slash-sep { color: #bbb; font-size: 1.5rem; margin: 0 10px; font-family: inherit; font-weight: 300; pointer-events: none; user-select: none; }
            .nav-slash-style .view-toggle-btn { background: none; border: none; font-size: 16px; font-family: inherit; font-weight: 400; color: #bbb; padding: 0 2px; cursor: pointer; transition: color 0.2s, font-weight 0.2s; }
        .nav-slash-style .view-toggle-btn.active { color: #111; font-weight: 400; }
        

        

        #hover-info-panel { 
            position: fixed; 
            bottom: 80px; 
            right: 20px; 
            display: inline-flex;
            padding: 0.75rem;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.5rem;
            border: 1px solid #E5E6E2;
            background: #F7F9F2;
            z-index: 1010; 
            opacity: 0; 
            visibility: hidden; 
            transform: translateY(0) scale(1) rotate(0deg); 
            transition: all 0.3s ease;
            pointer-events: none;
            width: 350px;
            direction: rtl;
            font-family: var(--main-font-family);
        }



        #hover-info-panel.visible { 
            opacity: 1; 
            visibility: visible; 
            transform: translateY(0) scale(1) rotate(0deg); 
            transition-delay: 0s, 0s, 0s;
            animation: none;
            pointer-events: auto;
        }



        .hover-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            align-self: stretch;
        }
        
        .hover-info-title { 
            font-size: 14px; 
            font-weight: 400; 
            color: #333; 
            text-align: right; 
            line-height: 1.2;
            font-family: "Miriam Libre";
        }
        
        .hover-info-date { 
            font-size: 10px; 
            color: #A0A0A0; 
            text-align: left;
            font-family: "Miriam Libre";
        }
        .hover-info-speakers {
            color: #9A9A9A;
            font-family: "Miriam Libre";
            font-size: 0.7rem;
            font-style: normal;
            font-weight: 400;
            line-height: 1.2rem;
            text-align: right;
        }
        
        .hover-info-divider {
            width: 100%;
            height: 1px;
            background-color: #E5E6E2;
            margin: 6px 0;
        }
        
        .hover-info-topic-section, .hover-info-emotions-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            align-self: stretch;
        }
        
        .hover-info-section-title {
            font-size: 11px;
            color: #333;
            font-family: "Miriam Libre";
            font-weight: 400;
            text-align: right;
        }
        
        .hover-info-topic-tags {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        
        .hover-info-topic-tag {
            padding: 3px 6px;
            font-size: 10px;
            color: #333;
            font-family: var(--main-font-family);
            border: 1px solid #E5E6E2;
        }
        
        .hover-info-topic-section, .hover-info-emotions-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            align-self: stretch;
        }
        
        .hover-info-section-title {
            font-size: 11px;
            color: #333;
            font-family: "Miriam Libre";
            font-weight: 400;
            text-align: right;
        }
        
        .hover-info-topic-tags {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        
        .hover-info-topic-tag {
            padding: 4px 8px;
            font-size: 11px;
            color: #333;
            font-family: var(--main-font-family);
            border: 1px solid #E5E6E2;
        }
        
        .hover-info-additional {
            font-size: 14px;
            color: #666;
            margin-bottom: 16px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 10px;
            border: 1px solid rgba(128, 128, 128, 0.12);
            font-family: var(--main-font-family);
            font-weight: 500;
            backdrop-filter: blur(4px);
        }
    
    .hover-info-tags { 
        display: flex; 
        gap: 8px; 
        flex-wrap: wrap;
        justify-content: flex-end;
    }
    .hover-info-tag { 
        color: #333; 
        padding: 4px 8px; 
        font-size: 11px;
        font-weight: 400;
        font-family: var(--main-font-family);
        border: 1px solid #E5E6E2;
        border-radius: 0;
        background: transparent;
        transition: all 0.2s ease;
        letter-spacing: -0.1px;
        display: inline-flex;
        align-items: center;
        gap: 3px;
    }
    
    .hover-info-tag:hover {
        background: transparent;
        transform: translateY(-1px);
        box-shadow: none;
        border-color: rgba(139, 115, 85, 0.3);
    }
    
    .hover-info-tag .emotion-color-square {
        width: 12px;
        height: 12px;
        border-radius: 0; /* No border radius - square rectangle */
        flex-shrink: 0;
        margin-left: 6px; /* Space after text */
    }
    
    .hover-info-tag {
        display: flex;
        align-items: center;
        margin: 2px 4px;
        padding: 2px 6px;
        border-radius: 0;
        background: transparent;
        gap: 8px; /* Space between text and square */
    }
    .hover-info-metadata-tags {
        font-size: 11px;
        color: #888;
        margin-top: 8px;
        padding: 8px 10px;
        background: rgba(139, 115, 85, 0.05);
        border-radius: 6px;
        border: 1px solid rgba(139, 115, 85, 0.1);
        font-family: var(--main-font-family);
        font-weight: 500;
        font-style: normal;
        letter-spacing: -0.1px;
    }
    .timeline-tooltip {
        position: absolute;
        bottom: 100%; /* Position above the track */
        transform: translateX(-50%);
        background-color: #333;
        color: #fff;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none; /* So it doesn't interfere with mouse events */
        display: none; /* Hidden by default */
        margin-bottom: 10px;
    }

    .handle-date-display {
        position: absolute;
        top: -25px; /* Position above the handle */
        font-size: 12px;
        color: #333;
        white-space: nowrap;
    }
    .handle-date-display.left { left: 0; }
    .handle-date-display.right { right: 0; }
    
    /* Performance and Loading Indicators */
    .loading-indicator {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        text-align: center;
        z-index: 1000;
        display: none;
        font-family: var(--main-font-family);
    }
    
    .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #8B7355;
        border-radius: 50%;
        animation: spin-loader 1s linear infinite;
        margin: 0 auto 15px;
    }
    
    @keyframes spin-loader {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .audio-prompt {
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(139, 115, 85, 0.9);
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        z-index: 1000;
        cursor: pointer;
        transition: all 0.3s ease;
        display: none;
        font-family: var(--main-font-family);
        font-size: 14px;
        border: none;
    }
    
    .audio-prompt:hover {
        background: rgba(139, 115, 85, 1);
        transform: scale(1.05);
    }
    
    /* Re-transcription Floating Panel */
    .retranscribe-panel {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.9);
        background: rgba(255, 255, 255, 0.98);
        border: 2px solid #ddd;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        z-index: 3000;
        display: none;
        width: 90%;
        max-width: 700px;
        max-height: 80vh;
        overflow-y: auto;
        font-family: var(--main-font-family);
        backdrop-filter: blur(20px);
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .retranscribe-panel.visible {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    
    .retranscribe-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 18px 18px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 18px;
        font-weight: 600;
    }
    
    .retranscribe-content {
        padding: 30px;
    }
    
    .retranscribe-options h3 {
        margin: 0 0 20px 0;
        color: #333;
        text-align: center;
        font-size: 20px;
    }
    
    .analysis-option {
        margin-bottom: 30px;
        border: 2px solid #f0f0f0;
        border-radius: 15px;
        padding: 20px;
        background: #fafafa;
    }
    
    .option-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 10px;
    }
    
    .option-icon {
        font-size: 24px;
    }
    
    .option-title {
        font-size: 18px;
        font-weight: 600;
        color: #333;
    }
    
    .option-description {
        color: #666;
        margin: 0 0 15px 36px;
        font-size: 14px;
    }
    
    .conversation-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 15px;
        margin-top: 15px;
    }
    
    .convo-option {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 15px 20px;
        background: white;
        border: 2px solid #e0e0e0;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: inherit;
        text-align: right;
    }
    
    .convo-option:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        border-color: #667eea;
    }
    
    .convo-option.quick-analysis {
        border-left: 5px solid #4CAF50;
    }
    
    .convo-option.quick-analysis:hover {
        border-color: #4CAF50;
        background: #f8fff8;
    }
    
    .convo-option.full-reprocess:hover {
        border-color: #FF9800;
        background: #fffaf0;
    }
    
    .convo-icon {
        font-size: 28px;
        flex-shrink: 0;
    }
    
    .convo-details {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        flex: 1;
    }
    
    .convo-name {
        font-weight: 600;
        font-size: 16px;
        color: #333;
    }
    
    .convo-count {
        font-size: 13px;
        color: #666;
        margin-top: 2px;
    }
    
    .close-btn {
        background: rgba(255,255,255,0.2);
        border: 1px solid rgba(255,255,255,0.3);
        color: white;
        border-radius: 50%;
        width: 35px;
        height: 35px;
        cursor: pointer;
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
    }
    
    .close-btn:hover {
        background: rgba(255,255,255,0.3);
        transform: scale(1.1);
    }
    
    /* Preview Canvas Styles */
    .conversation-preview-canvas {
        background: #f7f9f3;
        border-radius: 0;
    }
    
    .preview-canvas {
        transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .conversation-grid-item-container:hover .preview-canvas {
        transform: none; /* No scaling on hover */
        box-shadow: none;
    }
    
    .mini-spinner {
        width: 20px;
        height: 20px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #8B7355;
        border-radius: 50%;
        animation: spin-loader 1s linear infinite;
    }
    
    .preview-loading {
        background: rgba(247, 249, 243, 0.9);
        padding: 10px;
        border-radius: 0;
    }
    
    /* Hover effect for preview */
    .conversation-grid-item-container:hover .conversation-preview-canvas {
        box-shadow: none;
        background: transparent; /* Ensure no background color change */
    }
    

    /* Preview Video Styles */
    .preview-video {
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        cursor: pointer;
    }
    
    .conversation-grid-item-container:hover .preview-video {
        transform: none; /* No scaling on hover */
        box-shadow: none; /* No shadow on hover */
    }
    
    .fallback-canvas {
        display: none;
    }



    /* Playground Mode Styles */
    #playground-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f7f9f3;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    #playground-canvas-container {
        position: relative;
        width: 80%;
        max-width: 1200px;
        height: 60%;
        background: #f7f9f3;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        overflow: hidden;
        border: 2px solid #e0e0e0;
    }

    #playground-canvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #playground-controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 15px;
        align-items: center;
        background: rgba(255, 255, 255, 0.9);
        padding: 15px 25px;
        border-radius: 50px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        backdrop-filter: blur(10px);
    }

    .playground-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s ease;
        font-family: var(--main-font-family);
    }

    .playground-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }

    .playground-btn:active {
        transform: translateY(0);
    }

    .playground-btn.recording {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        animation: pulse-recording 2s infinite;
    }

    @keyframes pulse-recording {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .mic-status {
        font-size: 14px;
        color: #666;
        font-weight: 500;
        font-family: var(--main-font-family);
    }

    .mic-status.active {
        color: #27ae60;
        font-weight: 600;
    }

    .audio-level-display {
        font-size: 12px;
        color: #888;
        font-family: var(--main-font-family);
        min-width: 80px;
        text-align: center;
    }

    .audio-level-display.active {
        color: #3498db;
        font-weight: 600;
    }

    /* Playground Navigation Button Styles */
    .playground-nav-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
        color: white !important;
        border: none !important;
        cursor: pointer;
        transition: all 0.3s ease;
        text-decoration: none !important;
        padding: 8px 16px !important;
        border-radius: 20px !important;
        font-size: 14px !important;
        font-weight: 600 !important;
        margin-right: 10px !important;
    }

    .playground-nav-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%) !important;
        color: white !important;
        border-bottom: 2px solid transparent !important;
    }

    .playground-nav-btn.active {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%) !important;
        color: white !important;
        border-bottom: 2px solid transparent !important;
    }

    /* ENHANCED ISOTOPE-STYLE ANIMATED TRANSITIONS BETWEEN VIEWS */
    .conversation-grid-item-container {
        /* OPTIMIZED transition for smooth view switching */
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1) !important;
        /* Smooth 3D morphing between layouts */
        transform-style: preserve-3d !important;
        will-change: transform, left, top, width, height, opacity !important;
        /* Enhanced visual effects during transitions */
        backface-visibility: hidden !important;
        perspective: 1000px !important;
    }
    
    /* Enhanced transition states for view switching */
    .conversation-grid-item-container.transitioning {
        /* Smooth morphing animation */
        transition: left 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   top 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   width 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   height 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   transform 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   opacity 1.0s cubic-bezier(0.23, 1, 0.32, 1) !important;
        /* 3D transformation effects */
        transform-origin: center center !important;
        transform-style: preserve-3d !important;
        /* Smooth opacity transition */
        opacity: 1 !important;
    }
    
    /* Staggered animation delays for isotope effect */
    .conversation-grid-item-container:nth-child(1) { animation-delay: 0.0s !important; }
    .conversation-grid-item-container:nth-child(2) { animation-delay: 0.1s !important; }
    .conversation-grid-item-container:nth-child(3) { animation-delay: 0.2s !important; }
    .conversation-grid-item-container:nth-child(4) { animation-delay: 0.3s !important; }
    .conversation-grid-item-container:nth-child(5) { animation-delay: 0.4s !important; }
    .conversation-grid-item-container:nth-child(6) { animation-delay: 0.5s !important; }
    .conversation-grid-item-container:nth-child(7) { animation-delay: 0.6s !important; }
    .conversation-grid-item-container:nth-child(8) { animation-delay: 0.7s !important; }
    .conversation-grid-item-container:nth-child(9) { animation-delay: 0.8s !important; }
    .conversation-grid-item-container:nth-child(10) { animation-delay: 0.9s !important; }
    .conversation-grid-item-container:nth-child(11) { animation-delay: 1.0s !important; }
    .conversation-grid-item-container:nth-child(12) { animation-delay: 1.1s !important; }
    .conversation-grid-item-container:nth-child(13) { animation-delay: 1.2s !important; }
    
    .layout-people .conversation-grid-item-container {
  /* PEOPLE VIEW: Standard people view layout */
  width: 60px !important; /* Standard people view size */
  height: 60px !important; /* Standard people view size */
  min-width: 60px !important; /* Force consistent size */
  min-height: 60px !important;
  max-width: 60px !important; /* Force consistent size */
  max-height: 60px !important;
  box-sizing: border-box;
  border: 1px solid #E5E6E2 !important; /* Navigation color border */
  border-radius: 0 !important; /* No corner radius */
  /* Fixed aspect ratio */
  aspect-ratio: 1 / 1;
  /* Smooth transitions */
  transition: left 0.3s ease, top 0.3s ease, opacity 0.3s ease;
  /* ABSOLUTE POSITIONING: Essential for no-overlap layout */
  position: absolute !important;
  /* NO margins or padding that could cause positioning issues */
  margin: 0 !important;
  padding: 0 !important;
  /* Clear z-index for proper stacking */
  z-index: 10;
}

    .layout-timeline .conversation-grid-item-container {
  /* VISUAL SIZE: Use calculated optimal size with proper margins */
  width: var(--visual-conversation-size, 80px) !important; /* Optimal visual width */
  height: var(--visual-conversation-size, 80px) !important; /* Optimal visual height */
  min-width: var(--visual-conversation-size, 80px) !important; /* Force consistent size */
  min-height: var(--visual-conversation-size, 80px) !important;
  max-width: var(--visual-conversation-size, 80px) !important; /* Force consistent size */
  max-height: var(--visual-conversation-size, 80px) !important;
  box-sizing: border-box;
  border: 1px solid #E5E6E2 !important; /* Navigation color border */
  border-radius: 0 !important; /* No corner radius */
  /* Fixed aspect ratio */
  aspect-ratio: 1 / 1;
  /* ABSOLUTE POSITIONING: Essential for no-overlap layout */
  position: absolute !important;
  /* NO margins or padding that could cause positioning issues */
  margin: 0 !important;
  padding: 0 !important;
  /* Clear z-index for proper stacking */
  z-index: 10;
     /* ISOTOPE ANIMATIONS: Enhanced smooth transitions for timeline */
   transition: left 0.8s cubic-bezier(0.23, 1, 0.32, 1), 
              top 0.8s cubic-bezier(0.23, 1, 0.32, 1),
              width 0.8s cubic-bezier(0.23, 1, 0.32, 1),
              height 0.8s cubic-bezier(0.23, 1, 0.32, 1),
              transform 0.4s cubic-bezier(0.23, 1, 0.32, 1),
              opacity 0.3s cubic-bezier(0.23, 1, 0.32, 1) !important;
   will-change: transform, left, top, width, height, opacity !important;
   backface-visibility: hidden !important;
   perspective: 1000px !important;
   transform-style: preserve-3d !important;
     /* Staggered animation delay for isotope effect */
  animation-delay: calc(var(--item-index, 0) * 0.03s) !important;
}

    /* Timeline view hover effect - Black border */
    .layout-timeline .conversation-grid-item-container:hover {
        border: 1px solid #000000 !important; /* Black border on hover - same thickness */
        z-index: 15 !important; /* Higher than default z-index */
        transition: border 0.3s ease !important;
    }

    
    /* People view - OPTIMIZED transitions */
    .layout-people .conversation-grid-item-container {
        /* Fast, smooth positioning transitions */
        transition: left 0.6s cubic-bezier(0.23, 1, 0.32, 1), 
                   top 0.6s cubic-bezier(0.23, 1, 0.32, 1),
                   width 0.6s cubic-bezier(0.23, 1, 0.32, 1),
                   height 0.6s cubic-bezier(0.23, 1, 0.32, 1),
                   transform 0.3s cubic-bezier(0.23, 1, 0.32, 1),
                   opacity 0.4s cubic-bezier(0.23, 1, 0.32, 1) !important;
        /* Reduced staggered animation delay */
        animation-delay: calc(var(--item-index, 0) * 0.02s) !important;
    }
    
    /* OPTIMIZED container transitions */
    #timeline-axes-container {
        transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1) !important;
    }
    
    #layout-canvas {
        transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1) !important;
    }
    
    /* Enhanced isotope view switching animation */
    .layout-timeline #layout-canvas {
        transform-origin: center center !important;
        transition: transform 0.8s cubic-bezier(0.23, 1, 0.32, 1) !important;
        /* STACKED LAYOUT: Use absolute positioning for precise date group stacking */
        display: block !important;
        position: relative !important;
        padding: 20px !important;
        box-sizing: border-box !important;
        overflow: hidden !important;
        width: 100% !important;
        height: 100% !important;
    }
    
    .layout-people #layout-canvas {
        transform-origin: center bottom !important;
        transition: transform 0.8s cubic-bezier(0.23, 1, 0.32, 1) !important;
    }
    
    /* Isotope-style entrance animations */
    @keyframes isotopeEnter {
        0% {
            opacity: 0;
            transform: scale(0.6) rotateY(180deg);
        }
        50% {
            opacity: 0.8;
            transform: scale(1.1) rotateY(90deg);
        }
        100% {
            opacity: 1;
            transform: scale(1) rotateY(0deg);
        }
    }
    
    /* Isotope-style exit animations */
    @keyframes isotopeExit {
        0% {
            opacity: 1;
            transform: scale(1) rotateY(0deg);
        }
        50% {
            opacity: 0.3;
            transform: scale(0.8) rotateY(-90deg);
        }
        100% {
            opacity: 0;
            transform: scale(0.4) rotateY(-180deg);
        }
    }
    
    /* Apply isotope animations during view transitions */
    .isotope-transitioning .conversation-grid-item-container {
        animation: isotopeEnter 1.2s cubic-bezier(0.23, 1, 0.32, 1) forwards !important;
    }

    /* Ensure timeline containers get isotope animations */
    .layout-timeline.isotope-transitioning .conversation-grid-item-container,
    .isotope-transitioning .layout-timeline .conversation-grid-item-container {
        animation: isotopeEnter 1.2s cubic-bezier(0.23, 1, 0.32, 1) forwards !important;
    }

    /* Timeline track wrapper isotope transitions */
    .timeline-track-wrapper.isotope-transitioning {
        animation: isotopeEnter 1.2s cubic-bezier(0.23, 1, 0.32, 1) forwards !important;
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1) !important;
    }

    /* Timeline conversations container isotope transitions */
    #timeline-conversations-container.isotope-transitioning {
        animation: isotopeEnter 1.2s cubic-bezier(0.23, 1, 0.32, 1) forwards !important;
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1) !important;
    }

    /* Enhanced isotope switching animations for better consistency */
    .isotope-switching .conversation-grid-item-container {
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1) !important;
        will-change: transform, left, top, width, height, opacity;
        transform-origin: center center;
        backface-visibility: hidden;
        perspective: 1000px;
    }

    /* Prevent layout breaks during view transitions */
    #layout-canvas.isotope-transitioning,
    #layout-canvas.isotope-switching,
    #timeline-axes-container.isotope-transitioning,
    #timeline-axes-container.isotope-switching {
        position: relative !important;
        overflow: visible !important;
        min-height: 600px !important;
        width: 100% !important;
        height: 100% !important;
    }

    /* Layout stability during transitions */
    .transitioning {
        pointer-events: none; /* Prevent interaction during transitions */
    }

    /* Emergency layout consistency fixes */
    .layout-timeline #timeline-axes-container,
    .layout-people #timeline-axes-container,
    .layout-emotions #timeline-axes-container {
        display: block !important;
        visibility: visible !important;
        position: relative !important;
        width: 100% !important;
        height: 100% !important;
    }

    /* Ensure consistent canvas sizing across views */
    #layout-canvas {
        position: relative !important;
        width: 100% !important;
        min-height: 600px !important;
        overflow: hidden !important;
    }








    @keyframes naturalFloat {
        0% {
            transform: translate(-50%, -50%) scale(1) rotate(0deg);
            left: 25%;
            top: 35%;
        }
        8% {
            transform: translate(-50%, -50%) scale(1.05) rotate(8deg);
            left: 35%;
            top: 30%;
        }
        16% {
            transform: translate(-50%, -50%) scale(0.98) rotate(-5deg);
            left: 45%;
            top: 25%;
        }
        24% {
            transform: translate(-50%, -50%) scale(1.08) rotate(12deg);
            left: 55%;
            top: 30%;
        }
        32% {
            transform: translate(-50%, -50%) scale(0.95) rotate(-8deg);
            left: 65%;
            top: 35%;
        }
        40% {
            transform: translate(-50%, -50%) scale(1.03) rotate(6deg);
            left: 75%;
            top: 40%;
        }
        48% {
            transform: translate(-50%, -50%) scale(0.97) rotate(-3deg);
            left: 70%;
            top: 50%;
        }
        56% {
            transform: translate(-50%, -50%) scale(1.06) rotate(10deg);
            left: 60%;
            top: 60%;
        }
        64% {
            transform: translate(-50%, -50%) scale(0.94) rotate(-7deg);
            left: 50%;
            top: 65%;
        }
        72% {
            transform: translate(-50%, -50%) scale(1.04) rotate(4deg);
            left: 40%;
            top: 60%;
        }
        80% {
            transform: translate(-50%, -50%) scale(0.99) rotate(-2deg);
            left: 30%;
            top: 55%;
        }
        88% {
            transform: translate(-50%, -50%) scale(1.07) rotate(9deg);
            left: 25%;
            top: 45%;
        }
        96% {
            transform: translate(-50%, -50%) scale(0.96) rotate(-4deg);
            left: 28%;
            top: 38%;
        }
        100% {
            transform: translate(-50%, -50%) scale(1) rotate(0deg);
            left: 25%;
            top: 35%;
        }
    }

    @keyframes naturalFloat2 {
        0% {
            transform: translate(-50%, -50%) scale(1) rotate(0deg);
            left: 70%;
            top: 60%;
        }
        10% {
            transform: translate(-50%, -50%) scale(1.06) rotate(12deg);
            left: 80%;
            top: 45%;
        }
        20% {
            transform: translate(-50%, -50%) scale(0.97) rotate(-8deg);
            left: 65%;
            top: 35%;
        }
        30% {
            transform: translate(-50%, -50%) scale(1.09) rotate(15deg);
            left: 75%;
            top: 50%;
        }
        40% {
            transform: translate(-50%, -50%) scale(0.94) rotate(-5deg);
            left: 60%;
            top: 65%;
        }
        50% {
            transform: translate(-50%, -50%) scale(1.04) rotate(8deg);
            left: 85%;
            top: 70%;
        }
        60% {
            transform: translate(-50%, -50%) scale(0.98) rotate(-3deg);
            left: 70%;
            top: 80%;
        }
        70% {
            transform: translate(-50%, -50%) scale(1.07) rotate(11deg);
            left: 55%;
            top: 75%;
        }
        80% {
            transform: translate(-50%, -50%) scale(0.95) rotate(-7deg);
            left: 45%;
            top: 65%;
        }
        90% {
            transform: translate(-50%, -50%) scale(1.03) rotate(6deg);
            left: 60%;
            top: 55%;
        }
        100% {
            transform: translate(-50%, -50%) scale(1) rotate(0deg);
            left: 70%;
            top: 60%;
        }
    }

    /* Different emotion color schemes - HIGHLY PIXELATED SQUARE GRADIENT */
    .emotion-blob.happiness, .emotion-blob.happy {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 215, 0, 0.2) 2px,
                rgba(255, 215, 0, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(255, 215, 0, 0.2) 2px,
                rgba(255, 215, 0, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(255, 215, 0, 0.1) 3px,
                rgba(255, 215, 0, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(255, 215, 0, 0.5), rgba(255, 215, 0, 0.35), rgba(255, 215, 0, 0.2));
        filter: blur(6px) contrast(1.3) saturate(1.2);
    }

    .emotion-blob.joy {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 255, 0, 0.2) 2px,
                rgba(255, 255, 0, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(255, 255, 0, 0.2) 2px,
                rgba(255, 255, 0, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(255, 255, 0, 0.1) 3px,
                rgba(255, 255, 0, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(255, 255, 0, 0.6), rgba(255, 255, 0, 0.4), rgba(255, 255, 0, 0.25));
        filter: blur(5px) contrast(1.4) saturate(1.3);
        animation: naturalFloat 25s infinite ease-in-out;
    }

    .emotion-blob.sadness, .emotion-blob.sad {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(65, 105, 225, 0.2) 2px,
                rgba(65, 105, 225, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(65, 105, 225, 0.2) 2px,
                rgba(65, 105, 225, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(65, 105, 225, 0.1) 3px,
                rgba(65, 105, 225, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(65, 105, 225, 0.5), rgba(65, 105, 225, 0.35), rgba(65, 105, 225, 0.2));
        filter: blur(8px) contrast(1.2) saturate(1.1);
    }

    .emotion-blob.anger, .emotion-blob.angry {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 69, 0, 0.2) 2px,
                rgba(255, 69, 0, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(255, 69, 0, 0.2) 2px,
                rgba(255, 69, 0, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(255, 69, 0, 0.1) 3px,
                rgba(255, 69, 0, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(255, 69, 0, 0.6), rgba(255, 69, 0, 0.4), rgba(255, 69, 0, 0.25));
        filter: blur(4px) contrast(1.5) saturate(1.4);
    }

    .emotion-blob.love {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(25, 56, 97, 0.2) 2px,
                rgba(25, 56, 97, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(25, 56, 97, 0.2) 2px,
                rgba(25, 56, 97, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(25, 56, 97, 0.1) 3px,
                rgba(25, 56, 97, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(25, 56, 97, 0.6), rgba(25, 56, 97, 0.4), rgba(25, 56, 97, 0.25));
        filter: blur(7px) contrast(1.3) saturate(1.2);
    }

    .emotion-blob.excitement, .emotion-blob.excited {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 20, 147, 0.2) 2px,
                rgba(255, 20, 147, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(255, 20, 147, 0.2) 2px,
                rgba(255, 20, 147, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(255, 20, 147, 0.1) 3px,
                rgba(255, 20, 147, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(255, 20, 147, 0.6), rgba(255, 20, 147, 0.4), rgba(255, 20, 147, 0.25));
        filter: blur(6px) contrast(1.4) saturate(1.3);
        animation: naturalFloat 20s infinite ease-in-out;
    }

    .emotion-blob.calm {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(78, 205, 196, 0.2) 2px,
                rgba(78, 205, 196, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(78, 205, 196, 0.2) 2px,
                rgba(78, 205, 196, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(78, 205, 196, 0.1) 3px,
                rgba(78, 205, 196, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(78, 205, 196, 0.4), rgba(78, 205, 196, 0.25), rgba(78, 205, 196, 0.15));
        filter: blur(10px) contrast(1.1) saturate(1.0);
    }

    .emotion-blob.neutral {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(169, 169, 169, 0.2) 2px,
                rgba(169, 169, 169, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(192, 192, 192, 0.2) 2px,
                rgba(192, 192, 192, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(211, 211, 211, 0.1) 3px,
                rgba(211, 211, 211, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(169, 169, 169, 0.4), rgba(192, 192, 192, 0.3), rgba(211, 211, 211, 0.15));
        filter: blur(8px) contrast(1.2) saturate(1.1);
    }



    @keyframes gentleExcitement {
        0%, 100% {
            transform: translate(-50%, -50%) scale(1) rotate(0deg);
            left: 35%;
            top: 45%;
        }
        12.5% {
            transform: translate(-50%, -50%) scale(1.15) rotate(8deg);
            left: 70%;
            top: 30%;
        }
        25% {
            transform: translate(-50%, -50%) scale(0.9) rotate(-12deg);
            left: 85%;
            top: 55%;
        }
        37.5% {
            transform: translate(-50%, -50%) scale(1.2) rotate(15deg);
            left: 60%;
            top: 75%;
        }
        50% {
            transform: translate(-50%, -50%) scale(0.85) rotate(-8deg);
            left: 25%;
            top: 65%;
        }
        62.5% {
            transform: translate(-50%, -50%) scale(1.1) rotate(20deg);
            left: 10%;
            top: 40%;
        }
        75% {
            transform: translate(-50%, -50%) scale(0.95) rotate(-5deg);
            left: 20%;
            top: 20%;
        }
        87.5% {
            transform: translate(-50%, -50%) scale(1.05) rotate(10deg);
            left: 50%;
            top: 25%;
        }
    }


    
    /* Hide scrollbars for conversation wizard and about page containers */
    #conversation-wizard-page::-webkit-scrollbar {
        display: none;
    }
    
    #about-page::-webkit-scrollbar {
        display: none;
    }
    
    /* Hide scrollbars for retranscribe panel */
    .retranscribe-panel::-webkit-scrollbar {
        display: none;
    }
  </style>
</head>

<body>





  <div id="header-container"></div>
  <!-- header.js removed - not needed -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
        // Header functionality removed - no longer needed
    });
  </script>

  <script>
    // Dynamic conversation data - loaded from auto-generated configuration
    window.conversationDataGlobal = [];
    window.originalConversationData = [];
    
    // Load people data from JSON
    async function loadPeopleData() {
        try {
            const response = await fetch('/config/people_data.json');
            if (!response.ok) {
                throw new Error(`Failed to load people data: ${response.status}`);
            }
            const data = await response.json();
            window.peopleData = data;
            console.log('âœ… Loaded people data:', data);
            return data;
        } catch (error) {
            console.error('âŒ Failed to load people data:', error);
            return null;
        }
    }
    
    // Load conversation configuration dynamically
    async function loadConversationConfig(isRefresh = false) {
        try {
            // âœ… ENHANCED CACHE-BUSTING: Always prevent stale config after refresh
            const cacheBuster = isRefresh ? `?v=${Date.now()}&refresh=true` : `?v=${Date.now()}`;
            console.log(`ğŸ“¡ Loading conversation config from: config/conversations_config.json${cacheBuster}`);
            
            const response = await fetch(`config/conversations_config.json${cacheBuster}`, {
                cache: 'no-cache',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            });
            
            if (!response.ok) {
                throw new Error(`Failed to load config: ${response.status} ${response.statusText}`);
            }
            
            const config = await response.json();
            console.log('ğŸ“„ Index.html loaded config:', config);
            
            // Convert configuration to the format expected by the frontend - FILTER AND SORT
            const allConversationData = Object.entries(config.conversations)
                .map(([folder, data], index) => {
                    // Use enhanced metadata if available
                    const metadata = data.metadata || {};
                    
                    // Get display name - prioritize metadata name
                    const displayName = metadata.name || `×©×™×—×” ${data.number}`;
                    
                    // Get participants info - use metadata if available
                    const participants = metadata.participants?.length 
                        ? metadata.participants.join(', ') 
                        : displayName;
                    
                    // Get date - use metadata date if available
                    const conversationDate = metadata.date || '2024-06-26';
                    
                    // Get duration - use calculated duration if available
                    const duration = metadata.duration || `${Math.round(data.mp3_count * 0.5)} ×“×§×•×ª`;
                    
                    // Get emotions - use main emotions if available
                    const mainEmotions = metadata.mainEmotions?.length 
                        ? metadata.mainEmotions 
                        : ['× ×™×ª×•×— ×¨×’×©×™'];
                    
                    // Create summary feelings from main emotions and word count
                    const emotionSummary = mainEmotions.join(', ');
                    const wordCount = metadata.totalWords ? ` | ${metadata.totalWords} ××™×œ×™×` : '';
                    const summaryFeelings = `${emotionSummary}${wordCount}`;
                    
                    // Parse duration to get minutes (if in MM:SS format)
                    let durationMinutes = Math.round(data.mp3_count * 0.5);
                    if (metadata.duration && metadata.duration.includes(':')) {
                        const [minutes, seconds] = metadata.duration.split(':').map(Number);
                        durationMinutes = minutes + Math.round(seconds / 60);
                    }
                    
                    return {
                        id: `conv${data.number}`,
                        folder: folder,
                        date: conversationDate,
                        time: '12:00',
                        participants: participants,
                        summaryFeelings: summaryFeelings,
                        durationMinutes: durationMinutes,
                        emotionFile: data.ai_file || data.emotion_file,
                        mp3_count: data.mp3_count,
                        conversationNumber: data.number,
                        // Include metadata for advanced features
                        metadata: metadata,
                        displayName: displayName,
                        mainEmotions: mainEmotions,
                        isImportant: metadata.isImportant || false,
                        isPrivate: metadata.isPrivate || false,
                        needsReview: metadata.needsReview || false
                    };
                })
                .sort((a, b) => a.conversationNumber - b.conversationNumber);
            
            // FILTER OUT CONVERSATIONS WITH INSUFFICIENT CONTENT
            const newConversationData = allConversationData.filter(conv => {
                // Minimum requirements for display - RELAXED for timeline compatibility
                const hasEnoughContent = conv.mp3_count >= 1; // At least 1 MP3 file (reduced from 3)
                
                if (!hasEnoughContent) {
                    console.log(`âš ï¸ Filtering out ${conv.folder}: insufficient content (${conv.mp3_count} MP3s)`);
                    return false;
                }
                
                // Always show conversations in timeline - video files are optional
                console.log(`âœ… Including ${conv.folder} in timeline (${conv.mp3_count} MP3s)`);
                return true;
            });
            
            // Check if there are any changes (for refresh scenarios)
            const hasChanges = JSON.stringify(newConversationData) !== JSON.stringify(window.conversationDataGlobal);
            
                            if (hasChanges || !isRefresh) {
                window.conversationDataGlobal = newConversationData;
                window.originalConversationData = JSON.parse(JSON.stringify(window.conversationDataGlobal));
                
                // Enhanced logging to show filtered conversations
                const totalFromConfig = allConversationData.length;
                const displayedCount = window.conversationDataGlobal.length;
                const filteredOut = totalFromConfig - displayedCount;
                
                console.log(`ğŸ“Š Conversation Filtering Results:`);
                console.log(`   ğŸ“ Total in config: ${totalFromConfig}`);
                console.log(`   âœ… Displaying: ${displayedCount}`);
                console.log(`   ğŸš« Filtered out: ${filteredOut}`);
                console.log(`   ğŸ¬ Displayed conversations: ${window.conversationDataGlobal.map(c => c.folder).join(', ')}`);
                
                if (isRefresh && hasChanges) {
                    console.log(`ğŸ”„ Detected ${window.conversationDataGlobal.length} conversations (updated from admin changes)`);
                    
                    // Remove deleted conversation items from DOM
                    removeDeletedConversationItems();
                    
                    // Re-render the layout with updated data
                    if (typeof window.renderNewLayout === 'function') {
                        window.renderNewLayout(false);
                    }
                    
                    // Show notification about the change (commented out)
                    // showConversationUpdateNotification();
                } else {
                    console.log(`âœ… Loaded ${window.conversationDataGlobal.length} conversations dynamically`);
                
                // Update blob emotion based on loaded conversations
                setTimeout(() => {
                    if (typeof window.updateBlobEmotionFromConversations === 'function') {
                        window.updateBlobEmotionFromConversations();
                    }
                }, 1000);
                }
            }
            
            return true;
        } catch (error) {
            console.error('âŒ Failed to load conversation config, using fallback:', error);
            
            // Fallback to hardcoded data if config file doesn't exist - ALL CONVERSATIONS (videos optional)
            window.conversationDataGlobal = [
                { id: 'conv1', folder: 'convo1', date: '2024-04-05', time: '11:00', participants: '×©×™×—×” ×¢× ××‘×', summaryFeelings: '×©××—×”, ×¢× ×™×™×Ÿ', durationMinutes: 37, mp3_count: 73 },
                { id: 'conv2', folder: 'convo2', date: '2024-05-15', time: '16:00', participants: '×©×™×—×” ×¢×œ ×”×¦×‘×', summaryFeelings: '× ×™×ª×•×—, ×¡×§×¨× ×•×ª', durationMinutes: 87, mp3_count: 174 },
                { id: 'conv3', folder: 'convo3', date: '2024-06-24', time: '21:10', participants: '×©×™×—×” ×¢× ×—×‘×™×œ×”', summaryFeelings: '×©×™×—×” ×§×¦×¨×”', durationMinutes: 2, mp3_count: 4 },
                { id: 'conv4', folder: 'convo4', date: '2024-07-01', time: '10:00', participants: '×¢×œ ×”×—×™×™×', summaryFeelings: '×¡×§×¨× ×•×ª, × ×™×ª×•×—', durationMinutes: 10, mp3_count: 20 },
                { id: 'conv5', folder: 'convo5', date: '2024-07-10', time: '14:30', participants: '×©×™×¢×•×¨ ×•×“×’×—×', summaryFeelings: '×“×™×•×Ÿ ××¢××™×§', durationMinutes: 37, mp3_count: 73 },
                { id: 'conv6', folder: 'convo6', date: '2024-07-15', time: '09:15', participants: '×‘×™×•× ×™×•× ×¢× ×¤×¨×“×™', summaryFeelings: '×©×™×—×” ××¨×•×›×”', durationMinutes: 52, mp3_count: 104 },
                { id: 'conv7', folder: 'convo7', date: '2024-07-20', time: '16:45', participants: '××‘×—×Ÿ ×©×œ ×™×•××‘', summaryFeelings: '×©×™×—×” ×‘×™× ×•× ×™×ª', durationMinutes: 35, mp3_count: 68 },
                { id: 'conv8', folder: 'convo8', date: '2024-07-25', time: '12:00', participants: '× ×¤×’×©×™× ×‘×™×¨×™×“', summaryFeelings: '×©×™×—×” ×§×¦×¨×”', durationMinutes: 8, mp3_count: 14 },
                { id: 'conv10', folder: 'convo10', date: '2024-08-01', time: '13:30', participants: '×¤×¨×™×“×” ××’×™×œ×™×‘×¨', summaryFeelings: '×©×™×—×” ××¨×•×›×”', durationMinutes: 52, mp3_count: 104 },
                // NEW CONVERSATIONS ADDED
                { id: 'conv19', folder: 'convo19', date: '2025-07-20', time: '15:00', participants: '×œ× × ×¤×’×© ×¢× ×’×™×œ×™×‘×¨', summaryFeelings: '×©××—×”', durationMinutes: 1, mp3_count: 24 },
                { id: 'conv20', folder: 'convo20', date: '2025-07-25', time: '15:14', participants: '×©×™×—×” ×¢× ×’×™×œ×™×‘×¨ ×‘××—×•×‘×¨ 12', summaryFeelings: '× ×™×™×˜×¨×œ×™', durationMinutes: 1, mp3_count: 32 },
                { id: 'conv21', folder: 'convo21', date: '2025-07-25', time: '15:14', participants: '×©×™×—×” ×¢× ×’×™×œ×™×‘×¨ ×‘××—×•×‘×¨ 11', summaryFeelings: '× ×™×™×˜×¨×œ×™', durationMinutes: 1, mp3_count: 23 },
                { id: 'conv22', folder: 'convo22', date: '2025-07-25', time: '15:14', participants: '×©×™×—×” ×¢× ×’×™×œ×™×‘×¨ ×‘××—×•×‘×¨ 10', summaryFeelings: '× ×™×™×˜×¨×œ×™', durationMinutes: 1, mp3_count: 15 },
                { id: 'conv23', folder: 'convo23', date: '2025-07-25', time: '15:14', participants: '×©×™×—×” ×¢× ×’×™×œ×™×‘×¨ ×‘××—×•×‘×¨ 9', summaryFeelings: '× ×™×™×˜×¨×œ×™', durationMinutes: 1, mp3_count: 42 },
                { id: 'conv27', folder: 'convo27', date: '2025-07-25', time: '15:13', participants: '×©×™×—×” ×¢× ×’×™×œ×™×‘×¨ ×‘××—×•×‘×¨ 8', summaryFeelings: '× ×™×™×˜×¨×œ×™', durationMinutes: 1, mp3_count: 52 },
                { id: 'conv28', folder: 'convo28', date: '2025-07-25', time: '15:13', participants: '×©×™×—×” ×¢× ×’×™×œ×™×‘×¨ ×‘××—×•×‘×¨ 7', summaryFeelings: '× ×™×™×˜×¨×œ×™', durationMinutes: 2, mp3_count: 91 },
                { id: 'conv29', folder: 'convo29', date: '2025-07-25', time: '15:13', participants: '×©×™×—×” ×¢× ×’×™×œ×™×‘×¨ ×‘××—×•×‘×¨ 6', summaryFeelings: '× ×™×™×˜×¨×œ×™', durationMinutes: 1, mp3_count: 3 },
                { id: 'conv30', folder: 'convo30', date: '2025-07-25', time: '15:13', participants: '×©×™×—×” ×¢× ×’×™×œ×™×‘×¨ ×‘××—×•×‘×¨ 5', summaryFeelings: '× ×™×™×˜×¨×œ×™', durationMinutes: 1, mp3_count: 5 },
                { id: 'conv31', folder: 'convo31', date: '2025-07-25', time: '15:13', participants: '×©×™×—×” ×¢× ×’×™×œ×™×‘×¨ ×‘××—×•×‘×¨ 4', summaryFeelings: '× ×™×™×˜×¨×œ×™', durationMinutes: 2, mp3_count: 98 },
                { id: 'conv32', folder: 'convo32', date: '2025-07-25', time: '15:13', participants: '×©×™×—×” ×¢× ×’×™×œ×™×‘×¨ ×‘××—×•×‘×¨ 2', summaryFeelings: '× ×™×™×˜×¨×œ×™', durationMinutes: 2, mp3_count: 69 },
                { id: 'conv33', folder: 'convo33', date: '2025-07-25', time: '15:13', participants: '×©×™×—×” ×¢× ×’×™×œ×™×‘×¨ ×‘××—×•×‘×¨ 2', summaryFeelings: '× ×™×™×˜×¨×œ×™', durationMinutes: 2, mp3_count: 69 },
                { id: 'conv34', folder: 'convo34', date: '2025-07-25', time: '15:12', participants: '×©×œ×•×', summaryFeelings: '× ×™×™×˜×¨×œ×™', durationMinutes: 1, mp3_count: 24 },
            ];
            window.originalConversationData = JSON.parse(JSON.stringify(window.conversationDataGlobal));
            return false;
        }
    }
    
    // Helper function to remove deleted conversation items from DOM
    function removeDeletedConversationItems() {
        const layoutCanvas = document.getElementById('layout-canvas');
        if (!layoutCanvas) return;
        
        // Get list of current conversation folders
        const currentFolders = new Set(window.conversationDataGlobal.map(conv => conv.folder));
        
        // Find and remove conversation items that no longer exist
        const allConvItems = layoutCanvas.querySelectorAll('[id^="conv-item-"]');
        allConvItems.forEach(item => {
            const convId = item.id.replace('conv-item-', '');
            const convData = window.conversationDataGlobal.find(c => c.id === convId);
            
            if (!convData) {
                console.log(`ğŸ—‘ï¸ Removing deleted conversation item: ${convId}`);
                item.remove();
            }
        });
    }
    
    // Show notification when conversations are updated
    function showConversationUpdateNotification() {
        // Create or show notification
        let notification = document.getElementById('conversation-update-notification');
        if (!notification) {
            notification = document.createElement('div');
            notification.id = 'conversation-update-notification';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #4CAF50, #45a049);
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 10000;
                font-size: 14px;
                max-width: 300px;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
                direction: rtl;
            `;
            document.body.appendChild(notification);
        }
        
        notification.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 18px;">âœ…</span>
                <span>×”×©×™×—×•×ª ×¢×•×“×›× ×• ××•×˜×•××˜×™×ª</span>
            </div>
            <div style="font-size: 12px; margin-top: 5px; opacity: 0.9;">
                ×©×™× ×•×™×™× ××”×¤×× ×œ ×”× ×™×”×•×œ ×¡×•× ×›×¨× ×•
            </div>
        `;
        
        // Show notification
        setTimeout(() => {
            notification.style.opacity = '1';
            notification.style.transform = 'translateX(0)';
        }, 100);
        
        // Hide notification after 3 seconds
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    
    // Periodic refresh to check for admin panel changes
    let refreshInterval;
    function startConversationSync() {
        // Check for changes every 60 seconds instead of 10 to reduce load
        refreshInterval = setInterval(async () => {
            try {
                await loadConversationConfig(true);
                await loadPeopleData(); // Also sync people data
            } catch (error) {
                console.warn('âš ï¸ Failed to sync conversations:', error);
            }
        }, 60000); // 60 seconds (was 10 seconds)
    }
    
    function stopConversationSync() {
        if (refreshInterval) {
            clearInterval(refreshInterval);
            refreshInterval = null;
        }
    }
    
    // Manual refresh function (can be called from admin panel)
    window.refreshConversations = async function() {
        console.log('ğŸ”„ Manual conversation refresh requested');
        await loadConversationConfig(true);
        await loadPeopleData(); // Also refresh people data
    };
    
    window.populateConversationGrid = async function() {
        // Skip conversation loading if in lab mode
        if (window.isLabMode || window.skipConversationLoading) {
            console.log('ğŸ§ª Skipping conversation loading - Lab mode active');
            return;
        }
        
        console.log('ğŸš€ Starting conversation grid population...');
        
        // Load configuration first if not already loaded
        if (window.conversationDataGlobal.length === 0) {
            console.log('ğŸ“Š Loading conversation configuration with force refresh...');
            await loadConversationConfig(true); // Force refresh on initial page load
        }
        
        // Ensure data is loaded before proceeding
        if (window.conversationDataGlobal.length === 0) {
            console.error('âŒ No conversation data available after loading!');
            return;
        }
        
        console.log(`âœ… Conversation data loaded: ${window.conversationDataGlobal.length} conversations`);
        
        // Load people data for people view
        console.log('ğŸ‘¥ Loading people data...');
        await loadPeopleData();
        
        // Populate re-transcription options dynamically
        populateRetranscriptionOptions();
        
        // Ensure we start with timeline view for proper first load
        if (!window.activeLayout) {
            window.activeLayout = 'timeline';
            console.log('ğŸ¯ Set initial layout to timeline');
        }
        
        // Render the layout with initial data
        if (typeof window.renderNewLayout === 'function') {
            console.log('ğŸ¬ Rendering initial layout...');
            await window.renderNewLayout(true);
        } else {
            console.error('âŒ renderNewLayout function not available!');
        }
        
        // Start automatic synchronization
        startConversationSync();
        
        // Set up BroadcastChannel for cross-tab communication
        setupCrossTabSync();
        
        console.log('âœ… Conversation grid population completed');
    };
    
    // Set up cross-tab communication with admin panel
    function setupCrossTabSync() {
        if (typeof BroadcastChannel !== 'undefined') {
            const channel = new BroadcastChannel('conversation-sync');
            
            channel.addEventListener('message', async (event) => {
                const { type, folder, timestamp } = event.data;
                
                if (type === 'conversation-deleted') {
                    console.log(`ğŸ“» Received deletion broadcast for ${folder}`);
                    // Immediately refresh to sync changes
                    setTimeout(async () => {
                        await loadConversationConfig(true);
                    }, 1000);
                } else if (type === 'refresh-conversations') {
                    console.log(`ğŸ“» Received refresh broadcast from admin panel`);
                    setTimeout(async () => {
                        await loadConversationConfig(true);
                    }, 500);
                } else if (type === 'force-config-reload') {
                    console.log(`ğŸ“» Received force config reload broadcast from admin panel`);
                    
                    // Clear any cached data
                    window.conversationDataGlobal = [];
                    window.lastConfigUpdate = Date.now();
                    
                    setTimeout(async () => {
                        await loadConversationConfig(true);
                        console.log('âœ… Forced conversation config reload completed via broadcast');
                        
                        // Force re-render the current layout to show updated names
                        if (typeof window.renderNewLayout === 'function') {
                            console.log('ğŸ”„ Re-rendering layout via broadcast with updated conversation names...');
                            await window.renderNewLayout(true);
                            console.log('âœ… Layout re-rendered via broadcast with updated names');
                        }
                    }, 300);
                } else if (type === 'update-conversation-title') {
                    console.log(`ğŸ“» Received conversation title update broadcast from admin panel:`, event.data);
                    
                    // Update conversation data in memory and refresh grid
                    if (event.data.metadata && event.data.metadata.name && event.data.conversation) {
                        console.log(`ğŸ”„ Updating conversation data via broadcast for ${event.data.conversation} with name: ${event.data.metadata.name}`);
                        
                        // Update the conversation data in memory
                        const conversationToUpdate = window.conversationDataGlobal.find(conv => conv.folder === event.data.conversation);
                        if (conversationToUpdate) {
                            conversationToUpdate.displayName = event.data.metadata.name;
                            conversationToUpdate.metadata = { ...conversationToUpdate.metadata, ...event.data.metadata };
                            console.log(`âœ… Updated conversation data in memory via broadcast for ${event.data.conversation}`);
                        }
                        
                        // Update the data-conversation attribute for the grid item
                        const gridItem = document.getElementById(`conv-item-${event.data.conversation}`);
                        if (gridItem) {
                            gridItem.setAttribute('data-conversation', event.data.metadata.name);
                            console.log(`âœ… Updated grid item data-conversation attribute via broadcast for ${event.data.conversation}`);
                        }
                        
                        // If there's a currently visible hover panel for this conversation, update it
                        const hoverPanel = document.getElementById('hover-info-panel');
                        if (hoverPanel && hoverPanel.classList.contains('visible')) {
                            const titleElement = hoverPanel.querySelector('.hover-info-title');
                            if (titleElement && conversationToUpdate) {
                                // Update hover panel if it's showing this conversation
                                const panelText = titleElement.textContent;
                                if (panelText.includes(event.data.conversation) || panelText.includes(conversationToUpdate.displayName)) {
                                    showHoverPanel(conversationToUpdate);
                                    console.log(`âœ… Updated visible hover panel via broadcast for ${event.data.conversation}`);
                                }
                            }
                        }
                        
                        console.log(`âœ… Conversation title update via broadcast completed for ${event.data.conversation}`);
                    }
                }
            });
            
            console.log('ğŸ“» BroadcastChannel setup complete for conversation sync');
            
            // Clean up on page unload
            window.addEventListener('beforeunload', () => {
                channel.close();
            });
        }
    }
    
    // Function to populate re-transcription options dynamically
    function populateRetranscriptionOptions() {
        const quickAnalysisContainer = document.getElementById('quick-analysis-options');
        const fullReprocessContainer = document.getElementById('full-reprocess-options');
        
        if (!quickAnalysisContainer || !fullReprocessContainer) return;
        
        // Clear existing content
        quickAnalysisContainer.innerHTML = '';
        fullReprocessContainer.innerHTML = '';
        
        // Generate options for each conversation
        window.conversationDataGlobal.forEach(conv => {
            // Quick analysis option
            const quickButton = document.createElement('button');
            quickButton.className = 'convo-option quick-analysis';
            quickButton.onclick = () => retranscribeConversation(conv.folder, false);
            quickButton.innerHTML = `
                <span class="convo-icon">ğŸµ</span>
                <span class="convo-details">
                    <span class="convo-name">${conv.participants}</span>
                    <span class="convo-count">${conv.mp3_count || 'N/A'} ×§×˜×¢×™×</span>
                </span>
            `;
            quickAnalysisContainer.appendChild(quickButton);
            
            // Full reprocess option
            const fullButton = document.createElement('button');
            fullButton.className = 'convo-option full-reprocess';
            fullButton.onclick = () => reprocessMP3Files(conv.folder);
            fullButton.innerHTML = `
                <span class="convo-icon">ğŸ”Š</span>
                <span class="convo-details">
                    <span class="convo-name">${conv.participants} - ×ª××œ×•×œ ××œ×</span>
                    <span class="convo-count">${conv.mp3_count || 'N/A'} ×§×‘×¦×™ MP3</span>
                </span>
            `;
            fullReprocessContainer.appendChild(fullButton);
        });
    }
  </script>

  <div id="splash-screen">
    <div class="background-dots" id="backgroundDots"></div>
    <div class="scanlines"></div>
    
    <div class="loading-container">
        <div class="loading-text">×˜×•×¢×Ÿ: ×™×•××Ÿ ×”×©×™×—×•×ª ×©×œ ×œ×™××•×¨</div>
        <div class="loading-bar-container">
            <div class="loading-bar"></div>
        </div>
        <div class="loading-percentage" id="percentage">0%</div>
    </div>
    
    <div class="preview-window preview-1">
        <video muted autoplay loop style="width: 100%; height: 100%; object-fit: contain; background: #f7f9f3;">
            <source src="videos/convo1.mp4" type="video/mp4">
        </video>
    </div>
    
    <div class="preview-window preview-2">
        <video muted autoplay loop style="width: 100%; height: 100%; object-fit: contain; background: #f7f9f3;">
            <source src="videos/convo2.mp4" type="video/mp4">
        </video>
    </div>
    
    <div class="preview-window preview-3">
        <video muted autoplay loop style="width: 100%; height: 100%; object-fit: contain; background: #f7f9f3;">
            <source src="videos/convo4.mp4" type="video/mp4">
        </video>
    </div>
    
    <div class="preview-window preview-4">
        <video muted autoplay loop style="width: 100%; height: 100%; object-fit: contain; background: #f7f9f3;">
            <source src="videos/convo6.mp4" type="video/mp4">
        </video>
    </div>
    
    <div class="preview-window preview-5">
        <video muted autoplay loop style="width: 100%; height: 100%; object-fit: contain; background: #f7f9f3;">
            <source src="videos/convo7.mp4" type="video/mp4">
        </video>
    </div>
    
    <div class="preview-window preview-6">
        <video muted autoplay loop style="width: 100%; height: 100%; object-fit: contain; background: #f7f9f3;">
            <source src="videos/convo9.mp4" type="video/mp4">
        </video>
    </div>
  </div>

  <!-- Main Navigation Header -->
  <header class="app-header">
    <div class="header-title-container" style="all: unset; display: flex; align-items: center;">
      <div class="header-title" style="all: unset;">
        <span id="logo-text" style="font-size: 32px; font-weight: light; font-family: 'Miriam Libre', sans-serif; padding: 8px 0; display: inline-block; min-width: 60px; text-align: center;">1:1</span>
      </div>
      <div id="new-conversation-btn" onclick="showConversationWizardAndGoToMicrophone(); return false;" style="background: transparent; border: 1px solid #999; color: #333; padding: 8px 16px; font-size: 14px; font-family: 'Miriam Libre', sans-serif; cursor: pointer; border-radius: 0; transition: all 0.2s ease; margin-left: 30px; z-index: 9999; position: relative; display: none; visibility: visible; opacity: 1;" onmouseover="this.style.border='1px solid #000'" onmouseout="this.style.border='1px solid #999'">×¦×•×¨ ×©×™×—×” ×—×“×©×”</div>
    </div>
    
            <nav class="header-nav" style="gap: 30px;">
            <a href="#" class="nav-link active-nav" onclick="showConversationsPage(); return false;">×©×™×—×•×ª</a>
            <a href="#" class="nav-link" onclick="showAboutPage(); return false;">×¢×œ ×”×¤×¨×•×™×§×˜</a>
        </nav>
  </header>

    <div id="timeline-grid-wrapper">
        <div id="timeline-axes-container" class="layout-timeline">
            <div id="layout-canvas"></div>
        </div>
    </div>
    
    <!-- Conversation Wizard Container -->
    <div id="conversation-wizard-page" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; z-index: 1000; overflow-y: auto; scrollbar-width: none; -ms-overflow-style: none;">
        <iframe id="conversation-wizard-iframe" src="" style="width: 100%; height: 100%; border: none;"></iframe>
    </div>

    <!-- About Page Container -->
        <div id="about-page" style="display: none; position: fixed; top: 60px; left: 0; width: 100%; height: calc(100% - 60px); background: #f7f9f3; z-index: 500; overflow-y: auto; padding: 60px 40px 40px 40px; scrollbar-width: none; -ms-overflow-style: none;">
        <div style="max-width: 600px; margin: 0 auto; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 0;">
            <h1 style="text-align: center; font-size: 24px; font-weight: 400; color: #333; margin-bottom: 30px;">×¢×œ ×”×¤×¨×•×™×§×˜</h1>
            
            <div style="margin-bottom: 25px;">
                <h2 style="font-size: 16px; font-weight: 400; color: #333; margin-bottom: 10px; text-align: right;">××•×˜×™×‘×¦×™×”</h2>
                <p style="font-size: 14px; line-height: 1.5; color: #555; text-align: right; margin: 0;">
                    ×”×¤×¨×•×™×§×˜ × ×•×œ×“ ××ª×•×š ×¨×¦×•×Ÿ ×œ×—×§×•×¨ ×•×œ× ×ª×— ×©×™×—×•×ª ×× ×•×©×™×ª ×“×¨×š ×¢×“×©×ª ×”×¨×’×©×•×ª. 
                    ×‘×××¦×¢×•×ª ×˜×›× ×•×œ×•×’×™×•×ª ××ª×§×“××•×ª ×©×œ ×‘×™× ×” ××œ××›×•×ª×™×ª, ×× ×• ××¡×•×’×œ×™× ×œ×–×”×•×ª, ×œ××“×•×“ ×•×œ×”×¦×™×’ 
                    ××ª ×”×¨×’×©×•×ª ×”×¢×•×œ×™× ×‘××”×œ×š ×©×™×—×•×ª, ×ª×•×š ×©××™×¨×” ×¢×œ ×¤×¨×˜×™×•×ª ×”××©×ª×ª×¤×™×. 
                    ×”××˜×¨×” ×”×™× ×œ×™×¦×•×¨ ×›×œ×™ ×©×™××¤×©×¨ ×”×‘× ×” ×¢××•×§×” ×™×•×ª×¨ ×©×œ ×”×“×™× ××™×§×” ×”×¨×’×©×™×ª ×‘×©×™×—×•×ª.
                </p>
            </div>
            
            <div style="margin-bottom: 25px;">
                <h2 style="font-size: 16px; font-weight: 400; color: #333; margin-bottom: 10px; text-align: right;">××§×•×¨ ×“××˜×”</h2>
                <p style="font-size: 14px; line-height: 1.5; color: #555; text-align: right; margin: 0;">
                    ×”× ×ª×•× ×™× ××’×™×¢×™× ××©×™×—×•×ª ××•×ª× ×˜×™×•×ª ×©×ª×•×¢×“×• ×‘××”×œ×š ××—×§×¨ ×¢×œ ×ª×§×©×•×¨×ª ×× ×•×©×™×ª. 
                    ×›×œ ×©×™×—×” ×¢×•×‘×¨×ª ×¢×™×‘×•×“ ×‘×××¦×¢×•×ª ××œ×’×•×¨×™×ª××™× ××ª×§×“××™× ×œ×–×™×”×•×™ ×¨×’×©×•×ª, 
                    ×”××¡×•×’×œ×™× ×œ×–×”×•×ª ××’×•×•×Ÿ ×¨×—×‘ ×©×œ ×¨×’×©×•×ª ×›×’×•×Ÿ ×©××—×”, ×¢×¦×‘, ×›×¢×¡, ×¤×—×“, ×”×¤×ª×¢×” ×•×¢×•×“. 
                    ×”× ×ª×•× ×™× ××•×¦×’×™× ×‘×¦×•×¨×” ×•×™×–×•××œ×™×ª ××™× ×˜×¨××§×˜×™×‘×™×ª ×”×××¤×©×¨×ª ×—×§×¨ ××¢××™×§.
                </p>
            </div>
            
            <div style="margin-bottom: 25px;">
                <h2 style="font-size: 16px; font-weight: 400; color: #333; margin-bottom: 10px; text-align: right;">×™×¦×™×¨×ª ×”×¤×¨×•×™×§×˜</h2>
                <p style="font-size: 14px; line-height: 1.5; color: #555; text-align: right; margin: 0;">
                    ×”×¤×¨×•×™×§×˜ ×¤×•×ª×— ×‘×××¦×¢×•×ª ×˜×›× ×•×œ×•×’×™×•×ª ×•×•×‘ ××ª×§×“××•×ª, ×›×•×œ×œ JavaScript, HTML5 ×•-CSS3. 
                    ×”× ×™×ª×•×— ×”×¨×’×©×™ ××ª×‘×¦×¢ ×‘×××¦×¢×•×ª ××•×“×œ×™× ×©×œ ×‘×™× ×” ××œ××›×•×ª×™×ª, 
                    ×•×”×”×¦×’×” ×”×•×•×™×–×•××œ×™×ª × ×•×¦×¨×ª ×‘×××¦×¢×•×ª ×¡×¤×¨×™×•×ª ×’×¨×¤×™×•×ª ××ª×§×“××•×ª. 
                    ×”×××©×§ ××ª×•×›× ×Ÿ ×œ×”×™×•×ª ××™× ×˜×•××™×˜×™×‘×™ ×•× ×’×™×© ×œ××©×ª××©×™× ××›×œ ×¨×§×¢ ×˜×›× ×™.
                </p>
            </div>
            

        </div>
    </div>
    

    
    <div id="bottom-controls-container" style="display: flex; justify-content: space-between; align-items: center; width: 100%; padding: 0 20px;">
        <!-- Zoom Controls on the LEFT side -->
        <div class="zoom-controls" style="display: flex; align-items: center; gap: 10px; z-index: 1002;">
            <button id="zoom-out-btn" class="zoom-btn" title="×”×§×˜×Ÿ ×ª×¦×•×’×”">â–</button>
            <span id="zoom-indicator" class="zoom-indicator">100%</span>
            <button id="zoom-in-btn" class="zoom-btn" title="×”×’×“×œ ×ª×¦×•×’×”">â•</button>
            <span style="margin-left: 15px; color: #666; font-size: 12px;">|</span>
            <span id="pan-indicator" style="color: #666; font-size: 12px; width: fit-content;">××¨×›×–</span>
        </div>
        
        <!-- Views on the RIGHT side -->
        <div class="view-toggle-buttons nav-slash-style" style="gap: 8px;">
            <button id="timeline-view-btn" class="view-toggle-btn active">×¦×™×¨ ×–××Ÿ</button>
            <span>/</span>
            <button id="people-view-btn" class="view-toggle-btn">×× ×©×™×</button>
            <span>/</span>
            <button id="emotions-view-btn" class="view-toggle-btn">×¨×’×©×•×ª</button>
        </div>

    </div>



    <div id="hover-info-panel"></div>
    <div id="visualization-modal-container"></div>
  
  <!-- Exit Tooltip -->
  <div id="exit-tooltip" class="exit-tooltip">×œ×—×¥ ×›×“×™ ×œ×¡×’×•×¨</div>
    
    <!-- Audio Prompt removed -->
    
    <!-- Loading Indicator -->
    <div id="loading-indicator" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 8px; z-index: 5002;">
        <div id="loading-text">×˜×•×¢×Ÿ...</div>
        <div id="loading-details" style="font-size: 14px; margin-top: 10px;"></div>
    </div>

    <script>
        // Hebrew Splash Screen Functions
        function createBackgroundDots() {
            const container = document.getElementById('backgroundDots');
            if (!container) return;
            
            const dotCount = 50;
            
            for (let i = 0; i < dotCount; i++) {
                const dot = document.createElement('div');
                dot.className = 'dot';
                dot.style.left = Math.random() * 100 + '%';
                dot.style.top = Math.random() * 100 + '%';
                dot.style.animationDelay = Math.random() * 3 + 's';
                container.appendChild(dot);
            }
        }
        
        // Animate loading percentage
        function animatePercentage() {
            const percentageEl = document.getElementById('percentage');
            if (!percentageEl) return;
            
            let progress = 0;
            const targetTime = 2500; // 2.5 seconds to reach 100%
            const increment = 100 / (targetTime / 100); // Calculate increment needed
            
            const interval = setInterval(() => {
                progress += increment + (Math.random() * 0.3); // Small random variation
                if (progress >= 100) {
                    progress = 100;
                    percentageEl.textContent = '100%';
                    clearInterval(interval);
                } else {
                    percentageEl.textContent = Math.floor(progress) + '%';
                }
            }, 100);
        }
        
        // Create random flash effects
        function startFlashEffects() {
            const flashInterval = setInterval(() => {
                const splashScreen = document.getElementById('splash-screen');
                if (!splashScreen || splashScreen.classList.contains('hidden')) {
                    clearInterval(flashInterval);
                    return;
                }
                
                if (Math.random() > 0.8) {
                    const flash = document.createElement('div');
                    flash.style.position = 'absolute';
                    flash.style.top = Math.random() * 100 + '%';
                    flash.style.left = Math.random() * 100 + '%';
                    flash.style.width = '3px';
                    flash.style.height = '3px';
                    flash.style.background = '#8B7355';
                    flash.style.borderRadius = '50%';
                    flash.style.opacity = '0.8';
                    flash.style.animation = 'twinkle 0.5s ease-out';
                    flash.style.zIndex = '2';
                    splashScreen.appendChild(flash);
                    
                    setTimeout(() => flash.remove(), 500);
                }
            }, 200);
        }

        document.addEventListener('DOMContentLoaded', async () => {
        // Load emotions config at startup
        await loadHoverEmotionsConfig();
        
        // STATIC BACKGROUND GRID: Handled by CSS and ensureStaticBackgroundGrid function
        
        const splashScreen = document.getElementById('splash-screen');
        
        // Always show splash screen on page load/refresh
        // Initialize Hebrew splash screen animations
        createBackgroundDots();
        animatePercentage();
        startFlashEffects();
        
        setTimeout(async () => {
            splashScreen.classList.add('hidden');
            await window.populateConversationGrid();
        }, 2500);
        
        // Start the logo animation
        startLogoAnimation();
        
        // Initialize hover panel event listeners
        initializeHoverPanel();
        
        // Initialize tooltip control system
        initializeTooltipControl();
    });
    
    // Logo animation function
    function startLogoAnimation() {
        const logoElement = document.getElementById('logo-text');
        const symbols = ['!', '?', '['];
        
        function animateLogo() {
            if (logoElement) {
                // Randomly decide if "1" should be on left or right
                const oneOnLeft = Math.random() < 0.5;
                
                if (oneOnLeft) {
                    // "1" on the left, random symbol on the right
                    const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                    logoElement.textContent = '1' + ':' + randomSymbol;
                } else {
                    // Random symbol on the left, "1" on the right
                    const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                    logoElement.textContent = randomSymbol + ':' + '1';
                }
            }
        }
        
        // Change characters every 2 seconds
        setInterval(animateLogo, 2000);
        
        // Initial animation
        animateLogo();
    }

    

    
    // Debug function to check conversation visibility
    function debugConversationVisibility() {
        const layoutCanvas = document.getElementById('layout-canvas');
        const conversations = document.querySelectorAll('.conversation-grid-item-container');
        
        console.log('ğŸ” DEBUG: Conversation Visibility Check');
        console.log('ğŸ“ Layout Canvas:', {
            element: layoutCanvas,
            exists: !!layoutCanvas,
            dimensions: layoutCanvas ? {
                width: layoutCanvas.offsetWidth,
                height: layoutCanvas.offsetHeight,
                clientWidth: layoutCanvas.clientWidth,
                clientHeight: layoutCanvas.clientHeight,
                scrollWidth: layoutCanvas.scrollWidth,
                scrollHeight: layoutCanvas.scrollHeight
            } : 'N/A',
            style: layoutCanvas ? {
                position: layoutCanvas.style.position,
                top: layoutCanvas.style.top,
                left: layoutCanvas.style.left,
                width: layoutCanvas.style.width,
                height: layoutCanvas.style.height,
                display: layoutCanvas.style.display,
                visibility: layoutCanvas.style.visibility
            } : 'N/A'
        });
        
        console.log('ğŸ¬ Conversations Found:', conversations.length);
        conversations.forEach((conv, index) => {
            const rect = conv.getBoundingClientRect();
            console.log(`ğŸ“ ${conv.id}:`, {
                index: index,
                dimensions: {
                    width: conv.offsetWidth,
                    height: conv.offsetHeight,
                    clientWidth: conv.clientWidth,
                    clientHeight: conv.clientHeight
                },
                position: {
                    left: conv.style.left,
                    top: conv.style.top,
                    position: conv.style.position
                },
                visibility: {
                    display: conv.style.display,
                    visibility: conv.style.visibility,
                    opacity: conv.style.opacity,
                    zIndex: conv.style.zIndex
                },
                boundingRect: {
                    left: Math.round(rect.left),
                    top: Math.round(rect.top),
                    width: Math.round(rect.width),
                    height: Math.round(rect.height),
                    visible: rect.width > 0 && rect.height > 0
                }
            });
        });
        
        return {
            layoutCanvas: !!layoutCanvas,
            conversationCount: conversations.length,
            visibleConversations: Array.from(conversations).filter(conv => {
                const rect = conv.getBoundingClientRect();
                return rect.width > 0 && rect.height > 0;
            }).length
        };
    }
    
    // Make debug function available globally
    window.debugConversationVisibility = debugConversationVisibility;
    </script>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        // Message listener moved above to handle all iframe messages
        const modalContainer = document.getElementById('visualization-modal-container');
        if (modalContainer) {
            // Show tooltip on hover near edges
            modalContainer.addEventListener('mousemove', (event) => {
                if (event.target === modalContainer) {
                    const rect = modalContainer.getBoundingClientRect();
                    const edgeThreshold = 60; // pixels from edge
                    
                    // Check if mouse is near any edge
                    const nearEdge = event.clientX < edgeThreshold || 
                                   event.clientX > rect.width - edgeThreshold ||
                                   event.clientY < edgeThreshold ||
                                   event.clientY > rect.height - edgeThreshold;
                    
                    if (nearEdge) {
                        showExitTooltip();
                    } else {
                        hideExitTooltip();
                    }
                }
            });
            
            // Hide tooltip when leaving modal
            modalContainer.addEventListener('mouseleave', () => {
                hideExitTooltip();
            });
            
            // Close modal on click outside
            modalContainer.addEventListener('click', (event) => {
                if (event.target === modalContainer) {
                    closeVisualizationModal();
                }
            });
        }
        const viewButtons = document.querySelectorAll('.view-toggle-btn');
        viewButtons.forEach(button => {
            button.addEventListener('click', function() {
                viewButtons.forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                const layout = this.id.split('-')[0];
                console.log(`ğŸ¬ ISOTOPE: User clicked ${layout} view button - triggering smooth animations`);
                
                if (layout === 'people') {
                    console.log(`ğŸ‘¥ PEOPLE VIEW: Button clicked, switching to people layout`);
                    
                    // DEBUG: Check if people data is available
                    fetch('/config/people_data.json')
                        .then(response => response.json())
                        .then(data => {
                            console.log(`ğŸ‘¥ DEBUG: People data loaded:`, data);
                            console.log(`ğŸ‘¥ DEBUG: Number of people:`, Object.keys(data.people || {}).length);
                        })
                        .catch(error => console.error(`âŒ DEBUG: People data load error:`, error));
                    
                    // DEBUG: Check layout canvas visibility
                    setTimeout(() => {
                        const layoutCanvas = document.getElementById('layout-canvas');
                        const timelineContainer = document.getElementById('timeline-axes-container');
                        console.log(`ğŸ‘¥ DEBUG: Layout canvas class:`, layoutCanvas.className);
                        console.log(`ğŸ‘¥ DEBUG: Layout canvas style:`, layoutCanvas.style.cssText);
                        console.log(`ğŸ‘¥ DEBUG: Timeline container dimensions:`, {
                            width: timelineContainer.clientWidth,
                            height: timelineContainer.clientHeight,
                            offsetWidth: timelineContainer.offsetWidth,
                            offsetHeight: timelineContainer.offsetHeight
                        });
                        
                        // Check for any overlaying elements
                        const allLabels = document.querySelectorAll('.person-name-label');
                        const allMessages = document.querySelectorAll('.people-debug-message');
                        console.log(`ğŸ‘¥ DEBUG: Found ${allLabels.length} person labels and ${allMessages.length} debug messages`);
                        
                        // Check z-index issues
                        const highZIndexElements = Array.from(document.querySelectorAll('*')).filter(el => {
                            const zIndex = window.getComputedStyle(el).zIndex;
                            return zIndex && parseInt(zIndex) > 1000;
                        });
                        console.log(`ğŸ‘¥ DEBUG: High z-index elements that might cover people view:`, highZIndexElements.map(el => ({
                            element: el.tagName + (el.className ? '.' + el.className : ''),
                            zIndex: window.getComputedStyle(el).zIndex
                        })));
                    }, 500);
                }
                
                // TIMELINE VIEW: No position reset needed - use cached positions
                if (layout === 'timeline') {
                    console.log('ğŸ”„ TIMELINE SWITCH: Will use cached positions - no reset needed');
                }
                
                if(typeof window.switchLayout === 'function') window.switchLayout(layout);
            });
        });
        
        // Add special double-click functionality to force refresh timeline positions
        document.addEventListener('dblclick', function(event) {
            if (event.target.classList.contains('view-toggle-btn') && 
                event.target.textContent.includes('Timeline')) {
                console.log('ğŸ”„ DOUBLE-CLICK: Force clearing timeline cache and recalculating');
                // Clear timeline cache and force recalculation
                if (window.layoutPositions) {
                    window.layoutPositions.timeline = {}; // Clear cache
                    console.log('ğŸ—‘ï¸ Timeline position cache cleared');
                }
                // Force fresh calculation
                if (window.conversations && typeof window.renderNewLayout === 'function') {
                    window.renderNewLayout(false);
                    console.log('âœ… Timeline positions recalculated after cache clear');
                }
            }
        });

        // Initialize playground mode
        if (typeof initializePlaygroundMode === 'function') {
            initializePlaygroundMode();
        } else {
            console.log('âš ï¸ Playground mode not available');
        }
      });
    </script>
    

    
    <script>
    // --- UNIFIED CONTROLS SCRIPT ---
    document.addEventListener('DOMContentLoaded', () => {
        // --- Shared variables ---
        const panzoomContainer = document.getElementById('timeline-axes-container');
        const layoutCanvas = document.getElementById('layout-canvas');
        const timelineControls = document.getElementById('bottom-controls-container');

        window.MIN_ZOOM = 0.5;
        window.MAX_ZOOM = 4;
        window.ZOOM_STEP = 0.1;

        // --- Camera and Transform Logic (Shared by all controls) ---
        function updateTransform() {
            if(layoutCanvas) {
                // Apply both zoom and pan transforms
                layoutCanvas.style.transform = `translate(${camera.x}px, ${camera.y}px) scale(${camera.zoom})`;
                layoutCanvas.style.animation = 'none';
                console.log(`ğŸ” Transform applied: zoom=${camera.zoom}, pan=(${camera.x}, ${camera.y}), layout=${window.activeLayout}`);
            } else {
                console.log('âš ï¸ No layoutCanvas found for transform');
            }
        }

        // This is defined here so resetCamera can use it.
        let initializeTimeline;

        window.resetCamera = function() {
            camera.x = 0;
            camera.y = 0;
            camera.zoom = 1;
            updateTransform();
            updateZoomIndicator();
            updatePanIndicator();
            if (typeof initializeTimeline === 'function') {
                initializeTimeline();
            }
        }

        // --- Mouse Wheel Zoom Logic ---
        function onWheel(e) {
            // Enable zoom for all layout views (timeline, people, emotions)
            if (window.activeLayout === 'playground') return;
            e.preventDefault();
            const zoomDirection = e.deltaY < 0 ? 'in' : 'out';
            zoom(zoomDirection);
        }

        function zoom(direction) {
            console.log(`ğŸ¯ Zoom ${direction} requested in ${window.activeLayout} view`);
            const oldZoom = camera.zoom;
            let newZoom = direction === 'in' ? Math.min(window.MAX_ZOOM, camera.zoom + window.ZOOM_STEP) : Math.max(window.MIN_ZOOM, camera.zoom - window.ZOOM_STEP);
            if (newZoom === oldZoom) {
                console.log(`âš ï¸ Zoom already at limit: ${newZoom}`);
                return;
            }
            
            camera.zoom = newZoom;
            console.log(`âœ… Zoom changed: ${oldZoom} â†’ ${newZoom}`);
            updateTransform();
            updateZoomIndicator();
            updatePanIndicator();
        }

        function updateZoomIndicator() {
            const zoomIndicator = document.getElementById('zoom-indicator');
            if (zoomIndicator) {
                zoomIndicator.textContent = Math.round(camera.zoom * 100) + '%';
            }
        }

        function updatePanIndicator() {
            const panIndicator = document.getElementById('pan-indicator');
            if (panIndicator) {
                if (camera.x === 0 && camera.y === 0) {
                    panIndicator.textContent = '××¨×›×–';
                } else {
                    const xDir = camera.x > 0 ? '×™××™×Ÿ' : camera.x < 0 ? '×©×××œ' : '';
                    const yDir = camera.y > 0 ? '×œ××˜×”' : camera.y < 0 ? '×œ××¢×œ×”' : '';
                    const directions = [xDir, yDir].filter(d => d).join(' ');
                    panIndicator.textContent = directions || '××¨×›×–';
                }
            }
        }

        if (panzoomContainer) {
            panzoomContainer.addEventListener('wheel', onWheel, { passive: false });
        }

        // --- Zoom Button Event Listeners ---
        document.getElementById('zoom-in-btn')?.addEventListener('click', () => {
            zoom('in');
        });

        document.getElementById('zoom-out-btn')?.addEventListener('click', () => {
            zoom('out');
        });

        document.getElementById('zoom-reset-btn')?.addEventListener('click', () => {
            window.resetCamera();
            updateZoomIndicator();
        });

        // Initialize zoom indicator
        updateZoomIndicator();
        updatePanIndicator();

        // --- Mouse Drag Panning Logic ---
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartCameraX = 0;
        let dragStartCameraY = 0;

        function onMouseDown(e) {
            // Only enable dragging for timeline, people, and emotions views
            if (window.activeLayout === 'playground') return;
            
            // Don't start drag if clicking on controls or buttons
            if (e.target.closest('#bottom-controls-container') || 
                e.target.closest('.zoom-controls') ||
                e.target.closest('.view-toggle-buttons') ||
                e.target.closest('button')) {
                return;
            }

            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragStartCameraX = camera.x;
            dragStartCameraY = camera.y;
            
            document.body.style.cursor = 'grabbing';
            e.preventDefault();
        }

        function onMouseMove(e) {
            if (!isDragging) return;
            
            const deltaX = e.clientX - dragStartX;
            const deltaY = e.clientY - dragStartY;
            
            camera.x = dragStartCameraX + deltaX;
            camera.y = dragStartCameraY + deltaY;
            
            updateTransform();
            updatePanIndicator();
            e.preventDefault();
        }

        function onMouseUp() {
            if (isDragging) {
                isDragging = false;
                document.body.style.cursor = 'default';
            }
        }

        // Add mouse event listeners to the panzoom container
        if (panzoomContainer) {
            panzoomContainer.addEventListener('mousedown', onMouseDown);
            panzoomContainer.addEventListener('mousemove', onMouseMove);
            panzoomContainer.addEventListener('mouseup', onMouseUp);
            panzoomContainer.addEventListener('mouseleave', onMouseUp);
            
            // Add hover effect to indicate draggable area
            panzoomContainer.addEventListener('mouseenter', () => {
                if (window.activeLayout !== 'playground') {
                    panzoomContainer.style.cursor = 'grab';
                }
            });
            
            panzoomContainer.addEventListener('mouseleave', () => {
                if (!isDragging) {
                    panzoomContainer.style.cursor = 'default';
                }
            });
            
            // Prevent text selection while dragging
            panzoomContainer.style.userSelect = 'none';
            panzoomContainer.style.webkitUserSelect = 'none';
            panzoomContainer.style.mozUserSelect = 'none';
            panzoomContainer.style.msUserSelect = 'none';
        }

        // --- Keyboard Zoom Shortcuts ---
        document.addEventListener('keydown', (e) => {
            // Only handle zoom shortcuts when not in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            // Ctrl/Cmd + Plus/Minus for zoom
            if ((e.ctrlKey || e.metaKey) && !e.shiftKey) {
                if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    zoom('in');
                } else if (e.key === '-') {
                    e.preventDefault();
                    zoom('out');
                } else if (e.key === '0') {
                    e.preventDefault();
                    window.resetCamera();
                    updateZoomIndicator();
                }
            }
        });
        
        // --- Timeline Brush Logic ---
        if (timelineControls) {
            const track = timelineControls.querySelector('.timeline-track-wrapper');
            const brush = timelineControls.querySelector('.timeline-brush');
            
            // Add null checks for iframe mode where timeline elements may not exist
            if (!brush) {
                console.log('Timeline brush not found - likely in iframe mode with noTimeline=true');
                return; // Exit early if timeline elements don't exist
            }
            
            const handleLeft = brush.querySelector('.timeline-handle.left');
            const handleRight = brush.querySelector('.timeline-handle.right');
            const tooltip = document.querySelector('.timeline-tooltip');
            const dateDisplayLeft = brush.querySelector('.handle-date-display.left');
            const dateDisplayRight = brush.querySelector('.handle-date-display.right');

            let minDate, maxDate, totalDays;
            let isDragging = null;
            let startX, startBrushLeft, startBrushWidth;

            initializeTimeline = function() {
                const dates = window.originalConversationData.map(c => new Date(c.date).getTime());
                minDate = new Date(Math.min.apply(null, dates));
                maxDate = new Date(Math.max.apply(null, dates));
                totalDays = (maxDate - minDate) / (1000 * 60 * 60 * 24);
                brush.style.left = '0%';
                brush.style.width = '100%';
                updateDateDisplays();
            }

            function pctToDate(pct) {
                const date = new Date(minDate);
                date.setDate(date.getDate() + (totalDays * (pct / 100)));
                return date.toLocaleDateString('he-IL', { day: 'numeric', month: 'short' });
            }
            
            function updateDateDisplays() {
                const leftPct = parseFloat(brush.style.left);
                const widthPct = parseFloat(brush.style.width);
                dateDisplayLeft.textContent = pctToDate(leftPct);
                dateDisplayRight.textContent = pctToDate(leftPct + widthPct);
            }

            function updateMainViewFromBrush() {
                const brushWidthPct = parseFloat(brush.style.width) / 100;
                
                const layout = layoutPositions.timeline;
                if (!layout || Object.keys(layout).length === 0) return;
                
                const allX = Object.values(layout).filter(p => p.left !== undefined).map(p => p.left);
                if (allX.length === 0) return;

                const minX = Math.min(...allX);
                const maxX = Math.max(...allX) + 70;
                const totalContentWidth = maxX - minX;
                const viewWidth = totalContentWidth * brushWidthPct;
                const containerWidth = panzoomContainer.clientWidth;
                
                camera.zoom = Math.min(window.MAX_ZOOM, containerWidth / viewWidth * 0.9);
                
                // NO PANNING. camera.x is not changed.
                
                updateTransform();
            }

            function onDragStart(e, type) {
                if (window.activeLayout !== 'timeline') return;
                e.stopPropagation();
                isDragging = type;
                startX = e.clientX;
                startBrushLeft = brush.offsetLeft;
                startBrushWidth = brush.offsetWidth;
                document.body.style.cursor = 'ew-resize';
                window.addEventListener('mousemove', onDrag);
                window.addEventListener('mouseup', onDragEnd);
            }

            function onDrag(e) {
                if (!isDragging) return;
                const deltaX = e.clientX - startX;
                const trackWidth = track.offsetWidth;
                if (isDragging === 'left') {
                    const newLeft = Math.max(0, startBrushLeft + deltaX);
                    const newRight = startBrushLeft + startBrushWidth;
                    const newWidth = newRight - newLeft;
                    if (newWidth / trackWidth * 100 < 2) return;
                    brush.style.left = `${(newLeft / trackWidth) * 100}%`;
                    brush.style.width = `${(newWidth / trackWidth) * 100}%`;
                } else if (isDragging === 'right') {
                    const newWidth = Math.max(10, startBrushWidth + deltaX);
                    const newRight = startBrushLeft + newWidth;
                    if (newRight > trackWidth) return;
                    brush.style.width = `${(newWidth / trackWidth) * 100}%`;
                }
                // 'brush' dragging is disabled.
                updateDateDisplays();
                // This is called onDragEnd for a better UX
            }

            function onDragEnd() {
                isDragging = null;
                document.body.style.cursor = 'default';
                window.removeEventListener('mousemove', onDrag);
                window.removeEventListener('mouseup', onDragEnd);
                updateMainViewFromBrush(); // Update view after dragging is finished
            }

            track.addEventListener('mousemove', (e) => {
                if (isDragging) return;
                const trackRect = track.getBoundingClientRect();
                const x = e.clientX - trackRect.left;
                const pct = (x / track.offsetWidth) * 100;
                tooltip.style.left = `${x}px`;
                tooltip.textContent = pctToDate(pct);
                tooltip.style.display = 'block';
            });
            track.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });
            handleLeft.addEventListener('mousedown', (e) => onDragStart(e, 'left'));
            handleRight.addEventListener('mousedown', (e) => onDragStart(e, 'right'));
            // Event listener for dragging the whole brush is removed to prevent panning.
            
            setTimeout(initializeTimeline, 500);
        }

        // --- General page setup ---
        window.addEventListener('resize', () => {
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(() => {
                if (typeof window.switchLayout === 'function') {
                    window.switchLayout(window.activeLayout, true);
                }
                // Recalculate emotions grid if emotions page is visible
                recalculateEmotionsGrid();
            }, 250);
        });
    });
    </script>
    
    <!-- Live Visualization Script -->
    <script>
// sketch-live.js removed - no longer needed

// Global error handler to prevent RingBuffer/AmplitudeProcessor errors from breaking people view
window.addEventListener('error', function(event) {
    if (event.message && (event.message.includes('RingBuffer') || event.message.includes('AmplitudeProcessor'))) {
        console.warn('ğŸ”‡ Audio processing error caught and suppressed:', event.message);
        event.preventDefault();
        return false;
    }
});

// Global error handler for unhandled promise rejections
window.addEventListener('unhandledrejection', function(event) {
    if (event.reason && (event.reason.message && (event.reason.message.includes('RingBuffer') || event.reason.message.includes('AmplitudeProcessor')))) {
        console.warn('ğŸ”‡ Audio processing promise rejection caught and suppressed:', event.reason.message);
        event.preventDefault();
        return false;
    }
});
  </script>
     
     <script>
     // FORCE DISPLAY: Simple backup people view renderer
     window.forceDisplayPeopleView = async function() {
        console.log('ğŸš€ FORCE DISPLAY: Starting simple people view...');
        
        try {
            // 1. Force people layout mode
            window.activeLayout = 'people';
            document.body.className = 'layout-people';
            const layoutCanvas = document.getElementById('layout-canvas');
            layoutCanvas.className = 'people-active';
            
            // 2. Clear any existing content
            layoutCanvas.innerHTML = '';
            
            // 3. Load people data directly
            const response = await fetch('/config/people_data.json');
            if (!response.ok) {
                console.error('âŒ Failed to fetch people data:', response.status);
                layoutCanvas.innerHTML = '<div style="color: red; font-size: 24px; padding: 50px; text-align: center;">âŒ Failed to load people data (server error)</div>';
                return;
            }
            
            const peopleData = await response.json();
            console.log('ğŸ“Š Loaded people data:', peopleData);
            
            if (!peopleData || !peopleData.people || Object.keys(peopleData.people).length === 0) {
                console.error('âŒ No people data found in response:', peopleData);
                layoutCanvas.innerHTML = '<div style="color: red; font-size: 24px; padding: 50px; text-align: center;">âŒ No people found in data file</div>';
                return;
            }
            
            // 4. Create simple list display
            const peopleCount = Object.keys(peopleData.people).length;
            console.log(`âœ… Found ${peopleCount} people, creating simple display...`);
            
            let y = 50;
            const leftMargin = 100;
            const rowHeight = 120;
            
            // 5. Create title header
            const header = document.createElement('div');
            header.style.cssText = `
                position: absolute;
                left: ${leftMargin}px;
                top: 20px;
                font-size: 28px;
                font-weight: bold;
                color: #333;
                z-index: 1000;
            `;
            header.innerHTML = `ğŸ‘¥ ×¨×©×™××ª ×× ×©×™× (${peopleCount} ×× ×©×™×)`;
            layoutCanvas.appendChild(header);
            
            // 6. Display each person simply
            Object.entries(peopleData.people).forEach(([personId, person], index) => {
                const conversationCount = person.conversations ? person.conversations.length : 0;
                
                // Person row container
                const personRow = document.createElement('div');
                personRow.style.cssText = `
                    position: absolute;
                    left: ${leftMargin}px;
                    top: ${y}px;
                    width: 800px;
                    height: ${rowHeight - 20}px;
                    background: linear-gradient(135deg, ${person.color}20, ${person.color}10);
                    border: 2px solid ${person.color};
                    border-radius: 12px;
                    padding: 20px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                    z-index: ${1000 + index};
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                `;
                
                // Person info (right side in RTL)
                const personInfo = document.createElement('div');
                personInfo.style.cssText = `
                    text-align: right;
                    direction: rtl;
                `;
                personInfo.innerHTML = `
                    <div style="font-size: 22px; font-weight: bold; color: ${person.color}; margin-bottom: 5px;">
                        ${person.name}
                    </div>
                    <div style="font-size: 16px; color: #666; margin-bottom: 5px;">
                        ${conversationCount} ×©×™×—×•×ª
                    </div>
                    <div style="font-size: 14px; color: #888;">
                        ${person.description || '××™×Ÿ ×ª×™××•×¨'}
                    </div>
                `;
                
                // Conversation badges (left side)
                const conversationBadges = document.createElement('div');
                conversationBadges.style.cssText = `
                    display: flex;
                    flex-wrap: wrap;
                    gap: 5px;
                    max-width: 400px;
                `;
                
                if (person.conversations && person.conversations.length > 0) {
                    person.conversations.slice(0, 10).forEach(conv => {
                        const badge = document.createElement('span');
                        badge.style.cssText = `
                            background: ${person.color};
                            color: white;
                            padding: 4px 8px;
                            border-radius: 12px;
                            font-size: 12px;
                            font-weight: bold;
                        `;
                        badge.textContent = conv;
                        conversationBadges.appendChild(badge);
                    });
                    
                    if (person.conversations.length > 10) {
                        const moreBadge = document.createElement('span');
                        moreBadge.style.cssText = `
                            background: #999;
                            color: white;
                            padding: 4px 8px;
                            border-radius: 12px;
                            font-size: 12px;
                        `;
                        moreBadge.textContent = `+${person.conversations.length - 10}`;
                        conversationBadges.appendChild(moreBadge);
                    }
                } else {
                    conversationBadges.innerHTML = '<span style="color: #999; font-style: italic;">××™×Ÿ ×©×™×—×•×ª</span>';
                }
                
                personRow.appendChild(personInfo);
                personRow.appendChild(conversationBadges);
                layoutCanvas.appendChild(personRow);
                
                y += rowHeight;
            });
            
            // 7. Set canvas height
            const totalHeight = y + 50;
            layoutCanvas.style.height = `${totalHeight}px`;
            console.log(`âœ… People view displayed successfully with ${peopleCount} people`);
            
            // 8. Add success message
            const successMsg = document.createElement('div');
            successMsg.style.cssText = `
                position: absolute;
                bottom: 20px;
                left: ${leftMargin}px;
                background: #d4edda;
                color: #155724;
                padding: 15px;
                border-radius: 8px;
                border: 1px solid #c3e6cb;
                font-size: 16px;
                z-index: 2000;
            `;
            successMsg.innerHTML = `âœ… ×”×¦×’×ª ${peopleCount} ×× ×©×™× ×”×•×©×œ××” ×‘×”×¦×œ×—×”`;
            layoutCanvas.appendChild(successMsg);
            
            return true;
            
        } catch (error) {
            console.error('âŒ Error in force display people view:', error);
            const layoutCanvas = document.getElementById('layout-canvas');
            layoutCanvas.innerHTML = `
                <div style="color: red; font-size: 24px; padding: 50px; text-align: center;">
                    âŒ ×©×’×™××” ×‘×”×¦×’×ª ×¨×©×™××ª ×”×× ×©×™×<br>
                    <small style="font-size: 16px;">${error.message}</small>
                </div>
            `;
            return false;
        }
    };
    </script>



 </body>
 </html>