

<html lang="he" dir="rtl" style="height: 100%;">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Emotion Visualizer</title>
  <link rel="icon" href="data:,">


  <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.indigo-pink.min.css">
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Miriam+Libre:wght@400;700&display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap">
  <script src="https://code.getmdl.io/1.3.0/material.min.js"></script>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  
  
  
  <script>
                     // Initialize responsive VIDEO PREVIEW sizing on page load
          if (typeof updateResponsiveBlockSizes !== 'undefined') {
              // Expose functions globally
              window.updateResponsiveBlockSizes = updateResponsiveBlockSizes;
              window.calculateOptimalBlockSize = calculateOptimalBlockSize;
              
              // Test function for FULL-SCREEN video preview responsiveness
              window.testVideoPreviewResponsiveness = function() {
                  console.log('🎬 Testing FULL-SCREEN Video Preview Responsiveness...');
                  const containers = document.querySelectorAll('.conversation-grid-item-container');
                  console.log(`📊 Found ${containers.length} video preview containers`);
                  
                  if (containers.length > 0) {
                      const currentSize = containers[0].style.width || 'unknown';
                      console.log(`📐 Current video preview size: ${currentSize}`);
                      updateResponsiveBlockSizes(true);
                      setTimeout(() => {
                          const newSize = containers[0].style.width || 'unknown';
                          console.log(`📐 Updated video preview size: ${newSize}`);
                          console.log('✅ FULL-SCREEN video preview test complete');
                      }, 200);
                  } else {
                      console.log('⚠️ No video preview containers found yet');
                  }
              };
              
              // Initialize on page load
              document.addEventListener('DOMContentLoaded', () => {
                  setTimeout(() => {
                      console.log('🎬 Initializing FULL-SCREEN Video Preview Responsive System...');
                      updateResponsiveBlockSizes(true);
                      // Initialize zoom-responsive grid system
                      if (typeof initializeZoomResponsiveGrid !== 'undefined') {
                          initializeZoomResponsiveGrid();
                      }
                      // Initialize intersection observer for performance optimization
                      initConversationIntersectionObserver();
                      console.log('👀 Intersection observer initialized for lazy loading optimization');
                  }, 100); // Earlier initialization to prevent 60px flash
              });
              
              // Also initialize on conversation data load
              if (window.originalConversationData && window.originalConversationData.length > 0) {
                  updateResponsiveBlockSizes(true);
              }
          }
    
    // Auto-scaling configuration for FULL-SCREEN video previews
    let autoScalingConfig = {
        enabled: true,
        minBlockSize: 250,     // Much larger minimum for better visibility
        maxBlockSize: 1200,    // Even larger maximum for big screens
        densityFactor: 0.85,   // Use 85% of screen space for better spacing
        aspectRatio: 1,        // Maintain square aspect ratio
        padding: 20,           // More padding between larger blocks
        lastCalculatedSize: null,
        debounceTimeout: null
    };

    // Calculate optimal conversation VIDEO PREVIEW block size - PEOPLE VIEW OPTIMIZED
    function calculateOptimalBlockSize(conversationCount, containerWidth, containerHeight, layoutType = 'timeline') {
        if (!autoScalingConfig.enabled || conversationCount === 0) {
            return autoScalingConfig.lastCalculatedSize || 300;
        }

        console.log(`🎬 Calculating optimal VIDEO PREVIEW size for ${conversationCount} blocks in ${layoutType} view`);

        // Use almost the full screen width and height
        const availableWidth = containerWidth * 0.98;
        const availableHeight = (containerHeight - 100) * 0.95;

        let optimalSize;
        
        if (layoutType === 'people') {
            // PEOPLE VIEW: Optimize to show ALL people and their conversations
            // Assume typical people view has ~5-15 different people, each with 1-10 conversations
            
            // Estimate number of people groups (assume average 3 conversations per person)
            const estimatedPeopleCount = Math.max(3, Math.ceil(conversationCount / 3));
            
            // Calculate optimal size to fit all people rows on screen
            const peopleRowHeight = 80; // Space needed for person name + conversations
            const totalRowsNeeded = estimatedPeopleCount;
            
            // Size based on fitting all people vertically
            const maxSizeByHeight = Math.min(
                (availableHeight / totalRowsNeeded) * 0.7, // 70% of row height for conversations
                120 // Don't go below readable size
            );
            
            // Size based on fitting ~8-12 conversations per row horizontally
            const conversationsPerRow = Math.min(12, Math.max(6, Math.floor(availableWidth / 80)));
            const maxSizeByWidth = (availableWidth / conversationsPerRow) - 15;
            
            // Use the smaller of the two to ensure everything fits
            optimalSize = Math.min(maxSizeByHeight, maxSizeByWidth);
            
            console.log(`👥 People view: ${estimatedPeopleCount} people, ${conversationsPerRow} convos/row, size: ${Math.round(optimalSize)}px`);
            
        } else {
            // TIMELINE/EMOTIONS: Organized grid layout for better visibility
            if (conversationCount <= 4) {
                const cols = Math.min(2, conversationCount);
                const rows = Math.ceil(conversationCount / cols);
                optimalSize = Math.min(
                    availableWidth / cols - 40,
                    availableHeight / rows - 40,
                    120 // Max size for organization
                );
            } else if (conversationCount <= 16) {
                const cols = Math.min(4, Math.ceil(Math.sqrt(conversationCount)));
                const rows = Math.ceil(conversationCount / cols);
                optimalSize = Math.min(
                    availableWidth / cols - 30,
                    availableHeight / rows - 30,
                    100 // Max size for organization
                );
            } else {
                const aspectRatio = availableWidth / availableHeight;
                const cols = Math.ceil(Math.sqrt(conversationCount * aspectRatio));
                const rows = Math.ceil(conversationCount / cols);
                
                optimalSize = Math.min(
                    availableWidth / cols - 20,
                    availableHeight / rows - 20,
                    80 // Max size for dense organization
                );
            }
        }

        // Apply constraints - ORGANIZED SIZES
        const minSize = layoutType === 'people' ? 60 : 60; // Consistent organized minimum
        const maxSize = layoutType === 'people' ? 120 : 100; // Organized maximum for proper spacing
        
        optimalSize = Math.max(minSize, Math.min(maxSize, optimalSize));

        // Apply zoom factor
        optimalSize *= currentZoomLevel;

        // Cache the result
        autoScalingConfig.lastCalculatedSize = Math.round(optimalSize);
        
        console.log(`🎬 ${layoutType} view: ${conversationCount} blocks, optimal size: ${autoScalingConfig.lastCalculatedSize}px`);
        
        return autoScalingConfig.lastCalculatedSize;
    }

    // Update all VIDEO PREVIEW conversation block sizes responsively
    function updateResponsiveBlockSizes(forceRecalculate = false) {
        clearTimeout(autoScalingConfig.debounceTimeout);
        autoScalingConfig.debounceTimeout = setTimeout(() => {
            const layoutCanvas = document.getElementById('layout-canvas');
            if (!layoutCanvas || !window.originalConversationData) return;

            const conversationCount = window.originalConversationData.length;
            const containerWidth = layoutCanvas.offsetWidth || window.innerWidth;
            const containerHeight = layoutCanvas.offsetHeight || window.innerHeight;
            const currentLayout = window.activeLayout || 'timeline';

            const newOptimalSize = calculateOptimalBlockSize(
                conversationCount, 
                containerWidth, 
                containerHeight, 
                currentLayout
            );

            // Only update if size changed significantly or forced
            if (forceRecalculate || !autoScalingConfig.lastCalculatedSize || 
                Math.abs(newOptimalSize - autoScalingConfig.lastCalculatedSize) > 5) {
                
                console.log(`🎬 Updating VIDEO PREVIEW sizes to ${newOptimalSize}px for ${conversationCount} conversation blocks`);
                
                // Update CSS custom properties specifically for video preview containers
                const sizeVariables = [
                    '--timeline-item-size',
                    '--timeline-square-size', 
                    '--people-square-size',
                    '--conversation-block-size'
                ];

                sizeVariables.forEach(varName => {
                    document.documentElement.style.setProperty(varName, `${newOptimalSize}px`);
                });

                // Directly update all conversation video preview containers
                const conversationContainers = document.querySelectorAll('.conversation-grid-item-container');
                conversationContainers.forEach(container => {
                    // Update container size
                    container.style.width = `${newOptimalSize}px`;
                    container.style.height = `${newOptimalSize}px`;
                    
                    // Update video wrapper if it exists
                    const videoWrapper = container.querySelector('.video-container-wrapper');
                    if (videoWrapper) {
                        videoWrapper.style.width = `${newOptimalSize}px`;
                        videoWrapper.style.height = `${newOptimalSize}px`;
                    }
                    
                    // Update video element sizing
                    const video = container.querySelector('.conversation-video-preview');
                    if (video) {
                        video.style.width = `${newOptimalSize}px`;
                        video.style.height = `${newOptimalSize}px`;
                    }
                });

                console.log(`✅ Updated ${conversationContainers.length} video preview blocks to ${newOptimalSize}px`);
                
                // Trigger layout recalculation if we have a significant size change
                if (window.renderNewLayout && (forceRecalculate || 
                    Math.abs(newOptimalSize - (autoScalingConfig.lastCalculatedSize || 0)) > 20)) {
                    setTimeout(() => {
                        window.renderNewLayout(false);
                    }, 100);
                }
            }
        }, 150); // Debounce rapid calls
    }
    
    // Detect zoom level changes
    function detectZoomLevel() {
        // Method 1: Using window.devicePixelRatio (most reliable)
        const pixelRatio = window.devicePixelRatio || 1;
        
        // Method 2: Using window dimensions vs screen dimensions
        const widthZoom = window.outerWidth / window.innerWidth;
        const heightZoom = window.outerHeight / window.innerHeight;
        
        // Method 3: Create a test element to measure zoom
        const testElement = document.createElement('div');
        testElement.style.cssText = 'position: absolute; left: 0; top: 0; width: 100px; height: 100px; visibility: hidden;';
        document.body.appendChild(testElement);
        const rect = testElement.getBoundingClientRect();
        document.body.removeChild(testElement);
        
        const elementZoom = rect.width / 100;
        
        // Use the most reliable zoom detection method
        let detectedZoom = elementZoom;
        
        // Fallback methods if element zoom fails
        if (Math.abs(detectedZoom - 1) < 0.01) {
            detectedZoom = Math.max(widthZoom, heightZoom);
        }
        
        // Clamp zoom level to reasonable bounds
        return Math.max(0.25, Math.min(5, detectedZoom));
    }
    
    // Simplified grid system - no longer needed since grids are removed
    function initializeZoomResponsiveGrid() {
        console.log('🔍 Grid system disabled - using solid backgrounds');
    }
    


    // Initialize on page load
    document.addEventListener('DOMContentLoaded', initializeZoomResponsiveGrid);
    
    // --- Ensure Static Background Grid Function ---
    function ensureStaticBackgroundGrid() {
        // Grid background disabled - just ensure solid background color
        document.body.style.background = '#f7f9f3';
        document.body.style.backgroundImage = 'none';
        console.log('✅ Grid background disabled - using solid background');
    }
    
    // --- Global Variables ---
    let camera = { x: 0, y: 0, zoom: 1 };
    window.activeLayout = 'timeline';
    let layoutPositions = { timeline: null, people: null, emotions: null };
    
    // Global layout state variables - promote to window for consistency
    window.isLayoutRendering = false;
    window.layoutRenderTimeout = null;
    window.peopleViewStabilityCheck = null;
    window.layoutPositions = layoutPositions;
    let targetPositions = null;
    
    // Timeline state reset function for consistency issues
    window.resetTimelineState = function() {
        console.log('🔄 Resetting timeline state for consistency...');
        
        // Clear all timeouts
        if (window.layoutRenderTimeout) {
            clearTimeout(window.layoutRenderTimeout);
            window.layoutRenderTimeout = null;
        }
        if (window.peopleViewStabilityCheck) {
            clearTimeout(window.peopleViewStabilityCheck);
            window.peopleViewStabilityCheck = null;
        }
        
        // Reset flags
        window.isLayoutRendering = false;
        
        // Clear cached positions except timeline (keep timeline as base)
        if (window.layoutPositions) {
            window.layoutPositions.people = null;
            window.layoutPositions.emotions = null;
        }
        
        // Clean up DOM classes and elements
        const layoutCanvas = document.getElementById('layout-canvas');
        const gridContainer = document.getElementById('timeline-axes-container');
        
        if (layoutCanvas) {
            layoutCanvas.classList.remove('isotope-transitioning', 'isotope-switching');
            
            // Clean up emotions view specific elements that might interfere
            const emotionLabels = layoutCanvas.querySelectorAll('.emotion-cluster-label, .emotion-circle-label, .emotion-circle-background, .emotion-inner-circle, .emotion-count-badge');
            emotionLabels.forEach(el => el.remove());
            console.log(`🧹 Removed ${emotionLabels.length} emotions view elements`);
        }
        
        if (gridContainer) {
            gridContainer.classList.remove('isotope-transitioning', 'isotope-switching');
            // Ensure proper layout class
            gridContainer.className = `layout-${window.activeLayout}`;
        }
        
        // COMPREHENSIVE BODY CLASS RESET: Clear all layout classes
        document.body.classList.remove('layout-timeline', 'layout-people', 'layout-emotions');
        
        // Set proper body class for current layout
        if (window.activeLayout === 'timeline') {
            document.body.className = 'layout-timeline';
        } else if (window.activeLayout === 'people') {
            document.body.className = 'layout-people';
        } else if (window.activeLayout === 'emotions') {
            document.body.className = 'layout-emotions';
        } else {
            document.body.className = '';
        }
        
        console.log(`🏗️ Reset body class to: ${document.body.className || '(empty)'}`)
        
        console.log('✅ Timeline state reset complete');
    };
    
    // Emotions view cleanup function for smooth transitions
    window.cleanupEmotionsView = function() {
        console.log('🎭 Cleaning up emotions view for transition...');
        
        const layoutCanvas = document.getElementById('layout-canvas');
        const gridContainer = document.getElementById('timeline-axes-container');
        
        if (layoutCanvas) {
            // Remove all emotions-specific elements
            const emotionsElements = layoutCanvas.querySelectorAll(
                '.emotion-cluster-label, .emotion-circle-label, .emotion-circle-background, ' +
                '.emotion-inner-circle, .emotion-count-badge, .emotion-line-background'
            );
            emotionsElements.forEach(el => el.remove());
            console.log(`🧹 Removed ${emotionsElements.length} emotions view elements`);
            
            // Clear emotions-specific canvas classes
            layoutCanvas.classList.remove('emotions-active');
            
            // Clear emotions-specific styles and positioning
            layoutCanvas.style.removeProperty('background');
            layoutCanvas.style.removeProperty('background-color');
            layoutCanvas.style.removeProperty('position');
            layoutCanvas.style.removeProperty('top');
            layoutCanvas.style.removeProperty('left');
            layoutCanvas.style.removeProperty('right');
            layoutCanvas.style.removeProperty('bottom');
            layoutCanvas.style.removeProperty('width');
            layoutCanvas.style.removeProperty('height');
            layoutCanvas.style.removeProperty('padding');
            layoutCanvas.style.removeProperty('overflow');
        }
        
        // Clear emotions body class specifically
        document.body.classList.remove('layout-emotions');
        
        // Clear emotions cache to prevent stale positions
        if (window.layoutPositions) {
            window.layoutPositions.emotions = null;
            console.log('🗑️ Cleared emotions layout cache');
        }
        
        // CRITICAL: Clear CSS custom properties set by emotions view
        // This prevents emotions view sizing from interfering with timeline view calculations
        document.documentElement.style.removeProperty('--timeline-square-size');
        document.documentElement.style.removeProperty('--timeline-item-size');
        document.documentElement.style.removeProperty('--people-square-size');
        document.documentElement.style.removeProperty('--visual-conversation-size');
        console.log('🧹 Cleared emotions view CSS custom properties');
        
        console.log('✅ Emotions view cleanup complete');
    };
    
    // Timeline validation function to check for consistency issues
    window.validateTimelineState = function() {
        console.log('🔍 Validating timeline state...');
        
        const issues = [];
        const layoutCanvas = document.getElementById('layout-canvas');
        const gridContainer = document.getElementById('timeline-axes-container');
        
        // Check if containers exist
        if (!layoutCanvas) issues.push('layout-canvas missing');
        if (!gridContainer) issues.push('timeline-axes-container missing');
        
        // Check layout consistency
        if (gridContainer && window.activeLayout) {
            const expectedClass = `layout-${window.activeLayout}`;
            if (!gridContainer.classList.contains(expectedClass)) {
                issues.push(`Missing layout class: ${expectedClass}`);
            }
        }
        
        // Check for stale transition classes
        if (gridContainer) {
            if (gridContainer.classList.contains('isotope-transitioning')) {
                issues.push('Stale isotope-transitioning class');
            }
            if (gridContainer.classList.contains('isotope-switching')) {
                issues.push('Stale isotope-switching class');
            }
        }
        
        // Check rendering state
        if (window.isLayoutRendering) {
            issues.push('Layout rendering stuck');
        }
        
        // Check for orphaned timeouts
        if (window.layoutRenderTimeout) {
            issues.push('Active layout render timeout');
        }
        if (window.peopleViewStabilityCheck) {
            issues.push('Active people view stability check');
        }
        
        // Check for emotions view remnants
        if (layoutCanvas) {
            const emotionElements = layoutCanvas.querySelectorAll('.emotion-cluster-label, .emotion-circle-label, .emotion-circle-background');
            if (emotionElements.length > 0 && window.activeLayout !== 'emotions') {
                issues.push(`${emotionElements.length} orphaned emotions elements found`);
            }
        }
        
        // Check body class consistency
        const bodyClassConsistent = 
            (window.activeLayout === 'timeline' && document.body.classList.contains('layout-timeline')) ||
            (window.activeLayout === 'people' && document.body.classList.contains('layout-people')) ||
            (window.activeLayout === 'emotions' && document.body.classList.contains('layout-emotions')) ||
            (window.activeLayout && !document.body.className);
            
        if (!bodyClassConsistent) {
            issues.push(`Body class mismatch: layout=${window.activeLayout}, body="${document.body.className}"`);
        }
        
        if (issues.length > 0) {
            console.warn('⚠️ Timeline state issues detected:', issues);
            return { valid: false, issues: issues };
        } else {
            console.log('✅ Timeline state is consistent');
            return { valid: true, issues: [] };
        }
    };
    
    // Zoom variables
    let currentZoomLevel = 1.0; // Default zoom level (100%)
    window.hebrewMonths = ["ינואר", "פברואר", "מרץ", "אפריל", "מאי", "יוני", "יולי", "אוגוסט", "ספטמבר", "אוקטובר", "נובמבר", "דצמבר"];
    window.peopleData = null; // Store loaded people data
    
    // Hebrew emotion translation mapping - used throughout the application
    window.EMOTION_HEBREW_MAP = {
        'anger': 'כעס',
        'confusion': 'בלבול', 
        'contentment': 'שביעות רצון',
        'curiosity': 'סקרנות',
        'excitement': 'התרגשות',
        'fear': 'פחד',
        'happiness': 'שמחה',
        'interest': 'עניין',
        'neutral': 'נייטרלי',
        'sadness': 'עצב',
        'surprise': 'הפתעה'
    };
    
    // --- UNIFIED MP4 PREVIEW COMPONENT SYSTEM ---
    const MP4_PREVIEW_CONFIG = {
    videoStyles: {
        objectFit: 'contain', // FIT: Show entire video without cropping
        objectPosition: 'center center',
        display: 'block',
        visibility: 'visible',
        opacity: '1',
        width: '100%',
        height: '100%',
        margin: '0',
        padding: '0',
        border: 'none',
        borderRadius: '0',
        position: 'absolute',
        top: '0',
        left: '0',
        transition: 'transform 0.3s ease',
        background: '#f7f9f3',
        filter: 'none',
        boxShadow: 'none',
        transform: 'scale(1)',
        maxWidth: '100%',
        maxHeight: '100%'
    },

    containerStyles: {
        position: 'absolute',
        boxSizing: 'border-box',
        padding: '0',
        margin: '0px', // Remove margins for maximum space utilization
        display: 'block',
        overflow: 'hidden',
        borderRadius: '0',
        cursor: 'pointer',
        transition: 'transform 0.3s ease, box-shadow 0.3s ease',
        border: 'none',
        background: '#f7f9f3',
        zIndex: '2',
        transformOrigin: 'center center',
        aspectRatio: '1 / 1',
        contain: 'layout style paint',
        backfaceVisibility: 'hidden',
        perspective: '1000px',
        isolation: 'isolate',
        width: '100%',
        height: '100%',
        transform: 'scale(1)',
        boxShadow: 'none'
    },

    hoverEffects: {
        container: {
            transform: 'scale(1.35)',
            zIndex: '10'
        },
        video: {
            filter: 'none',
            boxShadow: 'none'
        }
    }
};

    
    // Helper function to get EXACT Timeline square size
    function getTimelineSquareSize(conversations, container) {
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const totalConversations = conversations.length;
        
        // Use EXACT same calculation as Timeline view
        const padding = 10;
        const availableWidth = containerWidth - (2 * padding);
        const availableHeight = containerHeight - (2 * padding);
        const gapBetweenSquares = 1;
        const totalGapWidth = (totalConversations - 1) * gapBetweenSquares;
        const availableForSquares = availableWidth - totalGapWidth;
        const maxSquareSize = availableForSquares / totalConversations;
        const finalSquareSize = Math.min(maxSquareSize, availableHeight);
        
        return finalSquareSize;
    }
    
    // UNIFIED MP4 PREVIEW COMPONENT CREATOR
    function createMP4PreviewComponent(conv, index) {
        const itemCell = document.createElement('div');
        itemCell.className = 'conversation-grid-item-container';
        itemCell.id = `conv-item-${conv.folder}`;
        
        // Apply unified container styles
        Object.assign(itemCell.style, MP4_PREVIEW_CONFIG.containerStyles);
        
        // Add data attributes
        const properName = conv.metadata?.name || conv.displayName || conv.participants || conv.id;
        itemCell.setAttribute('data-conversation', properName);
        itemCell.style.order = index;
        
        // Add emotion data attribute for emotions view styling
        if (conv.metadata?.mainEmotions && conv.metadata.mainEmotions.length > 0) {
            itemCell.setAttribute('data-emotion', conv.metadata.mainEmotions[0]);
        } else {
            itemCell.setAttribute('data-emotion', 'neutral');
        }
        
        // Create video container wrapper for better centering
        const videoContainer = document.createElement('div');
        videoContainer.className = 'video-container-wrapper';
        videoContainer.style.cssText = `
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            background: transparent;
            border-radius: 0;
        `;
        
        // Create simple image element for PNG preview
        const video = document.createElement('img');
        video.id = `video-preview-${conv.folder}`;
        video.className = 'conversation-video-preview';
        video.src = `videos/${conv.folder}.png`;
        video.loading = 'lazy';
        video.alt = `Preview of ${conv.folder}`;
        
        // Simple styling
        video.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: center;
            background: linear-gradient(135deg, #f7f9f3 0%, #e8f4f8 100%);
        `;
        
        // Simple error handling - show placeholder if PNG not found
        video.addEventListener('error', function() {
            console.log(`📷 PNG not found for ${conv.folder}, showing placeholder`);
            video.style.display = 'none';
            
            const placeholder = document.createElement('div');
            placeholder.style.cssText = `
                width: 100%; height: 100%; 
                background: linear-gradient(135deg, #f7f9f3 0%, #e8f4f8 100%);
                display: flex; align-items: center; justify-content: center;
                color: #888; font-size: 12px; text-align: center;
                border: 1px solid rgba(229, 230, 226, 0.5);
            `;
            
            const conversationName = conv.metadata?.name || conv.displayName || conv.folder;
            const mainEmotion = conv.metadata?.mainEmotions?.[0] || 'neutral';
            const emotionIcon = getEmotionIcon(mainEmotion);
            
            placeholder.innerHTML = `
                <div>
                    <div style="font-size: 24px; margin-bottom: 8px;">${emotionIcon}</div>
                    <div style="font-size: 10px; margin-bottom: 4px;">${conversationName}</div>
                    <div style="font-size: 8px; color: #aaa;">No preview image</div>
                </div>
            `;
            
            videoContainer.appendChild(placeholder);
        });
        
        // Add conversation label (removed weird ש letter)
        const label = document.createElement('div');
        label.className = 'conversation-label';
        label.textContent = ''; // Empty - no weird letters
        
        // Assemble component with proper nesting
        videoContainer.appendChild(video);
        itemCell.appendChild(videoContainer);
        itemCell.appendChild(label);
        itemCell.classList.add('video-preview-item');
        
        // Add unified event handlers only for video elements
        if (video.tagName === 'VIDEO') {
            addMP4PreviewEventHandlers(itemCell, conv, video);
        }
        
        // Add click and hover events to the itemCell itself
        addConversationItemEventHandlers(itemCell, conv);
        
        // Add to intersection observer for performance optimization
        if (conversationObserver) {
            conversationObserver.observe(itemCell);
        }
        
        return itemCell;
    }
    
    // Emotion to icon mapping for static previews
    function getEmotionIcon(emotion) {
        const emotionIcons = {
            'joy': '😊',
            'happiness': '😄',
            'excitement': '🎉',
            'love': '❤️',
            'sadness': '😢',
            'fear': '😨',
            'anger': '😠',
            'disgust': '🤢',
            'surprise': '😲',
            'neutral': '😐',
            'curiosity': '🤔',
            'confusion': '😕',
            'frustration': '😤',
            'anxiety': '😰',
            'calm': '😌',
            'tired': '😴',
            'bored': '😑',
            'default': '💭'
        };
        return emotionIcons[emotion?.toLowerCase()] || emotionIcons['default'];
    }

    // Intersection Observer for performance optimization
    let conversationObserver;
    
    function initConversationIntersectionObserver() {
        if (conversationObserver) {
            conversationObserver.disconnect();
        }
        
        conversationObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                const itemCell = entry.target;
                if (entry.isIntersecting) {
                    // Enable hover events when in viewport
                    itemCell.setAttribute('data-viewport-visible', 'true');
                } else {
                    // Disable hover events and cleanup when out of viewport
                    itemCell.removeAttribute('data-viewport-visible');
                    
                    // Clean up any loaded iframes to save memory
                    const videoContainer = itemCell.querySelector('.video-container-wrapper');
                    if (videoContainer) {
                        const placeholder = videoContainer.querySelector('.lazy-iframe-placeholder');
                        const iframe = videoContainer.querySelector('iframe');
                        
                        if (placeholder && iframe && placeholder.getAttribute('data-iframe-loaded') === 'true') {
                            console.log(`🧹 Cleaning up iframe for ${itemCell.id} (out of viewport)`);
                            iframe.remove();
                            placeholder.style.display = 'flex';
                            placeholder.removeAttribute('data-iframe-loaded');
                        }
                        
                        // Reset video preload for performance
                        const video = videoContainer.querySelector('.conversation-video-preview');
                        if (video && video.tagName === 'VIDEO') {
                            video.pause();
                            video.preload = 'none';
                        }
                    }
                }
            });
        }, {
            root: null,
            rootMargin: '50px', // Start loading slightly before coming into view
            threshold: 0.1
        });
    }

    // UNIFIED EVENT HANDLERS for Conversation Items
    function addConversationItemEventHandlers(itemCell, conv) {
        // Click handler with zoom effect
        itemCell.addEventListener('click', (e) => {
            console.log(`🎯 Clicked on conversation: ${conv.folder}`);
            e.preventDefault();
            itemCell.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            itemCell.style.transform = 'scale(1.3)';
            itemCell.style.zIndex = '100';
            
            setTimeout(() => {
                console.log(`🚀 Opening visualization for: ${conv.folder}`);
                openVisualizationInModal(conv.folder);
                setTimeout(() => {
                    itemCell.style.transform = 'scale(1)';
                    itemCell.style.zIndex = '2';
                    setTimeout(() => {
                        itemCell.style.transition = 'all 1.8s cubic-bezier(0.165, 0.84, 0.44, 1)';
                    }, 400);
                }, 100);
            }, 200);
        });
        
        // Simplified hover handlers - let CSS handle visual effects
        itemCell.addEventListener('mouseenter', () => {
            // Only show hover panel, let CSS handle visual styling
            showHoverPanel(conv);
        });
        
        itemCell.addEventListener('mouseleave', () => {
            // Only hide hover panel, let CSS handle visual styling
            hideHoverPanel(true);
        });
    }
    
    // UNIFIED EVENT HANDLERS for MP4 Preview Components
    function addMP4PreviewEventHandlers(itemCell, conv, video) {
        // Only add video event handlers if this is actually a video element
        if (video.tagName !== 'VIDEO') {
            console.log(`📷 Skipping video handlers for ${conv.folder} - element is ${video.tagName}`);
            return;
        }
        
        // Video loading handlers
        video.addEventListener('loadstart', () => {
            console.log(`🎬 Loading video for ${conv.folder} - src: ${video.src}`);
        });
        
        video.addEventListener('canplay', () => {
            console.log(`✅ Video ready for ${conv.folder} - duration: ${video.duration}`);
        });
        
        video.addEventListener('loadeddata', () => {
            console.log(`💾 Video data loaded for ${conv.folder} - ensuring first frame is visible`);
            // Ensure the first frame is visible
            video.currentTime = 0;
        });
        
        video.addEventListener('loadedmetadata', () => {
            console.log(`📊 Video metadata loaded for ${conv.folder} - ${video.videoWidth}x${video.videoHeight}`);
            Object.assign(video.style, {
                display: 'block',
                visibility: 'visible',
                opacity: '1'
            });
            
            // ISOTOPE READY: Prepare video content for smooth transitions
            video.currentTime = 0.1; // Use 0.1 to ensure frame is loaded
            
            // Make video ready for isotope animations - show actual content
            const prepareVideoForTransitions = () => {
                // Brief play to load the frame, then pause for static display
                video.play().then(() => {
                    setTimeout(() => {
                        video.pause();
                        video.currentTime = 0.1; // Keep at first frame for isotope transitions
                        console.log(`🎬 Video ready for isotope transitions: ${conv.folder}`);
                        
                        // Mark video as ready for smooth view transitions
                        video.setAttribute('data-isotope-ready', 'true');
                    }, 80); // Quick frame load for responsiveness
                }).catch(e => {
                    // If autoplay is blocked, just seek to frame
                    video.currentTime = 0.1;
                    video.setAttribute('data-isotope-ready', 'true');
                    console.log(`🎯 Video frame set for isotope: ${conv.folder}`);
                });
            };
            
            // Prepare immediately if video is ready
            if (video.readyState >= 2) {
                prepareVideoForTransitions();
            } else {
                // Wait for video to be ready
                video.addEventListener('canplay', prepareVideoForTransitions, { once: true });
            }
        });
        
        video.addEventListener('error', () => {
            console.warn(`❌ Video failed for ${conv.folder}`, video.error);
            const errorOverlay = document.createElement('div');
            errorOverlay.style.cssText = `
                position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(255, 0, 0, 0.1); border: 2px solid red;
                display: flex; align-items: center; justify-content: center;
                color: red; font-size: 12px; font-weight: bold; text-align: center; z-index: 100;
            `;
            errorOverlay.textContent = `Video Error\n${conv.folder}`;
            itemCell.style.position = 'relative';
            itemCell.appendChild(errorOverlay);
        });
        
        // Click handler with zoom effect
        itemCell.addEventListener('click', (e) => {
            console.log(`🎯 Clicked on conversation: ${conv.folder}`);
            e.preventDefault();
            itemCell.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            itemCell.style.transform = 'scale(1.3)';
            itemCell.style.zIndex = '100';
            
            setTimeout(() => {
                console.log(`🚀 Opening visualization for: ${conv.folder}`);
                openVisualizationInModal(conv.folder);
                setTimeout(() => {
                    itemCell.style.transform = 'scale(1)';
                    itemCell.style.zIndex = '2';
                    setTimeout(() => {
                        itemCell.style.transition = 'all 1.8s cubic-bezier(0.165, 0.84, 0.44, 1)';
                    }, 400);
                }, 100);
            }, 200);
        });
        
        // Simplified hover handlers - let CSS handle visual effects
        itemCell.addEventListener('mouseenter', () => {
            // Only show hover panel, let CSS handle visual styling
            showHoverPanel(conv);
        });
        
        itemCell.addEventListener('mouseleave', () => {
            // Only hide hover panel, let CSS handle visual styling
            hideHoverPanel(true);
        });
    }
    
    // UNIFIED HOVER PANEL FUNCTIONS
    // Store emotions config for hover panel
    let hoverEmotionsConfig = null;
    
    // Load emotions config for hover panel
    async function loadHoverEmotionsConfig() {
        if (!hoverEmotionsConfig) {
            try {
                const response = await fetch('/config/emotions_config.json');
                hoverEmotionsConfig = await response.json();
            } catch (error) {
                console.error('Failed to load emotions config for hover:', error);
                hoverEmotionsConfig = {};
            }
        }
        return hoverEmotionsConfig;
    }
    
    // Get emotion data for hover panel
    function getEmotionDataForHover(emotion) {
        const defaultData = {
            hebrew: emotion,
            color: '#9B9B9B',
            emoji: '😐'
        };
        
        if (!hoverEmotionsConfig) {
            return defaultData;
        }
        
        // Since emotions config now uses Hebrew keys, try direct lookup first
        if (hoverEmotionsConfig[emotion]) {
            return {
                hebrew: emotion, // The key itself is Hebrew
                color: hoverEmotionsConfig[emotion].color || '#9B9B9B',
                emoji: hoverEmotionsConfig[emotion].emoji || '😐'
            };
        }
        
        // For backward compatibility, try English variations and lookup by English field
        const variations = [
            emotion,
            emotion.toLowerCase(),
            emotion.charAt(0).toUpperCase() + emotion.slice(1).toLowerCase(),
            emotion.charAt(0).toLowerCase() + emotion.slice(1)
        ];
        
        // Try variations as keys
        for (const variant of variations) {
            if (hoverEmotionsConfig[variant]) {
                return {
                    hebrew: hoverEmotionsConfig[variant].hebrew || emotion,
                    color: hoverEmotionsConfig[variant].color || '#9B9B9B',
                    emoji: hoverEmotionsConfig[variant].emoji || '😐'
                };
            }
        }
        
        // Search by English field if emotion is English
        for (const [hebrewKey, emotionData] of Object.entries(hoverEmotionsConfig)) {
            if (emotionData.english === emotion || emotionData.english === emotion.toLowerCase()) {
                return {
                    hebrew: hebrewKey, // Use the Hebrew key as display name
                    color: emotionData.color || '#9B9B9B',
                    emoji: emotionData.emoji || '😐'
                };
            }
        }
        
        return defaultData;
    }


    
    // Hover panel management with timeout to prevent race conditions
    let hoverPanelTimeout = null;
    let currentHoveredConversation = null;
    
    function showHoverPanel(conv) {
        const hoverPanel = document.getElementById('hover-info-panel');
        if (!hoverPanel) return;
        
        // Clear any pending hide timeout
        if (hoverPanelTimeout) {
            clearTimeout(hoverPanelTimeout);
            hoverPanelTimeout = null;
        }
        
        // Track currently hovered conversation
        currentHoveredConversation = conv.folder || conv.displayName;
        
        const metadata = conv.metadata || {};
        const emotions = conv.mainEmotions?.length ? conv.mainEmotions : conv.summaryFeelings.split(',').map(e => e.trim());
        
        const tagsHTML = emotions.map(e => {
            const emotionData = getEmotionDataForHover(e.trim());
            return `<div class="hover-info-tag">
                <span>${emotionData.hebrew}</span>
                <div class="emotion-color-square" style="background-color: ${emotionData.color}"></div>
            </div>`;
        }).join('');
        
        const date = new Date(conv.date);
        const monthNames = ['ינו', 'פבר', 'מרץ', 'אפר', 'מאי', 'יונ', 'יול', 'אוג', 'ספט', 'אוק', 'נוב', 'דצמ'];
        const formattedDate = `${date.getDate()} ${monthNames[date.getMonth()]}`;
        
        const statusIcons = [];
        if (conv.isImportant) statusIcons.push('<span style="color: #f44336;" title="שיחה חשובה">⭐</span>');
        if (conv.isPrivate) statusIcons.push('<span style="color: #9c27b0;" title="שיחה פרטית">🔒</span>');
        if (conv.needsReview) statusIcons.push('<span style="color: #ff9800;" title="דורש בדיקה">⚠️</span>');
        
        const additionalInfo = [];
        if (metadata.totalWords) additionalInfo.push(`${metadata.totalWords} מילים`);
        if (conv.mp3_count) additionalInfo.push(`${conv.mp3_count} קטעים`);
        if (metadata.emotionalIntensity) additionalInfo.push(`עוצמה: ${metadata.emotionalIntensity}/10`);
        
        const additionalInfoHTML = additionalInfo.length > 0 
            ? `<div class="hover-info-additional">${additionalInfo.join(' | ')}</div>` 
            : '';
        
        const tagsHtml = metadata.tags?.length 
            ? `<div class="hover-info-metadata-tags">🏷️ ${metadata.tags.join(', ')}</div>`
            : '';
        
        hoverPanel.innerHTML = `
            <div class="hover-info-header">
                <div class="hover-info-title">
                    ${conv.displayName || 'שיחה עם נאמל'}
                    ${statusIcons.join(' ')}
                </div>
                <div class="hover-info-date">${formattedDate}</div>
            </div>
            <div class="hover-info-speakers">${conv.participants}</div>
            <div class="hover-info-divider"></div>
            <div class="hover-info-emotions-section">
                <div class="hover-info-section-title">רגשות:</div>
                <div class="hover-info-tags">${tagsHTML}</div>
            </div>
        `;
        
        // Show panel immediately
        hoverPanel.classList.add('visible');
    }
    
    function hideHoverPanel(immediate = false) {
        const hoverPanel = document.getElementById('hover-info-panel');
        if (!hoverPanel) return;
        
        // Clear current conversation tracking
        currentHoveredConversation = null;
        
        if (immediate) {
            // Clear any pending timeout and hide immediately
            if (hoverPanelTimeout) {
                clearTimeout(hoverPanelTimeout);
                hoverPanelTimeout = null;
            }
            hoverPanel.classList.remove('visible');
        } else {
            // Use a small delay to prevent flickering when moving between elements
            if (hoverPanelTimeout) {
                clearTimeout(hoverPanelTimeout);
            }
            hoverPanelTimeout = setTimeout(() => {
                hoverPanel.classList.remove('visible');
                hoverPanelTimeout = null;
            }, 50);
        }
    }
    
    // Initialize hover panel event listeners (called once on page load)
    function initializeHoverPanel() {
        const hoverPanel = document.getElementById('hover-info-panel');
        if (!hoverPanel) return;
        
        // No additional hover panel event listeners needed - 
        // panel should only be visible when hovering over conversations
    }
    
    // TOOLTIP CONTROL SYSTEM - Ensure tooltips only appear on conversation items
    function initializeTooltipControl() {
        console.log('🔧 Initializing tooltip control system...');
        
        // Disable tooltips on all non-conversation elements
        const disableTooltipsOnElements = [
            '.view-toggle-btn',
            '.nav-link', 
            '.hover-info-tag',
            '.hover-info-topic-tag',
            '.person-name-label',
            '.emotion-separator',
            '.zoom-btn',
            '.timeline-track',
            '.bottom-controls-container *',
            '.app-header *',
            '.about-page *'
        ];
        
        // Remove title attributes from non-conversation elements
        disableTooltipsOnElements.forEach(selector => {
            document.querySelectorAll(selector).forEach(element => {
                element.removeAttribute('title');
                // Prevent any hover info panels from showing
                element.addEventListener('mouseenter', (e) => {
                    e.stopPropagation();
                });
            });
        });
        
        // Ensure only conversation grid items can show hover panels
        document.addEventListener('mouseover', (e) => {
            const target = e.target;
            
            // Check if the target or its parent is a conversation item (exclude hover panel itself)
            const conversationItem = target.closest('.conversation-grid-item-container') || 
                                   target.closest('[id^="conv-item-"]');
            
            if (!conversationItem) {
                // If not hovering over a conversation, hide panel immediately
                hideHoverPanel(true);
            } else {
                // Check if we're hovering over a different conversation
                const conversationId = conversationItem.id || conversationItem.getAttribute('data-conversation');
                if (currentHoveredConversation && conversationId && 
                    currentHoveredConversation !== conversationId) {
                    // Switching to a different conversation, hide current panel immediately
                    hideHoverPanel(true);
                }
            }
        }, true);
        
        // Also hide hover panel when moving mouse outside of layout canvas
        const layoutCanvas = document.getElementById('layout-canvas');
        if (layoutCanvas) {
            layoutCanvas.addEventListener('mouseleave', () => {
                hideHoverPanel();
            });
        }
        
        // Add CSS to prevent tooltips on non-conversation elements
        const tooltipControlStyle = document.createElement('style');
        tooltipControlStyle.textContent = `
            /* Disable tooltips on all elements except conversation items */
            *:not(.conversation-grid-item-container):not([id^="conv-item-"]) {
                pointer-events: auto !important;
            }
            
            /* Prevent title tooltips on specific UI elements */
            .view-toggle-btn[title],
            .nav-link[title],
            .hover-info-tag[title],
            .hover-info-topic-tag[title],
            .person-name-label[title],
            .emotion-separator[title],
            .zoom-btn[title],
            .timeline-track[title],
            .bottom-controls-container *[title],
            .app-header *[title],
            .about-page *[title] {
                position: relative;
            }
            
            .view-toggle-btn[title]:hover::after,
            .nav-link[title]:hover::after,
            .hover-info-tag[title]:hover::after,
            .hover-info-topic-tag[title]:hover::after,
            .person-name-label[title]:hover::after,
            .emotion-separator[title]:hover::after,
            .zoom-btn[title]:hover::after,
            .timeline-track[title]:hover::after,
            .bottom-controls-container *[title]:hover::after,
            .app-header *[title]:hover::after,
            .about-page *[title]:hover::after {
                display: none !important;
                content: none !important;
            }
        `;
        document.head.appendChild(tooltipControlStyle);
        
        console.log('✅ Tooltip control system initialized');
    }

    // GLOBAL MP4 PREVIEW CONFIGURATION UPDATER
    // Use this function to update styling across ALL views at once
    window.updateMP4PreviewConfig = function(newConfig) {
        // Merge new configuration with existing
        if (newConfig.videoStyles) {
            Object.assign(MP4_PREVIEW_CONFIG.videoStyles, newConfig.videoStyles);
        }
        if (newConfig.containerStyles) {
            Object.assign(MP4_PREVIEW_CONFIG.containerStyles, newConfig.containerStyles);
        }
        if (newConfig.hoverEffects) {
            Object.assign(MP4_PREVIEW_CONFIG.hoverEffects, newConfig.hoverEffects);
        }
        
        // Apply updated styles to all existing MP4 preview components
        const allVideoElements = document.querySelectorAll('.conversation-video-preview');
        const allContainerElements = document.querySelectorAll('.conversation-grid-item-container');
        
        allVideoElements.forEach(video => {
            Object.assign(video.style, MP4_PREVIEW_CONFIG.videoStyles);
        });
        
        allContainerElements.forEach(container => {
            Object.assign(container.style, MP4_PREVIEW_CONFIG.containerStyles);
        });
        
        console.log('✅ MP4 Preview configuration updated globally across all views');
        return MP4_PREVIEW_CONFIG;
    };
    
    // Function to reset all conversation containers to default state
    window.resetAllConversationContainers = function() {
        const allContainerElements = document.querySelectorAll('.conversation-grid-item-container');
        const allVideoElements = document.querySelectorAll('.conversation-video-preview');
        const allVideoContainers = document.querySelectorAll('.video-container-wrapper');
        
        allContainerElements.forEach(container => {
            Object.assign(container.style, {
                transform: 'scale(1)',
                zIndex: '2',
                boxShadow: 'none',
                background: 'transparent',
                border: 'none',
                borderRadius: '0',
                margin: '0px', // Remove margins for maximum space utilization
                width: '100%',
                height: '100%',
                transition: 'transform 0.3s ease, box-shadow 0.3s ease'
            });
        });
        
        allVideoElements.forEach(video => {
            Object.assign(video.style, {
                filter: 'none',
                boxShadow: 'none',
                transform: 'scale(1)'
            });
        });
        
        allVideoContainers.forEach(container => {
            Object.assign(container.style, {
                transform: 'scale(1)'
            });
        });
        
        console.log('✅ All conversation containers reset to default state');
    };
    
    // EXAMPLE: How to update MP4 preview styling globally
    // window.updateMP4PreviewConfig({
    //     videoStyles: {
    //         borderRadius: '8px',
    //         filter: 'contrast(1.2) brightness(1.1) saturate(1.2)'
    //     },
    //     containerStyles: {
    //         borderRadius: '8px',
    //         boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)'
    //     }
    // });
    
    // --- Layout Calculation Functions ---
    
    function getTimelineLayoutPositions(conversations, container, preservedXPositions = {}) {
        console.log(`📅 TIMELINE VIEW: getTimelineLayoutPositions called for ${conversations.length} conversations`);
        const positions = {};

        const layoutCanvas = document.getElementById('layout-canvas');
        const useContainer = layoutCanvas && window.activeLayout === 'timeline' ? layoutCanvas : container;
        const containerWidth = useContainer.offsetWidth || 1200; 
        const containerHeight = useContainer.clientHeight || 800;
        
        const totalConversations = conversations.length;
        
        // CENTERED TIMELINE: Center conversations horizontally and use FULL height
        const horizontalPadding = 4; // 4px padding as requested
        const verticalPadding = 4; // 4px padding as requested
        const availableWidth = containerWidth - (2 * horizontalPadding); // Account for padding
        const availableHeight = containerHeight - (2 * verticalPadding); // Use most of screen height
        
        // Sort conversations by date first
        const sortedConversations = conversations.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // Group conversations by date (YYYY-MM-DD format)
        const dateGroups = {};
        sortedConversations.forEach(conv => {
            const dateKey = conv.date ? conv.date.split('T')[0] : 'unknown';
            if (!dateGroups[dateKey]) {
                dateGroups[dateKey] = [];
            }
            dateGroups[dateKey].push(conv);
        });
        
        const dateKeys = Object.keys(dateGroups).sort(); // Ensure chronological order
        const totalDateGroups = dateKeys.length;
        
        console.log(`📅 CENTERED Timeline: ${totalConversations} conversations centered layout`);
        console.log(`📅 DATE GROUPS DEBUG: Found ${totalDateGroups} date groups:`, dateGroups);
        console.log(`📅 DATE KEYS DEBUG:`, dateKeys);
        dateKeys.forEach(date => {
            console.log(`  📅 ${date}: ${dateGroups[date].length} conversations ${dateGroups[date].length > 1 ? '(centered stack)' : '(single)'}`);
        });
        
        // DYNAMIC SIZING: Calculate item size first before using it - ORGANIZED
        const maxItemSize = 100; // Organized maximum for proper spacing
        const minItemSize = 60; // Compact minimum for visibility
        
        // Find the maximum conversations in any single date group
        const maxConversationsInGroup = Math.max(...dateKeys.map(key => dateGroups[key].length));
        
        // FULL HEIGHT DISTRIBUTION: Use entire screen height for conversations
        const bottomMargin = 10; // Minimal margin from bottom  
        const topMargin = 120; // More top margin to move conversations down from header
        const availableVerticalSpace = Math.max(400, containerHeight - bottomMargin - topMargin); // Use nearly full height
        const containerBaselineY = 50; // 50% of container height (since we'll use percentage positioning)
        
        // Calculate item size first - use fixed gap for initial calculation
        const baseStackGap = 15; // Fixed gap for initial calculation
        const totalGapsNeeded = Math.max(maxConversationsInGroup - 1, 0) * baseStackGap;
        const optimalVerticalSize = Math.min((availableVerticalSpace - totalGapsNeeded) / Math.max(maxConversationsInGroup, 1), maxItemSize);
        let itemSize = Math.max(minItemSize, Math.min(maxItemSize, optimalVerticalSize));
        
        // CONSISTENT GAPS: 2px gap everywhere for visual consistency
        const uniformGap = 2; // 2px gap everywhere for visual consistency
        const stackGap = 2; // 2px gap between conversations in the same column
        const columnMargin = 2; // 2px gap between columns
        
        // AUTOMATIC COLUMN SIZE CALCULATION: Maximize conversation size aggressively
        const totalGaps = (totalDateGroups - 1) * columnMargin; // Total space needed for gaps between columns
        const availableForColumns = availableWidth - totalGaps; // Space available for actual columns
        const optimalColumnWidth = Math.floor(availableForColumns / totalDateGroups); // Optimal column width
        const fixedColumnWidth = optimalColumnWidth; // Use full optimal size - no artificial minimum
        
        // AGGRESSIVE SIZING: Check if we can squeeze out more pixels by using remaining space
        const usedWidth = (totalDateGroups * fixedColumnWidth) + totalGaps;
        const remainingWidth = availableWidth - usedWidth;
        const extraPerColumn = Math.floor(remainingWidth / totalDateGroups);
        let finalColumnWidth = fixedColumnWidth + extraPerColumn; // Add any remaining pixels
        
        // FORCE MINIMUM SIZE: Ensure conversations are reasonably sized
        const minimumSize = 69; // Force minimum 70px for good visibility
        finalColumnWidth = Math.max(finalColumnWidth, minimumSize);
        
        const totalColumnsWidth = (totalDateGroups * finalColumnWidth) + totalGaps; // Total width needed for all columns including margins
        const centeredStartX = horizontalPadding + ((availableWidth - totalColumnsWidth) / 2); // Center within padded area
        const dateColumnWidth = Math.min(finalColumnWidth * 0.9, 150); // Organized column width for better spacing
        
        console.log(`📐 BASELINE LAYOUT: itemSize=${itemSize}px, maxStack=${maxConversationsInGroup}, tallestHeight=${Math.round(maxConversationsInGroup * itemSize + (maxConversationsInGroup - 1) * stackGap)}px, availableV=${availableVerticalSpace}px`);
        
        // Set CSS custom properties for container-relative baseline timeline styling  
        const visualConversationSize = finalColumnWidth; // Use exact column width to maintain proper margins
        document.documentElement.style.setProperty('--timeline-item-size', `${visualConversationSize}px`);
        document.documentElement.style.setProperty('--timeline-column-spacing', `${finalColumnWidth + columnMargin}px`);
        document.documentElement.style.setProperty('--visual-conversation-size', `${visualConversationSize}px`);
        document.documentElement.style.setProperty('--timeline-stack-gap', `${stackGap}px`);
        document.documentElement.style.setProperty('--timeline-baseline-y', `50%`);
        
        // INVISIBLE COLUMN TIMELINE POSITIONING: Column logic without visual elements
        let globalOrder = 0;
        const firstColumnCenterX = centeredStartX + (finalColumnWidth / 2); // Center of first column
        
        // NO visual elements - but keep structure for rendering metadata
        positions._dateLabels = [];
        positions._dateSeparators = [];
        positions._dateColumns = [];
        positions._timelineBaseline = null; // Remove baseline completely
        
        dateKeys.forEach((dateKey, groupIndex) => {
            const groupConversations = dateGroups[dateKey];
            console.log(`📅 PROCESSING DATE GROUP: ${dateKey} (index ${groupIndex}) with ${groupConversations.length} conversations`);
            
            // Create date label for this column (MM/DD format)
            const dateObj = new Date(dateKey);
            const month = String(dateObj.getMonth() + 1).padStart(2, '0');
            const day = String(dateObj.getDate()).padStart(2, '0');
            const formattedDate = `${month}/${day}`;
            console.log(`📅 FORMATTED DATE: "${formattedDate}" from "${dateKey}"`);
            
            // UPWARD BASELINE POSITIONING: Calculate baseline position for this date group
            const containerHeight = availableVerticalSpace; // Use actual container height
            const fixedItemHeight = finalColumnWidth; // Match the column width for square items
            const fixedVerticalGap = stackGap; // 2px gap between conversations in the same column
            
            // Calculate baseline position so the tallest column is centered on screen
            const tallestColumnHeight = maxConversationsInGroup * fixedItemHeight + (maxConversationsInGroup - 1) * fixedVerticalGap;
            const screenCenterY = containerHeight / 2; // Center of screen
            // Add offset to move timeline higher up on the canvas
            const centeringOffset = -60; // Move conversations up higher on the canvas
            const commonBaseline = screenCenterY + (tallestColumnHeight / 2) + centeringOffset; // Position baseline higher
            
            // CONSISTENT POSITIONING: Same calculations for every conversation
            groupConversations.forEach((conv, stackIndex) => {
                // RIGHT-TO-LEFT X POSITION: Use preserved X if available, otherwise calculate from right side
                const x = preservedXPositions[conv.folder] !== undefined ? 
                         preservedXPositions[conv.folder] : 
                         centeredStartX + ((totalDateGroups - 1 - groupIndex) * (finalColumnWidth + columnMargin));
                
                // All conversations stack upward TO the common baseline (highest stackIndex reaches baseline)
                const reverseStackIndex = groupConversations.length - 1 - stackIndex; // Reverse the stacking order
                const y = commonBaseline - (reverseStackIndex * (fixedItemHeight + fixedVerticalGap)); // Stack upward to baseline
                
                console.log(`  📏 Upward baseline: screenCenter=${Math.round(screenCenterY)}px, tallestColumn=${Math.round(tallestColumnHeight)}px, commonBaseline=${Math.round(commonBaseline)}px (offset=${centeringOffset}px), conversation ${stackIndex + 1} (reverse=${reverseStackIndex}) at Y=${Math.round(y)}px`)
                
                // No adjustments - use exact calculated positions for consistency
                const finalX = x;
                const finalY = y;
                
                positions[conv.folder] = {
                    left: finalX,
                    top: finalY,
                    width: fixedItemHeight,
                    height: fixedItemHeight,
                    gridOrder: globalOrder,
                    flexOrder: globalOrder,
                    dateGroup: dateKey,
                    formattedDate: formattedDate,
                    stackIndex: stackIndex,
                    groupIndex: groupIndex,
                    // Upward baseline positioning indicators
                    isTopOfStack: stackIndex === groupConversations.length - 1, // Last item reaches the baseline (top)
                    isOnBaseline: stackIndex === groupConversations.length - 1, // Last item sits on the common baseline
                    isBottomOfStack: stackIndex === 0, // First item is at the bottom
                    totalInStack: groupConversations.length,
                    isOnlyInStack: groupConversations.length === 1,
                    isConsistentLayout: true,
                    uniformSize: itemSize
                };
                
                console.log(`  📍 ${conv.folder} (${formattedDate}): Column ${groupIndex + 1} (RTL pos ${totalDateGroups - groupIndex}), X=${Math.round(finalX)}, Y=${Math.round(finalY)}, UPWARD stack ${stackIndex + 1}/${groupConversations.length} → baseline (commonBaseline=${Math.round(commonBaseline)}px)`);
                globalOrder++;
            });
            
            // ADD DATE LABEL UNDER EACH COLUMN - Use actual conversation positions
            // Use ACTUAL conversation positions to find the real column center
            let actualConversationCenterX = 0;
            groupConversations.forEach((conv, stackIndex) => {
                const actualX = positions[conv.folder] ? positions[conv.folder].left : 0;
                const actualWidth = positions[conv.folder] ? positions[conv.folder].width : finalColumnWidth;
                const actualCenterX = actualX + (actualWidth / 2);
                actualConversationCenterX = actualCenterX; // All conversations in this column have same center
            });
            
            console.log(`📅 COLUMN POSITIONING: "${formattedDate}" group ${groupIndex}/${totalDateGroups}`);
            console.log(`   Using ACTUAL conversation center: ${Math.round(actualConversationCenterX)}`);
            
            // Calculate position below the bottom conversation in this column
            // Use ACTUAL conversation positions, not theoretical calculations
            let actualBottomMostY = 0;
            
            groupConversations.forEach((conv, stackIndex) => {
                // Get the actual Y position that was stored for this conversation
                const actualConversationTop = positions[conv.folder] ? positions[conv.folder].top : 0;
                const actualConversationBottom = actualConversationTop + fixedItemHeight;
                actualBottomMostY = Math.max(actualBottomMostY, actualConversationBottom);
            });
            
            const dateLabelY = actualBottomMostY + 30  ; // 30px below the actual bottom-most conversation
            
            console.log(`📅 Y POSITIONING: "${formattedDate}" - actualBottomMostY=${Math.round(actualBottomMostY)}, labelY=${Math.round(dateLabelY)}`);
            
            const dateLabelHeight = 50;
            
            console.log(`📅 CREATING DATE LABEL: "${formattedDate}" for group ${groupIndex}/${totalDateGroups} at actualCenterX=${Math.round(actualConversationCenterX)}, dateLabelY=${Math.round(dateLabelY)}, conversations=${groupConversations.length}`);
            
            // Position text DIRECTLY at ACTUAL conversation center using transform translateX(-50%)
            const labelWidth = 100; // Fixed width for consistent appearance
            const labelX = actualConversationCenterX; // Position at exact ACTUAL conversation center
            
            positions._dateLabels.push({
                name: formattedDate,
                fullDate: dateKey,
                x: labelX,
                y: dateLabelY,
                width: labelWidth,
                height: dateLabelHeight,
                groupIndex: groupIndex,
                conversationCount: groupConversations.length,
                rtlPosition: totalDateGroups - groupIndex
            });
            
            console.log(`📅 STORED DATE LABEL: "${formattedDate}" at final position (${Math.round(labelX)}, ${Math.round(dateLabelY)})`);
            console.log(`   📏 Label positioned at ACTUAL conversation center: ${Math.round(actualConversationCenterX)}`);
            console.log(`   📏 Label will use transform translateX(-50%) to center the text`);
            
            console.log(`  📅 Date label "${formattedDate}" at ACTUAL X=${Math.round(actualConversationCenterX)}, Y=${dateLabelY} (under column ${groupIndex + 1})`);
        });
        
        console.log(`📅 TIMELINE LAYOUT: Created ${positions._dateLabels.length} date labels for timeline view`);

        // RENDER DATE LABELS: Create date labels directly in layout function  
        console.log(`📅 DOM RENDERING: Starting date label rendering for ${positions._dateLabels?.length || 0} labels`);
        
        // Clear any existing timeline date labels first
        const existingLabels = document.querySelectorAll('.timeline-date-label-protected');
        const existingDebugElements = document.querySelectorAll('.debug-center-dot, .debug-column-center');
        existingLabels.forEach(label => label.remove());
        existingDebugElements.forEach(el => el.remove());
        console.log(`📅 CLEANUP: Removed ${existingLabels.length} existing timeline date labels and ${existingDebugElements.length} debug elements`);
        
        // ALWAYS render if we have date labels, regardless of other conditions
        if (positions._dateLabels && positions._dateLabels.length > 0) {
                         positions._dateLabels.forEach((labelData, index) => {
                                 const labelElement = document.createElement('div');
                labelElement.className = 'timeline-date-label-protected';
                labelElement.setAttribute('data-timeline-date', 'true');
                
                // Simple date text only - no conversation count
                labelElement.textContent = labelData.name;
               
                // Perfect center alignment using CSS transform
                labelElement.style.cssText = `
                    position: absolute;
                    left: ${labelData.x}px;
                    top: ${labelData.y}px;
                    transform: translate(-50%, -50%) !important;
                    z-index: 2;
                    font-family: var(--main-font-family);
                    font-size: 14px;
                    font-weight: normal;
                    color: #333;
                    text-align: center !important;
                    width: ${labelData.width}px;
                    height: ${labelData.height}px;
                    line-height: ${labelData.height}px !important;
                    background: none !important;
                    border: none !important;
                    box-shadow: none !important;
                    padding: 0 !important;
                    margin: 0 !important;
                    direction: ltr !important;
                    box-sizing: border-box !important;
                    white-space: nowrap !important;
                    overflow: visible !important;
                `;
                
                console.log(`📅 Created date label "${labelData.name}" at position (${labelData.x}, ${labelData.y}) with size ${labelData.width}x${labelData.height}`);
                
                                 // Add to layout-canvas to ensure proper positioning relative to conversations
                 const layoutCanvas = document.getElementById('layout-canvas');
                 if (layoutCanvas) {
                     layoutCanvas.appendChild(labelElement);
                 } else {
                     document.body.appendChild(labelElement);
                 }
             });
             console.log(`📅 ✅ Successfully rendered ${positions._dateLabels.length} date labels for timeline`);
             
             // DEBUG: Check if elements are being removed and when
             const checkLabels = () => {
                 const renderedLabels = document.querySelectorAll('.timeline-date-label-protected');
                 console.log(`📅 DOM CHECK: Found ${renderedLabels.length} protected date labels in BODY at ${Date.now()}`);
                 return renderedLabels.length;
             };
             
             // Check immediately
             console.log(`📅 IMMEDIATE CHECK: ${checkLabels()} labels found right after creation`);
             
             // Check after delays to see when they disappear
             setTimeout(() => checkLabels(), 50);
             setTimeout(() => checkLabels(), 100);
             setTimeout(() => checkLabels(), 200);
             setTimeout(() => checkLabels(), 500);
             setTimeout(() => checkLabels(), 1000);
         }

        // Common baseline timeline debug info
        console.log(`📅 UPWARD BASELINE Timeline (RIGHT-TO-LEFT): ${totalConversations} conversations across ${totalDateGroups} date columns, all stacking up to top baseline`);
        console.log(`🎯 Layout: ${containerWidth}x${containerHeight}px, base item: ${Math.round(itemSize)}px, uniform spacing`);
        console.log(`📊 Upward baseline positioning - all columns stack upward to same top baseline, overall layout centered`);
        console.log(`📅 Date labels: ${dateKeys.length} labels positioned at bottom of columns`);
        console.log(`📏 MAXIMIZED LAYOUT: ${totalDateGroups} columns × ${finalColumnWidth}px + ${uniformGap}px gaps = ${Math.round(totalColumnsWidth)}px, Available: ${availableWidth}px, Padding: ${horizontalPadding}px`);
        console.log(`🔍 AGGRESSIVE SIZING: Container=${containerWidth}px, Padding=${horizontalPadding*2}px, Available=${availableWidth}px, Gaps=${totalGaps}px, For Columns=${availableForColumns}px, Base=${fixedColumnWidth}px, Extra=${extraPerColumn}px, Final=${finalColumnWidth}px`);
        console.log(`💎 COLUMN SPACING: ${finalColumnWidth + columnMargin}px (${finalColumnWidth}px + ${columnMargin}px gap)`);
        console.log(`🎯 CONVERSATION SIZE: ${visualConversationSize}px × ${visualConversationSize}px (maintains proper margins)`);
        console.log(`📐 UPWARD BASELINE: All conversations stack upward to same top baseline, positioned for centered overall layout`);
        
        // Store container baseline timeline metadata for rendering
        positions._meta = {
            layout: 'upward-baseline-timeline',
            dateGroups: dateGroups,
            dateKeys: dateKeys,
            totalDateGroups: totalDateGroups,
            maxConversationsInGroup: maxConversationsInGroup,
            baseItemSize: itemSize,
            maxItemSize: maxItemSize,
            minItemSize: minItemSize,
            fixedColumnWidth: finalColumnWidth,
            columnMargin: columnMargin,
            uniformGap: uniformGap,
            dateColumnWidth: dateColumnWidth,
            stackGap: stackGap,
            containerBaselineY: containerBaselineY,
            bottomMargin: bottomMargin,
            topMargin: topMargin,
            availableVerticalSpace: availableVerticalSpace,
            centeredStartX: centeredStartX,
            firstColumnCenterX: firstColumnCenterX,
            totalColumnsWidth: totalColumnsWidth,
            isCenteredTimeline: true,
            // Date labels are now included in _dateLabels array
            dateLabels: positions._dateLabels,
            timelineBaseline: null,
            dateSeparators: [],
            dateColumns: []
        };
        
        // BASELINE POSITIONING: Conversations are already positioned relative to baseline
        // No additional centering needed - conversations should stay on their baseline positions
        console.log(`✅ Conversations positioned on baseline - no additional centering applied`);
        
        return positions;
    }

    function getPeopleViewPositions(conversations, container) {
        console.log(`👥 PEOPLE VIEW: getPeopleViewPositions called for ${conversations.length} conversations`);
        const positions = {};
        
        // Use layout canvas dimensions for proper sizing
        const layoutCanvas = document.getElementById('layout-canvas');
        const useContainer = layoutCanvas ? layoutCanvas : container;
        const containerWidth = useContainer.offsetWidth || 1200;
        const containerHeight = useContainer.clientHeight || 800;
        
        console.log(`📏 People view using layout canvas dimensions: ${containerWidth}x${containerHeight}`);
        
        // If container dimensions are invalid, return empty positions
        if (containerWidth < 100 || containerHeight < 100) {
            console.warn(`⚠️ Invalid container dimensions: ${containerWidth}x${containerHeight} - skipping People view layout`);
            return {};
        }
        
        // BUILD PEOPLE GROUPS FROM CONVERSATION METADATA (not people_data.json)
        const peopleGroups = {};
        
        conversations.forEach(conv => {
            // Get participant from conversation metadata
            let participant = 'עדן'; // Default fallback
            
            if (conv.metadata) {
                if (conv.metadata.customParticipantName) {
                    participant = conv.metadata.customParticipantName;
                } else if (conv.metadata.participants && conv.metadata.participants.length > 0) {
                    participant = conv.metadata.participants[0];
                } else if (conv.metadata.mainParticipant && conv.metadata.mainParticipant !== 'custom') {
                    participant = conv.metadata.mainParticipant;
                }
            }
            
            if (!peopleGroups[participant]) {
                peopleGroups[participant] = [];
            }
            peopleGroups[participant].push(conv.folder);
        });
        
        console.log('👥 People groups from conversation metadata:', peopleGroups);
        
        // 🔍 DEBUG: Detailed logging for טל מקלר conversations
        console.log('🔍 DEBUGGING טל מקלר conversations:');
        conversations.forEach(conv => {
            if (conv.metadata && (
                (conv.metadata.mainParticipant && conv.metadata.mainParticipant.includes('טל מקלר')) ||
                (conv.metadata.customParticipantName && conv.metadata.customParticipantName.includes('טל מקלר'))
            )) {
                console.log(`  📁 ${conv.folder}:`);
                console.log(`    - customParticipantName: "${conv.metadata.customParticipantName}"`);
                console.log(`    - mainParticipant: "${conv.metadata.mainParticipant}"`);
                console.log(`    - participants: [${conv.metadata.participants?.join(', ')}]`);
                console.log(`    - name: "${conv.metadata.name}"`);
            }
        });
        
        // Show which group each conversation ended up in
        Object.entries(peopleGroups).forEach(([person, convos]) => {
            if (person.includes('טל מקלר')) {
                console.log(`🎯 "${person}" group has ${convos.length} conversations: [${convos.join(', ')}]`);
            }
        });
        
        if (Object.keys(peopleGroups).length === 0) {
            console.warn('⚠️ No people groups found - returning empty positions');
            return {};
        }
        
        // GRID LAYOUT SETTINGS - ORIGINAL SIZE TO FIT ALL ON SCREEN
        const conversationSize = 60; // Original size so all conversations fit without scrolling
        const conversationsPerRow = 15; // 11 conversations per row like in the image
        const conversationGap = 2; // 2px gap between conversations to match timeline view
        const rowHeight = 1; // Further reduced height for each person's row section - tighter spacing
        const personNameWidth = 120; // Width reserved for person names (increased to prevent overlapping)
        const horizontalPadding = 2;
        const verticalPadding = 1; // Further reduced vertical padding for tighter spacing
        
        console.log(`👥 PEOPLE VIEW: Using original size=${conversationSize}px (compact to fit all on screen), ConversationsPerRow=${conversationsPerRow}, Gap=${conversationGap}px`);
        
        // Calculate layout dimensions
        const availableWidth = containerWidth - (2 * horizontalPadding) - personNameWidth - 2; // 2px gap between conversations and names
        const conversationRowWidth = (conversationsPerRow * conversationSize) + ((conversationsPerRow - 1) * conversationGap);
        
        // Calculate total height needed for all people to center them vertically
        const peopleNames = Object.keys(peopleGroups);
        let totalHeight = 0;
        peopleNames.forEach((personName) => {
            const personConversations = peopleGroups[personName];
            const totalRows = Math.ceil(personConversations.length / conversationsPerRow);
            totalHeight += (totalRows * (conversationSize + conversationGap)) + 0; // Include 0px gap between people
        });
        
        // Align with emotions view: start at top like emotions view (not centered)
        const availableHeight = containerHeight - 120; // Account for header/footer
        const topMargin = 60; // Same top margin as emotions view
        const startY = topMargin; // Start at same position as emotions view baseline
        let currentY = startY;
        
        // Calculate person name alignment position (right-aligned on screen)
        // Position person names on the right side of the screen, not based on logo
        const rightMargin = 20; // Margin from right edge
        const globalPersonNameStartX = containerWidth - rightMargin - personNameWidth; // Right-aligned position
        console.log(`📍 Positioning all person names at RIGHT side: ${globalPersonNameStartX}px (container: ${containerWidth}px, margin: ${rightMargin}px, width: ${personNameWidth}px)`);
        
        // Position conversations for each person
        peopleNames.forEach((personName, personIndex) => {
            const personConversations = peopleGroups[personName];
            const totalRows = Math.ceil(personConversations.length / conversationsPerRow);
            
            console.log(`👤 ${personName}: ${personConversations.length} conversations in ${totalRows} row(s)`);
            
            // Position person name label first (aligned with emotion labels position)
            const personLabelY = currentY + ((totalRows * (conversationSize + conversationGap)) / 2) - (conversationSize / 2);
            
            // Use the global person name position calculated outside the loop
            const personNameX = globalPersonNameStartX;
            
            // Position conversations to the left of the person name
            personConversations.forEach((convFolder, convIndex) => {
                const conversation = conversations.find(c => c.folder === convFolder);
                if (!conversation) return;
                
                const rowIndex = Math.floor(convIndex / conversationsPerRow);
                const colIndex = convIndex % conversationsPerRow;
                
                // Calculate conversations starting to the LEFT of person name and flowing left
                // Small gap to prevent overlap with person name
                const conversationsEndX = personNameX - 10; // Just 10px gap to prevent overlap
                const convX = conversationsEndX - ((colIndex + 1) * (conversationSize + conversationGap));
                const convY = currentY + (rowIndex * (conversationSize + conversationGap));
                
                positions[convFolder] = {
                    left: convX,
                    top: convY,
                    width: conversationSize,
                    height: conversationSize,
                    personName: personName,
                    personIndex: personIndex,
                    rowIndex: rowIndex,
                    colIndex: colIndex
                };
                
                console.log(`  📍 ${convFolder}: row ${rowIndex + 1}, col ${colIndex + 1} at (${Math.round(convX)}, ${Math.round(convY)}) [personNameX: ${Math.round(personNameX)}, conversationsEndX: ${Math.round(conversationsEndX)}, gap: ${Math.round(personNameX - conversationsEndX)}px]`);
            });
            
            if (!positions._personNames) positions._personNames = [];
            positions._personNames.push({
                name: personName,
                x: personNameX,
                y: personLabelY,
                width: personNameWidth,
                height: conversationSize,
                personIndex: personIndex,
                conversationCount: personConversations.length,
                totalRows: totalRows
            });
            
            // Move to next person's section (add space between people)
            currentY += (totalRows * (conversationSize + conversationGap)) + 2; // 2px gap between people for consistent spacing
        });
        
                         // Set CSS custom property for people view only
        document.documentElement.style.setProperty('--people-conversation-size', `${conversationSize}px`);
        
        console.log(`✅ People view layout complete: ${peopleNames.length} people, positioned ${Object.keys(positions).length - 1} conversations`);
        console.log(`🎯 PEOPLE VIEW FINAL SIZE: ${conversationSize}px × ${conversationSize}px (original compact size to fit all on screen)`);
         
        return positions;
    }

    function getEmotionsViewPositions(conversations, container) {
        const positions = {};
        
        console.log(`🎭 EMOTIONS VIEW: getEmotionsViewPositions called for ${conversations.length} conversations`);
        
        // Use layout canvas dimensions for proper sizing
        const layoutCanvas = document.getElementById('layout-canvas');
        const useContainer = layoutCanvas ? layoutCanvas : container;
        const containerWidth = useContainer.offsetWidth || 1200;
        const containerHeight = useContainer.clientHeight || 800;
        
        console.log(`🎭 Emotions view using layout canvas dimensions: ${containerWidth}x${containerHeight}`);
        
        // If container dimensions are invalid, return empty positions
        if (containerWidth < 100 || containerHeight < 100) {
            console.warn(`⚠️ Invalid container dimensions: ${containerWidth}x${containerHeight} - skipping Emotions view layout`);
            return {};
        }
        
        // USE SAME SIZE AS TIMELINE VIEWS for consistency 
        const timelineSquareSize = 80; // Fixed size for emotions view (independent of people view)
        const emotionGap = 2; // 2px gap like timeline and people view
        const headerSpace = 62; // 60px header + 2px padding
        const footerSpace = 62; // 60px footer + 2px padding
        
        // 🎭 TETRIS-STYLE EMOTIONS VIEW: Group conversations by main emotion from metadata
        const emotionGroups = {};
        
        // Group conversations by their main emotions from conversation management metadata
        // Each conversation has only ONE main emotion (as set in management tab)
        conversations.forEach(conv => {
            const mainEmotions = conv.metadata?.mainEmotions || ['neutral'];
            
            // Take the first (and should be only) emotion since each conversation now has single emotion
            const selectedEmotion = mainEmotions[0];
            
            // Skip undefined/invalid emotions
            if (!selectedEmotion || selectedEmotion === 'undefined') {
                console.warn(`⚠️ Skipping conversation ${conv.folder} with invalid emotion: ${selectedEmotion}`);
                return;
            }
            
            if (!emotionGroups[selectedEmotion]) {
                emotionGroups[selectedEmotion] = [];
            }
            emotionGroups[selectedEmotion].push(conv.folder);
        });
        
        const emotionTypes = Object.keys(emotionGroups);
        const emotionCount = emotionTypes.length;
        
        console.log(`🎭 Emotion Groups (Tetris style): ${emotionCount} different emotions found`, emotionGroups);
        
        // Define emotion cluster positions spread across viewport for visibility
        // Added more positions to handle up to 15 different emotions without overlap
        // VERTICAL STACKING PYRAMID: Group emotions by conversation count and stack vertically
        // First, sort emotions by conversation count (most conversations = bottom of pyramid)
        const emotionWithCounts = emotionTypes.map(emotion => ({
            emotion: emotion,
            count: emotionGroups[emotion].length
        })).sort((a, b) => a.count - b.count); // Sort ascending (fewest conversations first = top of pyramid)
        
        console.log(`🔺 PYRAMID SORTING: Sorted ${emotionWithCounts.length} emotions by conversation count:`, 
                   emotionWithCounts.map(e => `${e.emotion}: ${e.count}`));
        
        // GROUP BY CONVERSATION COUNT: Stack emotions with same count vertically
        const emotionCountGroups = {};
        emotionWithCounts.forEach(emotionData => {
            const count = emotionData.count;
            if (!emotionCountGroups[count]) {
                emotionCountGroups[count] = [];
            }
            emotionCountGroups[count].push(emotionData);
        });
        
        const conversationCounts = Object.keys(emotionCountGroups).map(Number).sort((a, b) => a - b); // Sort counts ascending
        console.log(`🔺 GROUPED BY COUNT: ${conversationCounts.length} different conversation counts:`, conversationCounts);
        
        // Generate cluster configs with baseline alignment like timeline
        const clusterConfigs = [];
        
        // BASELINE CALCULATION: Position emotions at the top for immediate visibility (no scrolling needed)
        const topMargin = 30; // Reduced header space for better visibility
        const bottomMargin = 60; // Reduced bottom space
        const availableVerticalSpace = Math.max(400, containerHeight - topMargin - bottomMargin);
        
        // Position emotions at the very top (just below header) for immediate visibility
        const emotionsBaselinePercent = 0; // Start emotions immediately at top (0% down from top)
        const baselineY = topMargin; // Start right after header, no additional offset
        
        let currentY = baselineY; // Start from the timeline baseline
        const lineHeight = timelineSquareSize + emotionGap; // Dynamic size + 2px gap between emotion rows
        const centerLeft = 50; // Center everything horizontally
        
        console.log(`📐 EMOTION BASELINE: Positioned at ${baselineY}px (${emotionsBaselinePercent}% of ${availableVerticalSpace}px available space)`);
        console.log(`📏 Available space: ${availableVerticalSpace}px, Top margin: ${topMargin}px, Container: ${containerWidth}x${containerHeight}px`);
        
        conversationCounts.forEach(count => {
            const emotionsWithThisCount = emotionCountGroups[count];
            console.log(`🔺 Processing ${emotionsWithThisCount.length} emotions with ${count} conversations each`);
            
            emotionsWithThisCount.forEach((emotionData, stackIndex) => {
                clusterConfigs.push({
                    position: { 
                        top: currentY + (stackIndex * lineHeight), // Stack vertically with pixel positioning
                        left: centerLeft // Center all emotions at 50%
                    },
                    gridType: 'pyramid',
                    emotionData: emotionData,
                    conversationCount: count,
                    stackIndex: stackIndex
                });
                console.log(`  📍 ${emotionData.emotion} (${count} conversations) stacked at position ${stackIndex} - ${currentY + (stackIndex * lineHeight)}px, 50%`);
            });
            
            // Move to next group with 2px spacing
            currentY += (emotionsWithThisCount.length * lineHeight) + emotionGap; // 2px gap between groups
        });
        
        console.log(`🔺 VERTICAL PYRAMID COMPLETE: Created ${clusterConfigs.length} stacked positions`);
        
        // Find neutral emotion position for label alignment
        let neutralLabelX = null;
        
        // ALIGN ALL LABELS TO THE RIGHT SIDE OF SCREEN
        const labelWidth = 150;
        const rightMargin = 20; // 20px margin from right edge
        neutralLabelX = containerWidth - labelWidth - rightMargin;
        console.log(`🎯 RIGHT ALIGNMENT: All emotion labels positioned at ${neutralLabelX}px (right-aligned with ${rightMargin}px margin)`)
        
        // PYRAMID POSITIONING: Process emotions in sorted order (fewest to most conversations)
        emotionWithCounts.forEach((emotionData, index) => {
            const emotion = emotionData.emotion;
            const conversations = emotionGroups[emotion];
            const conversationCount = conversations.length;
            
            if (conversationCount === 0 || index >= clusterConfigs.length) return;
            
            // Get the specific cluster configuration for this emotion's stacked pyramid position
            const config = clusterConfigs[index];
            console.log(`🔺 Stacked emotion "${emotion}" (${conversationCount} conversations) at ${config.position.top}%, centered at ${config.position.left}%`);
            
            // Calculate cluster position in pixels (all use left positioning now)
            const clusterX = containerWidth * config.position.left / 100;
            const clusterY = config.position.top; // Use pixel positioning directly
            console.log(`📍 Emotion "${emotion}" calculated position: (${clusterX.toFixed(2)}, ${clusterY.toFixed(2)}) from container ${containerWidth}x${containerHeight}`);
            
            // PYRAMID HORIZONTAL LINES: Each emotion is displayed as a single horizontal line
            const cols = conversationCount; // ALL conversations in a single horizontal line
            const rows = 1; // Always single row (horizontal line)
            const squareSize = 80; // Fixed size for emotions people view (independent of people layout)
            const minGap = 2; // 4px gap between conversations for emotions view
            const spacing = squareSize + minGap; // Total spacing (dynamic size + 2px gap)
            const titleHeight = 20; // Compact space for emotion title
            const titleGap = 5; // Small gap between line and title
            const gridHeight = rows * spacing; // Calculate total line height (always single row height)
             
            console.log(`🎯 Emotion "${emotion}" positioning: baseline=${currentY}px, conversations=${conversationCount}, line width will be ${conversationCount * spacing}px`);
             
            console.log(`🔺 Emotion "${emotion}": Creating horizontal line with ${cols} conversations (${conversationCount} total)`);
             
            switch(config.gridType) {
                case 'pyramid':
                default:
                    // Pyramid layout: Each emotion is a horizontal line of conversation squares
                    // cols = conversationCount, rows = 1 (always horizontal line)
                    break;
            }
            
            // Position conversations in Tetris-like grid
            // Position conversation line on the left side, leaving space for right-aligned labels
            // Leave enough space for emotion labels on the right side
            const labelGap = 30; // Gap between conversations and labels
            const labelSpace = labelWidth + 20; // Space needed for labels (width + margin)
            const maxLineWidth = containerWidth - labelSpace - labelGap; // Leave space for labels on right
            const actualSpacing = Math.max(squareSize + minGap, Math.min(spacing, maxLineWidth / conversationCount)); // Use 4px gap as requested
            const totalLineWidth = conversationCount * actualSpacing;
            const startX = Math.max(50, (maxLineWidth - totalLineWidth) / 2); // Position conversations on left side, centered in available space
             
            console.log(`🔺 Line width: ${conversationCount} conversations × ${actualSpacing.toFixed(1)}px = ${totalLineWidth.toFixed(1)}px (max: ${maxLineWidth.toFixed(1)}px)`);
            console.log(`   Spacing details: squareSize=${squareSize}px, minGap=${minGap}px, actualSpacing=${actualSpacing.toFixed(1)}px`);
            
            conversations.forEach((convFolder, index) => {
                const col = index; // All conversations in a single row (horizontal line)
                const row = 0; // Always row 0 (single horizontal line)
                
                const x = startX + (col * actualSpacing); // Horizontal positioning for the line
                const y = clusterY; // Single row at the pyramid position
                
                positions[convFolder] = {
                    left: x,
                    top: y,
                    width: timelineSquareSize,
                    height: timelineSquareSize,
                    emotionGroup: emotion,
                    gridConfig: config,
                    isEmotionCluster: true,
                    clusterPosition: { x: clusterX, y: clusterY },
                    gridPosition: { row, col },
                    isHorizontalLine: true,
                    lineLength: conversationCount
                };
                
                console.log(`  📦 Conversation ${index + 1}/${conversationCount} at (${Math.round(x)}, ${Math.round(y)})`);
            });
             
            // Store emotion label for rendering - position near conversations in staggered "stairs" style
            const hebrewEmotion = window.EMOTION_HEBREW_MAP[emotion] || emotion;
             
            // Calculate staggered position for "stairs" effect
            const conversationCenterY = clusterY + (timelineSquareSize / 2); // Vertical center of the conversation line
            
            // Position label near the conversations with consistent spacing (no stairs effect)
            const staggerOffset = 0; // Remove stairs effect - consistent spacing for all labels
            const labelLeftX = startX + totalLineWidth + 15; // Position after conversations with 15px gap (no stagger)
             
            positions[`emotion_label_${emotion}`] = {
                left: labelLeftX, // Position near conversations with consistent spacing
                top: conversationCenterY - (titleHeight / 2), // Center vertically with conversations
                width: labelWidth, // Use consistent label width
                height: titleHeight,
                isEmotionLabel: true,
                emotion: emotion,
                hebrewEmotion: hebrewEmotion,
                count: conversationCount,
                clusterConfig: config,
                isHorizontalLine: true,
                isRightAligned: true // New flag for right alignment
            };
             
            console.log(`🏷️ Label for "${emotion}" positioned with consistent spacing at (${Math.round(labelLeftX)}, ${Math.round(conversationCenterY - (titleHeight / 2))}px)`);
        });
        
        console.log(`🎭 Baseline-Aligned Emotions Layout: ${emotionCount} emotion clusters created with ${Object.keys(positions).length - emotionCount} conversations`);
        console.log(`📐 BASELINE SUMMARY: All emotions positioned higher at ${baselineY}px (${emotionsBaselinePercent}% down from top)`);
        
        // Store metadata for rendering and transitions
        positions._meta = { 
            layout: 'tetris-emotions',
            emotionGroups,
            clusterConfigs,
            itemSize: timelineSquareSize,
            containerWidth,
            containerHeight,
            totalEmotions: emotionCount,
            totalConversations: conversations.length,
            // BASELINE METADATA: Emotions positioned higher for better visibility
            emotionsBaselinePercent: emotionsBaselinePercent,
            baselineY: baselineY,
            bottomMargin: bottomMargin,
            topMargin: topMargin,
            availableVerticalSpace: availableVerticalSpace,
            isEmotionsHighAligned: true
        };
        
        return positions;
    }

    // --- Core Rendering and State Management ---
    let layoutRenderTimeout;
    let isLayoutRendering = false;
    
            window.renderNewLayout = function(isInitial = false) {
        console.log(`📅 DEBUG: renderNewLayout called, activeLayout = ${window.activeLayout}, isInitial = ${isInitial}`);
        
        // Ensure we have a default layout if none is set
        if (!window.activeLayout) {
            console.log(`🔄 Setting default timeline layout`);
            window.activeLayout = 'timeline';
        }
        
        // Prevent multiple simultaneous renders
        if (window.isLayoutRendering) {
            console.log('⚠️ Layout render already in progress, skipping...');
            return;
        }
        
        // Improved debouncing with shorter timeout for better responsiveness
        clearTimeout(window.layoutRenderTimeout);
        window.layoutRenderTimeout = setTimeout(() => {
            window.isLayoutRendering = true;
            
            const gridContainer = document.getElementById('timeline-axes-container');
            const layoutCanvas = document.getElementById('layout-canvas');
            if (!gridContainer || !layoutCanvas) {
                isLayoutRendering = false;
                return;
            }
            
            // STATIC BACKGROUND GRID: Ensure it exists before any layout operations
            ensureStaticBackgroundGrid();
            
            const conversations = window.originalConversationData || [];
            
            // If no conversations data is available, don't proceed with layout
            if (!conversations || conversations.length === 0) {
                console.log('❌ No conversations data available for layout rendering');
                window.isLayoutRendering = false;
                return;
            }
            
            // ISOTOPE ANIMATION: Capture current positions before layout change
            const currentPositions = {};
            conversations.forEach((conv) => {
                const itemCell = document.getElementById(`conv-item-${conv.folder}`);
                if (itemCell) {
                    const rect = itemCell.getBoundingClientRect();
                    const canvasRect = layoutCanvas.getBoundingClientRect();
                    currentPositions[conv.folder] = {
                        left: rect.left - canvasRect.left,
                        top: rect.top - canvasRect.top,
                        width: rect.width,
                        height: rect.height
                    };
                    console.log(`📸 Captured ${conv.folder} at (${Math.round(currentPositions[conv.folder].left)}, ${Math.round(currentPositions[conv.folder].top)})`);
                }
            });
            
            // CRITICAL: Clear all previous CSS classes and styles first
            layoutCanvas.className = '';
            gridContainer.className = '';
            
            // Force reflow to clear previous styles
            layoutCanvas.offsetHeight;
            gridContainer.offsetHeight;
            
            // Apply new CSS classes AFTER clearing previous ones
            gridContainer.className = 'layout-' + window.activeLayout;
            
            // Force immediate reflow to ensure CSS classes are applied
            gridContainer.offsetHeight;
            
            console.log(`🧹 Cleared previous CSS, applied new layout class: ${gridContainer.className}`);
            
            // Add isotope-switching class for transition effects
            if (!isInitial && Object.keys(currentPositions).length > 0) {
                gridContainer.classList.add('isotope-switching');
                console.log('🎬 Added isotope-switching class for smooth transitions');
                
                // Remove isotope-switching class after animations complete
                setTimeout(() => {
                    gridContainer.classList.remove('isotope-switching');
                    console.log('✅ Removed isotope-switching class - transitions complete');
                }, 800); // After all animations should be done
            }
            
            // TIMELINE VIEW: Use cached positions if available, otherwise calculate fresh
            if (window.activeLayout === 'timeline') {
                console.log('🔄 TIMELINE VIEW: Checking for cached positions');
                console.log(`📅 DEBUG: In timeline branch, conversations.length = ${conversations.length}`);
                
                // Check if we have valid cached timeline positions
                const hasCachedTimeline = layoutPositions.timeline && 
                                        Object.keys(layoutPositions.timeline).length > 0 &&
                                        conversations.every(conv => layoutPositions.timeline[conv.folder]);
                
                if (hasCachedTimeline) {
                    console.log('✅ USING CACHED TIMELINE POSITIONS - No recalculation needed');
                    targetPositions = layoutPositions.timeline;
                    
                    // Apply cached positions immediately
                    conversations.forEach((conv) => {
                        const cachedPos = layoutPositions.timeline[conv.folder];
                        if (cachedPos) {
                            const itemCell = document.getElementById(`conv-item-${conv.folder}`);
                            if (itemCell) {
                                itemCell.style.transition = 'none';
                                itemCell.style.position = 'absolute';
                                itemCell.style.left = `${cachedPos.left}px`;
                                itemCell.style.top = `${cachedPos.top}px`;
                                itemCell.style.width = `${cachedPos.width}px`;
                                itemCell.style.height = `${cachedPos.height}px`;
                                itemCell.offsetHeight; // Force reflow
                                itemCell.style.transition = ''; // Re-enable transitions
                                console.log(`📍 Applied cached position for ${conv.folder}: (${cachedPos.left}, ${cachedPos.top})`);
                            }
                        }
                    });
                    
                    // CRITICAL: Always recreate date labels to ensure proper positioning
                    console.log('📅 DEBUG: Using cached positions - recreating date labels for proper alignment');
                    const existingLabels = document.querySelectorAll('.timeline-date-label-protected');
                    
                    // Always remove existing labels and recreate them
                    const existingDebugElements = document.querySelectorAll('.debug-center-dot, .debug-column-center');
                    existingLabels.forEach(label => label.remove());
                    existingDebugElements.forEach(el => el.remove());
                    console.log(`📅 FORCE CLEANUP: Removed ${existingLabels.length} existing timeline date labels and ${existingDebugElements.length} debug elements for fresh positioning`);
                    
                    if (targetPositions._dateLabels) {
                        console.log('📅 DEBUG: No existing labels found, recreating from cached data');
                        console.log(`📅 DOM RENDERING: Starting date label rendering for ${targetPositions._dateLabels.length} cached labels`);
                        
                        // Clear any existing timeline date labels first
                        const oldLabels = document.querySelectorAll('.timeline-date-label-protected');
                        oldLabels.forEach(label => label.remove());
                        console.log(`📅 CLEANUP: Removed ${oldLabels.length} existing timeline date labels`);
                        
                        // Recreate labels from cached data
                        targetPositions._dateLabels.forEach((labelData, index) => {
                            const labelElement = document.createElement('div');
                            labelElement.className = 'timeline-date-label-protected';
                            labelElement.setAttribute('data-timeline-date', 'true');
                            
                            // Simple date text only - no conversation count
                            labelElement.textContent = labelData.name;
                           
                            // Perfect center alignment using CSS transform
                            labelElement.style.cssText = `
                                position: absolute;
                                left: ${labelData.x}px;
                                top: ${labelData.y}px;
                                transform: translate(-50%, -50%) !important;
                                z-index: 2;
                                font-family: var(--main-font-family);
                                font-size: 14px;
                                font-weight: normal;
                                color: #333;
                                text-align: center !important;
                                width: ${labelData.width}px;
                                height: ${labelData.height}px;
                                line-height: ${labelData.height}px !important;
                                background: none !important;
                                border: none !important;
                                box-shadow: none !important;
                                padding: 0 !important;
                                margin: 0 !important;
                                direction: ltr !important;
                                box-sizing: border-box !important;
                                white-space: nowrap !important;
                                overflow: visible !important;
                            `;
                            
                            console.log(`📅 Created cached date label "${labelData.name}" at position (${labelData.x}, ${labelData.y})`);
                            
                            // Add to layout-canvas to ensure proper positioning relative to conversations
                            const layoutCanvas = document.getElementById('layout-canvas');
                            if (layoutCanvas) {
                                layoutCanvas.appendChild(labelElement);
                            } else {
                                document.body.appendChild(labelElement);
                            }
                        });
                        console.log(`📅 ✅ Successfully rendered ${targetPositions._dateLabels.length} date labels from cache`);
                    } else {
                        console.log(`📅 WARNING: No _dateLabels found in cached positions`);
                    }
                } else {
                    console.log('🆕 CALCULATING FRESH TIMELINE POSITIONS - First time or cache invalid');
                    console.log(`📅 DEBUG: About to call getTimelineLayoutPositions with ${conversations.length} conversations`);
                    layoutPositions.timeline = getTimelineLayoutPositions(conversations, gridContainer);
                    targetPositions = layoutPositions.timeline;
                    console.log('✅ Fresh timeline positions calculated and cached');
                    console.log(`📅 DEBUG: Timeline positions result:`, layoutPositions.timeline);
                }
            } else {
                // For non-timeline views, always calculate fresh
                console.log(`🔄 Calculating fresh positions for ${window.activeLayout} view`);
                // Calculate initial positions for all views (only once for timeline)
                if (!layoutPositions.timeline || Object.keys(layoutPositions.timeline).length === 0) {
                    console.log('🆕 INITIAL: Calculating timeline positions for first time');
                    layoutPositions.timeline = getTimelineLayoutPositions(conversations, gridContainer);
                }
                
                // Calculate positions specific to the active layout
                if (window.activeLayout === 'people') {
                    console.log('👥 CALCULATING SIMPLIFIED PEOPLE VIEW positions');
                    layoutPositions.people = getPeopleViewPositions(conversations, gridContainer);
                } else if (window.activeLayout === 'emotions') {
                    console.log('🎭 FORCE REFRESH: Recalculating emotions view positions');
                    layoutPositions.emotions = getEmotionsViewPositions(conversations, gridContainer);
                }
                targetPositions = layoutPositions[window.activeLayout];
            }
            
            // CRITICAL: Ensure people view positioning is used when people layout is active
            if (window.activeLayout === 'people') {
                console.log(`👥 ENFORCING PEOPLE VIEW POSITIONS`);
                console.log(`📊 People view positions available:`, Object.keys(layoutPositions.people || {}).length);
                
                // Force people view positions even if they might be empty
                if (!targetPositions || Object.keys(targetPositions).length === 0) {
                    console.warn(`⚠️ People view positions empty, recalculating...`);
                    layoutPositions.people = getPeopleViewPositions(conversations, gridContainer);
                    targetPositions = layoutPositions.people;
                }
                
                // Verify people view positions are actually being used
                if (targetPositions && Object.keys(targetPositions).length > 0) {
                    console.log(`✅ Using people view positions: ${Object.keys(targetPositions).length} conversations`);
                } else {
                    console.error(`❌ People view positions failed, falling back to timeline`);
                    targetPositions = layoutPositions.timeline;
                }
            }
            
            // Set layout canvas class based on active layout
            if (window.activeLayout === 'emotions') {
                layoutCanvas.className = ''; // Clear canvas class to prevent double grid effects
                
                // COMPREHENSIVE BODY CLASS MANAGEMENT: Clear all layout classes first
                document.body.classList.remove('layout-timeline', 'layout-people', 'layout-emotions');
                document.body.className = 'layout-emotions';
                console.log('🏗️ Set body class to layout-emotions');
                
                // FORCE CLEAR EMOTIONS CACHE: Clear any cached emotions positions to force fresh calculation
                if (window.layoutPositions && window.layoutPositions.emotions) {
                    console.log('🗑️ Clearing cached emotions positions to force refresh');
                    window.layoutPositions.emotions = {};
                }
                
                // SET EMOTIONS VIEW SQUARE SIZE - MATCH LAYOUT CALCULATION
                const emotionsSquareSize = 80; // Match timelineSquareSize from layout calculation (80px)
                document.documentElement.style.setProperty('--timeline-square-size', `${emotionsSquareSize}px`);
                document.documentElement.style.setProperty('--timeline-item-size', `${emotionsSquareSize}px`);
                document.documentElement.style.setProperty('--people-square-size', `${emotionsSquareSize}px`);
                document.documentElement.style.setProperty('--visual-conversation-size', `${emotionsSquareSize}px`);
                console.log(`📐 Set emotions view square size to ${emotionsSquareSize}px (matches layout calculation)`);
            } else if (window.activeLayout === 'people') {
                // CRITICAL: Set both canvas class AND body class for people view
                layoutCanvas.className = 'people-active';
                
                // COMPREHENSIVE BODY CLASS MANAGEMENT: Clear all layout classes first
                document.body.classList.remove('layout-timeline', 'layout-people', 'layout-emotions');
                document.body.className = 'layout-people';
                console.log('🏗️ Set body class to layout-people');
                
                // ULTRA-AGGRESSIVE canvas height fixing for people view
                layoutCanvas.style.removeProperty('height');
                layoutCanvas.style.removeProperty('max-height');  
                layoutCanvas.style.removeProperty('min-height');
                layoutCanvas.style.setProperty('height', 'calc(100vh - 120px)', 'important');
                layoutCanvas.style.setProperty('min-height', '800px', 'important');
                layoutCanvas.style.setProperty('max-height', 'none', 'important');
                layoutCanvas.style.setProperty('overflow', 'hidden', 'important');
                
                // Force multiple reflows to ensure height sticks
                layoutCanvas.offsetHeight;
                layoutCanvas.offsetHeight;
                
                console.log(`🔧 PEOPLE VIEW: Ultra-aggressive canvas height fix applied`);
                console.log(`🔧 Canvas dimensions: ${layoutCanvas.offsetWidth}x${layoutCanvas.offsetHeight}`);
                
                // SET PEOPLE VIEW SQUARE SIZE - ORIGINAL SIZE TO FIT ALL ON SCREEN
                const peopleSquareSize = 60; // Original size so all conversations fit without scrolling
                document.documentElement.style.setProperty('--people-square-size', `${peopleSquareSize}px`);
                console.log(`📐 Set people view square size to ${peopleSquareSize}px (original compact size)`);
                
                            // CRITICAL FIX: For People view, recalculate positions AFTER CSS classes are applied
            // This ensures the container has the correct dimensions from the CSS
            setTimeout(async () => {
                if (window.activeLayout === 'people') {
                    console.log('🔄 Recalculating People view positions after CSS application');
                    
                    // Force another reflow
                    gridContainer.offsetHeight;
                    
                    // SET PEOPLE VIEW SQUARE SIZE - ORIGINAL SIZE TO FIT ALL ON SCREEN
                    const peopleSquareSize = 60; // Original size so all conversations fit without scrolling
                    document.documentElement.style.setProperty('--people-square-size', `${peopleSquareSize}px`);
                    console.log(`📐 Set people view square size to ${peopleSquareSize}px (original compact size - recalc)`);
                    
                    // Force CSS variables to apply immediately
                    console.log(`📐 Force set --people-square-size to ${peopleSquareSize}px for consistency`);
                    
                                                // Recalculate positions with the correct container dimensions
                            const updatedPositions = getPeopleViewPositions(conversations, gridContainer);
                            if (Object.keys(updatedPositions).length > 0) {
                                targetPositions = updatedPositions;
                                layoutPositions.people = updatedPositions;
                            
                            // Re-apply positions to existing elements
                            conversations.forEach((conv) => {
                                const pos = targetPositions[conv.folder];
                                if (pos) {
                                    const itemCell = document.getElementById(`conv-item-${conv.folder}`);
                                    if (itemCell) {
                                        itemCell.style.left = `${pos.left}px`;
                                        itemCell.style.top = `${pos.top}px`;
                                        itemCell.style.width = `${pos.width}px`;
                                        itemCell.style.height = `${pos.height}px`;
                                        console.log(`🔄 Updated ${conv.folder} position: (${Math.round(pos.left)}, ${Math.round(pos.top)})`);
                                    }
                                }
                            });
                            
                            // Clean up existing labels for all views
                            const existingPersonLabels = layoutCanvas.querySelectorAll('.person-name-label');
                            const existingDateLabels = layoutCanvas.querySelectorAll('.timeline-date-label, .timeline-date-label-immediate');
                            const existingBodyDateLabels = document.querySelectorAll('.timeline-date-label-protected'); // Check body for protected labels
                            const existingDebugMsg = layoutCanvas.querySelector('.people-debug-message');
                            const existingTestMsg = layoutCanvas.querySelector('.people-test-indicator');
                            existingPersonLabels.forEach(label => label.remove());
                            existingDateLabels.forEach(label => label.remove());
                            // Only clean up timeline labels if NOT in timeline view
                            if (window.activeLayout !== 'timeline') {
                                existingBodyDateLabels.forEach(label => label.remove()); // Clean up timeline labels
                                console.log(`📅 CLEANUP: Removed ${existingBodyDateLabels.length} timeline date labels from cleanup logic`);
                            }
                            if (existingDebugMsg) existingDebugMsg.remove();
                            if (existingTestMsg) existingTestMsg.remove();

                            // NEW PEOPLE VIEW: Render all elements for the new structure
                            if (window.activeLayout === 'people' && targetPositions) {
                                console.log(`👥 NEW PEOPLE VIEW: Rendering early elements`);
                                
                                // Render header
                                if (targetPositions._header) {
                                    const header = targetPositions._header;
                                    const headerElement = document.createElement('div');
                                    headerElement.className = 'people-view-header';
                                    headerElement.textContent = header.text;
                                    headerElement.style.cssText = `
                                        position: absolute;
                                        left: ${header.left}px;
                                        top: ${header.top}px;
                                        width: ${header.width}px;
                                        height: ${header.height}px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        font-family: '80k', 'Arial', sans-serif;
                                        font-size: 20px;
                                        font-weight: bold;
                                        color: #333;
                                        text-align: center;
                                        direction: rtl;
                                        z-index: 3;
                                        border-bottom: 2px solid #e0e0e0;
                                    `;
                                    layoutCanvas.appendChild(headerElement);
                                }
                                
                                // Render person names from _personNames structure
                                const personNameData = targetPositions._personNames || [];
                                console.log(`👥 Rendering ${personNameData.length} people name labels`);
                                
                                personNameData.forEach(nameData => {
                                    const labelElement = document.createElement('div');
                                    labelElement.className = 'person-name-label';
                                    
                                    // Create inner div with padding for the name
                                    const nameDiv = document.createElement('div');
                                    nameDiv.className = 'person-name-content';
                                    nameDiv.textContent = nameData.name;
                                    nameDiv.style.cssText = `
                                        padding: 0 8px !important;
                                        text-align: right !important;
                                        direction: rtl !important;
                                        width: 100% !important;
                                        box-sizing: border-box !important;
                                    `;
                                    
                                    labelElement.appendChild(nameDiv);
                                    labelElement.style.cssText = `
                                        position: absolute !important;
                                        left: ${nameData.x}px !important;
                                        top: ${nameData.y}px !important;
                                        width: ${nameData.width}px !important;
                                        height: ${nameData.height}px !important;
                                        z-index: 5 !important;
                                        display: flex !important;
                                        align-items: center !important;
                                    `;
                                    
                                    layoutCanvas.appendChild(labelElement);
                                    console.log(`👤 Added padded label for ${nameData.name} at (${nameData.x}, ${nameData.y})`);
                                });
                             }
                             
                             // Date labels are now rendered directly in the timeline layout function
                             
                             // Show debug message if people view is active but no data
                             if (targetPositions._debugMessage && window.activeLayout === 'people') {
                                 const debugMsg = targetPositions._debugMessage;
                                 const debugElement = document.createElement('div');
                                 debugElement.className = 'people-debug-message';
                                 debugElement.innerHTML = `
                                     <div style="text-align: center; color: #666; font-family: '80k', sans-serif;">
                                         <h3>תצוגת אנשים פעילה</h3>
                                         <p>לא נמצאו שיחות תואמות לאנשים</p>
                                         <p style="font-size: 12px;">בדוק בקונסול לפרטים נוספים</p>
                                     </div>
                                 `;
                                 debugElement.style.cssText = `
                                     position: absolute;
                                     left: ${debugMsg.left}px;
                                     top: ${debugMsg.top}px;
                                     width: ${debugMsg.width}px;
                                     height: ${debugMsg.height}px;
                                     background: rgba(255, 255, 255, 0.9);
                                     border: 2px solid #667eea;
                                     border-radius: 12px;
                                     display: flex;
                                     align-items: center;
                                     justify-content: center;
                                     z-index: 10;
                                 `;
                                 layoutCanvas.appendChild(debugElement);
                             }
                             
                             // Show test indicator - should ALWAYS appear in people view
                             if (targetPositions._testIndicator && window.activeLayout === 'people') {
                                 const testMsg = targetPositions._testIndicator;
                                 const testElement = document.createElement('div');
                                 testElement.className = 'people-test-indicator';
                                 testElement.innerHTML = `
                                     <div style="
                                         background: rgba(40, 167, 69, 0.95);
                                         color: white;
                                         padding: 12px;
                                         border-radius: 8px;
                                         text-align: center;
                                         font-size: 13px;
                                         border: 2px solid #28a745;
                                         font-weight: bold;
                                     ">
                                         ${testMsg.message || 'TEST MESSAGE'}
                                     </div>
                                 `;
                                 testElement.style.cssText = `
                                     position: absolute;
                                     left: ${testMsg.left}px;
                                     top: ${testMsg.top}px;
                                     width: ${testMsg.width}px;
                                     height: ${testMsg.height}px;
                                     z-index: 1001;
                                     pointer-events: none;
                                 `;
                                 layoutCanvas.appendChild(testElement);
                                 console.log(`🔧 Added people view test indicator at (${testMsg.left}, ${testMsg.top})`);
                             }
                        }
                    }
                }, 50); // Small delay to ensure CSS has fully applied
            } else {
                layoutCanvas.className = '';
                
                // COMPREHENSIVE BODY CLASS MANAGEMENT: Always clear and set proper class
                // Clear all layout-specific body classes first
                document.body.classList.remove('layout-timeline', 'layout-people', 'layout-emotions');
                
                // Set proper body class for current layout
                if (window.activeLayout === 'timeline') {
                    document.body.className = 'layout-timeline';
                    console.log('🏗️ Set body class to layout-timeline');
                } else {
                    document.body.className = '';
                    console.log('🏗️ Cleared body class for non-timeline view');
                }
                
                // CRITICAL FIX: For Timeline view, ensure CSS variables are set
                if (window.activeLayout === 'timeline') {
                    const timelineSquareSize = getTimelineSquareSize(conversations, gridContainer);
                    document.documentElement.style.setProperty('--timeline-square-size', `${timelineSquareSize}px`);
                    console.log(`📐 Set --timeline-square-size to ${timelineSquareSize}px for Timeline view`);
                    
                    // Timeline view uses cached positions - no recalculation needed
                    if (window.activeLayout === 'timeline') {
                        console.log('✅ Timeline view: Using cached positions, no recalculation needed');
                    }
                }
            }
        
        // Update wrapper background for people view - Remove redundant class application
        const timelineWrapper = document.getElementById('timeline-grid-wrapper');
        if (timelineWrapper) {
            // Only set class on main container, not wrapper to prevent double CSS application
            timelineWrapper.className = ''; // Clear class to prevent conflicts
        }
        
        console.log(`🏗️ Layout updated: gridContainer="${gridContainer.className}", canvas="${layoutCanvas.className}", wrapper="${timelineWrapper?.className}"`);
        // Remove old people view elements, timeline elements, and emotion circle labels
        Array.from(layoutCanvas.querySelectorAll('.people-view-header, .people-view-row-item, .person-header, .vertical-line, .people-row-separator, .person-name-label, .timeline-baseline, .timeline-date-separator, .timeline-date-label, .timeline-date-label-immediate, .emotion-circle-label, .emotion-circle-background, .emotion-inner-circle, .emotion-count-badge, .people-debug-message, .people-test-indicator')).forEach(el => el.remove());
        
        // Clean up timeline date labels only when switching away from timeline view
        if (window.activeLayout !== 'timeline') {
            Array.from(document.querySelectorAll('.timeline-date-label-protected')).forEach(el => el.remove());
            console.log(`📅 CLEANUP: Removed timeline date labels (not in timeline view)`);
        }

        // Static elements will be created inside setTimeout where metaData is available
        setTimeout(() => {
            // Keep meta data for debugging, will be cleaned up later
            const metaData = targetPositions._meta;
            if (targetPositions._meta) delete targetPositions._meta;
            

            
            // Debug: Log positions for people view
            if (window.activeLayout === 'people') {
                console.log('🎯 People view positions:', targetPositions);
                console.log('📐 Container dimensions:', gridContainer.clientWidth, 'x', gridContainer.clientHeight);
                console.log('👥 Groups:', metaData?.peopleGroups);
                console.log('🏷️ Person labels:', metaData?.personLabels?.length);
                console.log('🔍 Layout canvas dimensions:', layoutCanvas.clientWidth, 'x', layoutCanvas.clientHeight);
                console.log('🔍 Layout canvas position:', layoutCanvas.getBoundingClientRect());
            }
            
            const hoverPanel = document.getElementById('hover-info-panel');
            let hideTimeout;



            // Clear canvas and use ABSOLUTE POSITIONING for ALL layouts
            // NO BACKGROUND ELEMENTS: Body handles all background - clear everything
            if (!layoutCanvas) {
                console.error('❌ Layout canvas not found!');
                return;
            }
            console.log(`🎯 Layout canvas found:`, layoutCanvas);
            // CREATE OR REUSE TIMELINE CONTAINER DIV: Check before clearing to preserve animations
            let timelineContainer = null;
            if (window.activeLayout === 'timeline') {
                // Try to reuse existing timeline container to preserve isotope animations
                timelineContainer = document.getElementById('timeline-conversations-container');
                
                if (!timelineContainer) {
                    // Preserve timeline date labels when clearing
                    const existingLabels = layoutCanvas.querySelectorAll('.timeline-date-label-protected');
                    const savedLabels = Array.from(existingLabels).map(label => label.cloneNode(true));
                    
                    // Clear existing content and create new container
                    layoutCanvas.innerHTML = '';
                    
                    // Restore timeline date labels
                    savedLabels.forEach(label => layoutCanvas.appendChild(label));
                    
                    timelineContainer = document.createElement('div');
                    timelineContainer.id = 'timeline-conversations-container';
                    timelineContainer.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        overflow: visible;
                        z-index: 2;
                    `;
                    layoutCanvas.appendChild(timelineContainer);
                    console.log(`📦 Created new timeline container div for isotope animations`);
                } else {
                    // Keep existing container but clear conversation items only for regeneration
                    const existingItems = timelineContainer.querySelectorAll('.conversation-grid-item-container');
                    console.log(`🔄 Reusing existing timeline container, found ${existingItems.length} existing items`);
                }
            } else {
                // Clear existing content for non-timeline views
                layoutCanvas.innerHTML = '';
            }
            
            // ENSURE STATIC BACKGROUND GRID: Verify body background is set
            ensureStaticBackgroundGrid();
            
            // People view: use taller height to accommodate all conversations without overlapping
            if (window.activeLayout === 'people') {
                layoutCanvas.style.height = 'calc(100vh - 120px)';
                layoutCanvas.style.minHeight = '800px';
                layoutCanvas.style.overflowY = 'auto';
                layoutCanvas.style.overflow = 'auto';
                
                // FORCE PROPER DIMENSIONS: Sometimes CSS conflicts cause issues
                layoutCanvas.style.width = '100%';
                layoutCanvas.style.position = 'fixed';
                layoutCanvas.style.top = '60px';
                layoutCanvas.style.left = '0';
                layoutCanvas.style.right = '0';
                layoutCanvas.style.bottom = '60px';
                
                console.log(`📐 People view: set proper height for scrollable content`);
                console.log(`🔍 PEOPLE VIEW Canvas dimensions after setting:`, layoutCanvas.getBoundingClientRect());
                console.log(`🔍 PEOPLE VIEW Canvas computed styles:`, window.getComputedStyle(layoutCanvas).height, window.getComputedStyle(layoutCanvas).width);
            } else {
                layoutCanvas.style.height = 'calc(100vh - 120px)';
                layoutCanvas.style.overflowY = 'hidden';
            }
            
            // ISOTOPE ANIMATION: Universal layout for all views with smooth transitions
            console.log(`🎬 Creating ${conversations.length} conversation elements...`);
            console.log(`🎯 Target positions:`, targetPositions);
            
            // EMERGENCY FALLBACK: If no target positions, create simple grid positions
            if (!targetPositions || Object.keys(targetPositions).length === 0) {
                console.warn('⚠️ No target positions available, creating emergency grid positions');
                targetPositions = {};
                conversations.forEach((conv, index) => {
                    const row = Math.floor(index / 4);
                    const col = index % 4;
                    const fallbackSize = 200;
                    const fallbackGap = 20;
                    targetPositions[conv.folder] = {
                        left: 50 + (col * (fallbackSize + fallbackGap)),
                        top: 50 + (row * (fallbackSize + fallbackGap)),
                        width: fallbackSize,
                        height: fallbackSize,
                        gridOrder: index
                    };
                });
            }
            
            conversations.forEach((conv, index) => {
                let pos = targetPositions[conv.folder];
                
                // PEOPLE VIEW: Skip conversations that aren't assigned to people
                if (window.activeLayout === 'people' && !pos) {
                    console.log(`👥 Skipping unassigned conversation ${conv.folder} in people view`);
                    // Hide the element if it exists
                    const existingElement = document.getElementById(`conv-item-${conv.folder}`);
                    if (existingElement) {
                        existingElement.style.display = 'none';
                    }
                    return; // Skip this conversation entirely
                }
                
                // For timeline view, ensure ALL conversations are shown with positioning
                if (!pos) {
                    console.warn(`❌ No position found for ${conv.folder}, using emergency position`);
                    // Create emergency position for this conversation with compact sizing
                    const row = Math.floor(index / 15); // More columns to fit more conversations
                    const col = index % 15;
                    const emergencyItemSize = 60; // Match compact timeline item size
                    const emergencyGap = 1; // Match minimal gap
                    pos = {
                        left: 50 + (col * (emergencyItemSize + emergencyGap)),
                        top: 150 + (row * (emergencyItemSize + emergencyGap)),
                        width: emergencyItemSize,
                        height: emergencyItemSize,
                        gridOrder: index,
                        isEmergencyPosition: true
                    };
                    console.log(`🚨 Emergency position created for ${conv.folder} at (${pos.left}, ${pos.top})`);
                }
                console.log(`✅ Creating conversation ${conv.folder} at position (${Math.round(pos.left)}, ${Math.round(pos.top)})`);
                let itemCell = document.getElementById(`conv-item-${conv.folder}`);
                if (!itemCell) {
                    // CREATE UNIFIED MP4 PREVIEW COMPONENT
                    console.log(`🎬 Creating MP4 preview component for ${conv.folder}...`);
                    itemCell = createMP4PreviewComponent(conv, index);
                    
                    // Append to timeline container if in timeline view, otherwise to layout canvas
                    if (window.activeLayout === 'timeline' && timelineContainer) {
                        timelineContainer.appendChild(itemCell);
                    } else {
                        layoutCanvas.appendChild(itemCell);
                    }
                    
                    console.log(`✅ Created unified MP4 preview component for ${conv.folder}`);
                } else {
                    console.log(`🔄 Reusing existing component for ${conv.folder}`);
                    // Ensure element is visible (in case it was hidden in people view)
                    itemCell.style.display = 'flex';
                }
                
                const currentPos = currentPositions[conv.folder];
                const isRepositioning = currentPos && !isInitial;
                
                // Apply SMOOTH ISOTOPE-STYLE POSITIONING with ENHANCED ANIMATIONS
                console.log(`🎬 ${isRepositioning ? 'Animating' : 'Positioning'} ${conv.folder} from (${currentPos ? Math.round(currentPos.left) : 'new'}, ${currentPos ? Math.round(currentPos.top) : 'new'}) to (${Math.round(pos.left)}, ${Math.round(pos.top)})`);
                
                // Set isotope-style CSS custom property for staggered animation
                itemCell.style.setProperty('--item-index', index);
                
                // Set absolute positioning
                itemCell.style.position = 'absolute';
                itemCell.style.order = index;
                itemCell.style.zIndex = '10'; // Higher z-index during animation
                itemCell.style.display = 'flex';
                itemCell.style.visibility = 'visible';
                
                // Handle timeline layout with isotope animations
                if (window.activeLayout === 'timeline') {
                    // TIMELINE WITH ISOTOPE: Use same animation system as other views
                    if (isRepositioning) {
                        // Animate from current position to new position with isotope effects
                        itemCell.style.transition = 'none';
                        itemCell.style.position = 'absolute';
                        itemCell.style.left = `${currentPos.left}px`;
                        itemCell.style.top = `${currentPos.top}px`;
                        itemCell.style.width = `${currentPos.width}px`;
                        itemCell.style.height = `${currentPos.height}px`;
                        itemCell.style.transform = 'scale(1)';
                        itemCell.style.opacity = '1';
                        
                        // Add isotope transition class for timeline
                        itemCell.classList.add('isotope-transitioning');
                        
                        // Force reflow
                        itemCell.offsetHeight;
                        
                        // Timeline isotope transitions
                        const delay = index * 0.03;
                        itemCell.style.transition = `
                            left 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            top 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            width 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            height 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            transform 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            opacity 0.3s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s
                        `;
                        
                        // Animate to new position with isotope effects
                        requestAnimationFrame(() => {
                            itemCell.style.left = `${pos.left}px`;
                            itemCell.style.top = `${pos.top}px`;
                            itemCell.style.width = `${pos.width}px`;
                            itemCell.style.height = `${pos.height}px`;
                            itemCell.style.transform = 'scale(1.05) rotateY(5deg)'; // Isotope effect
                            
                            // Final settle animation
                            setTimeout(() => {
                                if (itemCell.classList.contains('isotope-transitioning')) {
                                    itemCell.style.transform = 'scale(1) rotateY(0deg)';
                                    itemCell.style.zIndex = '10';
                                    
                                    // Remove transition class
                                    setTimeout(() => {
                                        itemCell.classList.remove('isotope-transitioning');
                                    }, 100);
                                }
                            }, (delay * 1000) + 800);
                        });
                        
                        console.log(`🎬 TIMELINE ISOTOPE: ${conv.folder} animating from (${Math.round(currentPos.left)}, ${Math.round(currentPos.top)}) to (${Math.round(pos.left)}, ${Math.round(pos.top)})`);
                    } else {
                        // Initial positioning for timeline (still with some animation)
                        itemCell.style.position = 'absolute';
                        itemCell.style.order = pos.gridOrder || index;
                        itemCell.style.flex = 'none';
                        itemCell.style.zIndex = '10';
                        
                        // Add entrance animation delay for staggered effect
                        const delay = index * 0.03;
                        itemCell.style.transition = `
                            left 0.6s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            top 0.6s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            width 0.6s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            height 0.6s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            transform 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s,
                            opacity 0.3s cubic-bezier(0.23, 1, 0.32, 1) ${delay}s
                        `;
                        
                        // Set positions with entrance animation
                        itemCell.style.left = `${pos.left}px`;
                        itemCell.style.top = `${pos.top}px`;
                        itemCell.style.width = `${pos.width}px`;
                        itemCell.style.height = `${pos.height}px`;
                        itemCell.style.opacity = '1';
                        itemCell.style.transform = 'scale(1)';
                        
                        console.log(`📅 TIMELINE ENTRANCE: ${conv.folder} positioned at X=${Math.round(pos.left)}, Y=${Math.round(pos.top)} with ${delay}s delay`);
                    }
                    
                } else if (isRepositioning) {
                    // ISOTOPE ANIMATION: Start from current position, animate to new position
                    
                    // Temporarily disable transitions to snap to current position
                    itemCell.style.transition = 'none';
                    itemCell.style.position = 'absolute';
                    itemCell.style.left = `${currentPos.left}px`;
                    itemCell.style.top = `${currentPos.top}px`;
                    itemCell.style.width = `${currentPos.width}px`;
                    itemCell.style.height = `${currentPos.height}px`;
                    itemCell.style.transform = 'scale(1)';
                    itemCell.style.opacity = '1';
                    
                    // Add isotope transition class
                    itemCell.classList.add('isotope-transitioning');
                    
                    // Force reflow
                    itemCell.offsetHeight;
                    
                    // OPTIMIZED: Fast, smooth transitions with minimal delay
                    const delay = index * 0.02; // Reduced staggered delay
                    itemCell.style.transition = `
                        left 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        top 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        width 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        height 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        opacity 0.3s ease-out ${delay}s
                    `;
                    
                    // OPTIMIZED: Smooth position and size transitions with simple animation
                    requestAnimationFrame(() => {
                        itemCell.style.left = `${pos.left}px`;
                        itemCell.style.top = `${pos.top}px`;
                        itemCell.style.width = `${pos.width}px`;
                        itemCell.style.height = `${pos.height}px`;
                        itemCell.style.transform = 'scale(1.01)'; // Subtle scale during animation
                        
                        // Final settle animation
                        setTimeout(() => {
                            if (itemCell.classList.contains('isotope-transitioning')) {
                                itemCell.style.transform = 'scale(1)';
                                itemCell.style.zIndex = '2'; // Reset z-index after animation
                                
                                // Remove transition class after animation
                                setTimeout(() => {
                                    itemCell.classList.remove('isotope-transitioning');
                                }, 100);
                            }
                        }, (delay * 1000) + 600); // After main animation completes
                    });
                    
                } else {
                    // ABSOLUTE POSITIONING: Fast initial positioning with minimal animation
                    itemCell.style.position = 'absolute';
                    itemCell.style.transition = `
                        left 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                        top 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                        width 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                        height 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                        transform 0.3s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.01}s,
                        opacity 0.2s ease-out ${index * 0.01}s
                    `;
                    
                    // OPTIMIZED: Fast position and size transitions for initial positioning
                    requestAnimationFrame(() => {
                        itemCell.style.left = `${pos.left}px`;
                        itemCell.style.top = `${pos.top}px`;
                        itemCell.style.width = `${pos.width}px`;
                        itemCell.style.height = `${pos.height}px`;
                        itemCell.style.opacity = '1';
                        itemCell.style.transform = 'scale(1)';
                        itemCell.style.zIndex = '2';
                    });
                }
                
                // Add isotope-style entrance effect
                itemCell.classList.add('isotope-positioned');
            });
            
            /// Create enhanced person name labels and row separators for People view
            if (window.activeLayout === 'people' && metaData?.personLabels) {
                // Create row separators for visual clarity
                if (metaData.rowSeparators) {
                    metaData.rowSeparators.forEach(separator => {
                        const separatorElement = document.createElement('div');
                        separatorElement.className = 'people-row-separator';
                        separatorElement.style.cssText = `
                            position: absolute;
                            left: ${separator.x}px;
                            top: ${separator.y}px;
                            width: ${separator.width}px;
                            height: ${separator.height}px;
                            background: rgba(0, 0, 0, 0.1);
                            z-index: 0;
                        `;
                        layoutCanvas.appendChild(separatorElement);
                    });
                }
                
                // Create right-aligned person name labels  
                metaData.personLabels.forEach(label => {
                    const labelElement = document.createElement('div');
                    labelElement.className = 'person-name-label';
                    
                    // Minimal styling - just position and text
                    labelElement.style.cssText = `
                        position: absolute;
                        left: ${label.x}px;
                        top: ${label.y}px;
                        z-index: 2;
                    `;
                    
                    // Just show the person's name
                    labelElement.textContent = label.name;
                    
                    layoutCanvas.appendChild(labelElement);
                });
            }
            
            /// NO visual elements for bottom-up timeline
            if (window.activeLayout === 'timeline' && metaData?.isBottomUpTimeline) {
                console.log(`📅 Bottom-up timeline - conversations stacked from baseline with dynamic sizing`);
                console.log(`✅ Bottom-up timeline ready - ${metaData.totalDateGroups} date columns, dynamic sizes, stacked from bottom`);
            }
            
            // EMOTION CIRCLES CODE COMPLETELY REMOVED - Using only Tetris-style layout
            
            // Force reflow to ensure all items are positioned correctly
            layoutCanvas.offsetHeight;
            
            // Log final positions for debugging
            console.log(`✅ Layout complete for ${window.activeLayout} view with ${conversations.length} conversations positioned`);
            let createdCount = 0;
            conversations.forEach((conv, index) => {
                const itemCell = document.getElementById(`conv-item-${conv.folder}`);
                if (itemCell) {
                    createdCount++;
                    const rect = itemCell.getBoundingClientRect();
                    console.log(`📍 ${conv.folder}: positioned at (${itemCell.style.left}, ${itemCell.style.top}) with size ${itemCell.style.width}x${itemCell.style.height}`);
                } else {
                    console.warn(`❌ Missing element for ${conv.folder}`);
                }
            });
            console.log(`📊 Created ${createdCount}/${conversations.length} conversation elements`);

            /// Create person name labels for People view
            if (window.activeLayout === 'people' && metaData?.personLabels) {
                metaData.personLabels.forEach(label => {
                    const labelElement = document.createElement('div');
                    labelElement.className = 'person-name-label';
                    labelElement.style.cssText = `
                        position: absolute;
                        left: ${label.x}px;
                        top: ${label.y}px;
                        z-index: 1;
                    `;
                    labelElement.textContent = label.name;
                    layoutCanvas.appendChild(labelElement);
                });
            }
            
            /// Create emotion labels for Emotions view (Tetris style)
            if (window.activeLayout === 'emotions' && targetPositions) {
                // Clear any existing emotion labels first
                const existingLabels = layoutCanvas.querySelectorAll('.emotion-cluster-label, .emotion-circle-label, .emotion-count-badge, .emotion-circle-background, .emotion-inner-circle');
                existingLabels.forEach(label => label.remove());
                console.log(`🧹 Cleared ${existingLabels.length} existing emotion labels`);
                
                // Count how many emotion labels we're about to create
                const labelKeysToCreate = Object.keys(targetPositions).filter(key => key.startsWith('emotion_label_'));
                console.log(`📝 About to create ${labelKeysToCreate.length} new emotion labels: ${labelKeysToCreate.map(k => k.replace('emotion_label_', '')).join(', ')}`);
                
                // Find and render emotion labels
                Object.keys(targetPositions).forEach(key => {
                    if (key.startsWith('emotion_label_')) {
                        const labelData = targetPositions[key];
                        if (labelData.isEmotionLabel) {
                            // Create emotion label element
                            const labelElement = document.createElement('div');
                            labelElement.className = 'emotion-cluster-label';
                            labelElement.style.cssText = `
                                position: absolute;
                                left: ${labelData.left}px;
                                top: ${labelData.top}px;
                                width: ${labelData.width}px;
                                height: ${labelData.height}px;
                                z-index: 10;
                                font-family: 'Miriam Libre', serif;
                                font-size: 16px;
                                font-weight: normal;
                                color: #333;
                                display: flex;
                                align-items: center;
                                justify-content: ${labelData.isRightAligned ? 'flex-start' : 'flex-end'};
                                text-align: ${labelData.isRightAligned ? 'left' : 'right'};
                                direction: rtl;
                                pointer-events: none;
                                background: transparent;
                                border: none;
                                box-shadow: none;
                                padding: 0;
                            `;
                            
                            // Emotion name in Hebrew only (no count)
                            labelElement.innerHTML = `
                                ${labelData.hebrewEmotion}
                            `;
                            
                            layoutCanvas.appendChild(labelElement);
                            console.log(`🏷️ Created emotion label "${labelData.hebrewEmotion}" (${labelData.emotion}) at position (${labelData.left}, ${labelData.top}) with ${labelData.count} conversations - stairs offset: ${labelData.staggerOffset}px (index: ${labelData.globalEmotionIndex})`);
                        }
                    }
                });
            }
        }, 0);
        
        // Render all previews after layout is complete
        setTimeout(() => {
            // Iframe previews load automatically - no need to render manually
            console.log('✅ Layout complete - iframe previews will load automatically');
            
            // Debug conversation visibility after layout
            if (window.debugConversationVisibility) {
                const debugResult = window.debugConversationVisibility();
                console.log('🔍 Layout Debug Result:', debugResult);
            }
            
            // Reset the rendering flag and cleanup
            window.isLayoutRendering = false;
            
            // CONSISTENCY CHECK: Ensure layout classes are properly applied
            const finalGridContainer = document.getElementById('timeline-axes-container');
            const finalLayoutCanvas = document.getElementById('layout-canvas');
            
            if (finalGridContainer && window.activeLayout) {
                // Ensure the layout class is properly set
                if (!finalGridContainer.classList.contains(`layout-${window.activeLayout}`)) {
                    finalGridContainer.classList.add(`layout-${window.activeLayout}`);
                    console.log(`🔧 Applied missing layout class: layout-${window.activeLayout}`);
                }
                
                // Remove any stale isotope classes
                finalGridContainer.classList.remove('isotope-transitioning', 'isotope-switching');
            }
            
            if (finalLayoutCanvas) {
                // Ensure canvas classes match layout
                if (window.activeLayout === 'people' && !finalLayoutCanvas.classList.contains('people-active')) {
                    finalLayoutCanvas.classList.add('people-active');
                    console.log('🔧 Applied missing people-active class to canvas');
                }
                
                // Remove transitioning classes
                finalLayoutCanvas.classList.remove('isotope-transitioning');
            }
            
            console.log(`✅ Layout consistency check complete for ${window.activeLayout} view`);
        }, 150); // Increased timeout for better stability
        
        }, 30); // Reduced debounce timeout for better responsiveness
    }

    // Add responsive window resize handler
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            console.log('🔄 Window resized, updating layout...');
            
            // Update responsive block sizes first
            if (window.updateResponsiveBlockSizes) {
                window.updateResponsiveBlockSizes(true);
            }
            
            if (window.renderNewLayout) {
                window.renderNewLayout();
                
                // Special handling for People view to ensure consistency
                if (window.activeLayout === 'people') {
                    // Clear any existing stability check
                    if (window.peopleViewStabilityCheck) {
                        clearTimeout(window.peopleViewStabilityCheck);
                    }
                    
                    window.peopleViewStabilityCheck = setTimeout(() => {
                        if (window.renderNewLayout && window.activeLayout === 'people') {
                            console.log('🔄 People view resize stabilization...');
                            window.renderNewLayout(false);
                        }
                    }, 150);
                }
            }
        }, 300); // Debounce resize events
    });

    // Force layout recalculation after page load to fix initial positioning
    window.addEventListener('load', () => {
        setTimeout(() => {
            console.log('🔄 Page loaded, forcing layout recalculation...');
            if (window.renderNewLayout) {
                window.renderNewLayout();
                
                // Special handling for People view on page load
                if (window.activeLayout === 'people') {
                    // Clear any existing stability check
                    if (window.peopleViewStabilityCheck) {
                        clearTimeout(window.peopleViewStabilityCheck);
                    }
                    
                    window.peopleViewStabilityCheck = setTimeout(() => {
                        if (window.renderNewLayout && window.activeLayout === 'people') {
                            console.log('🔄 People view page load stabilization...');
                            window.renderNewLayout(false);
                        }
                    }, 300);
                }
            }
        }, 500); // Wait for DOM to be fully ready
    });

    window.switchLayout = function(newLayout, forceRefresh = true) {
        if (newLayout === window.activeLayout && !forceRefresh) return;
        
        const previousLayout = window.activeLayout;
        
        console.log(`🎬 ENHANCED SWITCH: ${previousLayout} → ${newLayout}`);
        
        // CLEANUP: Clear all pending layout operations to prevent race conditions
        if (window.layoutRenderTimeout) {
            clearTimeout(window.layoutRenderTimeout);
            window.layoutRenderTimeout = null;
        }
        if (window.peopleViewStabilityCheck) {
            clearTimeout(window.peopleViewStabilityCheck);
            window.peopleViewStabilityCheck = null;
        }
        
        // RESET: Clear layout rendering lock
        window.isLayoutRendering = false;
        
        // SET NEW LAYOUT EARLY: Ensure consistent state
        window.activeLayout = newLayout;
        
        // SPECIFIC CLEANUP FOR EMOTIONS VIEW TRANSITIONS
        if (previousLayout === 'emotions' && newLayout !== 'emotions') {
            console.log('🎭 Detected transition FROM emotions view - performing cleanup');
            window.cleanupEmotionsView();
        }
        
        // CLEAR CACHED POSITIONS: Force fresh calculation for all views except timeline
        if (previousLayout !== newLayout) {
            // SPECIAL CASE: Always clear all positions when coming FROM emotions view
            if (previousLayout === 'emotions' && window.layoutPositions) {
                console.log('🎭 EMOTION EXIT: Clearing ALL cached positions due to emotions view exit');
                window.layoutPositions.timeline = null;
                window.layoutPositions.people = null;
                window.layoutPositions.emotions = null;
            } else if (newLayout !== 'timeline' && window.layoutPositions) {
                // Keep timeline cache but clear others to force recalculation
                console.log(`🗑️ Clearing cached positions for fresh ${newLayout} calculation`);
                if (newLayout !== 'people') window.layoutPositions.people = null;
                if (newLayout !== 'emotions') window.layoutPositions.emotions = null;
            }
        }
        
        // CRITICAL: Pre-fix canvas height before any other operations
        const layoutCanvas = document.getElementById('layout-canvas');
        if (layoutCanvas) {
            // Clean up ALL CSS classes and styles first
            layoutCanvas.className = '';
            layoutCanvas.style.cssText = '';
            
            // Aggressively preserve height during view switching
            layoutCanvas.style.setProperty('height', 'calc(100vh - 120px)', 'important');
            layoutCanvas.style.setProperty('min-height', '800px', 'important');
            layoutCanvas.style.setProperty('overflow-y', 'auto', 'important');
            layoutCanvas.style.setProperty('overflow-x', 'hidden', 'important');
            layoutCanvas.style.setProperty('scrollbar-width', 'none', 'important');
            layoutCanvas.style.setProperty('-ms-overflow-style', 'none', 'important');
            
            // Force immediate reflow
            layoutCanvas.offsetHeight;
            console.log(`🔧 Pre-fixed canvas height for ${newLayout}: ${layoutCanvas.offsetHeight}px`);
        }
        
        // CLEANUP: Reset grid container classes
        const gridContainer = document.getElementById('timeline-axes-container');
        if (gridContainer) {
            gridContainer.className = '';
            gridContainer.style.cssText = '';
            gridContainer.offsetHeight; // Force reflow
        }
        
        // Reset all conversation containers to default state before layout change
        if (window.resetAllConversationContainers) {
            window.resetAllConversationContainers();
        }
        
        // Add visual feedback for view switching
        const viewButtons = document.querySelectorAll('.view-toggle-btn');
        viewButtons.forEach(btn => {
            btn.style.pointerEvents = 'none'; // Disable during transition
        });
        
        // Re-enable buttons after transition
        setTimeout(() => {
            viewButtons.forEach(btn => {
                btn.style.pointerEvents = 'auto';
            });
        }, 800);

        const timelineTrack = document.querySelector('.timeline-track-wrapper');
        const playgroundContainer = document.getElementById('playground-container');
        const timelineWrapper = document.getElementById('timeline-grid-wrapper');
        
        if (newLayout === 'playground') {
            // Show playground mode
            if (playgroundContainer) playgroundContainer.style.display = 'flex';
            if (timelineWrapper) timelineWrapper.style.display = 'none';
            if (timelineTrack) timelineTrack.style.visibility = 'hidden';
            
            // Start playground sketch
            if (typeof window.startPlaygroundSketch === 'function') {
                window.startPlaygroundSketch();
            }
        } else {
            // Show normal layout modes
            if (playgroundContainer) playgroundContainer.style.display = 'none';
            if (timelineWrapper) timelineWrapper.style.display = 'block';
            if (timelineTrack) {
                timelineTrack.style.visibility = (newLayout === 'timeline') ? 'visible' : 'hidden';
            }
            
            // Stop playground sketch
            if (typeof window.stopPlaygroundSketch === 'function') {
                window.stopPlaygroundSketch();
            }
            
            if (typeof window.resetCamera === 'function') {
                window.resetCamera();
            }
            
            // ENHANCED ISOTOPE ANIMATIONS: Add smooth morphing between views
            console.log(`🎬 Switching from ${window.activeLayout || 'initial'} to ${newLayout} with isotope-style animation`);
            
            // Add isotope transitioning class for enhanced animations
            const gridContainer = document.getElementById('timeline-axes-container');
            
            // CRITICAL: Maintain canvas height during transitions
            if (layoutCanvas) {
                layoutCanvas.classList.add('isotope-transitioning');
                layoutCanvas.style.transition = 'all 0.6s cubic-bezier(0.23, 1, 0.32, 1)';
                
                // RE-ENFORCE canvas height after adding classes
                layoutCanvas.style.setProperty('height', 'calc(100vh - 120px)', 'important');
                layoutCanvas.style.setProperty('min-height', '800px', 'important');
                layoutCanvas.style.setProperty('overflow-y', 'auto', 'important');
                layoutCanvas.style.setProperty('overflow-x', 'hidden', 'important');
                layoutCanvas.style.setProperty('scrollbar-width', 'none', 'important');
                layoutCanvas.style.setProperty('-ms-overflow-style', 'none', 'important');
                console.log(`🔧 Re-enforced canvas height during transition: ${layoutCanvas.offsetHeight}px`);
            }
            
            if (gridContainer) {
                gridContainer.classList.add('isotope-transitioning');
            }
            
            // Add isotope transitioning to timeline track for consistent animations
            if (timelineTrack) {
                timelineTrack.classList.add('isotope-transitioning');
                timelineTrack.style.transition = 'all 0.6s cubic-bezier(0.23, 1, 0.32, 1)';
            }
            
            // Add isotope transitioning to timeline conversations container
            const timelineConversationsContainer = document.getElementById('timeline-conversations-container');
            if (timelineConversationsContainer) {
                timelineConversationsContainer.classList.add('isotope-transitioning');
                timelineConversationsContainer.style.transition = 'all 0.6s cubic-bezier(0.23, 1, 0.32, 1)';
            }
            
            // ISOTOPE-STYLE SMOOTH VIDEO TRANSITIONS: Show videos moving to new positions
            const allContainers = document.querySelectorAll('.conversation-grid-item-container');
            
            // TIMELINE-SPECIFIC: Ensure timeline containers get proper isotope treatment
            if (newLayout === 'timeline' || previousLayout === 'timeline') {
                allContainers.forEach((container) => {
                    container.style.willChange = 'transform, left, top, width, height, opacity';
                    container.style.backfaceVisibility = 'hidden';
                    container.style.perspective = '1000px';
                    // Add extra transition properties for timeline
                    container.style.transformStyle = 'preserve-3d';
                    container.style.transformOrigin = 'center center';
                });
                console.log(`🎬 Enhanced timeline containers for isotope animations (${previousLayout} → ${newLayout})`);
            }
            
            // Phase 1: Prepare containers for smooth isotope animation
            allContainers.forEach((container, index) => {
                container.classList.add('transitioning');
                
                const video = container.querySelector('.conversation-video-preview');
                if (video) {
                    // Keep videos playing during transition for smooth movement effect
                    const wasPlaying = !video.paused;
                    
                    // Show first frame if video isn't playing to ensure content is visible
                    if (!wasPlaying && video.readyState >= 2) {
                        video.currentTime = 0.1;
                    }
                    
                    // Enable smooth video transitions during layout change
                    video.style.transition = 'transform 0.3s ease-out, filter 0.3s ease-out';
                    video.style.willChange = 'transform';
                }
                
                // Add smooth isotope-style transition with fast delays
                container.style.transition = `
                    left 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.03}s,
                    top 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.03}s,
                    width 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.03}s,
                    height 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.03}s,
                    transform 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                    opacity 0.3s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.01}s
                `;
                
                // Add subtle entrance animation for isotope effect
                container.style.transform = `scale(0.96) translateY(10px)`;
                container.style.opacity = '0.85';
                
                // Restore to normal state with staggered timing for organic feel
                setTimeout(() => {
                    container.style.transform = 'scale(1) translateY(0px)';
                    container.style.opacity = '1';
                }, 50 + (index * 30));
                
                // Clean up transition state after animation completes
                setTimeout(() => {
                    container.classList.remove('transitioning');
                    
                    // Reset video transitions to normal hover behavior
                    if (video) {
                        video.style.transition = 'filter 0.3s ease-out';
                        video.style.willChange = 'auto';
                    }
                    
                    // Reset container transitions to normal
                    container.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                }, 2000 + (index * 100)); // Allow time for all animations to complete
            });
            
            // CRITICAL FIX: For People view, ensure proper container dimensions before layout
            if (newLayout === 'people') {
                // Clear any existing stability checks
                if (window.peopleViewStabilityCheck) {
                    clearTimeout(window.peopleViewStabilityCheck);
                }
                
                // FORCE FIX: Ensure timeline-grid-wrapper is visible for people view
                const timelineWrapper = document.getElementById('timeline-grid-wrapper');
                if (timelineWrapper) {
                    timelineWrapper.style.cssText = `
                        position: absolute !important;
                        top: 60px !important;
                        left: 0px !important;
                        right: 0px !important;
                        bottom: 0px !important;
                        width: 100vw !important;
                        height: calc(100vh - 60px) !important;
                        min-width: 1200px !important;
                        min-height: 600px !important;
                        display: block !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                        overflow: visible !important;
                        z-index: 0 !important;
                        background: transparent !important;
                        padding: 0px !important;
                        margin: 0px !important;
                    `;
                    console.log('🔧 FORCED timeline-grid-wrapper to be visible for people view');
                }
                
                // SET TIMELINE SQUARE SIZE CSS VARIABLE for People view consistency
                const gridContainer = document.getElementById('timeline-axes-container') || timelineWrapper;
                const timelineSquareSize = getTimelineSquareSize(window.originalConversationData || [], gridContainer);
                document.documentElement.style.setProperty('--timeline-square-size', `${timelineSquareSize}px`);
                console.log(`📐 Set --timeline-square-size to ${timelineSquareSize}px for People view`);
                
                // Force immediate layout update to set CSS classes with isotope animations
                window.renderNewLayout(false);
                
                // Then wait for container to stabilize and recalculate
                window.peopleViewStabilityCheck = setTimeout(() => {
                    const gridContainer = document.getElementById('timeline-axes-container');
                    
                    if (!gridContainer) return;
                    
                    // Force a reflow to ensure DOM is ready
                    gridContainer.offsetHeight;
                    
                    const currentWidth = gridContainer.clientWidth;
                    const currentHeight = gridContainer.clientHeight;
                    
                    console.log(`🔧 People view container stabilization: ${currentWidth}x${currentHeight}`);
                    
                    // Check if dimensions are stable (not zero and reasonable)
                    if (currentWidth > 100 && currentHeight > 100) {
                        console.log(`🔄 People view STABLE dimensions detected: ${currentWidth}x${currentHeight} - recalculating layout`);
                        
                        if (window.renderNewLayout && window.activeLayout === 'people') {
                            window.renderNewLayout(false);
                        }
                    } else {
                        console.warn(`⚠️ People view dimensions not stable: ${currentWidth}x${currentHeight} - retrying...`);
                        
                        // Retry after another short delay if dimensions aren't stable
                        setTimeout(() => {
                            if (window.renderNewLayout && window.activeLayout === 'people') {
                                console.log(`🔄 People view retry layout calculation`);
                                window.renderNewLayout(false);
                            }
                        }, 200);
                    }
                }, 150); // Increased delay to ensure CSS has applied
            } else {
                // For other layouts, render immediately with isotope transitions
                if (newLayout === 'timeline') {
                    // TIMELINE SPECIAL: Delay rendering to allow isotope animations to start
                    setTimeout(() => {
                        window.renderNewLayout(false);
                        console.log(`🎬 Triggered isotope animations for ${newLayout} view (delayed for timeline)`);
                    }, 100); // Small delay to let isotope animations start first
                } else {
                    // SPECIAL CASE: When transitioning FROM timeline, add slight delay for smooth isotope
                    if (previousLayout === 'timeline') {
                        setTimeout(() => {
                            window.renderNewLayout(false);
                            console.log(`🎬 Triggered isotope animations for ${newLayout} view (delayed from timeline)`);
                        }, 50); // Smaller delay when transitioning FROM timeline
                    } else {
                        window.renderNewLayout(false);
                        console.log(`🎬 Triggered isotope animations for ${newLayout} view`);
                    }
                }
                
                // Add completion callback for isotope transitions
                setTimeout(() => {
                    console.log(`✅ Isotope transition to ${newLayout} view completed`);
                    
                    // Clean up isotope transitioning classes
                    if (layoutCanvas) {
                        layoutCanvas.classList.remove('isotope-transitioning');
                    }
                    if (gridContainer) {
                        gridContainer.classList.remove('isotope-transitioning');
                    }
                    const timelineTrack = document.querySelector('.timeline-track-wrapper');
                    if (timelineTrack) {
                        timelineTrack.classList.remove('isotope-transitioning');
                    }
                    const timelineConversationsContainer = document.getElementById('timeline-conversations-container');
                    if (timelineConversationsContainer) {
                        timelineConversationsContainer.classList.remove('isotope-transitioning');
                    }
                }, 600); // Match isotope transition duration
            }
            
            // ENHANCED: Global cleanup for isotope classes after all transitions
            setTimeout(() => {
                const allContainers = document.querySelectorAll('.conversation-grid-item-container');
                allContainers.forEach((container, index) => {
                    // Clean up isotope classes
                    container.classList.remove('isotope-positioned', 'transitioning');
                    
                    // Reset transition delays
                    container.style.transitionDelay = '';
                    
                    // Ensure final position is stable
                    container.style.transform = 'scale(1) rotateY(0deg) rotateX(0deg)';
                    
                    // Reset to normal transition for hover effects
                    setTimeout(() => {
                        container.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    }, index * 10);
                });
                
                if (layoutCanvas) {
                    layoutCanvas.classList.remove('isotope-transitioning');
                }
                if (gridContainer) {
                    gridContainer.classList.remove('isotope-transitioning');
                }
                const timelineTrack = document.querySelector('.timeline-track-wrapper');
                if (timelineTrack) {
                    timelineTrack.classList.remove('isotope-transitioning');
                }
                const timelineConversationsContainer = document.getElementById('timeline-conversations-container');
                if (timelineConversationsContainer) {
                    timelineConversationsContainer.classList.remove('isotope-transitioning');
                }
                
                console.log(`✨ Isotope transition to ${newLayout} view completed with enhanced animations`);
            }, 1000); // Fast cleanup to allow all animations to finish
        }
    }

    function openVisualizationInModal(folder) {
        console.log(`🔍 openVisualizationInModal called for: ${folder}`);
        const modalContainer = document.getElementById('visualization-modal-container');
        if (!modalContainer) {
            console.error(`❌ Modal container not found for: ${folder}`);
            return;
        }
        console.log(`✅ Modal container found for: ${folder}`);
        
        // Check if we already have an iframe for this folder
        const existingIframe = modalContainer.querySelector(`iframe[data-folder="${folder}"]`);
        
        if (existingIframe) {
            // If iframe already exists, just show it
            console.log(`♻️ Reusing existing visualization for ${folder}`);
            modalContainer.style.display = 'flex';
            setTimeout(() => modalContainer.classList.add('visible'), 10);
            return;
        }
        
        // IMPORTANT: Always stop all audio and clear content when switching conversations
        const currentFolder = modalContainer.querySelector('iframe')?.getAttribute('data-folder');
        if (currentFolder && currentFolder !== folder) {
            // Stop all audio in the current iframe before switching
            const currentIframe = modalContainer.querySelector('iframe');
            if (currentIframe && currentIframe.contentWindow) {
                try {
                    // Send message to stop all audio
                    currentIframe.contentWindow.postMessage({
                        type: 'stop-all-audio',
                        reason: 'conversation-switch'
                    }, '*');
                } catch (e) {
                    console.warn('Could not send stop-audio message to iframe:', e);
                }
            }
            
            // Clear the modal and wait a moment for audio to stop
            modalContainer.innerHTML = '';
            console.log(`🔇 Stopped audio for ${currentFolder}, switching to ${folder}`);
        }
        
        // Create iframe with enhanced cache-busting (with delay if switching conversations)
        const createNewIframe = () => {
            const iframe = document.createElement('iframe');
            iframe.setAttribute('data-folder', folder);
            
            // Force reload with timestamp to ensure fresh data
            const timestamp = Date.now();
            const randomId = Math.random().toString(36).substr(2, 9);
            iframe.src = `visualization.html?folder=${encodeURIComponent(folder)}&viewMode=iframe&t=${timestamp}&r=${randomId}&force=true`;
            
            return iframe;
        };
        
        // Add delay if we just switched conversations to ensure audio cleanup
        const shouldDelay = currentFolder && currentFolder !== folder;
        
        const setupIframe = () => {
            const iframe = createNewIframe();
            
            // Styles are now handled by CSS, no need to set them here
            iframe.style.backgroundColor = '#f7f9f3';
            
            iframe.onload = () => {
                console.log(`✅ Visualization iframe loaded for ${folder} with cache-busting`);
                // Hide loading indicator if present
                const loadingIndicator = document.getElementById('loading-indicator');
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'none';
                }
                
                // Send message to iframe to ensure emotion data is loaded
                setTimeout(() => {
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({ 
                            type: 'ensure-emotion-data',
                            folder: folder,
                            timestamp: Date.now()
                        }, '*');
                    }
                }, 500);
                
                // Send multiple color reload messages to ensure latest colors are used
                setTimeout(() => {
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'reloadEmotionColors',
                            timestamp: Date.now()
                        }, '*');
                        console.log(`🎨 Sent emotion color reload to iframe for ${folder}`);
                    }
                }, 1500);
                
                // Send a second reload after more time to be extra sure
                setTimeout(() => {
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'forceVisualRefresh',
                            timestamp: Date.now()
                        }, '*');
                        console.log(`🔄 Sent force visual refresh to iframe for ${folder}`);
                    }
                }, 2500);
                
                // Try direct function call if available
                setTimeout(() => {
                    try {
                        if (iframe.contentWindow && iframe.contentWindow.forceUpdateAllBlobColors) {
                            iframe.contentWindow.forceUpdateAllBlobColors();
                            console.log(`🎨 Called forceUpdateAllBlobColors directly on iframe for ${folder}`);
                        }
                    } catch (e) {
                        console.log(`🎨 Direct function call not available for ${folder}:`, e.message);
                    }
                }, 3500);
                
                // Also set up a periodic check to ensure colors stay updated
                const colorUpdateInterval = setInterval(() => {
                    if (!iframe.parentNode) {
                        // iframe was removed, clear interval
                        clearInterval(colorUpdateInterval);
                        return;
                    }
                    
                    try {
                        if (iframe.contentWindow) {
                            iframe.contentWindow.postMessage({
                                type: 'reloadEmotionColors',
                                timestamp: Date.now(),
                                source: 'periodic-update'
                            }, '*');
                            console.log(`🔄 Sent periodic color update to ${folder}`);
                        }
                    } catch (e) {
                        console.log(`🔄 Periodic update failed for ${folder}:`, e.message);
                    }
                }, 30000); // Every 30 seconds
            };
            
            modalContainer.appendChild(iframe);
            modalContainer.style.display = 'flex';
            setTimeout(() => modalContainer.classList.add('visible'), 10);
        };
        
        if (shouldDelay) {
            // Wait 300ms for audio to stop before creating new iframe
            console.log(`⏱️ Waiting for audio cleanup before loading ${folder}`);
            setTimeout(setupIframe, 300);
        } else {
            setupIframe();
        }
    }
    

    
    // Audio interaction function removed
    
    // Listen for messages from iframe about loading state
    window.addEventListener('message', (event) => {
        if (event.data && (event.data.type === 'close-visualization-modal' || 
                          event.data.type === 'closeVisualization' || 
                          event.data.action === 'closeModal')) {
            closeVisualizationModal();
        } else if (event.data && event.data.type === 'loading-progress') {
            const loadingIndicator = document.getElementById('loading-indicator');
            const loadingText = document.getElementById('loading-text');
            const loadingDetails = document.getElementById('loading-details');
            
            if (event.data.show && loadingIndicator) {
                loadingIndicator.style.display = 'block';
                if (loadingText) loadingText.textContent = event.data.message || '';
                if (loadingDetails) loadingDetails.textContent = event.data.details || '';
            } else if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
        } else if (event.data && event.data.type === 'conversation-deleted') {
            // Handle conversation deletion notification from admin panel
            console.log('🗑️ Received conversation deletion notification:', event.data.folder);
            
            // Immediately refresh conversations to sync with admin changes
            setTimeout(async () => {
                await loadConversationConfig(true);
            }, 1000); // Small delay to ensure backend has finished processing
        } else if (event.data && event.data.type === 'refresh-conversations') {
            // Handle general refresh request from admin panel
            console.log('🔄 Received conversation refresh request from admin panel');
            
            setTimeout(async () => {
                await loadConversationConfig(true);
            }, 500);
        } else if (event.data && event.data.type === 'force-config-reload') {
            // Handle forced config reload (e.g., after conversation name change)
            console.log('🔄 Received force config reload request from admin panel');
            
            // Clear any cached data
            window.conversationDataGlobal = [];
            window.lastConfigUpdate = Date.now();
            
            setTimeout(async () => {
                await loadConversationConfig(true);
                console.log('✅ Forced conversation config reload completed');
                
                // Force re-render the current layout to show updated names
                if (typeof window.renderNewLayout === 'function') {
                    console.log('🔄 Re-rendering layout with updated conversation names...');
                    await window.renderNewLayout(true);
                    console.log('✅ Layout re-rendered with updated names');
                }
            }, 300);
        } else if (event.data && event.data.type === 'update-conversation-title') {
            // Handle specific conversation title update from admin panel
            console.log('🏷️ Received conversation title update from admin panel:', event.data);
            
            // Update conversation data in memory and refresh grid
            if (event.data.metadata && event.data.metadata.name && event.data.conversation) {
                console.log(`🔄 Updating conversation data for ${event.data.conversation} with name: ${event.data.metadata.name}`);
                
                // Update the conversation data in memory
                const conversationToUpdate = window.conversationDataGlobal.find(conv => conv.folder === event.data.conversation);
                if (conversationToUpdate) {
                    conversationToUpdate.displayName = event.data.metadata.name;
                    conversationToUpdate.metadata = { ...conversationToUpdate.metadata, ...event.data.metadata };
                    console.log(`✅ Updated conversation data in memory for ${event.data.conversation}`);
                }
                
                // Update the data-conversation attribute for the grid item
                const gridItem = document.getElementById(`conv-item-${event.data.conversation}`);
                if (gridItem) {
                    gridItem.setAttribute('data-conversation', event.data.metadata.name);
                    console.log(`✅ Updated grid item data-conversation attribute for ${event.data.conversation}`);
                }
                
                // If there's a currently visible hover panel for this conversation, update it
                const hoverPanel = document.getElementById('hover-info-panel');
                if (hoverPanel && hoverPanel.classList.contains('visible')) {
                    const titleElement = hoverPanel.querySelector('.hover-info-title');
                    if (titleElement && conversationToUpdate) {
                        // Update hover panel if it's showing this conversation
                        const panelText = titleElement.textContent;
                        if (panelText.includes(event.data.conversation) || panelText.includes(conversationToUpdate.displayName)) {
                            showHoverPanel(conversationToUpdate);
                            console.log(`✅ Updated visible hover panel for ${event.data.conversation}`);
                        }
                    }
                }
                
                console.log(`✅ Conversation title update completed for ${event.data.conversation}`);
            }
        } else if (event.data && (event.data.type === 'updateEmotions' || 
                                   event.data.type === 'reloadEmotionColors' || 
                                   event.data.type === 'forceVisualRefresh' ||
                                   event.data.type === 'emotionColorsUpdated')) {
            
            console.log('🎨 Received emotion color update from admin panel:', event.data.type);
            
            // Use the working test function that we know works
            setTimeout(() => {
                const success = window.testConversationColorUpdate();
                if (success) {
                    console.log('✅ Successfully triggered conversation color update');
                } else {
                    console.log('ℹ️ No conversations open to update');
                }
            }, 100);
        }
    });

    // 🧪 TEST FUNCTION: Test טל מקלר conversations grouping
    window.testTalMaklerGrouping = async function() {
        console.log('🧪 TESTING טל מקלר conversations grouping...');
        
        try {
            // Force reload configuration
            console.log('🔄 Force reloading conversation config...');
            await loadConversationConfig(true);
            
            // Check טל מקלר conversations
            const talMaklerConvos = window.conversationDataGlobal.filter(conv => 
                conv.metadata && (
                    (conv.metadata.mainParticipant && conv.metadata.mainParticipant.includes('טל מקלר')) ||
                    (conv.metadata.customParticipantName && conv.metadata.customParticipantName.includes('טל מקלר'))
                )
            );
            
            console.log(`🔍 Found ${talMaklerConvos.length} טל מקלר conversations:`);
            talMaklerConvos.forEach(conv => {
                console.log(`  📁 ${conv.folder}: customParticipantName="${conv.metadata.customParticipantName}", mainParticipant="${conv.metadata.mainParticipant}"`);
            });
            
            // Test people view grouping
            if (talMaklerConvos.length > 0) {
                console.log('🎯 Testing people view grouping...');
                const positions = getPeopleViewPositions(window.conversationDataGlobal, document.getElementById('layout-canvas'));
                
                const talMaklerGroups = Object.entries(positions._personNames || []).filter(([name, data]) => 
                    name.includes('טל מקלר') || data.name.includes('טל מקלר')
                );
                
                console.log(`👥 Found ${talMaklerGroups.length} טל מקלר groups in people view`);
                talMaklerGroups.forEach(([name, data]) => {
                    console.log(`  🎯 Group "${data.name}": ${data.conversationCount} conversations`);
                });
            }
            
            return talMaklerConvos.length;
            
        } catch (error) {
            console.error('❌ TEST FAILED:', error);
            return 0;
        }
    };

    // 🧪 TEST FUNCTION: Test conversation name updates in index.html
    window.testIndexConversationNameUpdate = async function(conversationFolder = 'convo1', testName = null) {
        const uniqueTestName = testName || `Index Test ${Date.now()}`;
        console.log(`🧪 INDEX TEST: Testing conversation name update for ${conversationFolder} with name: "${uniqueTestName}"`);
        
        try {
            // Step 1: Find the conversation in memory
            const conversationToTest = window.conversationDataGlobal.find(conv => conv.folder === conversationFolder);
            if (!conversationToTest) {
                console.error(`❌ Conversation ${conversationFolder} not found in conversationDataGlobal`);
                return false;
            }
            
            const originalName = conversationToTest.displayName;
            console.log(`📝 Original name: "${originalName}"`);
            
            // Step 2: Update the conversation data in memory
            conversationToTest.displayName = uniqueTestName;
            conversationToTest.metadata = { ...conversationToTest.metadata, name: uniqueTestName };
            
            // Step 3: Update the grid item data attribute
            const gridItem = document.getElementById(`conv-item-${conversationFolder}`);
            if (gridItem) {
                gridItem.setAttribute('data-conversation', uniqueTestName);
                console.log(`✅ Updated grid item data attribute`);
            } else {
                console.warn(`⚠️ Grid item conv-item-${conversationFolder} not found`);
            }
            
            // Step 4: Test hover panel by simulating hover
            if (gridItem) {
                console.log(`🔄 Testing hover panel update...`);
                
                // Simulate mouseover to show hover panel
                const event = new MouseEvent('mouseover', { bubbles: true });
                gridItem.dispatchEvent(event);
                
                // Check if hover panel shows updated name
                setTimeout(() => {
                    const hoverPanel = document.getElementById('hover-info-panel');
                    if (hoverPanel && hoverPanel.classList.contains('visible')) {
                        const titleElement = hoverPanel.querySelector('.hover-info-title');
                        if (titleElement && titleElement.textContent.includes(uniqueTestName)) {
                            console.log(`✅ Hover panel shows updated name: "${titleElement.textContent}"`);
                        } else {
                            console.error(`❌ Hover panel does not show updated name. Shows: "${titleElement?.textContent}"`);
                        }
                    } else {
                        console.warn(`⚠️ Hover panel not visible`);
                    }
                    
                    // Hide hover panel
                    hideHoverPanel();
                    
                    // Step 5: Restore original name
                    conversationToTest.displayName = originalName;
                    conversationToTest.metadata = { ...conversationToTest.metadata, name: originalName };
                    if (gridItem) {
                        gridItem.setAttribute('data-conversation', originalName);
                    }
                    console.log(`✅ Restored original name: "${originalName}"`);
                    console.log(`🎉 INDEX TEST COMPLETED`);
                }, 500);
                
                return true;
            } else {
                console.error(`❌ Could not test hover panel - grid item not found`);
                return false;
            }
            
        } catch (error) {
            console.error('❌ INDEX TEST FAILED:', error);
            return false;
        }
    };

    // Function to force update all open conversation visualizations
    // Test function that can be called from browser console
    window.testConversationColorUpdate = function() {
        console.log('🧪 TESTING: Conversation color update from console...');
        return window.forceUpdateAllConversationColors();
    };

    window.forceUpdateAllConversationColors = function() {
        console.log('🎨 FORCING UPDATE OF ALL CONVERSATION COLORS...');
        
        const modalContainer = document.getElementById('visualization-modal-container');
        if (modalContainer) {
            const iframe = modalContainer.querySelector('iframe');
            if (iframe && iframe.contentWindow) {
                try {
                    // Send multiple update messages
                    const messages = [
                        { type: 'reloadEmotionColors', timestamp: Date.now() },
                        { type: 'forceVisualRefresh', timestamp: Date.now() + 100 },
                        { type: 'forceCompleteReload', timestamp: Date.now() + 200 }
                    ];
                    
                    messages.forEach((message, index) => {
                        setTimeout(() => {
                            iframe.contentWindow.postMessage(message, '*');
                            console.log(`📤 Sent ${message.type} to conversation iframe`);
                        }, index * 300);
                    });
                    
                    // Try direct function call
                    setTimeout(() => {
                        try {
                            if (iframe.contentWindow.forceUpdateAllBlobColors) {
                                iframe.contentWindow.forceUpdateAllBlobColors();
                                console.log('🎨 Called forceUpdateAllBlobColors directly');
                            }
                        } catch (e) {
                            console.log('🎨 Direct function call failed:', e.message);
                        }
                    }, 1000);
                    
                    return true;
                } catch (e) {
                    console.warn('Could not update conversation iframe:', e);
                    return false;
                }
            } else {
                console.log('❌ No conversation iframe found to update');
                return false;
            }
        } else {
            console.log('❌ No modal container found');
            return false;
        }
    };

    // Listen for emotion color updates via BroadcastChannel
    try {
        const emotionBroadcastChannel = new BroadcastChannel('emotion-updates');
        emotionBroadcastChannel.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'emotionColorsUpdated') {
                console.log('📻 Received emotion color update via BroadcastChannel');
                
                // Automatically run the color update that we know works
                setTimeout(() => {
                    const success = window.testConversationColorUpdate();
                    if (success) {
                        console.log('✅ Automatically updated conversation colors');
                    } else {
                        console.log('ℹ️ No conversation open to update');
                    }
                }, 500);
            }
        });
        console.log('📻 BroadcastChannel listener setup for emotion updates');
    } catch (e) {
        console.log('📻 BroadcastChannel not available, using only postMessage');
    }

    function closeVisualizationModal() {
        const modalContainer = document.getElementById('visualization-modal-container');
        if (!modalContainer) return;
        
        // Prevent double closing
        if (modalContainer.dataset.closing === 'true') return;
        modalContainer.dataset.closing = 'true';
        
        // Get the currently open conversation folder from iframe
        const iframe = modalContainer.querySelector('iframe');
        let currentFolder = null;
        if (iframe) {
            const src = iframe.src;
            const folderMatch = src.match(/folder=([^&]+)/);
            if (folderMatch) {
                currentFolder = decodeURIComponent(folderMatch[1]);
            }
            
            // IMPORTANT: Stop all audio in the iframe before closing
            if (iframe.contentWindow) {
                try {
                    iframe.contentWindow.postMessage({
                        type: 'stop-all-audio',
                        reason: 'modal-close'
                    }, '*');
                    console.log(`🔇 Stopping audio for ${currentFolder} before closing modal`);
                } catch (e) {
                    console.warn('Could not send stop-audio message to iframe on close:', e);
                }
            }
        }
        
        modalContainer.classList.remove('visible');
        hideExitTooltip(); // Hide tooltip when closing
        
        // Add zoom-out effect to the conversation item
        if (currentFolder) {
            const conversationItem = document.querySelector(`[id*="${currentFolder}"]`);
            if (conversationItem) {
                conversationItem.style.transition = 'transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                conversationItem.style.transform = 'scale(0.8)';
                conversationItem.style.zIndex = '100';
                
                setTimeout(() => {
                    conversationItem.style.transform = 'scale(1)';
                    conversationItem.style.zIndex = '2';
                    // Restore original transition
                    setTimeout(() => {
                        conversationItem.style.transition = 'all 1.8s cubic-bezier(0.165, 0.84, 0.44, 1)';
                    }, 500);
                }, 100);
            }
        }
        
        setTimeout(() => {
            modalContainer.style.display = 'none';
            modalContainer.innerHTML = '';
            modalContainer.dataset.closing = 'false';
        }, 150);
    }
    
    // Show exit tooltip
    function showExitTooltip() {
        const exitTooltip = document.getElementById('exit-tooltip');
        if (exitTooltip) {
            exitTooltip.classList.add('show');
        }
    }
    
    // Hide exit tooltip
    function hideExitTooltip() {
        const exitTooltip = document.getElementById('exit-tooltip');
        if (exitTooltip) {
            exitTooltip.classList.remove('show');
        }
    }
    
    // Add hover detection for modal container
    document.addEventListener('DOMContentLoaded', () => {
        const modalContainer = document.getElementById('visualization-modal-container');
        if (modalContainer) {
            let hoverTimeout;
            
            // Show tooltip when hovering on the dark overlay (not the iframe)
            modalContainer.addEventListener('mousemove', (event) => {
                // Check if mouse is on the overlay (not on the iframe)
                if (event.target === modalContainer) {
                    clearTimeout(hoverTimeout);
                    showExitTooltip();
                    
                    // Move modal down slightly when hovering outside
                    const iframe = modalContainer.querySelector('iframe');
                    if (iframe) {
                        iframe.style.transform = 'translateY(20px)';
                    }
                } else {
                    // Mouse is over the iframe
                    hideExitTooltip();
                    
                    // Reset modal position
                    const iframe = modalContainer.querySelector('iframe');
                    if (iframe) {
                        iframe.style.transform = 'translateY(0)';
                    }
                }
            });
            
            // Hide tooltip when leaving modal container
            modalContainer.addEventListener('mouseleave', () => {
                hideExitTooltip();
                
                // Reset modal position
                const iframe = modalContainer.querySelector('iframe');
                if (iframe) {
                    iframe.style.transform = 'translateY(0)';
                }
            });
        }
    });
    
    // Add escape key handler
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
            const modalContainer = document.getElementById('visualization-modal-container');
            if (modalContainer && modalContainer.classList.contains('visible')) {
                closeVisualizationModal();
            }
        }
    });
    
    // Add click handler to close modal when clicking outside
    document.addEventListener('click', (event) => {
        const modalContainer = document.getElementById('visualization-modal-container');
        if (modalContainer && modalContainer.classList.contains('visible')) {
            // Check if click is directly on the modal container (not its children)
            if (event.target === modalContainer) {
                closeVisualizationModal();
            }
        }
    });

    // Page switching functions
    function showConversationsPage() {
        document.getElementById('playground-container').style.display = 'none';
        document.getElementById('timeline-grid-wrapper').style.display = 'block';
        
        console.log('📄 Switched to conversations page');
    }
    
    // Open live visualization in new window/tab
    function openLiveVisualization() {
        console.log('🎬 Opening Live Visualization...');
        
        // Open in new window for better performance
        const liveVizWindow = window.open(
            'live_visualization.html',
            'LiveVisualization',
            'width=1200,height=800,scrollbars=no,resizable=yes,status=no,toolbar=no,menubar=no'
        );
        
        if (liveVizWindow) {
            // Send start message after window loads
            setTimeout(() => {
                try {
                    liveVizWindow.postMessage({ type: 'start-live-visualization' }, '*');
                } catch (error) {
                    console.log('Could not send start message to live visualization window');
                }
            }, 1000);
        } else {
            // Fallback: open in same window if popup blocked
            window.location.href = 'live_visualization.html';
        }
    }
    
    // Make function globally available
    window.openLiveVisualization = openLiveVisualization;
    
        // Conversation Wizard functions
    function showConversationWizardAndStartRecording() {
        try {
            console.log('🔄 Starting showConversationWizardAndStartRecording...');
            
            // First show the conversation wizard
            showConversationWizard();
            
            // Wait for the iframe to load, then show the grid first
            setTimeout(() => {
                const wizardIframe = document.getElementById('conversation-wizard-iframe');
                if (wizardIframe && wizardIframe.contentWindow) {
                    try {
                        // Call the showGrid function in the iframe to show the placeholder grid
                        wizardIframe.contentWindow.showGrid();
                        console.log('✅ Started with grid page in wizard');
                    } catch (error) {
                        console.error('❌ Error showing grid in wizard:', error);
                    }
                } else {
                    console.error('❌ Wizard iframe not ready yet');
                }
            }, 1000); // Wait 1 second for iframe to load
            
        } catch (error) {
            console.error('❌ Error in showConversationWizardAndStartRecording:', error);
        }
    }
    
    function showConversationWizardAndGoToMicrophone() {
        try {
            console.log('🔄 Starting showConversationWizardAndGoToMicrophone...');
            
            // First show the conversation wizard
            showConversationWizard();
            
            // Wait for the iframe to load, then go directly to microphone interface
            setTimeout(() => {
                const wizardIframe = document.getElementById('conversation-wizard-iframe');
                if (wizardIframe && wizardIframe.contentWindow) {
                    try {
                        // Call the showQuestionnaire function in the iframe to go directly to microphone
                        wizardIframe.contentWindow.showQuestionnaire();
                        console.log('✅ Started with microphone interface in wizard');
                    } catch (error) {
                        console.error('❌ Error starting microphone interface:', error);
                    }
                } else {
                    console.error('❌ Wizard iframe not ready yet');
                }
            }, 1000); // Wait 1 second for iframe to load
            
        } catch (error) {
            console.error('❌ Error in showConversationWizardAndGoToMicrophone:', error);
        }
    }
    
    function showConversationWizard() {
        try {
            console.log('🔄 Starting showConversationWizard...');
            
            const wizardPage = document.getElementById('conversation-wizard-page');
            const wizardIframe = document.getElementById('conversation-wizard-iframe');
            const aboutPage = document.getElementById('about-page');
            const emotionsPage = document.getElementById('emotions-page');
            const mainContent = document.getElementById('timeline-grid-wrapper');
            const bottomControls = document.getElementById('bottom-controls-container');
            
            // Reset conversation wizard to grid page
            if (wizardIframe && wizardIframe.contentWindow && typeof wizardIframe.contentWindow.showGrid === 'function') {
                try {
                    console.log('🔄 Resetting conversation wizard to grid page...');
                    wizardIframe.contentWindow.showGrid();
                } catch (error) {
                    console.log('⚠️ Could not reset wizard state (iframe not ready):', error.message);
                }
            }
            
            console.log('🔍 Element check:');
            console.log('  - wizardPage:', !!wizardPage);
            console.log('  - wizardIframe:', !!wizardIframe);
            console.log('  - aboutPage:', !!aboutPage);
            console.log('  - mainContent:', !!mainContent);
            console.log('  - bottomControls:', !!bottomControls);
            
            // Hide other pages
            if (aboutPage && aboutPage.style.display === 'block') {
                aboutPage.style.display = 'none';
                console.log('✅ Hidden about page');
            }
            
            if (emotionsPage && emotionsPage.style.display === 'block') {
                emotionsPage.style.display = 'none';
                console.log('✅ Hidden emotions page');
            }
            
            if (mainContent) {
                mainContent.style.display = 'none';
                console.log('✅ Hidden main content');
            } else {
                console.error('❌ Main content element not found');
            }
            
            if (bottomControls) {
                bottomControls.style.display = 'none';
                bottomControls.style.visibility = 'hidden';
                console.log('✅ Hidden bottom controls');
            } else {
                console.error('❌ Bottom controls element not found');
            }
            
            // Show wizard page
            if (wizardPage && wizardIframe) {
                console.log('📦 Showing wizard page...');
                wizardPage.style.display = 'block';
                
                // Check current iframe src
                console.log('🔗 Current iframe src:', wizardIframe.src);
                
                // Load the wizard iframe if not already loaded
                const expectedSrc = window.location.origin + '/frontend/conversation_wizard.html';
                if (!wizardIframe.src || wizardIframe.src === '' || wizardIframe.src !== expectedSrc) {
                    console.log('📡 Loading conversation wizard iframe:', expectedSrc);
                    wizardIframe.src = expectedSrc;
                    
                    // Add load event listener
                    wizardIframe.onload = function() {
                        console.log('✅ Wizard iframe loaded successfully');
                        // Ensure wizard starts in grid state
                        setTimeout(() => {
                            if (wizardIframe.contentWindow && typeof wizardIframe.contentWindow.showGrid === 'function') {
                                try {
                                    console.log('🔄 Ensuring wizard starts in grid state...');
                                    wizardIframe.contentWindow.showGrid();
                                } catch (error) {
                                    console.log('⚠️ Could not reset wizard state on load:', error.message);
                                }
                            }
                        }, 100);
                    };
                    
                    wizardIframe.onerror = function() {
                        console.error('❌ Wizard iframe failed to load');
                    };
                } else {
                    console.log('📡 Wizard iframe already loaded');
                }
                
                console.log('✅ Shown conversation wizard container');
            } else {
                console.error('❌ Conversation wizard elements not found - wizardPage:', !!wizardPage, 'wizardIframe:', !!wizardIframe);
                return;
            }
            
            // Update navigation active state
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active-nav');
            });
            // Find and activate the wizard navigation link
            const wizardLink = document.querySelector('.nav-link[onclick*="showConversationWizard"]');
            if (wizardLink) {
                wizardLink.classList.add('active-nav');
                console.log('✅ Updated navigation to conversation wizard');
            } else {
                console.error('❌ Conversation wizard navigation link not found');
            }
            
            // Show the new conversation button
            const newConversationBtn = document.getElementById('new-conversation-btn');
            if (newConversationBtn) {
                newConversationBtn.style.display = 'block';
                console.log('✅ Showed new conversation button');
            } else {
                console.error('❌ New conversation button not found');
            }
            
            console.log('✅ showConversationWizard completed successfully');
        } catch (error) {
            console.error('❌ Error in showConversationWizard:', error);
            console.error('❌ Error stack:', error.stack);
        }
    }

    // About page functions
    function showAboutPage() {
        try {
            console.log('🔄 Showing about page...');
            const aboutPage = document.getElementById('about-page');
            const wizardPage = document.getElementById('conversation-wizard-page');
            const emotionsPage = document.getElementById('emotions-page');
            const mainContent = document.getElementById('timeline-grid-wrapper');
            const bottomControls = document.getElementById('bottom-controls-container');
            
            // Hide wizard page if it's visible
            if (wizardPage && wizardPage.style.display === 'block') {
                wizardPage.style.display = 'none';
                console.log('✅ Hidden conversation wizard');
            }
            
            // Hide emotions page if it's visible
            if (emotionsPage && emotionsPage.style.display === 'block') {
                emotionsPage.style.display = 'none';
                console.log('✅ Hidden emotions page');
            }
            
            if (aboutPage) {
                aboutPage.style.display = 'block';
                console.log('✅ Shown about page');
                
                if (mainContent) {
                    mainContent.style.display = 'none';
                    console.log('✅ Hidden main content');
                } else {
                    console.error('❌ Main content element not found');
                }
                
                if (bottomControls) {
                    bottomControls.style.display = 'none';
                    bottomControls.style.visibility = 'hidden';
                    console.log('✅ Hidden bottom controls');
                } else {
                    console.error('❌ Bottom controls element not found');
                }
                
                // Keep navigation visible by not hiding the header
                // The header will remain visible since we're not hiding it
                
                // Update navigation active state
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active-nav');
                });
                // Find and activate the about page navigation link
                const aboutLink = document.querySelector('.nav-link[onclick*="showAboutPage"]');
                if (aboutLink) {
                    aboutLink.classList.add('active-nav');
                    console.log('✅ Updated navigation to about page');
                } else {
                    console.error('❌ About page navigation link not found');
                }
                
                // Hide the new conversation button
                const newConversationBtn = document.getElementById('new-conversation-btn');
                if (newConversationBtn) {
                    newConversationBtn.style.display = 'none';
                    console.log('✅ Hidden new conversation button');
                }
                console.log('✅ About page shown successfully');
            } else {
                console.error('❌ About page element not found');
            }
        } catch (error) {
            console.error('❌ Error in showAboutPage:', error);
        }
    }
    

    

    

    
    // Function to recalculate emotions grid layout on resize
    function recalculateEmotionsGrid() {
        const emotionsGrid = document.getElementById('emotions-grid');
        const emotionsPageContainer = document.getElementById('emotions-page');
        
        if (!emotionsGrid || !emotionsPageContainer || emotionsPageContainer.style.display === 'none') {
            return;
        }
        
        const emotionCards = emotionsGrid.querySelectorAll('.emotion-emoji-card');
        if (emotionCards.length === 0) return;
        
        // Get available dimensions
        const containerHeight = emotionsPageContainer.clientHeight - 20;
        const gridContainer = emotionsGrid.parentElement;
        const gridWidth = gridContainer.clientWidth - 10;
        const gridHeight = containerHeight;
        
        // Calculate optimal grid configuration
        const emotionCount = emotionCards.length;
        const aspectRatio = gridWidth / gridHeight;
        
        // Find optimal columns and rows to fit all emotions
        let optimalCols = Math.ceil(Math.sqrt(emotionCount * aspectRatio));
        let optimalRows = Math.ceil(emotionCount / optimalCols);
        
        // Ensure grid fits within available space
        const minItemSize = 25;
        const maxItemSize = 50;
        
        const itemSizeByWidth = Math.min(maxItemSize, Math.max(minItemSize, (gridWidth - (optimalCols - 1) * 2) / optimalCols));
        const itemSizeByHeight = Math.min(maxItemSize, Math.max(minItemSize, (gridHeight - (optimalRows - 1) * 2) / optimalRows));
        
        const finalItemSize = Math.min(itemSizeByWidth, itemSizeByHeight);
        
        // Recalculate columns based on final item size
        optimalCols = Math.floor(gridWidth / (finalItemSize + 2));
        optimalRows = Math.ceil(emotionCount / optimalCols);
        
        // Ensure we don't exceed available height
        while (optimalRows * (finalItemSize + 2) > gridHeight && optimalCols < emotionCount) {
            optimalCols++;
            optimalRows = Math.ceil(emotionCount / optimalCols);
        }
        
        // Apply calculated grid layout
        emotionsGrid.style.gridTemplateColumns = `repeat(${optimalCols}, ${finalItemSize}px)`;
        emotionsGrid.style.gridTemplateRows = `repeat(${optimalRows}, ${finalItemSize}px)`;
        
        // Update emotion card sizes
        emotionCards.forEach(card => {
            card.style.width = `${finalItemSize}px`;
            card.style.height = `${finalItemSize}px`;
            card.style.minHeight = `${finalItemSize}px`;
            card.style.fontSize = `${Math.max(12, finalItemSize * 0.4)}px`;
        });
        
        // Also adjust emotions labels list to fit without scrolling
        const emotionsLabels = document.getElementById('emotions-labels');
        const emotionsLabelsList = document.getElementById('emotions-labels-list');
        if (emotionsLabels && emotionsLabelsList) {
            const labelItems = emotionsLabelsList.querySelectorAll('.emotion-label-item');
            if (labelItems.length > 0) {
                const availableHeight = emotionsLabels.clientHeight - 50; // Account for header
                const itemsCount = labelItems.length;
                const maxItemHeight = Math.max(30, Math.floor(availableHeight / itemsCount) - 2); // 2px for gap
                
                labelItems.forEach(item => {
                    if (maxItemHeight < 40) {
                        // Compact mode for many emotions
                        item.style.padding = '4px 8px';
                        item.style.fontSize = '10px';
                        const spans = item.querySelectorAll('span');
                        spans.forEach((span, index) => {
                            if (index === 0) span.style.fontSize = '12px'; // emoji
                            if (index === 1) span.style.fontSize = '10px'; // Hebrew text
                        });
                    } else {
                        // Normal mode
                        item.style.padding = '8px 12px';
                        item.style.fontSize = '12px';
                    }
                });
            }
        }
    }
    
    // Function to show emotion sidebar with detailed information
    function showEmotionSidebar(emotionKey, emotionConfig, popularityData) {
        const sidebar = document.getElementById('emotions-sidebar');
        const title = document.getElementById('emotion-sidebar-title');
        const subtitle = document.getElementById('emotion-sidebar-subtitle');
        
        if (!sidebar || !title || !subtitle) return;
        
        // Store current emotion for use in other functions
        currentSelectedEmotion = emotionKey;
        
        // Update header
        title.innerHTML = `${emotionConfig.emoji} ${emotionConfig.hebrew}`;
        subtitle.innerHTML = popularityData ? `דירוג ${popularityData.rank} מתוך ${Object.keys(emotionAnalysisData.emotions).length}` : 'ללא נתונים';
        
        // Show sidebar
        sidebar.style.display = 'flex';
        
        // Hide the emotions labels panel when detailed sidebar is shown
        const emotionsLabels = document.getElementById('emotions-labels');
        if (emotionsLabels) {
            emotionsLabels.style.display = 'none';
        }
        
        // Adjust main pyramid container to full width when sidebar is shown
        const emotionsPyramidContainer = document.querySelector('#emotions-page > div > div:first-child');
        if (emotionsPyramidContainer) {
            emotionsPyramidContainer.style.maxWidth = '100%';
            emotionsPyramidContainer.style.paddingRight = '35%';
        }
        
        // Reset to stats tab
        document.querySelectorAll('.emotion-sidebar-tab').forEach(t => {
            t.classList.remove('active');
            t.style.color = '#6c757d';
            t.style.borderBottomColor = 'transparent';
            t.style.fontWeight = '500';
        });
        document.querySelectorAll('.emotion-tab-content').forEach(content => {
            content.style.display = 'none';
        });
        
        // Activate stats tab
        const statsTab = document.querySelector('.emotion-sidebar-tab[data-tab="stats"]');
        const statsContent = document.getElementById('emotion-stats-content');
        if (statsTab && statsContent) {
            statsTab.classList.add('active');
            statsTab.style.color = '#2c3e50';
            statsTab.style.borderBottomColor = '#171717';
            statsTab.style.fontWeight = '600';
            statsContent.style.display = 'block';
        }
        
        // Load initial tab content
        loadEmotionStats(emotionKey, emotionConfig, popularityData);
        
        console.log('✅ Emotion sidebar shown for:', emotionKey);
    }
    
    // Function to set up sidebar event handlers
    function setupEmotionSidebar() {
        // Tab switching
        document.querySelectorAll('.emotion-sidebar-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs
                document.querySelectorAll('.emotion-sidebar-tab').forEach(t => {
                    t.classList.remove('active');
                    t.style.color = '#6c757d';
                    t.style.borderBottomColor = 'transparent';
                    t.style.fontWeight = '500';
                });
                
                // Hide all tab contents
                document.querySelectorAll('.emotion-tab-content').forEach(content => {
                    content.style.display = 'none';
                });
                
                // Activate clicked tab
                tab.classList.add('active');
                tab.style.color = '#2c3e50';
                tab.style.borderBottomColor = '#171717';
                tab.style.fontWeight = '600';
                
                // Show corresponding content
                const tabId = tab.getAttribute('data-tab');
                const content = document.getElementById(`emotion-${tabId}-content`);
                if (content) {
                    content.style.display = 'block';
                }
                
                // Load tab-specific content
                const activeEmotion = document.getElementById('emotion-sidebar-title').textContent.split(' ').slice(1).join(' ');
                loadEmotionTabContent(tabId, activeEmotion);
            });
        });
        
        // Close button
        const closeBtn = document.getElementById('emotions-sidebar-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                const sidebar = document.getElementById('emotions-sidebar');
                if (sidebar) {
                    sidebar.style.display = 'none';
                    
                    // Restore emotions labels panel
                    const emotionsLabels = document.getElementById('emotions-labels');
                    if (emotionsLabels) {
                        emotionsLabels.style.display = 'block';
                    }
                    
                    // Restore pyramid container to original state
                    const emotionsPyramidContainer = document.querySelector('#emotions-page > div > div:first-child');
                    if (emotionsPyramidContainer) {
                        emotionsPyramidContainer.style.maxWidth = '60%';
                        emotionsPyramidContainer.style.paddingRight = '0';
                    }
                }
            });
        }
    }
    
    // Function to load emotion statistics
    function loadEmotionStats(emotionKey, emotionConfig, popularityData) {
        const statsContainer = document.getElementById('emotion-stats-data');
        if (!statsContainer) return;
        
        if (!popularityData) {
            statsContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">אין נתונים זמינים</div>';
            return;
        }
        
        const totalEmotions = emotionAnalysisData.totalEmotions;
        const totalConversations = emotionAnalysisData.totalConversations;
        
        statsContainer.innerHTML = `
            <div style="text-align: center; margin-bottom: 20px;">
                <div style="font-size: 32px; margin-bottom: 10px;">${emotionConfig.emoji}</div>
                <div style="font-size: 18px; font-weight: 600; color: #2c3e50; margin-bottom: 5px;">${emotionConfig.hebrew}</div>
                <div style="font-size: 14px; color: #6c757d;">דירוג ${popularityData.rank}</div>
            </div>
            
            <div style="background: white; border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid #e0e0e0;">
                <div style="font-size: 14px; font-weight: 600; color: #2c3e50; margin-bottom: 10px;">סטטיסטיקות כלליות</div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span style="color: #6c757d;">סה"כ הופעות:</span>
                    <span style="font-weight: 600;">${popularityData.count}</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span style="color: #6c757d;">אחוז מכלל הרגשות:</span>
                    <span style="font-weight: 600;">${popularityData.percentage}%</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #6c757d;">שיחות עם הרגש:</span>
                    <span style="font-weight: 600;">${popularityData.conversationCount} מתוך ${totalConversations}</span>
                </div>
            </div>
            
            <div style="background: white; border-radius: 8px; padding: 15px; border: 1px solid #e0e0e0;">
                <div style="font-size: 14px; font-weight: 600; color: #2c3e50; margin-bottom: 10px;">התפלגות</div>
                <div style="background: #f8f9fa; border-radius: 4px; padding: 10px;">
                    <div style="width: 100%; height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden;">
                        <div style="width: ${popularityData.percentage}%; height: 100%; background: ${emotionConfig.color}; transition: width 0.3s ease;"></div>
                    </div>
                    <div style="font-size: 12px; color: #6c757d; margin-top: 5px; text-align: center;">${popularityData.percentage}% מכלל הרגשות</div>
                </div>
            </div>
        `;
    }
    
    // Function to load tab-specific content
    function loadEmotionTabContent(tabId, emotionHebrew) {
        if (tabId === 'conversations') {
            loadEmotionConversations(emotionHebrew);
        } else if (tabId === 'insights') {
            loadEmotionInsights(emotionHebrew);
        }
    }
    
    // Global variable to store current selected emotion for sidebar
    let currentSelectedEmotion = null;
    
    // Function to load conversations containing this emotion
    function loadEmotionConversations(emotionHebrew) {
        const conversationsContainer = document.getElementById('emotion-conversations-data');
        if (!conversationsContainer || !emotionAnalysisData || !currentSelectedEmotion) return;
        
        const emotionData = emotionAnalysisData.emotions[currentSelectedEmotion.toLowerCase()];
        
        if (!emotionData) {
            conversationsContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">לא נמצאו שיחות</div>';
            return;
        }
        
        const conversations = emotionData.conversations || [];
        
        if (conversations.length === 0) {
            conversationsContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">לא נמצאו שיחות</div>';
            return;
        }
        
        let conversationsHtml = '';
        conversations.forEach(convoId => {
            const details = emotionAnalysisData.conversationDetails[convoId];
            const title = details?.participants || convoId;
            const date = details?.date || 'לא ידוע';
            
            conversationsHtml += `
                <div style="background: white; border-radius: 8px; padding: 15px; margin-bottom: 10px; border: 1px solid #e0e0e0; cursor: pointer;" onclick="openConversation('${convoId}')">
                    <div style="font-weight: 600; color: #2c3e50; margin-bottom: 5px;">${title}</div>
                    <div style="font-size: 12px; color: #6c757d;">תאריך: ${date}</div>
                    <div style="font-size: 12px; color: #6c757d;">מזהה: ${convoId}</div>
                </div>
            `;
        });
        
        conversationsContainer.innerHTML = conversationsHtml;
    }
    
    // Function to load emotion insights
    function loadEmotionInsights(emotionHebrew) {
        const insightsContainer = document.getElementById('emotion-insights-data');
        if (!insightsContainer) return;
        
        // Generate insights based on emotion data
        insightsContainer.innerHTML = `
            <div style="background: white; border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid #e0e0e0;">
                <div style="font-size: 14px; font-weight: 600; color: #2c3e50; margin-bottom: 10px;">תובנות על הרגש</div>
                <div style="font-size: 13px; color: #555; line-height: 1.5;">
                    הרגש "${emotionHebrew}" מופיע בדפוסים מעניינים במהלך השיחות. 
                    ניתן לראות את ההשפעה שלו על הדינמיקה הכללית של השיחה.
                </div>
            </div>
            
            <div style="background: white; border-radius: 8px; padding: 15px; border: 1px solid #e0e0e0;">
                <div style="font-size: 14px; font-weight: 600; color: #2c3e50; margin-bottom: 10px;">המלצות</div>
                <div style="font-size: 13px; color: #555; line-height: 1.5;">
                    • שימו לב לתדירות הופעת הרגש<br>
                    • בדקו קשרים לרגשות אחרים<br>
                    • נתחו את ההקשר של השיחות
                </div>
            </div>
        `;
    }
    
    // Function to open a specific conversation
    function openConversation(convoId) {
        // Close the emotions page and open the conversation
        hideEmotionsPage();
        
        // Navigate to the specific conversation in the main view
        if (typeof window.loadConversation === 'function') {
            window.loadConversation(convoId);
        } else {
            console.log('📖 Open conversation:', convoId);
        }
    }
    
    // Function to hide emotions page and return to main view
    function hideEmotionsPage() {
        const emotionsPage = document.getElementById('emotions-page');
        const mainContent = document.getElementById('timeline-grid-wrapper');
        const bottomControls = document.getElementById('bottom-controls-container');
        
        if (emotionsPage) {
            emotionsPage.style.display = 'none';
            console.log('✅ Hidden emotions page');
        }
        
            if (mainContent) {
                mainContent.style.display = 'block';
            console.log('✅ Shown main content');
            }
            
            if (bottomControls) {
                bottomControls.style.display = 'flex';
                bottomControls.style.visibility = 'visible';
            console.log('✅ Shown bottom controls');
        }
        
        // Update navigation active state back to conversations
        document.querySelectorAll('.nav-link').forEach(link => {
            link.classList.remove('active-nav');
        });
        const conversationsLink = document.querySelector('.nav-link[onclick*="showConversationsPage"]');
        if (conversationsLink) {
            conversationsLink.classList.add('active-nav');
            console.log('✅ Updated navigation back to conversations');
        }
    }
    
    // Function to set up navigation event handlers for emotions page
    function setupEmotionsPageNavigation() {
        console.log('🔄 Emotions page navigation setup - using main header navigation');
        // Since we removed the bottom navigation buttons from emotions page,
        // navigation now happens through the main header navigation
        // No additional setup needed - main navigation handlers will work
        console.log('✅ Emotions page navigation relies on main header navigation');
    }
    
    // Function to show timeline view
    function showTimelineView() {
        console.log('🔄 Switching to timeline view');
        const previousLayout = window.activeLayout;
        window.activeLayout = 'timeline';
        console.log(`📅 DEBUG: activeLayout set to ${window.activeLayout}`);
        
        // CONDITIONAL FIX: Only clear timeline cache when switching FROM other views TO timeline
        // This preserves timeline layout integrity when already in timeline view
        if (previousLayout && previousLayout !== 'timeline' && layoutPositions && layoutPositions.timeline) {
            console.log(`🗑️ Clearing cached timeline positions due to switch from ${previousLayout} to timeline`);
            layoutPositions.timeline = null;
        } else if (previousLayout === 'timeline') {
            console.log('✅ Already in timeline view - preserving cached positions');
        }
        
        // Reset isotope instances only when coming from other views
        if (previousLayout && previousLayout !== 'timeline') {
            const layoutCanvas = document.getElementById('layout-canvas');
            if (layoutCanvas && layoutCanvas.isotope) {
                console.log('🧹 Destroying isotope instance before timeline view');
                layoutCanvas.isotope.destroy();
            }
        }
        
        // Update view toggle buttons
        document.querySelectorAll('.view-toggle-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.getElementById('timeline-view-btn')?.classList.add('active');
        
        // Trigger layout rendering with small delay to ensure CSS classes are applied
        setTimeout(() => {
            // ADDITIONAL CLEANUP: Ensure body classes are clean before timeline calculation
            if (previousLayout === 'emotions') {
                document.body.classList.remove('layout-emotions');
                document.body.className = 'layout-timeline';
                console.log('🎭➡️📅 Final body class cleanup for emotions→timeline transition');
                
                // Force another reflow after body class change
                const layoutCanvas = document.getElementById('layout-canvas');
                if (layoutCanvas) {
                    layoutCanvas.offsetHeight;
                    console.log(`📐 Post-cleanup canvas dimensions: ${layoutCanvas.offsetWidth}x${layoutCanvas.offsetHeight}`);
                }
            }
            
            // Ensure conversation data is loaded before rendering timeline
            if (!window.originalConversationData || window.originalConversationData.length === 0) {
                console.log('📅 Timeline view: Waiting for conversation data to load...');
                
                // Wait for data to be loaded
                const waitForData = () => {
                    if (window.originalConversationData && window.originalConversationData.length > 0) {
                        console.log('📅 Timeline view: Conversation data loaded, rendering layout');
                        if (typeof window.renderNewLayout === 'function') {
                            window.renderNewLayout(false);
                        }
                    } else {
                        setTimeout(waitForData, 100); // Check again in 100ms
                    }
                };
                waitForData();
            } else {
                if (typeof window.renderNewLayout === 'function') {
                    window.renderNewLayout(false);
                }
            }
            
            // Ensure timeline date labels exist after render
            setTimeout(() => {
                const existingLabels = document.querySelectorAll('.timeline-date-label-protected');
                if (existingLabels.length === 0 && window.activeLayout === 'timeline') {
                    console.log('📅 Timeline labels missing after view switch - forcing re-render');
                    if (layoutPositions && layoutPositions.timeline) {
                        layoutPositions.timeline = null; // Clear cache to force recreation
                    }
                    if (window.originalConversationData && window.originalConversationData.length > 0) {
                        window.renderNewLayout(false); // Re-render to recreate labels
                    }
                }
            }, 200);
        }, 50); // Small delay to ensure CSS has fully applied
    }
    
    // Function to show people view
    function showPeopleView() {
        console.log('🔄 Switching to people view');
        window.activeLayout = 'people';
        
        // Update view toggle buttons
        document.querySelectorAll('.view-toggle-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.getElementById('people-view-btn')?.classList.add('active');
        
        // Trigger layout rendering
        if (typeof window.renderNewLayout === 'function') {
            window.renderNewLayout(false);
        }
    }
    
    // Reusable function to reset conversations to fresh state
    async function resetConversationsToFreshState() {
        console.log('🔄 Resetting conversations to fresh state like page refresh...');
        
        // Reset to timeline view (default state)
        window.activeLayout = 'timeline';
        
        // Reset view toggle buttons to timeline
        document.querySelectorAll('.view-toggle-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.getElementById('timeline-view-btn')?.classList.add('active');
        
        // Reset camera/zoom state
        if (typeof window.resetCamera === 'function') {
            window.resetCamera();
        }
        
        // Complete reset of all state variables
        if (window.layoutPositions) {
            window.layoutPositions = {
                timeline: {},
                people: {},
                emotions: {}
            };
        }
        
        // FORCE CLEAR EMOTIONS CACHE: Ensure emotions layout is always fresh
        console.log('🎭 Clearing emotions cache for fresh layout calculation');
        
        // Reset layout rendering flag
        if (typeof window.isLayoutRendering !== 'undefined') {
            window.isLayoutRendering = false;
        }
        
        // Clear any timeouts
        if (window.layoutRenderTimeout) {
            clearTimeout(window.layoutRenderTimeout);
            window.layoutRenderTimeout = null;
        }
        
        // Reset body classes
        document.body.className = '';
        
        // Reset layout canvas completely
        const layoutCanvas = document.getElementById('layout-canvas');
        if (layoutCanvas) {
            // Preserve timeline date labels if we're in timeline view
            const existingLabels = layoutCanvas.querySelectorAll('.timeline-date-label-protected');
            const savedLabels = Array.from(existingLabels).map(label => label.cloneNode(true));
            
            // Clear all styles and classes
            layoutCanvas.className = '';
            layoutCanvas.style.cssText = '';
            layoutCanvas.innerHTML = '';
            
            // Restore timeline date labels if we were preserving them
            if (window.activeLayout === 'timeline') {
                savedLabels.forEach(label => layoutCanvas.appendChild(label));
            }
            
            // Force proper canvas height
            layoutCanvas.style.setProperty('height', 'calc(100vh - 120px)', 'important');
            layoutCanvas.style.setProperty('min-height', '800px', 'important');
            layoutCanvas.style.setProperty('overflow-y', 'auto', 'important');
            layoutCanvas.style.setProperty('overflow-x', 'hidden', 'important');
            layoutCanvas.style.setProperty('scrollbar-width', 'none', 'important');
            layoutCanvas.style.setProperty('-ms-overflow-style', 'none', 'important');
            layoutCanvas.style.setProperty('position', 'relative', 'important');
            
            // Force reflow
            layoutCanvas.offsetHeight;
        }
        
        // Reset grid container classes
        const gridContainer = document.getElementById('timeline-axes-container');
        if (gridContainer) {
            gridContainer.className = '';
        }
        
        // CRITICAL: Use populateConversationGrid like initial page load
        if (window.populateConversationGrid) {
            console.log('🎬 Running complete conversation grid population like page load...');
            setTimeout(async () => {
                try {
                    await window.populateConversationGrid();
                    console.log('✅ Fresh conversation grid populated successfully');
                } catch (error) {
                    console.error('❌ Error during conversation grid population:', error);
                    // Fallback to renderNewLayout
                    if (window.renderNewLayout) {
                        window.renderNewLayout(true);
                    }
                }
            }, 100);
        } else if (window.renderNewLayout) {
            console.log('🎬 Fallback: Using renderNewLayout...');
            setTimeout(() => {
                window.renderNewLayout(true);
            }, 100);
        }
        
        console.log('✅ Conversations reset to fresh state initiated');
    }

    async function hideAboutPage() {
        console.log('🔄 Hiding about page and returning to conversations...');
        // Simply call showConversationsPage which will handle everything
        await showConversationsPage();
    }
    
    // Enhanced showConversationsPage function with fresh state reset
    async function showConversationsPage() {
        try {
            console.log('🔄 Starting showConversationsPage...');
            
            const aboutPage = document.getElementById('about-page');
            const wizardPage = document.getElementById('conversation-wizard-page');
            const mainContent = document.getElementById('timeline-grid-wrapper');
            const bottomControls = document.getElementById('bottom-controls-container');
            
            // Hide about page if it's visible
            if (aboutPage && aboutPage.style.display === 'block') {
                aboutPage.style.display = 'none';
                console.log('✅ Hidden about page');
            }
            
            // Hide wizard page if it's visible
            if (wizardPage && wizardPage.style.display === 'block') {
                wizardPage.style.display = 'none';
                console.log('✅ Hidden conversation wizard');
            }
            
            // Hide about page if it's visible
            if (aboutPage && aboutPage.style.display === 'block') {
                aboutPage.style.display = 'none';
                console.log('✅ Hidden about page');
            }
            
            // Show main content
            if (mainContent) {
                mainContent.style.display = 'block';
                console.log('✅ Shown main content from showConversationsPage');
            } else {
                console.error('❌ Main content element not found');
            }
            
            if (bottomControls) {
                bottomControls.style.display = 'flex';
                bottomControls.style.visibility = 'visible';
                console.log('✅ Shown bottom controls from showConversationsPage');
            } else {
                console.error('❌ Bottom controls element not found');
            }
            
            // Update navigation active state first
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active-nav');
            });
            // Find and activate the conversations navigation link
            const conversationsLink = document.querySelector('.nav-link[onclick*="showConversationsPage"]');
            if (conversationsLink) {
                conversationsLink.classList.add('active-nav');
                console.log('✅ Updated navigation state');
            } else {
                console.error('❌ Conversations navigation link not found');
            }
            
            // Hide the new conversation button
            const newConversationBtn = document.getElementById('new-conversation-btn');
            if (newConversationBtn) {
                newConversationBtn.style.display = 'none';
                console.log('✅ Hidden new conversation button');
            }
            
            // RESET TO FRESH STATE: Do this asynchronously to not block navigation
            setTimeout(async () => {
                try {
                    await resetConversationsToFreshState();
                    console.log('✅ Background reset completed');
                } catch (error) {
                    console.error('❌ Error in background reset:', error);
                }
            }, 100);
            
            console.log('✅ showConversationsPage completed successfully');
        } catch (error) {
            console.error('❌ Error in showConversationsPage:', error);
        }
    }
    
    // Debug function for testing navigation
    function debugNavigation() {
        console.log('🔍 DEBUG: Navigation Elements Check');
        
        const aboutPage = document.getElementById('about-page');
        const wizardPage = document.getElementById('conversation-wizard-page');
        const mainContent = document.getElementById('timeline-grid-wrapper');
        const bottomControls = document.getElementById('bottom-controls-container');
        const conversationsLink = document.querySelector('.nav-link[onclick*="showConversationsPage"]');
        const wizardLink = document.querySelector('.nav-link[onclick*="showConversationWizard"]');
        const aboutLink = document.querySelector('.nav-link[onclick*="showAboutPage"]');
        
        console.log('📄 About Page Element:', aboutPage ? '✅ Found' : '❌ Missing', aboutPage);
        console.log('📄 Wizard Page Element:', wizardPage ? '✅ Found' : '❌ Missing', wizardPage);
        console.log('📄 Main Content Element:', mainContent ? '✅ Found' : '❌ Missing', mainContent);
        console.log('📄 Bottom Controls Element:', bottomControls ? '✅ Found' : '❌ Missing', bottomControls);
        console.log('🔗 Conversations Link:', conversationsLink ? '✅ Found' : '❌ Missing', conversationsLink);
        console.log('🔗 Wizard Link:', wizardLink ? '✅ Found' : '❌ Missing', wizardLink);
        console.log('🔗 About Link:', aboutLink ? '✅ Found' : '❌ Missing', aboutLink);
        
        if (aboutPage) {
            console.log('📄 About Page Display:', aboutPage.style.display);
        }
        if (wizardPage) {
            console.log('📄 Wizard Page Display:', wizardPage.style.display);
        }
        if (mainContent) {
            console.log('📄 Main Content Display:', mainContent.style.display);
        }
        if (bottomControls) {
            console.log('📄 Bottom Controls Display:', bottomControls.style.display);
        }
        
        // Test functions
        console.log('🔧 Available Functions:');
        console.log('  - showAboutPage:', typeof window.showAboutPage);
        console.log('  - showConversationWizard:', typeof window.showConversationWizard);
        console.log('  - showConversationsPage:', typeof window.showConversationsPage);
        console.log('  - resetConversationsToFreshState:', typeof window.resetConversationsToFreshState);
        
        return {
            aboutPage: !!aboutPage,
            wizardPage: !!wizardPage,
            mainContent: !!mainContent,
            bottomControls: !!bottomControls,
            conversationsLink: !!conversationsLink,
            wizardLink: !!wizardLink,
            aboutLink: !!aboutLink,
            functionsAvailable: {
                showAboutPage: typeof window.showAboutPage === 'function',
                showConversationWizard: typeof window.showConversationWizard === 'function',
                showConversationsPage: typeof window.showConversationsPage === 'function',
                resetConversationsToFreshState: typeof window.resetConversationsToFreshState === 'function'
            }
        };
    }

    // Test function for conversation wizard
    function testConversationWizard() {
        console.log('🧪 TESTING: Conversation wizard access...');
        
        // Test if file exists
        fetch('/frontend/conversation_wizard.html')
            .then(response => {
                console.log('📁 Wizard file response status:', response.status);
                if (response.ok) {
                    console.log('✅ Conversation wizard file found');
                    return response.text();
                } else {
                    console.error('❌ Conversation wizard file not found');
                    throw new Error(`HTTP ${response.status}`);
                }
            })
            .then(html => {
                console.log('📄 Wizard HTML length:', html.length);
                console.log('✅ Wizard file loaded successfully');
            })
            .catch(error => {
                console.error('❌ Error loading wizard file:', error);
            });
    }

    // Simple version for testing - just does the basic navigation without reset
    function simpleShowConversations() {
        console.log('🔄 SIMPLE: Starting simpleShowConversations...');
        
        const aboutPage = document.getElementById('about-page');
        const emotionsPage = document.getElementById('emotions-page');
        const mainContent = document.getElementById('timeline-grid-wrapper');
        const bottomControls = document.getElementById('bottom-controls-container');
        
        // Hide about page
        if (aboutPage) {
            aboutPage.style.display = 'none';
            console.log('✅ SIMPLE: Hidden about page');
        }
        
        // Hide emotions page
        if (emotionsPage) {
            emotionsPage.style.display = 'none';
            console.log('✅ SIMPLE: Hidden emotions page');
        }
        
        // Hide about page
        if (aboutPage) {
            aboutPage.style.display = 'none';
            console.log('✅ SIMPLE: Hidden about page');
        }
        
        // Show main content
        if (mainContent) {
            mainContent.style.display = 'block';
            console.log('✅ SIMPLE: Shown main content');
        }
        
        // Show bottom controls
        if (bottomControls) {
            bottomControls.style.display = 'flex';
            bottomControls.style.visibility = 'visible';
            console.log('✅ SIMPLE: Shown bottom controls');
        }
        
        // Update navigation
        document.querySelectorAll('.nav-link').forEach(link => {
            link.classList.remove('active-nav');
        });
        const conversationsLink = document.querySelector('.nav-link[onclick*="showConversationsPage"]');
        if (conversationsLink) {
            conversationsLink.classList.add('active-nav');
            console.log('✅ SIMPLE: Updated navigation');
        }
        
        console.log('✅ SIMPLE: Navigation completed successfully');
    }
    
    // Make functions globally available
    window.showAboutPage = showAboutPage;
    window.hideAboutPage = hideAboutPage;
    window.showConversationsPage = showConversationsPage;
    window.showConversationWizard = showConversationWizard;
    window.testConversationWizard = testConversationWizard;
    window.resetConversationsToFreshState = resetConversationsToFreshState;
    window.debugNavigation = debugNavigation;
    window.simpleShowConversations = simpleShowConversations;





    // Initialize animated emotion separators with random emotions
    function initializeEmotionSeparators() {
        const emotionChars = ['●', '◉', '○', '◯', '⬢', '⬡', '◊', '◈', '★', '☆', '✨', '♥', '◦', '•', '∘', '⊙', '⊚', '⊛'];
        const emotionColors = ['#FFD700', '#FF69B4', '#FF8C00', '#87CEEB', '#FFA500', '#DC143C', '#8B008B', '#228B22'];
        
        const separators = document.querySelectorAll('.emotion-separator');
        
        function updateEmotionChar(separator, index) {
            const randomChar = emotionChars[Math.floor(Math.random() * emotionChars.length)];
            const randomColor = emotionColors[Math.floor(Math.random() * emotionColors.length)];
            separator.textContent = randomChar;
            separator.style.color = randomColor;
        }
        
        // Initial setup
        separators.forEach((separator, index) => {
            updateEmotionChar(separator, index);
            
            // Change emotion character every 3-8 seconds randomly
            const interval = 3000 + Math.random() * 5000;
            setInterval(() => updateEmotionChar(separator, index), interval);
        });
    }

    // Initialize emotion separators when page loads
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(initializeEmotionSeparators, 1000); // Wait for page to load
        setTimeout(initializeHeaderEmotionCircles, 1500); // Wait for header to load
        
        // Ensure People view is properly initialized on DOM ready
        setTimeout(() => {
            if (window.activeLayout === 'people' && window.renderNewLayout) {
                // Clear any existing stability check
                if (window.peopleViewStabilityCheck) {
                    clearTimeout(window.peopleViewStabilityCheck);
                }
                
                window.peopleViewStabilityCheck = setTimeout(() => {
                    if (window.renderNewLayout && window.activeLayout === 'people') {
                        console.log('🔄 DOM ready - ensuring People view is properly initialized...');
                        window.renderNewLayout(false);
                    }
                }, 100);
            }
        }, 2000); // Wait for all initialization to complete
    });
    
    // Initialize header logo emotion circles with random emotions
    function initializeHeaderEmotionCircles() {
        const emotionChars = ['●', '◉', '○', '◯', '⬢', '⬡', '◊', '◈', '★', '☆', '✨', '♥', '◦', '•', '∘', '⊙', '⊚', '⊛'];
        const emotionColors = ['#FFD700', '#FF69B4', '#FF8C00', '#87CEEB', '#FFA500', '#DC143C', '#8B008B', '#228B22'];
        
        const logoCircles = document.querySelectorAll('.logo-emotion-circle');
        
        function updateHeaderEmotionChar(circle, index) {
            const randomChar = emotionChars[Math.floor(Math.random() * emotionChars.length)];
            const randomColor = emotionColors[Math.floor(Math.random() * emotionColors.length)];
            circle.textContent = randomChar;
            circle.style.color = randomColor;
        }
        
        // Initial setup
        logoCircles.forEach((circle, index) => {
            updateHeaderEmotionChar(circle, index);
            
            // Change emotion character every 2-6 seconds randomly
            const interval = 2000 + Math.random() * 4000;
            setInterval(() => updateHeaderEmotionChar(circle, index), interval);
        });
        
        console.log('✨ Header emotion circles initialized');
    }
  </script>
  
  <style>
    /* Font Definitions */
    @font-face { font-family: '80k'; src: url('assets/Fonts/80kb_desk/80-kb-Sharp.otf') format('opentype'); font-weight: 400; }
    @font-face { font-family: '80k'; src: url('assets/Fonts/80kb_desk/80-kb-SharpBold.otf') format('opentype'); font-weight: 700; }
    
    /* CSS Variables */
    :root { 
        --main-font-family: 'Miriam Libre', sans-serif;
        --main-bg-color: #f7f9f3;
    }
    
    /* Global font rule - apply Miriam Libre to all elements except logo */
    * {
        font-family: var(--main-font-family) !important;
    }
    
    /* Exception for logo - use Miriam Libre */
    #logo-text {
        font-family: 'Miriam Libre', sans-serif !important;
    }
    
    /* Global Transparency Rules - Consolidated */
    #timeline-grid-wrapper,
    #timeline-axes-container,
    #layout-canvas,
    .layout-timeline #timeline-grid-wrapper,
    .layout-timeline #timeline-axes-container,
    .layout-timeline #layout-canvas,
    .layout-emotions #timeline-grid-wrapper,
    .layout-emotions #timeline-axes-container,
    .layout-people #timeline-grid-wrapper,
    .layout-people #timeline-axes-container,
    .conversation-grid-item-container:hover,
    .person-name-label:hover {
        background: transparent !important;
        background-color: transparent !important;
        background-image: none !important;
    }
    
    /* Global Background Color Rules - Consolidated */
    #splash-screen,
    .mdl-progress > .progressbar,
    .progress-line,
    .analysis-section,
    .control-buttons,
    .loading-indicator {
        background: var(--main-bg-color);
        background-color: var(--main-bg-color);
    }
    /* Base HTML and Body Styles */
    html, body { 
        height: 100%; 
        margin: 0; 
        padding: 0; 
        background: var(--main-bg-color);
        font-family: var(--main-font-family); 
        color: #222; 
        font-size: 14px; 
        overflow: hidden;
    }
    /* Header Styles */
    .app-header { 
        width: 100%; 
        background: var(--main-bg-color); 
        padding: 15px 30px; 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        z-index: 1001; 
        position: fixed; 
        top: 0; 
        left: 0; 
        right: 0; 
        box-sizing: border-box; 
        height: 60px; 
        border-bottom: 1px solid rgba(128, 128, 128, 0.2) !important;
    }
    
    /* Bottom Controls - Zoom LEFT, Views RIGHT */
    #bottom-controls-container { 
        position: fixed; 
        bottom: 0; 
        left: 0; 
        right: 0; 
        background: var(--main-bg-color); 
        z-index: 1001 !important; 
        height: 60px !important; 
        display: flex !important; 
        align-items: center !important; 
        justify-content: space-between !important; /* Space between left and right items */
        box-sizing: border-box !important; 
        border-top: 1px solid rgba(128, 128, 128, 0.2) !important;
        padding: 0 20px !important;
    }
    
    /* Ensure child elements in bottom controls are properly styled and visible */
    #bottom-controls-container * {
        z-index: inherit !important;
        position: relative !important;
    }
    
    /* Style view toggle buttons to be visible on top of grid */
    .view-toggle-buttons {
        display: flex !important;
        align-items: center !important;
        gap: 15px !important;
        z-index: 1002 !important;
    }
    

    
    .view-toggle-btn {
        background: transparent !important;
        padding: 8px 16px !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        font-family: var(--main-font-family) !important;
        font-size: 14px !important;
        z-index: 1002 !important;
    }
    

    
    /* Zoom Controls Styling */
    .zoom-controls {
        display: flex !important;
        align-items: center !important;
        gap: 10px !important;
        z-index: 1002 !important;
        background: #F7F9F2 !important;
        padding: 6px 12px !important;
        border: 1px solid #E5E6E2 !important;
    }
    
    .zoom-btn {
        background: transparent !important;
        border: none !important;
        width: 28px !important;
        height: 28px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        font-size: 12px !important;
        font-weight: 100 !important;
        transition: all 0.2s ease !important;
        color: #333 !important;
        z-index: 1002 !important;
    }
    
    .zoom-btn:hover {
        background: rgba(0,0,0,0.05) !important;
    }
    
    .zoom-indicator {
        font-size: 12px !important;
        color: #666 !important;
        font-weight: 500 !important;
        min-width: 40px !important;
        text-align: center !important;
        z-index: 1002 !important;
    }
    
    /* Ensure all UI panels and overlays stay on top of the grid */
    .retranscribe-panel,
    .mdl-dialog,
    .mdl-tooltip,
    #playground-container,
    #live-visualization-container {
        z-index: 2000 !important;
    }
    .header-title { display: flex; align-items: center; font-size: 24px; font-weight: 400; }
    .header-nav { display: flex; align-items: center; gap: 20px; }
    .nav-link { cursor: pointer; color: #999; padding-bottom: 2px; text-decoration: none; font-size: 14px; border-bottom: 2px solid transparent; transition: color 0.2s, border-bottom-color 0.2s; font-weight: 400; }
    .nav-link:hover { color: #666; }
    .nav-link.active-nav { 
        color: #000 !important; 
        border-bottom: none; 
        position: relative; 
        font-weight: 500;
    }
    .nav-link.active-nav::before { 
        content: '['; 
        margin-right: 3px; 
        color: #000;
        font-weight: normal;
    }
    .nav-link.active-nav::after { 
        content: ']'; 
        margin-left: 3px; 
        color: #000;
        font-weight: normal;
    }
    #timeline-grid-wrapper { position: absolute; top: 60px; left: 0; right: 0; bottom: 0; background: transparent !important; overflow: hidden; display: flex; flex-direction: column; box-sizing: border-box; }
    
    /* Fix timeline-grid-wrapper in people view to prevent double containers */
    body.layout-people #timeline-grid-wrapper {
        position: absolute !important;
        top: 60px !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        background-color: transparent !important;
        overflow: visible !important; /* Change to visible instead of hidden */
        display: block !important; /* Change from flex to block */
        padding: 0 !important;
        margin: 0 !important;
        z-index: 0 !important; /* Behind the layout-canvas */
        width: 100vw !important;
        height: calc(100vh - 60px) !important;
        min-width: 1200px !important;
        min-height: 600px !important;
    }
    #timeline-axes-container { 
        position: relative; 
        flex-grow: 1; 
        min-height: calc(100vh - 120px); /* Use full viewport height minus header/footer */
        height: calc(100vh - 120px); /* Ensure full height */
        padding: 10px; /* Reduced padding for more space */
        box-sizing: border-box; 
        overflow-y: auto;
        overflow-x: hidden;
        /* Hide scrollbar while keeping functionality */
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* Internet Explorer 10+ */
        background: transparent !important; /* Transparent to show body grid */
        background-image: none !important; /* No background patterns */
        background-color: transparent !important; /* Transparent to show body grid */
    }
    
    /* Hide scrollbar for webkit browsers */
    #timeline-axes-container::-webkit-scrollbar {
        display: none;
    }
    
    /* Hide scrollbar for layout canvas webkit browsers */
    #layout-canvas::-webkit-scrollbar {
        display: none;
    }
    
    /* Fix timeline-axes-container in people view to prevent conflicts */
    .layout-people #timeline-axes-container {
        position: relative !important;
        padding: 0 !important; /* Remove padding to prevent positioning conflicts */
        overflow: hidden !important; /* No scrollbar */
        height: 100% !important;
        width: 100% !important;
        background: transparent !important;
        z-index: 0 !important; /* Behind the layout-canvas */
    }

    /* Single Row Grid System - 12 videos in one row with square cells */
    #layout-canvas { 
        position: fixed;
        top: 60px;
        left: 0;
        right: 0;
        bottom: 60px;
        width: 100%;
        height: calc(100vh - 120px);
        display: block; /* Block layout for absolute positioning - prevents overlaps */
        padding-left: 24px !important;
        padding-right: 24px !important;
        box-sizing: border-box;
        background: transparent !important; /* Transparent so body grid shows through */
        border: none;
        border-radius: 0;
        overflow: hidden;
        box-shadow: none;
        /* Ensure conversations stay within padding boundaries */
        max-width: calc(100% - 48px) !important; /* Account for 24px padding on each side */
        margin: 0 auto !important; /* Center the content */
    }
    
    /* PEOPLE VIEW: Force proper height and layout */
    body.layout-people #layout-canvas {
        display: block !important;
        position: fixed !important;
        top: 60px !important; /* Below header */
        left: 0 !important;
        right: 0 !important;
        bottom: 60px !important; /* Above footer */
        width: 100vw !important;
        height: calc(100vh - 120px) !important;
        min-height: calc(100vh - 120px) !important;
        max-height: none !important;
        overflow: hidden !important; /* Remove scrollbar */
        padding: 20px !important;
        padding-top: 10px !important; /* Reduced top padding to minimize empty space */
        box-sizing: border-box !important;
        background: transparent !important;
        z-index: 500 !important; /* Higher z-index but below header */
    }
    
    /* Set CSS custom properties for horizontal line layout */
    #layout-canvas {
        --video-size: 150px;
        /* Calculate block size to fill width with 24px padding */
        --conversation-block-size: calc((100vw - 48px - 20px) / 6); /* 100vw - 48px padding - 20px margins - LARGER BLOCKS */
        --timeline-item-size: 60px; /* Compact timeline items to fit more */
    }

    /* FULL-SCREEN VIDEO PREVIEW containers - Large conversation blocks that fill screen width */
    .conversation-grid-item-container { 
        position: absolute; 
        box-sizing: border-box; 
        padding: 0; 
        margin: 5px !important; /* Slightly larger margin for big blocks */
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden !important; /* CRITICAL: Prevent video overflow */
        border-radius: 12px; /* Larger rounded corners for big blocks */
        cursor: pointer;
        transition: transform 0.3s ease, box-shadow 0.3s ease, width 0.3s ease, height 0.3s ease !important; /* Smooth transitions for responsive sizing */
        background: transparent !important; /* Transparent to show grid behind */
        border: none;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1); /* Subtle shadow for large blocks */
        z-index: 2;
        will-change: transform, box-shadow, width, height !important; /* Enable smooth responsive sizing */
        transform-origin: center center;
        /* FULL-SCREEN: Large video preview blocks - perfect square, fills screen width */
        aspect-ratio: 1 / 1;
        /* Dynamic sizing that fills screen width based on conversation count */
        width: var(--conversation-block-size, 300px) !important;
        height: var(--conversation-block-size, 300px) !important;
        /* Performance optimizations for large blocks */
        contain: layout style paint;
        backface-visibility: hidden;
        perspective: 1000px;
        isolation: isolate;
    }

    /* RESPONSIVE Video container wrapper for video preview blocks */
    .video-container-wrapper {
        width: 100% !important;
        height: 100% !important;
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        position: relative !important;
        overflow: hidden !important;
        background: transparent !important;
        border-radius: 0 !important;
        margin: 0 !important;
        padding: 0 !important;
        /* Responsive sizing support */
        max-width: var(--conversation-block-size, 100px) !important;
        max-height: var(--conversation-block-size, 100px) !important;
        /* Ensure perfect centering */
        place-items: center !important;
        place-content: center !important;
        /* Performance optimizations */
        contain: layout style paint !important;
        backface-visibility: hidden !important;
        will-change: transform, width, height !important; /* Enable responsive sizing */
        transition: transform 0.3s ease, width 0.3s ease, height 0.3s ease !important; /* Smooth responsive transitions */
    }
    
    /* Grid cell inner div container - ULTRA ENHANCED */
    .grid-cell-content {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: transparent;
        border-radius: 0;
        overflow: hidden;
        position: relative;
        text-align: center;
        place-items: center;
        /* ULTRA ENHANCED: Maximum cropping and visual quality */
        aspect-ratio: 1 / 1;
        /* Enhanced visual masking for better focus */
        mask: radial-gradient(circle at center, black 85%, transparent 100%);
        -webkit-mask: radial-gradient(circle at center, black 85%, transparent 100%);
        /* Improved rendering */
        will-change: transform !important; /* Enable will-change for smooth animations */
        contain: layout style paint;
        transition: transform 0.3s ease !important; /* Smooth transitions for hover effects */
    }

    .conversation-grid-item-container:hover { 
        border: 1px solid #000000 !important; /* Simple black border on hover */
        transition: border 0.2s ease !important; /* Fast, smooth border transition */
    }
    
    .conversation-grid-item-container:hover .grid-cell-content {
        border-radius: 0;
    }

    /* Enhanced hover effects for video container wrapper */
    .conversation-grid-item-container:hover .video-container-wrapper {
        transform: scale(1) !important; /* NO scaling - keep same size */
        background: transparent !important;
        border-radius: 0 !important;
        width: 100% !important; /* MAINTAIN CONSISTENT WIDTH */
        height: 100% !important; /* MAINTAIN CONSISTENT HEIGHT */
        margin: 0 !important; /* MAINTAIN CONSISTENT MARGIN */
    }

    /* CRITICAL: Ensure video preview containers have NO backdrop effects */
    .video-preview-item, 
    .video-preview-item:hover {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
    }

    /* Video wrapper styles removed - videos now display directly */
    
    /* SIMPLIFIED Video styling - Direct and efficient */
    /* RESPONSIVE Video preview elements - auto-scaling based on conversation count */
    .conversation-video-preview { 
        object-fit: cover !important; /* FILL: Cover entire container, may crop content */
        object-position: center center;
        display: block; 
        width: 100%; 
        height: 100%; 
        border: none; 
        border-radius: 0; /* No border radius */
        margin: 0;
        padding: 0;
        position: absolute;
        top: 0;
        left: 0;
        transition: none !important; /* Remove image scaling transitions */
        background: #f7f9f3; /* Match visualization background */
        /* Responsive sizing - adapts to conversation count and viewport */
        max-width: var(--conversation-block-size, 140px);
        max-height: var(--conversation-block-size, 140px);
        /* Performance optimization for responsive scaling */
        will-change: transform, width, height;
        /* Prevent image scaling on hover */
        transform: scale(1) !important;
    }
    
    /* CLEAN hover effects - Simple and non-blocking */
    .conversation-grid-item-container:hover .conversation-video-preview {
        opacity: 1.0 !important; /* Keep full opacity, no fade effect */
        transform: scale(1) !important; /* NO scaling - keep image same size while container grows */
    }
    
    /* Removed conflicting hover styles that caused white background duplication */

    /* Hide video error overlays */
    .conversation-grid-item-container div[style*="Video Error"] {
        display: none !important;
    }

    /* Lazy iframe placeholder styles */
    .lazy-iframe-placeholder {
        transition: background 0.3s ease, transform 0.3s ease !important;
        will-change: transform, background;
    }

    /* Removed placeholder hover background that caused glow effect */

    /* Removed scaling effect that contributed to hover duplication */

    /* Responsive adjustments - Optimized for People view visibility */
    @media (max-width: 1400px) {
        #layout-canvas {
            padding-left: 24px !important;
            padding-right: 24px !important;
        }
        /* Calculate block size to fill width with 24px padding */
        :root {
            --conversation-block-size: calc((100vw - 48px - 20px) / 6);
        }
    }

    @media (max-width: 1200px) {
        #layout-canvas {
            padding-left: 24px !important;
            padding-right: 24px !important;
        }
        /* Calculate block size to fill width with 24px padding */
        :root {
            --conversation-block-size: calc((100vw - 48px - 20px) / 6);
        }
    }

    @media (max-width: 800px) {
        #layout-canvas {
            padding-left: 24px !important;
            padding-right: 24px !important;
        }
        /* Calculate block size to fill width with 24px padding */
        :root {
            --conversation-block-size: calc((100vw - 48px - 20px) / 6);
        }
    }

    @media (min-width: 1800px) {
        /* Large screens - calculate block size to fill width with 24px padding */
        :root {
            --conversation-block-size: calc((100vw - 48px - 20px) / 6);
        }
    }

    @media (min-width: 2400px) {
        /* Ultra-wide screens - calculate block size to fill width with 24px padding */
        :root {
            --conversation-block-size: calc((100vw - 48px - 20px) / 6);
        }
    }

    @media (max-width: 768px) {
        #layout-canvas {
            padding-left: 24px !important;
            padding-right: 24px !important;
        }
        /* Mobile: 2 larger blocks per row */
        :root {
            --conversation-block-size: calc((100vw - 48px) / 2);
        }
    }

    @media (max-width: 480px) {
        #layout-canvas {
            padding-left: 24px !important;
            padding-right: 24px !important;
        }
        /* Small mobile: 1 large block per row for best visibility */
        :root {
            --conversation-block-size: calc(100vw - 48px);
        }
    }

    /* People view styles are handled above */

    /* People view - Column layout with person names and conversation previews - BOTTOM ALIGNED */
    body.layout-people #layout-canvas,
    .layout-people #layout-canvas {
        display: block !important;
        padding: 24px !important; /* 24px padding as requested */
        padding-top: 10px !important; /* Reduced top padding to align content to top */
        overflow: hidden auto !important; /* Clean overflow management */
        max-width: none !important;
        margin: 0 !important;
        position: fixed !important; /* Use fixed positioning like other views */
        top: 60px !important; /* Standard header offset */
        left: 0 !important;
        right: 0 !important;
        bottom: 60px !important; /* Standard footer offset */
        width: 100vw !important;
        height: calc(100vh - 120px) !important;
        min-height: 600px !important;
        background: transparent !important; /* Transparent to show body grid background */
        box-sizing: border-box !important;
        z-index: 1 !important; /* Ensure proper layering */
    }

    /* People view name labels - Base styles */
    .layout-people .person-name-label {
        cursor: pointer;
        user-select: none;
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: flex-end;
    }
    
    .layout-people .person-name-content {
        text-align: right;
        direction: rtl;
        width: 100%;
        box-sizing: border-box;
        padding: 0 8px;
    }
    
    .layout-people .person-name-label .person-info {
        text-align: right;
        direction: rtl;
        width: 100%;
    }
    
    .layout-people .person-name-label .person-name {
        font-size: 18px;
        font-weight: bold;
        color: #333;
        margin-bottom: 4px;
        line-height: 1.2;
        white-space: nowrap; /* Prevent line breaking */
        overflow: hidden; /* Hide overflow if name is too long */
        text-overflow: ellipsis; /* Add ... if name is too long */
    }
    
    .layout-people .person-name-label .person-stats {
        font-size: 12px;
        color: #666;
        margin-bottom: 2px;
        opacity: 0.8;
    }
    
    .layout-people .person-name-label .person-description {
        font-size: 11px;
        color: #888;
        opacity: 0.7;
        line-height: 1.1;
    }

    /* Timeline view date labels - Perfect center alignment */
    .layout-timeline .timeline-date-label,
    .timeline-date-label-protected {
        cursor: default;
        user-select: none;
        position: absolute !important;
        background: none !important;
        border: none !important;
        border-radius: 0 !important;
        box-shadow: none !important;
        padding: 0 !important;
        margin: 0 !important;
        direction: ltr !important;
        text-align: center !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        box-sizing: border-box !important;
        z-index: 2;
    }
    
    .layout-timeline .timeline-date-content,
    .timeline-date-label-protected .timeline-date-content {
        text-align: center !important;
        direction: ltr !important;
        width: 100%;
        box-sizing: border-box;
        padding: 0 !important;
    }
    
    .layout-timeline .timeline-date-label .date-info,
    .timeline-date-label-protected .date-info {
        text-align: center !important;
        direction: ltr !important;
        width: 100%;
    }
    
    .layout-timeline .timeline-date-label .date-name,
    .timeline-date-label-protected .date-name {
        font-size: 16px;
        font-weight: bold;
        color: #333;
        margin-bottom: 4px;
        line-height: 1.2;
    }
    
    .layout-timeline .timeline-date-label .date-stats,
    .timeline-date-label-protected .date-stats {
        font-size: 11px;
        color: #666;
        margin-bottom: 2px;
        opacity: 0.8;
    }

    /* People view containers - ORIGINAL COMPACT SIZE LIKE REFERENCE IMAGE */
    .layout-people .conversation-grid-item-container {
        /* Compact size matching the original reference image */
        position: absolute !important;
        box-sizing: border-box !important;
        padding: 0 !important;
        margin: 0 !important; /* No margin to ensure perfect alignment */
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        background: transparent !important;
        border: 1px solid #E5E6E2 !important; /* Navigation color border */
        border-radius: 0 !important; /* No corner radius */
        overflow: hidden !important;
        cursor: pointer !important;
        box-shadow: none !important; /* No shadow like original */
        z-index: 2 !important;
        transform-origin: center center !important;
        aspect-ratio: 1 / 1 !important;
        contain: layout style paint !important;
        backface-visibility: hidden !important;
        perspective: 1000px !important;
        isolation: isolate !important;
        /* LARGER CONTAINER for better conversation preview visibility */
        width: var(--timeline-square-size, 150px) !important;
        height: var(--timeline-square-size, 150px) !important;
        min-width: var(--timeline-square-size, 150px) !important;
        min-height: var(--timeline-square-size, 150px) !important;
        max-width: var(--timeline-square-size, 150px) !important;
        max-height: var(--timeline-square-size, 150px) !important;
        /* Smooth transitions for isotope animations */
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1) !important;
        /* Ensure perfect alignment with person names */
        transform: translateZ(0) !important; /* Force hardware acceleration */
    }

    .layout-people .conversation-grid-item-container:hover {
        /* NO SCALING - keep same size */
        transform: scale(1) !important; /* NO scaling */
        z-index: 10 !important;
        box-shadow: none !important; /* No shadow like original */
        border: 1px solid #000000 !important; /* Black border on hover - same thickness */
        border-radius: 0 !important; /* No border radius like original */
        /* Keep original size during hover */
        width: 100% !important;
        height: 100% !important;
        /* Smooth transition for hover state */
        transition: border 0.3s ease !important;
    }

    /* Ensure ALL image previews use FILL behavior - cover entire container */
    .conversation-video-preview {
        object-fit: cover !important; /* FILL: Cover entire container, may crop content */
        object-position: center center !important;
        transform: scale(1) !important; /* Prevent image scaling on hover */
    }

    /* People view specific image sizing - FILL images to cover entire container */
    .layout-people .conversation-video-preview {
        width: 100% !important;
        height: 100% !important;
        max-width: 100% !important;
        max-height: 100% !important;
        object-fit: cover !important; /* FILL: Cover entire container, may crop content */
        transform: scale(1) !important; /* No scaling - prevent image zoom on hover */
        transform-origin: center center !important;
    }

    /* Person name labels */
    /* Person name labels - NO STYLING */
.person-name-label {
    /* No background, no border, no fill, no stroke - just text */
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    padding: 0 !important;
    margin: 0 !important;
    border-radius: 0 !important;
    /* Keep only essential positioning */
    z-index: 10 !important;
    /* Prevent line breaking */
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
}

.person-name-content {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    margin: 0 !important;
    border-radius: 0 !important;
}

/* No hover effects */
.person-name-label:hover {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    transform: none !important;
}

.person-name-content:hover {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    transform: none !important;
}

    /* Hide conversation labels in People view - we use person name labels instead */
    .layout-people .conversation-label {
        display: none !important;
    }

    /* Emotions view layout canvas - Optimized for visibility without scrolling */
    body.layout-emotions #layout-canvas,
    .layout-emotions #layout-canvas {
        display: block !important;
        padding: 10px !important; /* Minimal padding for maximum space */
        padding-top: 10px !important; /* Minimal top padding */
        overflow: visible !important; /* No scrolling needed - emotions positioned at top */
        max-width: none !important;
        margin: 0 !important;
        position: fixed !important; /* Use fixed positioning like people view */
        top: 60px !important; /* Standard header offset */
        left: 0 !important;
        right: 0 !important;
        bottom: 60px !important; /* Standard footer offset */
        width: 100vw !important;
        height: calc(100vh - 120px) !important;
        min-height: 700px !important; /* Increased min-height for better emotion visibility */
        background: transparent !important; /* Transparent to show body grid background */
        box-sizing: border-box !important;
        z-index: 1 !important; /* Ensure proper layering */
    }

    .layout-emotions .conversation-grid-item-container {
        /* EMOTIONS VIEW - Match timeline/people view styling with navigation color borders */
        position: absolute !important;
        box-sizing: border-box !important;
        padding: 0 !important;
        margin: 0px !important; /* REMOVE MARGINS FOR MAXIMUM SPACE */
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1) !important; /* Same smooth transitions as other views */
        background: #f7f9f3 !important; /* Match visualization background */
        border: 1px solid #E5E6E2 !important; /* Navigation color border */
        border-radius: 0 !important; /* No corner radius */
        overflow: hidden !important;
        cursor: pointer !important;
        box-shadow: none !important;
        z-index: 2 !important;
        transform-origin: center center !important;
        aspect-ratio: 1 / 1 !important;
        contain: layout style paint !important;
        backface-visibility: hidden !important;
        perspective: 1000px !important;
        isolation: isolate !important;
        /* SAME SIZE AS PEOPLE AND TIMELINE VIEWS - USE CSS VARIABLE */
        width: var(--visual-conversation-size, 40px) !important;
        height: var(--visual-conversation-size, 40px) !important;
        min-width: var(--visual-conversation-size, 40px) !important;
        min-height: var(--visual-conversation-size, 40px) !important;
        max-width: var(--visual-conversation-size, 40px) !important;
        max-height: var(--visual-conversation-size, 40px) !important;
        transform: translateZ(0) !important; /* Force hardware acceleration */
    }
    
    .layout-emotions .conversation-grid-item-container:hover {
        /* NO SCALING - keep same size */
        transform: scale(1) !important; /* NO scaling */
        z-index: 10 !important;
        box-shadow: none !important;
        border: 1px solid #000000 !important; /* Black border on hover - same thickness */
        transition: border 0.3s ease !important;
    }
    
    /* Match video styling with timeline/people views */
    .layout-emotions .conversation-video-preview {
        object-fit: cover !important; /* FILL: Cover entire container, may crop content */
        object-position: center center !important;
        display: block !important;
        width: 100% !important;
        height: 100% !important;
        border: none !important;
        border-radius: 0 !important;
        margin: 0 !important;
        padding: 0 !important;
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        transition: none !important; /* Remove image scaling transitions */
        background: #f7f9f3 !important; /* Match visualization background */
        filter: none !important;
        box-shadow: none !important;
        transform: scale(1) !important; /* Prevent image scaling on hover */
    }
    
    .layout-emotions .video-container-wrapper {
        width: 100% !important;
        height: 100% !important;
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        position: relative !important;
        overflow: hidden !important;
        background: transparent !important;
        border-radius: 0 !important;
        border: none !important;
        margin: 0 !important;
        padding: 0 !important;
    }
    
    /* Emotion cluster labels - Simple text labels with consistent spacing - EMOTIONS VIEW ONLY */
    body.layout-emotions .emotion-cluster-label {
        font-family: 'Miriam Libre', serif !important;
        font-size: 14px !important;
        font-weight: normal !important;
        color: #333 !important;
        text-align: left !important;
        direction: ltr !important;
        pointer-events: none !important;
        z-index: 10 !important;
        background: none !important; /* Remove background */
        border: none !important; /* Remove border */
        border-radius: 0 !important; /* Remove border radius */
        box-shadow: none !important; /* Remove shadow */
        padding: 0 !important; /* Remove padding */
        position: absolute !important;
        display: flex !important;
        align-items: center !important;
        justify-content: flex-start !important;
        white-space: nowrap !important;
        transition: none !important; /* Remove transitions */
        min-width: auto !important; /* Auto width */
    }
    
    /* Remove all decorative styles - keep only plain text labels */
    
    /* Emotions view background - solid background without grid */
    body.layout-emotions {
        background: #f7f9f3 !important;
    }
    
    /* Disable animations in emotions view but allow isotope transitions and zoom */
    .layout-emotions *:not(#layout-canvas):not(.conversation-grid-item-container) {
        animation: none !important;
    }
    
    /* Allow isotope transitions for conversation items but no other animations */
    .layout-emotions .conversation-grid-item-container {
        animation: none !important;
    }
    
    /* Allow zoom transforms on the main layout canvas */
    .layout-emotions #layout-canvas {
        transform-origin: center center !important;
        animation: none !important;
    }

    /* Hebrew Splash Screen Styles */
    #splash-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f7f9f3;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        overflow: hidden;
        z-index: 9999;
        transition: opacity 0.5s ease-out;
    }
    #splash-screen.hidden { opacity: 0; pointer-events: none; }
    
    /* Animated background dots */
    .background-dots {
        position: absolute;
        width: 100%;
        height: 100%;
        opacity: 0.3;
    }
    
    .dot {
        position: absolute;
        width: 2px;
        height: 2px;
        background: #667eea;
        border-radius: 50%;
        animation: twinkle 3s infinite ease-in-out;
    }
    
    @keyframes twinkle {
        0%, 100% { opacity: 0.2; }
        50% { opacity: 0.8; }
    }
    
    /* Main loading container */
    .loading-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 100;
        width: 100%;
    }
    
    .loading-text {
        color: #333;
        font-size: 20px;
        font-weight: 400;
        letter-spacing: 3px;
        margin-bottom: 30px;
        white-space: nowrap;
        text-align: center;
    }
    
    /* Loading bar container - Clean style */
    .loading-bar-container {
        width: 480px;
        height: 12px;
        background: #e0e0e0;
        border: 1px solid #333;
        position: relative;
        overflow: hidden;
        z-index: 101;
        margin: 0 auto;
    }
    
    .loading-bar {
        height: 100%;
        background: #333;
        width: 0%;
        animation: loadProgress 2.5s ease-in-out forwards;
        position: relative;
    }
    
    @keyframes loadProgress {
        0% { width: 0%; }
        50% { width: 60%; }
        80% { width: 85%; }
        100% { width: 100%; }
    }
    
    @keyframes shine {
        0% { left: -100%; }
        100% { left: 100%; }
    }
    
    /* Preview windows */
    .preview-window {
        position: absolute;
        border: none;
        background: transparent;
        overflow: hidden;
        opacity: 0;
        animation: floatUp 15s linear infinite, fadeInOut 15s ease-in-out infinite;
        z-index: 1;
    }
    
    .preview-window video {
        width: 100%;
        height: 100%;
        object-fit: contain;
        pointer-events: none;
    }
    
    @keyframes floatUp {
        0% { transform: translateY(100vh); }
        100% { transform: translateY(-200px); }
    }
    
    @keyframes fadeInOut {
        0% { opacity: 0; }
        10% { opacity: 0.7; }
        90% { opacity: 0.7; }
        100% { opacity: 0; }
    }
    
    .preview-1 {
        left: 10%;
        width: 160px;
        height: 120px;
        animation-delay: 0s;
    }
    
    .preview-2 {
        left: 80%;
        width: 150px;
        height: 115px;
        animation-delay: -3s;
    }
    
    .preview-3 {
        left: 20%;
        width: 170px;
        height: 130px;
        animation-delay: -6s;
    }
    
    .preview-4 {
        left: 70%;
        width: 155px;
        height: 120px;
        animation-delay: -9s;
    }
    
    .preview-5 {
        left: 40%;
        width: 165px;
        height: 125px;
        animation-delay: -12s;
    }
    
    .preview-6 {
        left: 85%;
        width: 145px;
        height: 110px;
        animation-delay: -2s;
    }
    
    /* Retro scanlines effect */
    .scanlines {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
            0deg,
            transparent,
            transparent 2px,
            rgba(139, 115, 85, 0.05) 2px,
            rgba(139, 115, 85, 0.05) 4px
        );
        pointer-events: none;
    }
    
    /* Loading percentage */
    .loading-percentage {
        color: #333;
        font-size: 16px;
        margin-top: 15px;
        opacity: 0.8;
        text-align: center;
    }
    #visualization-modal-container { 
      position: fixed; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      background-color: rgba(0, 0, 0, 0.8); 
      backdrop-filter: blur(5px); 
      z-index: 5000; 
      display: none; 
      align-items: center; 
      justify-content: center; 
      opacity: 0; 
      transition: opacity 0.15s ease-in-out; 
      padding: 20px; 
      margin: 0; 
      box-sizing: border-box;
    }
    #visualization-modal-container.visible { 
      display: flex; 
      opacity: 1; 
    }
    #visualization-modal-container iframe { 
      width: 95vw; 
      height: 92vh; 
      max-width: none; 
      max-height: none; 
      border: none; 
      border-radius: 0 !important; 
      box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
      background-color: #f7f9f3;
      transition: transform 0.3s ease;
    }
    
    /* Exit Tooltip Styles */
    .exit-tooltip {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 12px 24px;
        border-radius: 0;
        font-size: 12px;
        font-family: var(--main-font-family);
        z-index: 5001;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s, visibility 0.3s;
        pointer-events: none;
        direction: rtl;
    }
    
    .exit-tooltip.show {
        opacity: 1;
        visibility: visible;
    }
    .nav-slash-style .slash-sep { color: #bbb; font-size: 1.5rem; margin: 0 10px; font-family: inherit; font-weight: 300; pointer-events: none; user-select: none; }
            .nav-slash-style .view-toggle-btn { background: none; border: none; font-size: 16px; font-family: inherit; font-weight: 400; color: #bbb; padding: 0 2px; cursor: pointer; transition: color 0.2s, font-weight 0.2s; }
        .nav-slash-style .view-toggle-btn.active { color: #111; font-weight: 400; }
        

        

        #hover-info-panel { 
            position: fixed; 
            bottom: 80px; 
            right: 20px; 
            display: inline-flex;
            padding: 0.75rem;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.5rem;
            border: 1px solid #E5E6E2;
            background: #F7F9F2;
            z-index: 1010; 
            opacity: 0; 
            visibility: hidden; 
            transform: translateY(0) scale(1) rotate(0deg); 
            transition: all 0.3s ease;
            pointer-events: none;
            width: 350px;
            direction: rtl;
            font-family: var(--main-font-family);
        }



        #hover-info-panel.visible { 
            opacity: 1; 
            visibility: visible; 
            transform: translateY(0) scale(1) rotate(0deg); 
            transition-delay: 0s, 0s, 0s;
            animation: none;
            pointer-events: auto;
        }



        .hover-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            align-self: stretch;
        }
        
        .hover-info-title { 
            font-size: 14px; 
            font-weight: 400; 
            color: #333; 
            text-align: right; 
            line-height: 1.2;
            font-family: "Miriam Libre";
        }
        
        .hover-info-date { 
            font-size: 10px; 
            color: #A0A0A0; 
            text-align: left;
            font-family: "Miriam Libre";
        }
        .hover-info-speakers {
            color: #9A9A9A;
            font-family: "Miriam Libre";
            font-size: 0.7rem;
            font-style: normal;
            font-weight: 400;
            line-height: 1.2rem;
            text-align: right;
        }
        
        .hover-info-divider {
            width: 100%;
            height: 1px;
            background-color: #E5E6E2;
            margin: 6px 0;
        }
        
        .hover-info-topic-section, .hover-info-emotions-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            align-self: stretch;
        }
        
        .hover-info-section-title {
            font-size: 11px;
            color: #333;
            font-family: "Miriam Libre";
            font-weight: 400;
            text-align: right;
        }
        
        .hover-info-topic-tags {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        
        .hover-info-topic-tag {
            padding: 3px 6px;
            font-size: 10px;
            color: #333;
            font-family: var(--main-font-family);
            border: 1px solid #E5E6E2;
        }
        
        .hover-info-topic-section, .hover-info-emotions-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            align-self: stretch;
        }
        
        .hover-info-section-title {
            font-size: 11px;
            color: #333;
            font-family: "Miriam Libre";
            font-weight: 400;
            text-align: right;
        }
        
        .hover-info-topic-tags {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        
        .hover-info-topic-tag {
            padding: 4px 8px;
            font-size: 11px;
            color: #333;
            font-family: var(--main-font-family);
            border: 1px solid #E5E6E2;
        }
        
        .hover-info-additional {
            font-size: 14px;
            color: #666;
            margin-bottom: 16px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 10px;
            border: 1px solid rgba(128, 128, 128, 0.12);
            font-family: var(--main-font-family);
            font-weight: 500;
            backdrop-filter: blur(4px);
        }
    
    .hover-info-tags { 
        display: flex; 
        gap: 8px; 
        flex-wrap: wrap;
        justify-content: flex-end;
    }
    .hover-info-tag { 
        color: #333; 
        padding: 4px 8px; 
        font-size: 11px;
        font-weight: 400;
        font-family: var(--main-font-family);
        border: 1px solid #E5E6E2;
        border-radius: 0;
        background: transparent;
        transition: all 0.2s ease;
        letter-spacing: -0.1px;
        display: inline-flex;
        align-items: center;
        gap: 3px;
    }
    
    .hover-info-tag:hover {
        background: transparent;
        transform: translateY(-1px);
        box-shadow: none;
        border-color: rgba(139, 115, 85, 0.3);
    }
    
    .hover-info-tag .emotion-color-square {
        width: 12px;
        height: 12px;
        border-radius: 0; /* No border radius - square rectangle */
        flex-shrink: 0;
        margin-left: 6px; /* Space after text */
    }
    
    .hover-info-tag {
        display: flex;
        align-items: center;
        margin: 2px 4px;
        padding: 2px 6px;
        border-radius: 0;
        background: transparent;
        gap: 8px; /* Space between text and square */
    }
    .hover-info-metadata-tags {
        font-size: 11px;
        color: #888;
        margin-top: 8px;
        padding: 8px 10px;
        background: rgba(139, 115, 85, 0.05);
        border-radius: 6px;
        border: 1px solid rgba(139, 115, 85, 0.1);
        font-family: var(--main-font-family);
        font-weight: 500;
        font-style: normal;
        letter-spacing: -0.1px;
    }
    .timeline-tooltip {
        position: absolute;
        bottom: 100%; /* Position above the track */
        transform: translateX(-50%);
        background-color: #333;
        color: #fff;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none; /* So it doesn't interfere with mouse events */
        display: none; /* Hidden by default */
        margin-bottom: 10px;
    }

    .handle-date-display {
        position: absolute;
        top: -25px; /* Position above the handle */
        font-size: 12px;
        color: #333;
        white-space: nowrap;
    }
    .handle-date-display.left { left: 0; }
    .handle-date-display.right { right: 0; }
    
    /* Performance and Loading Indicators */
    .loading-indicator {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        text-align: center;
        z-index: 1000;
        display: none;
        font-family: var(--main-font-family);
    }
    
    .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #8B7355;
        border-radius: 50%;
        animation: spin-loader 1s linear infinite;
        margin: 0 auto 15px;
    }
    
    @keyframes spin-loader {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .audio-prompt {
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(139, 115, 85, 0.9);
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        z-index: 1000;
        cursor: pointer;
        transition: all 0.3s ease;
        display: none;
        font-family: var(--main-font-family);
        font-size: 14px;
        border: none;
    }
    
    .audio-prompt:hover {
        background: rgba(139, 115, 85, 1);
        transform: scale(1.05);
    }
    
    /* Re-transcription Floating Panel */
    .retranscribe-panel {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.9);
        background: rgba(255, 255, 255, 0.98);
        border: 2px solid #ddd;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        z-index: 3000;
        display: none;
        width: 90%;
        max-width: 700px;
        max-height: 80vh;
        overflow-y: auto;
        font-family: var(--main-font-family);
        backdrop-filter: blur(20px);
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .retranscribe-panel.visible {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    
    .retranscribe-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 18px 18px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 18px;
        font-weight: 600;
    }
    
    .retranscribe-content {
        padding: 30px;
    }
    
    .retranscribe-options h3 {
        margin: 0 0 20px 0;
        color: #333;
        text-align: center;
        font-size: 20px;
    }
    
    .analysis-option {
        margin-bottom: 30px;
        border: 2px solid #f0f0f0;
        border-radius: 15px;
        padding: 20px;
        background: #fafafa;
    }
    
    .option-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 10px;
    }
    
    .option-icon {
        font-size: 24px;
    }
    
    .option-title {
        font-size: 18px;
        font-weight: 600;
        color: #333;
    }
    
    .option-description {
        color: #666;
        margin: 0 0 15px 36px;
        font-size: 14px;
    }
    
    .conversation-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 15px;
        margin-top: 15px;
    }
    
    .convo-option {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 15px 20px;
        background: white;
        border: 2px solid #e0e0e0;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: inherit;
        text-align: right;
    }
    
    .convo-option:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        border-color: #667eea;
    }
    
    .convo-option.quick-analysis {
        border-left: 5px solid #4CAF50;
    }
    
    .convo-option.quick-analysis:hover {
        border-color: #4CAF50;
        background: #f8fff8;
    }
    
    .convo-option.full-reprocess:hover {
        border-color: #FF9800;
        background: #fffaf0;
    }
    
    .convo-icon {
        font-size: 28px;
        flex-shrink: 0;
    }
    
    .convo-details {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        flex: 1;
    }
    
    .convo-name {
        font-weight: 600;
        font-size: 16px;
        color: #333;
    }
    
    .convo-count {
        font-size: 13px;
        color: #666;
        margin-top: 2px;
    }
    
    .close-btn {
        background: rgba(255,255,255,0.2);
        border: 1px solid rgba(255,255,255,0.3);
        color: white;
        border-radius: 50%;
        width: 35px;
        height: 35px;
        cursor: pointer;
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
    }
    
    .close-btn:hover {
        background: rgba(255,255,255,0.3);
        transform: scale(1.1);
    }
    
    /* Preview Canvas Styles */
    .conversation-preview-canvas {
        background: #f7f9f3;
        border-radius: 0;
    }
    
    .preview-canvas {
        transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .conversation-grid-item-container:hover .preview-canvas {
        transform: none; /* No scaling on hover */
        box-shadow: none;
    }
    
    .mini-spinner {
        width: 20px;
        height: 20px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #8B7355;
        border-radius: 50%;
        animation: spin-loader 1s linear infinite;
    }
    
    .preview-loading {
        background: rgba(247, 249, 243, 0.9);
        padding: 10px;
        border-radius: 0;
    }
    
    /* Hover effect for preview */
    .conversation-grid-item-container:hover .conversation-preview-canvas {
        box-shadow: none;
        background: transparent; /* Ensure no background color change */
    }
    

    /* Preview Video Styles */
    .preview-video {
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        cursor: pointer;
    }
    
    .conversation-grid-item-container:hover .preview-video {
        transform: none; /* No scaling on hover */
        box-shadow: none; /* No shadow on hover */
    }
    
    .fallback-canvas {
        display: none;
    }



    /* Playground Mode Styles */
    #playground-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f7f9f3;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    #playground-canvas-container {
        position: relative;
        width: 80%;
        max-width: 1200px;
        height: 60%;
        background: #f7f9f3;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        overflow: hidden;
        border: 2px solid #e0e0e0;
    }

    #playground-canvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #playground-controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 15px;
        align-items: center;
        background: rgba(255, 255, 255, 0.9);
        padding: 15px 25px;
        border-radius: 50px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        backdrop-filter: blur(10px);
    }

    .playground-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s ease;
        font-family: var(--main-font-family);
    }

    .playground-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }

    .playground-btn:active {
        transform: translateY(0);
    }

    .playground-btn.recording {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        animation: pulse-recording 2s infinite;
    }

    @keyframes pulse-recording {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .mic-status {
        font-size: 14px;
        color: #666;
        font-weight: 500;
        font-family: var(--main-font-family);
    }

    .mic-status.active {
        color: #27ae60;
        font-weight: 600;
    }

    .audio-level-display {
        font-size: 12px;
        color: #888;
        font-family: var(--main-font-family);
        min-width: 80px;
        text-align: center;
    }

    .audio-level-display.active {
        color: #3498db;
        font-weight: 600;
    }

    /* Playground Navigation Button Styles */
    .playground-nav-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
        color: white !important;
        border: none !important;
        cursor: pointer;
        transition: all 0.3s ease;
        text-decoration: none !important;
        padding: 8px 16px !important;
        border-radius: 20px !important;
        font-size: 14px !important;
        font-weight: 600 !important;
        margin-right: 10px !important;
    }

    .playground-nav-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%) !important;
        color: white !important;
        border-bottom: 2px solid transparent !important;
    }

    .playground-nav-btn.active {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%) !important;
        color: white !important;
        border-bottom: 2px solid transparent !important;
    }

    /* ENHANCED ISOTOPE-STYLE ANIMATED TRANSITIONS BETWEEN VIEWS */
    .conversation-grid-item-container {
        /* OPTIMIZED transition for smooth view switching */
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1) !important;
        /* Smooth 3D morphing between layouts */
        transform-style: preserve-3d !important;
        will-change: transform, left, top, width, height, opacity !important;
        /* Enhanced visual effects during transitions */
        backface-visibility: hidden !important;
        perspective: 1000px !important;
    }
    
    /* Enhanced transition states for view switching */
    .conversation-grid-item-container.transitioning {
        /* Smooth morphing animation */
        transition: left 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   top 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   width 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   height 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   transform 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   opacity 1.0s cubic-bezier(0.23, 1, 0.32, 1) !important;
        /* 3D transformation effects */
        transform-origin: center center !important;
        transform-style: preserve-3d !important;
        /* Smooth opacity transition */
        opacity: 1 !important;
    }
    
    /* Staggered animation delays for isotope effect */
    .conversation-grid-item-container:nth-child(1) { animation-delay: 0.0s !important; }
    .conversation-grid-item-container:nth-child(2) { animation-delay: 0.1s !important; }
    .conversation-grid-item-container:nth-child(3) { animation-delay: 0.2s !important; }
    .conversation-grid-item-container:nth-child(4) { animation-delay: 0.3s !important; }
    .conversation-grid-item-container:nth-child(5) { animation-delay: 0.4s !important; }
    .conversation-grid-item-container:nth-child(6) { animation-delay: 0.5s !important; }
    .conversation-grid-item-container:nth-child(7) { animation-delay: 0.6s !important; }
    .conversation-grid-item-container:nth-child(8) { animation-delay: 0.7s !important; }
    .conversation-grid-item-container:nth-child(9) { animation-delay: 0.8s !important; }
    .conversation-grid-item-container:nth-child(10) { animation-delay: 0.9s !important; }
    .conversation-grid-item-container:nth-child(11) { animation-delay: 1.0s !important; }
    .conversation-grid-item-container:nth-child(12) { animation-delay: 1.1s !important; }
    .conversation-grid-item-container:nth-child(13) { animation-delay: 1.2s !important; }
    
    .layout-people .conversation-grid-item-container {
  /* PEOPLE VIEW: Standard people view layout */
  width: 60px !important; /* Standard people view size */
  height: 60px !important; /* Standard people view size */
  min-width: 60px !important; /* Force consistent size */
  min-height: 60px !important;
  max-width: 60px !important; /* Force consistent size */
  max-height: 60px !important;
  box-sizing: border-box;
  border: 1px solid #E5E6E2 !important; /* Navigation color border */
  border-radius: 0 !important; /* No corner radius */
  /* Fixed aspect ratio */
  aspect-ratio: 1 / 1;
  /* Smooth transitions */
  transition: left 0.3s ease, top 0.3s ease, opacity 0.3s ease;
  /* ABSOLUTE POSITIONING: Essential for no-overlap layout */
  position: absolute !important;
  /* NO margins or padding that could cause positioning issues */
  margin: 0 !important;
  padding: 0 !important;
  /* Clear z-index for proper stacking */
  z-index: 10;
}

    .layout-timeline .conversation-grid-item-container {
  /* VISUAL SIZE: Use calculated optimal size with proper margins */
  width: var(--visual-conversation-size, 80px) !important; /* Optimal visual width */
  height: var(--visual-conversation-size, 80px) !important; /* Optimal visual height */
  min-width: var(--visual-conversation-size, 80px) !important; /* Force consistent size */
  min-height: var(--visual-conversation-size, 80px) !important;
  max-width: var(--visual-conversation-size, 80px) !important; /* Force consistent size */
  max-height: var(--visual-conversation-size, 80px) !important;
  box-sizing: border-box;
  border: 1px solid #E5E6E2 !important; /* Navigation color border */
  border-radius: 0 !important; /* No corner radius */
  /* Fixed aspect ratio */
  aspect-ratio: 1 / 1;
  /* ABSOLUTE POSITIONING: Essential for no-overlap layout */
  position: absolute !important;
  /* NO margins or padding that could cause positioning issues */
  margin: 0 !important;
  padding: 0 !important;
  /* Clear z-index for proper stacking */
  z-index: 10;
     /* ISOTOPE ANIMATIONS: Enhanced smooth transitions for timeline */
   transition: left 0.8s cubic-bezier(0.23, 1, 0.32, 1), 
              top 0.8s cubic-bezier(0.23, 1, 0.32, 1),
              width 0.8s cubic-bezier(0.23, 1, 0.32, 1),
              height 0.8s cubic-bezier(0.23, 1, 0.32, 1),
              transform 0.4s cubic-bezier(0.23, 1, 0.32, 1),
              opacity 0.3s cubic-bezier(0.23, 1, 0.32, 1) !important;
   will-change: transform, left, top, width, height, opacity !important;
   backface-visibility: hidden !important;
   perspective: 1000px !important;
   transform-style: preserve-3d !important;
     /* Staggered animation delay for isotope effect */
  animation-delay: calc(var(--item-index, 0) * 0.03s) !important;
}

    /* Timeline view hover effect - Black border */
    .layout-timeline .conversation-grid-item-container:hover {
        border: 1px solid #000000 !important; /* Black border on hover - same thickness */
        z-index: 15 !important; /* Higher than default z-index */
        transition: border 0.3s ease !important;
    }

    
    /* People view - OPTIMIZED transitions */
    .layout-people .conversation-grid-item-container {
        /* Fast, smooth positioning transitions */
        transition: left 0.6s cubic-bezier(0.23, 1, 0.32, 1), 
                   top 0.6s cubic-bezier(0.23, 1, 0.32, 1),
                   width 0.6s cubic-bezier(0.23, 1, 0.32, 1),
                   height 0.6s cubic-bezier(0.23, 1, 0.32, 1),
                   transform 0.3s cubic-bezier(0.23, 1, 0.32, 1),
                   opacity 0.4s cubic-bezier(0.23, 1, 0.32, 1) !important;
        /* Reduced staggered animation delay */
        animation-delay: calc(var(--item-index, 0) * 0.02s) !important;
    }
    
    /* OPTIMIZED container transitions */
    #timeline-axes-container {
        transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1) !important;
    }
    
    #layout-canvas {
        transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1) !important;
    }
    
    /* Enhanced isotope view switching animation */
    .layout-timeline #layout-canvas {
        transform-origin: center center !important;
        transition: transform 0.8s cubic-bezier(0.23, 1, 0.32, 1) !important;
        /* STACKED LAYOUT: Use absolute positioning for precise date group stacking */
        display: block !important;
        position: relative !important;
        padding: 20px !important;
        box-sizing: border-box !important;
        overflow: hidden !important;
        width: 100% !important;
        height: 100% !important;
    }
    
    .layout-people #layout-canvas {
        transform-origin: center bottom !important;
        transition: transform 0.8s cubic-bezier(0.23, 1, 0.32, 1) !important;
    }
    
    /* Isotope-style entrance animations */
    @keyframes isotopeEnter {
        0% {
            opacity: 0;
            transform: scale(0.6) rotateY(180deg);
        }
        50% {
            opacity: 0.8;
            transform: scale(1.1) rotateY(90deg);
        }
        100% {
            opacity: 1;
            transform: scale(1) rotateY(0deg);
        }
    }
    
    /* Isotope-style exit animations */
    @keyframes isotopeExit {
        0% {
            opacity: 1;
            transform: scale(1) rotateY(0deg);
        }
        50% {
            opacity: 0.3;
            transform: scale(0.8) rotateY(-90deg);
        }
        100% {
            opacity: 0;
            transform: scale(0.4) rotateY(-180deg);
        }
    }
    
    /* Apply isotope animations during view transitions */
    .isotope-transitioning .conversation-grid-item-container {
        animation: isotopeEnter 1.2s cubic-bezier(0.23, 1, 0.32, 1) forwards !important;
    }

    /* Ensure timeline containers get isotope animations */
    .layout-timeline.isotope-transitioning .conversation-grid-item-container,
    .isotope-transitioning .layout-timeline .conversation-grid-item-container {
        animation: isotopeEnter 1.2s cubic-bezier(0.23, 1, 0.32, 1) forwards !important;
    }

    /* Timeline track wrapper isotope transitions */
    .timeline-track-wrapper.isotope-transitioning {
        animation: isotopeEnter 1.2s cubic-bezier(0.23, 1, 0.32, 1) forwards !important;
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1) !important;
    }

    /* Timeline conversations container isotope transitions */
    #timeline-conversations-container.isotope-transitioning {
        animation: isotopeEnter 1.2s cubic-bezier(0.23, 1, 0.32, 1) forwards !important;
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1) !important;
    }

    /* Enhanced isotope switching animations for better consistency */
    .isotope-switching .conversation-grid-item-container {
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1) !important;
        will-change: transform, left, top, width, height, opacity;
        transform-origin: center center;
        backface-visibility: hidden;
        perspective: 1000px;
    }

    /* Prevent layout breaks during view transitions */
    #layout-canvas.isotope-transitioning,
    #layout-canvas.isotope-switching,
    #timeline-axes-container.isotope-transitioning,
    #timeline-axes-container.isotope-switching {
        position: relative !important;
        overflow: visible !important;
        min-height: 600px !important;
        width: 100% !important;
        height: 100% !important;
    }

    /* Layout stability during transitions */
    .transitioning {
        pointer-events: none; /* Prevent interaction during transitions */
    }

    /* Emergency layout consistency fixes */
    .layout-timeline #timeline-axes-container,
    .layout-people #timeline-axes-container,
    .layout-emotions #timeline-axes-container {
        display: block !important;
        visibility: visible !important;
        position: relative !important;
        width: 100% !important;
        height: 100% !important;
    }

    /* Ensure consistent canvas sizing across views */
    #layout-canvas {
        position: relative !important;
        width: 100% !important;
        min-height: 600px !important;
        overflow: hidden !important;
    }








    @keyframes naturalFloat {
        0% {
            transform: translate(-50%, -50%) scale(1) rotate(0deg);
            left: 25%;
            top: 35%;
        }
        8% {
            transform: translate(-50%, -50%) scale(1.05) rotate(8deg);
            left: 35%;
            top: 30%;
        }
        16% {
            transform: translate(-50%, -50%) scale(0.98) rotate(-5deg);
            left: 45%;
            top: 25%;
        }
        24% {
            transform: translate(-50%, -50%) scale(1.08) rotate(12deg);
            left: 55%;
            top: 30%;
        }
        32% {
            transform: translate(-50%, -50%) scale(0.95) rotate(-8deg);
            left: 65%;
            top: 35%;
        }
        40% {
            transform: translate(-50%, -50%) scale(1.03) rotate(6deg);
            left: 75%;
            top: 40%;
        }
        48% {
            transform: translate(-50%, -50%) scale(0.97) rotate(-3deg);
            left: 70%;
            top: 50%;
        }
        56% {
            transform: translate(-50%, -50%) scale(1.06) rotate(10deg);
            left: 60%;
            top: 60%;
        }
        64% {
            transform: translate(-50%, -50%) scale(0.94) rotate(-7deg);
            left: 50%;
            top: 65%;
        }
        72% {
            transform: translate(-50%, -50%) scale(1.04) rotate(4deg);
            left: 40%;
            top: 60%;
        }
        80% {
            transform: translate(-50%, -50%) scale(0.99) rotate(-2deg);
            left: 30%;
            top: 55%;
        }
        88% {
            transform: translate(-50%, -50%) scale(1.07) rotate(9deg);
            left: 25%;
            top: 45%;
        }
        96% {
            transform: translate(-50%, -50%) scale(0.96) rotate(-4deg);
            left: 28%;
            top: 38%;
        }
        100% {
            transform: translate(-50%, -50%) scale(1) rotate(0deg);
            left: 25%;
            top: 35%;
        }
    }

    @keyframes naturalFloat2 {
        0% {
            transform: translate(-50%, -50%) scale(1) rotate(0deg);
            left: 70%;
            top: 60%;
        }
        10% {
            transform: translate(-50%, -50%) scale(1.06) rotate(12deg);
            left: 80%;
            top: 45%;
        }
        20% {
            transform: translate(-50%, -50%) scale(0.97) rotate(-8deg);
            left: 65%;
            top: 35%;
        }
        30% {
            transform: translate(-50%, -50%) scale(1.09) rotate(15deg);
            left: 75%;
            top: 50%;
        }
        40% {
            transform: translate(-50%, -50%) scale(0.94) rotate(-5deg);
            left: 60%;
            top: 65%;
        }
        50% {
            transform: translate(-50%, -50%) scale(1.04) rotate(8deg);
            left: 85%;
            top: 70%;
        }
        60% {
            transform: translate(-50%, -50%) scale(0.98) rotate(-3deg);
            left: 70%;
            top: 80%;
        }
        70% {
            transform: translate(-50%, -50%) scale(1.07) rotate(11deg);
            left: 55%;
            top: 75%;
        }
        80% {
            transform: translate(-50%, -50%) scale(0.95) rotate(-7deg);
            left: 45%;
            top: 65%;
        }
        90% {
            transform: translate(-50%, -50%) scale(1.03) rotate(6deg);
            left: 60%;
            top: 55%;
        }
        100% {
            transform: translate(-50%, -50%) scale(1) rotate(0deg);
            left: 70%;
            top: 60%;
        }
    }

    /* Different emotion color schemes - HIGHLY PIXELATED SQUARE GRADIENT */
    .emotion-blob.happiness, .emotion-blob.happy {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 215, 0, 0.2) 2px,
                rgba(255, 215, 0, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(255, 215, 0, 0.2) 2px,
                rgba(255, 215, 0, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(255, 215, 0, 0.1) 3px,
                rgba(255, 215, 0, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(255, 215, 0, 0.5), rgba(255, 215, 0, 0.35), rgba(255, 215, 0, 0.2));
        filter: blur(6px) contrast(1.3) saturate(1.2);
    }

    .emotion-blob.joy {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 255, 0, 0.2) 2px,
                rgba(255, 255, 0, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(255, 255, 0, 0.2) 2px,
                rgba(255, 255, 0, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(255, 255, 0, 0.1) 3px,
                rgba(255, 255, 0, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(255, 255, 0, 0.6), rgba(255, 255, 0, 0.4), rgba(255, 255, 0, 0.25));
        filter: blur(5px) contrast(1.4) saturate(1.3);
        animation: naturalFloat 25s infinite ease-in-out;
    }

    .emotion-blob.sadness, .emotion-blob.sad {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(65, 105, 225, 0.2) 2px,
                rgba(65, 105, 225, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(65, 105, 225, 0.2) 2px,
                rgba(65, 105, 225, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(65, 105, 225, 0.1) 3px,
                rgba(65, 105, 225, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(65, 105, 225, 0.5), rgba(65, 105, 225, 0.35), rgba(65, 105, 225, 0.2));
        filter: blur(8px) contrast(1.2) saturate(1.1);
    }

    .emotion-blob.anger, .emotion-blob.angry {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 69, 0, 0.2) 2px,
                rgba(255, 69, 0, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(255, 69, 0, 0.2) 2px,
                rgba(255, 69, 0, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(255, 69, 0, 0.1) 3px,
                rgba(255, 69, 0, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(255, 69, 0, 0.6), rgba(255, 69, 0, 0.4), rgba(255, 69, 0, 0.25));
        filter: blur(4px) contrast(1.5) saturate(1.4);
    }

    .emotion-blob.love {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(25, 56, 97, 0.2) 2px,
                rgba(25, 56, 97, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(25, 56, 97, 0.2) 2px,
                rgba(25, 56, 97, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(25, 56, 97, 0.1) 3px,
                rgba(25, 56, 97, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(25, 56, 97, 0.6), rgba(25, 56, 97, 0.4), rgba(25, 56, 97, 0.25));
        filter: blur(7px) contrast(1.3) saturate(1.2);
    }

    .emotion-blob.excitement, .emotion-blob.excited {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 20, 147, 0.2) 2px,
                rgba(255, 20, 147, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(255, 20, 147, 0.2) 2px,
                rgba(255, 20, 147, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(255, 20, 147, 0.1) 3px,
                rgba(255, 20, 147, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(255, 20, 147, 0.6), rgba(255, 20, 147, 0.4), rgba(255, 20, 147, 0.25));
        filter: blur(6px) contrast(1.4) saturate(1.3);
        animation: naturalFloat 20s infinite ease-in-out;
    }

    .emotion-blob.calm {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(78, 205, 196, 0.2) 2px,
                rgba(78, 205, 196, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(78, 205, 196, 0.2) 2px,
                rgba(78, 205, 196, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(78, 205, 196, 0.1) 3px,
                rgba(78, 205, 196, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(78, 205, 196, 0.4), rgba(78, 205, 196, 0.25), rgba(78, 205, 196, 0.15));
        filter: blur(10px) contrast(1.1) saturate(1.0);
    }

    .emotion-blob.neutral {
        background: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(169, 169, 169, 0.2) 2px,
                rgba(169, 169, 169, 0.2) 4px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(192, 192, 192, 0.2) 2px,
                rgba(192, 192, 192, 0.2) 4px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(211, 211, 211, 0.1) 3px,
                rgba(211, 211, 211, 0.1) 6px
            ),
            radial-gradient(circle at 40% 40%, rgba(169, 169, 169, 0.4), rgba(192, 192, 192, 0.3), rgba(211, 211, 211, 0.15));
        filter: blur(8px) contrast(1.2) saturate(1.1);
    }



    @keyframes gentleExcitement {
        0%, 100% {
            transform: translate(-50%, -50%) scale(1) rotate(0deg);
            left: 35%;
            top: 45%;
        }
        12.5% {
            transform: translate(-50%, -50%) scale(1.15) rotate(8deg);
            left: 70%;
            top: 30%;
        }
        25% {
            transform: translate(-50%, -50%) scale(0.9) rotate(-12deg);
            left: 85%;
            top: 55%;
        }
        37.5% {
            transform: translate(-50%, -50%) scale(1.2) rotate(15deg);
            left: 60%;
            top: 75%;
        }
        50% {
            transform: translate(-50%, -50%) scale(0.85) rotate(-8deg);
            left: 25%;
            top: 65%;
        }
        62.5% {
            transform: translate(-50%, -50%) scale(1.1) rotate(20deg);
            left: 10%;
            top: 40%;
        }
        75% {
            transform: translate(-50%, -50%) scale(0.95) rotate(-5deg);
            left: 20%;
            top: 20%;
        }
        87.5% {
            transform: translate(-50%, -50%) scale(1.05) rotate(10deg);
            left: 50%;
            top: 25%;
        }
    }


    
    /* Hide scrollbars for conversation wizard and about page containers */
    #conversation-wizard-page::-webkit-scrollbar {
        display: none;
    }
    
    #about-page::-webkit-scrollbar {
        display: none;
    }
    
    /* Hide scrollbars for retranscribe panel */
    .retranscribe-panel::-webkit-scrollbar {
        display: none;
    }
  </style>
</head>

<body>





  <div id="header-container"></div>
  <!-- header.js removed - not needed -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
        // Header functionality removed - no longer needed
    });
  </script>

  <script>
    // Dynamic conversation data - loaded from auto-generated configuration
    window.conversationDataGlobal = [];
    window.originalConversationData = [];
    
    // Load people data from JSON
    async function loadPeopleData() {
        try {
            const response = await fetch('/config/people_data.json');
            if (!response.ok) {
                throw new Error(`Failed to load people data: ${response.status}`);
            }
            const data = await response.json();
            window.peopleData = data;
            console.log('✅ Loaded people data:', data);
            return data;
        } catch (error) {
            console.error('❌ Failed to load people data:', error);
            return null;
        }
    }
    
    // Load conversation configuration dynamically
    async function loadConversationConfig(isRefresh = false) {
        try {
            // ✅ ENHANCED CACHE-BUSTING: Always prevent stale config after refresh
            const cacheBuster = isRefresh ? `?v=${Date.now()}&refresh=true` : `?v=${Date.now()}`;
            console.log(`📡 Loading conversation config from: config/conversations_config.json${cacheBuster}`);
            
            const response = await fetch(`config/conversations_config.json${cacheBuster}`, {
                cache: 'no-cache',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            });
            
            if (!response.ok) {
                throw new Error(`Failed to load config: ${response.status} ${response.statusText}`);
            }
            
            const config = await response.json();
            console.log('📄 Index.html loaded config:', config);
            
            // Convert configuration to the format expected by the frontend - FILTER AND SORT
            const allConversationData = Object.entries(config.conversations)
                .map(([folder, data], index) => {
                    // Use enhanced metadata if available
                    const metadata = data.metadata || {};
                    
                    // Get display name - prioritize metadata name
                    const displayName = metadata.name || `שיחה ${data.number}`;
                    
                    // Get participants info - use metadata if available
                    const participants = metadata.participants?.length 
                        ? metadata.participants.join(', ') 
                        : displayName;
                    
                    // Get date - use metadata date if available
                    const conversationDate = metadata.date || '2024-06-26';
                    
                    // Get duration - use calculated duration if available
                    const duration = metadata.duration || `${Math.round(data.mp3_count * 0.5)} דקות`;
                    
                    // Get emotions - use main emotions if available
                    const mainEmotions = metadata.mainEmotions?.length 
                        ? metadata.mainEmotions 
                        : ['ניתוח רגשי'];
                    
                    // Create summary feelings from main emotions and word count
                    const emotionSummary = mainEmotions.join(', ');
                    const wordCount = metadata.totalWords ? ` | ${metadata.totalWords} מילים` : '';
                    const summaryFeelings = `${emotionSummary}${wordCount}`;
                    
                    // Parse duration to get minutes (if in MM:SS format)
                    let durationMinutes = Math.round(data.mp3_count * 0.5);
                    if (metadata.duration && metadata.duration.includes(':')) {
                        const [minutes, seconds] = metadata.duration.split(':').map(Number);
                        durationMinutes = minutes + Math.round(seconds / 60);
                    }
                    
                    return {
                        id: `conv${data.number}`,
                        folder: folder,
                        date: conversationDate,
                        time: '12:00',
                        participants: participants,
                        summaryFeelings: summaryFeelings,
                        durationMinutes: durationMinutes,
                        emotionFile: data.ai_file || data.emotion_file,
                        mp3_count: data.mp3_count,
                        conversationNumber: data.number,
                        // Include metadata for advanced features
                        metadata: metadata,
                        displayName: displayName,
                        mainEmotions: mainEmotions,
                        isImportant: metadata.isImportant || false,
                        isPrivate: metadata.isPrivate || false,
                        needsReview: metadata.needsReview || false
                    };
                })
                .sort((a, b) => a.conversationNumber - b.conversationNumber);
            
            // FILTER OUT CONVERSATIONS WITH INSUFFICIENT CONTENT
            const newConversationData = allConversationData.filter(conv => {
                // Minimum requirements for display - RELAXED for timeline compatibility
                const hasEnoughContent = conv.mp3_count >= 1; // At least 1 MP3 file (reduced from 3)
                
                if (!hasEnoughContent) {
                    console.log(`⚠️ Filtering out ${conv.folder}: insufficient content (${conv.mp3_count} MP3s)`);
                    return false;
                }
                
                // Always show conversations in timeline - video files are optional
                console.log(`✅ Including ${conv.folder} in timeline (${conv.mp3_count} MP3s)`);
                return true;
            });
            
            // Check if there are any changes (for refresh scenarios)
            const hasChanges = JSON.stringify(newConversationData) !== JSON.stringify(window.conversationDataGlobal);
            
                            if (hasChanges || !isRefresh) {
                window.conversationDataGlobal = newConversationData;
                window.originalConversationData = JSON.parse(JSON.stringify(window.conversationDataGlobal));
                
                // Enhanced logging to show filtered conversations
                const totalFromConfig = allConversationData.length;
                const displayedCount = window.conversationDataGlobal.length;
                const filteredOut = totalFromConfig - displayedCount;
                
                console.log(`📊 Conversation Filtering Results:`);
                console.log(`   📁 Total in config: ${totalFromConfig}`);
                console.log(`   ✅ Displaying: ${displayedCount}`);
                console.log(`   🚫 Filtered out: ${filteredOut}`);
                console.log(`   🎬 Displayed conversations: ${window.conversationDataGlobal.map(c => c.folder).join(', ')}`);
                
                if (isRefresh && hasChanges) {
                    console.log(`🔄 Detected ${window.conversationDataGlobal.length} conversations (updated from admin changes)`);
                    
                    // Remove deleted conversation items from DOM
                    removeDeletedConversationItems();
                    
                    // Re-render the layout with updated data
                    if (typeof window.renderNewLayout === 'function') {
                        window.renderNewLayout(false);
                    }
                    
                    // Show notification about the change (commented out)
                    // showConversationUpdateNotification();
                } else {
                    console.log(`✅ Loaded ${window.conversationDataGlobal.length} conversations dynamically`);
                
                // Update blob emotion based on loaded conversations
                setTimeout(() => {
                    if (typeof window.updateBlobEmotionFromConversations === 'function') {
                        window.updateBlobEmotionFromConversations();
                    }
                }, 1000);
                }
            }
            
            return true;
        } catch (error) {
            console.error('❌ Failed to load conversation config, using fallback:', error);
            
            // Fallback to hardcoded data if config file doesn't exist - ALL CONVERSATIONS (videos optional)
            window.conversationDataGlobal = [
                { id: 'conv1', folder: 'convo1', date: '2024-04-05', time: '11:00', participants: 'שיחה עם אבא', summaryFeelings: 'שמחה, עניין', durationMinutes: 37, mp3_count: 73 },
                { id: 'conv2', folder: 'convo2', date: '2024-05-15', time: '16:00', participants: 'שיחה על הצבא', summaryFeelings: 'ניתוח, סקרנות', durationMinutes: 87, mp3_count: 174 },
                { id: 'conv3', folder: 'convo3', date: '2024-06-24', time: '21:10', participants: 'שיחה עם חבילה', summaryFeelings: 'שיחה קצרה', durationMinutes: 2, mp3_count: 4 },
                { id: 'conv4', folder: 'convo4', date: '2024-07-01', time: '10:00', participants: 'על החיים', summaryFeelings: 'סקרנות, ניתוח', durationMinutes: 10, mp3_count: 20 },
                { id: 'conv5', folder: 'convo5', date: '2024-07-10', time: '14:30', participants: 'שיעור ודגחמ', summaryFeelings: 'דיון מעמיק', durationMinutes: 37, mp3_count: 73 },
                { id: 'conv6', folder: 'convo6', date: '2024-07-15', time: '09:15', participants: 'ביום יום עם פרדי', summaryFeelings: 'שיחה ארוכה', durationMinutes: 52, mp3_count: 104 },
                { id: 'conv7', folder: 'convo7', date: '2024-07-20', time: '16:45', participants: 'מבחן של יואב', summaryFeelings: 'שיחה בינונית', durationMinutes: 35, mp3_count: 68 },
                { id: 'conv8', folder: 'convo8', date: '2024-07-25', time: '12:00', participants: 'נפגשים ביריד', summaryFeelings: 'שיחה קצרה', durationMinutes: 8, mp3_count: 14 },
                { id: 'conv10', folder: 'convo10', date: '2024-08-01', time: '13:30', participants: 'פרידה מגיליבר', summaryFeelings: 'שיחה ארוכה', durationMinutes: 52, mp3_count: 104 },
                // NEW CONVERSATIONS ADDED
                { id: 'conv19', folder: 'convo19', date: '2025-07-20', time: '15:00', participants: 'לא נפגש עם גיליבר', summaryFeelings: 'שמחה', durationMinutes: 1, mp3_count: 24 },
                { id: 'conv20', folder: 'convo20', date: '2025-07-25', time: '15:14', participants: 'שיחה עם גיליבר במחובר 12', summaryFeelings: 'נייטרלי', durationMinutes: 1, mp3_count: 32 },
                { id: 'conv21', folder: 'convo21', date: '2025-07-25', time: '15:14', participants: 'שיחה עם גיליבר במחובר 11', summaryFeelings: 'נייטרלי', durationMinutes: 1, mp3_count: 23 },
                { id: 'conv22', folder: 'convo22', date: '2025-07-25', time: '15:14', participants: 'שיחה עם גיליבר במחובר 10', summaryFeelings: 'נייטרלי', durationMinutes: 1, mp3_count: 15 },
                { id: 'conv23', folder: 'convo23', date: '2025-07-25', time: '15:14', participants: 'שיחה עם גיליבר במחובר 9', summaryFeelings: 'נייטרלי', durationMinutes: 1, mp3_count: 42 },
                { id: 'conv27', folder: 'convo27', date: '2025-07-25', time: '15:13', participants: 'שיחה עם גיליבר במחובר 8', summaryFeelings: 'נייטרלי', durationMinutes: 1, mp3_count: 52 },
                { id: 'conv28', folder: 'convo28', date: '2025-07-25', time: '15:13', participants: 'שיחה עם גיליבר במחובר 7', summaryFeelings: 'נייטרלי', durationMinutes: 2, mp3_count: 91 },
                { id: 'conv29', folder: 'convo29', date: '2025-07-25', time: '15:13', participants: 'שיחה עם גיליבר במחובר 6', summaryFeelings: 'נייטרלי', durationMinutes: 1, mp3_count: 3 },
                { id: 'conv30', folder: 'convo30', date: '2025-07-25', time: '15:13', participants: 'שיחה עם גיליבר במחובר 5', summaryFeelings: 'נייטרלי', durationMinutes: 1, mp3_count: 5 },
                { id: 'conv31', folder: 'convo31', date: '2025-07-25', time: '15:13', participants: 'שיחה עם גיליבר במחובר 4', summaryFeelings: 'נייטרלי', durationMinutes: 2, mp3_count: 98 },
                { id: 'conv32', folder: 'convo32', date: '2025-07-25', time: '15:13', participants: 'שיחה עם גיליבר במחובר 2', summaryFeelings: 'נייטרלי', durationMinutes: 2, mp3_count: 69 },
                { id: 'conv33', folder: 'convo33', date: '2025-07-25', time: '15:13', participants: 'שיחה עם גיליבר במחובר 2', summaryFeelings: 'נייטרלי', durationMinutes: 2, mp3_count: 69 },
                { id: 'conv34', folder: 'convo34', date: '2025-07-25', time: '15:12', participants: 'שלום', summaryFeelings: 'נייטרלי', durationMinutes: 1, mp3_count: 24 },
            ];
            window.originalConversationData = JSON.parse(JSON.stringify(window.conversationDataGlobal));
            return false;
        }
    }
    
    // Helper function to remove deleted conversation items from DOM
    function removeDeletedConversationItems() {
        const layoutCanvas = document.getElementById('layout-canvas');
        if (!layoutCanvas) return;
        
        // Get list of current conversation folders
        const currentFolders = new Set(window.conversationDataGlobal.map(conv => conv.folder));
        
        // Find and remove conversation items that no longer exist
        const allConvItems = layoutCanvas.querySelectorAll('[id^="conv-item-"]');
        allConvItems.forEach(item => {
            const convId = item.id.replace('conv-item-', '');
            const convData = window.conversationDataGlobal.find(c => c.id === convId);
            
            if (!convData) {
                console.log(`🗑️ Removing deleted conversation item: ${convId}`);
                item.remove();
            }
        });
    }
    
    // Show notification when conversations are updated
    function showConversationUpdateNotification() {
        // Create or show notification
        let notification = document.getElementById('conversation-update-notification');
        if (!notification) {
            notification = document.createElement('div');
            notification.id = 'conversation-update-notification';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #4CAF50, #45a049);
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 10000;
                font-size: 14px;
                max-width: 300px;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
                direction: rtl;
            `;
            document.body.appendChild(notification);
        }
        
        notification.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 18px;">✅</span>
                <span>השיחות עודכנו אוטומטית</span>
            </div>
            <div style="font-size: 12px; margin-top: 5px; opacity: 0.9;">
                שינויים מהפאנל הניהול סונכרנו
            </div>
        `;
        
        // Show notification
        setTimeout(() => {
            notification.style.opacity = '1';
            notification.style.transform = 'translateX(0)';
        }, 100);
        
        // Hide notification after 3 seconds
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    
    // Periodic refresh to check for admin panel changes
    let refreshInterval;
    function startConversationSync() {
        // Check for changes every 60 seconds instead of 10 to reduce load
        refreshInterval = setInterval(async () => {
            try {
                await loadConversationConfig(true);
                await loadPeopleData(); // Also sync people data
            } catch (error) {
                console.warn('⚠️ Failed to sync conversations:', error);
            }
        }, 60000); // 60 seconds (was 10 seconds)
    }
    
    function stopConversationSync() {
        if (refreshInterval) {
            clearInterval(refreshInterval);
            refreshInterval = null;
        }
    }
    
    // Manual refresh function (can be called from admin panel)
    window.refreshConversations = async function() {
        console.log('🔄 Manual conversation refresh requested');
        await loadConversationConfig(true);
        await loadPeopleData(); // Also refresh people data
    };
    
    window.populateConversationGrid = async function() {
        // Skip conversation loading if in lab mode
        if (window.isLabMode || window.skipConversationLoading) {
            console.log('🧪 Skipping conversation loading - Lab mode active');
            return;
        }
        
        console.log('🚀 Starting conversation grid population...');
        
        // Load configuration first if not already loaded
        if (window.conversationDataGlobal.length === 0) {
            console.log('📊 Loading conversation configuration with force refresh...');
            await loadConversationConfig(true); // Force refresh on initial page load
        }
        
        // Ensure data is loaded before proceeding
        if (window.conversationDataGlobal.length === 0) {
            console.error('❌ No conversation data available after loading!');
            return;
        }
        
        console.log(`✅ Conversation data loaded: ${window.conversationDataGlobal.length} conversations`);
        
        // Load people data for people view
        console.log('👥 Loading people data...');
        await loadPeopleData();
        
        // Populate re-transcription options dynamically
        populateRetranscriptionOptions();
        
        // Ensure we start with timeline view for proper first load
        if (!window.activeLayout) {
            window.activeLayout = 'timeline';
            console.log('🎯 Set initial layout to timeline');
        }
        
        // Render the layout with initial data
        if (typeof window.renderNewLayout === 'function') {
            console.log('🎬 Rendering initial layout...');
            await window.renderNewLayout(true);
        } else {
            console.error('❌ renderNewLayout function not available!');
        }
        
        // Start automatic synchronization
        startConversationSync();
        
        // Set up BroadcastChannel for cross-tab communication
        setupCrossTabSync();
        
        console.log('✅ Conversation grid population completed');
    };
    
    // Set up cross-tab communication with admin panel
    function setupCrossTabSync() {
        if (typeof BroadcastChannel !== 'undefined') {
            const channel = new BroadcastChannel('conversation-sync');
            
            channel.addEventListener('message', async (event) => {
                const { type, folder, timestamp } = event.data;
                
                if (type === 'conversation-deleted') {
                    console.log(`📻 Received deletion broadcast for ${folder}`);
                    // Immediately refresh to sync changes
                    setTimeout(async () => {
                        await loadConversationConfig(true);
                    }, 1000);
                } else if (type === 'refresh-conversations') {
                    console.log(`📻 Received refresh broadcast from admin panel`);
                    setTimeout(async () => {
                        await loadConversationConfig(true);
                    }, 500);
                } else if (type === 'force-config-reload') {
                    console.log(`📻 Received force config reload broadcast from admin panel`);
                    
                    // Clear any cached data
                    window.conversationDataGlobal = [];
                    window.lastConfigUpdate = Date.now();
                    
                    setTimeout(async () => {
                        await loadConversationConfig(true);
                        console.log('✅ Forced conversation config reload completed via broadcast');
                        
                        // Force re-render the current layout to show updated names
                        if (typeof window.renderNewLayout === 'function') {
                            console.log('🔄 Re-rendering layout via broadcast with updated conversation names...');
                            await window.renderNewLayout(true);
                            console.log('✅ Layout re-rendered via broadcast with updated names');
                        }
                    }, 300);
                } else if (type === 'update-conversation-title') {
                    console.log(`📻 Received conversation title update broadcast from admin panel:`, event.data);
                    
                    // Update conversation data in memory and refresh grid
                    if (event.data.metadata && event.data.metadata.name && event.data.conversation) {
                        console.log(`🔄 Updating conversation data via broadcast for ${event.data.conversation} with name: ${event.data.metadata.name}`);
                        
                        // Update the conversation data in memory
                        const conversationToUpdate = window.conversationDataGlobal.find(conv => conv.folder === event.data.conversation);
                        if (conversationToUpdate) {
                            conversationToUpdate.displayName = event.data.metadata.name;
                            conversationToUpdate.metadata = { ...conversationToUpdate.metadata, ...event.data.metadata };
                            console.log(`✅ Updated conversation data in memory via broadcast for ${event.data.conversation}`);
                        }
                        
                        // Update the data-conversation attribute for the grid item
                        const gridItem = document.getElementById(`conv-item-${event.data.conversation}`);
                        if (gridItem) {
                            gridItem.setAttribute('data-conversation', event.data.metadata.name);
                            console.log(`✅ Updated grid item data-conversation attribute via broadcast for ${event.data.conversation}`);
                        }
                        
                        // If there's a currently visible hover panel for this conversation, update it
                        const hoverPanel = document.getElementById('hover-info-panel');
                        if (hoverPanel && hoverPanel.classList.contains('visible')) {
                            const titleElement = hoverPanel.querySelector('.hover-info-title');
                            if (titleElement && conversationToUpdate) {
                                // Update hover panel if it's showing this conversation
                                const panelText = titleElement.textContent;
                                if (panelText.includes(event.data.conversation) || panelText.includes(conversationToUpdate.displayName)) {
                                    showHoverPanel(conversationToUpdate);
                                    console.log(`✅ Updated visible hover panel via broadcast for ${event.data.conversation}`);
                                }
                            }
                        }
                        
                        console.log(`✅ Conversation title update via broadcast completed for ${event.data.conversation}`);
                    }
                }
            });
            
            console.log('📻 BroadcastChannel setup complete for conversation sync');
            
            // Clean up on page unload
            window.addEventListener('beforeunload', () => {
                channel.close();
            });
        }
    }
    
    // Function to populate re-transcription options dynamically
    function populateRetranscriptionOptions() {
        const quickAnalysisContainer = document.getElementById('quick-analysis-options');
        const fullReprocessContainer = document.getElementById('full-reprocess-options');
        
        if (!quickAnalysisContainer || !fullReprocessContainer) return;
        
        // Clear existing content
        quickAnalysisContainer.innerHTML = '';
        fullReprocessContainer.innerHTML = '';
        
        // Generate options for each conversation
        window.conversationDataGlobal.forEach(conv => {
            // Quick analysis option
            const quickButton = document.createElement('button');
            quickButton.className = 'convo-option quick-analysis';
            quickButton.onclick = () => retranscribeConversation(conv.folder, false);
            quickButton.innerHTML = `
                <span class="convo-icon">🎵</span>
                <span class="convo-details">
                    <span class="convo-name">${conv.participants}</span>
                    <span class="convo-count">${conv.mp3_count || 'N/A'} קטעים</span>
                </span>
            `;
            quickAnalysisContainer.appendChild(quickButton);
            
            // Full reprocess option
            const fullButton = document.createElement('button');
            fullButton.className = 'convo-option full-reprocess';
            fullButton.onclick = () => reprocessMP3Files(conv.folder);
            fullButton.innerHTML = `
                <span class="convo-icon">🔊</span>
                <span class="convo-details">
                    <span class="convo-name">${conv.participants} - תמלול מלא</span>
                    <span class="convo-count">${conv.mp3_count || 'N/A'} קבצי MP3</span>
                </span>
            `;
            fullReprocessContainer.appendChild(fullButton);
        });
    }
  </script>

  <div id="splash-screen">
    <div class="background-dots" id="backgroundDots"></div>
    <div class="scanlines"></div>
    
    <div class="loading-container">
        <div class="loading-text">טוען: יומן השיחות של ליאור</div>
        <div class="loading-bar-container">
            <div class="loading-bar"></div>
        </div>
        <div class="loading-percentage" id="percentage">0%</div>
    </div>
    
    <div class="preview-window preview-1">
        <video muted autoplay loop style="width: 100%; height: 100%; object-fit: contain; background: #f7f9f3;">
            <source src="videos/convo1.mp4" type="video/mp4">
        </video>
    </div>
    
    <div class="preview-window preview-2">
        <video muted autoplay loop style="width: 100%; height: 100%; object-fit: contain; background: #f7f9f3;">
            <source src="videos/convo2.mp4" type="video/mp4">
        </video>
    </div>
    
    <div class="preview-window preview-3">
        <video muted autoplay loop style="width: 100%; height: 100%; object-fit: contain; background: #f7f9f3;">
            <source src="videos/convo4.mp4" type="video/mp4">
        </video>
    </div>
    
    <div class="preview-window preview-4">
        <video muted autoplay loop style="width: 100%; height: 100%; object-fit: contain; background: #f7f9f3;">
            <source src="videos/convo6.mp4" type="video/mp4">
        </video>
    </div>
    
    <div class="preview-window preview-5">
        <video muted autoplay loop style="width: 100%; height: 100%; object-fit: contain; background: #f7f9f3;">
            <source src="videos/convo7.mp4" type="video/mp4">
        </video>
    </div>
    
    <div class="preview-window preview-6">
        <video muted autoplay loop style="width: 100%; height: 100%; object-fit: contain; background: #f7f9f3;">
            <source src="videos/convo9.mp4" type="video/mp4">
        </video>
    </div>
  </div>

  <!-- Main Navigation Header -->
  <header class="app-header">
    <div class="header-title-container" style="all: unset; display: flex; align-items: center;">
      <div class="header-title" style="all: unset;">
        <span id="logo-text" style="font-size: 32px; font-weight: light; font-family: 'Miriam Libre', sans-serif; padding: 8px 0; display: inline-block; min-width: 60px; text-align: center;">1:1</span>
      </div>
      <div id="new-conversation-btn" onclick="showConversationWizardAndGoToMicrophone(); return false;" style="background: transparent; border: 1px solid #999; color: #333; padding: 8px 16px; font-size: 14px; font-family: 'Miriam Libre', sans-serif; cursor: pointer; border-radius: 0; transition: all 0.2s ease; margin-left: 30px; z-index: 9999; position: relative; display: none; visibility: visible; opacity: 1;" onmouseover="this.style.border='1px solid #000'" onmouseout="this.style.border='1px solid #999'">צור שיחה חדשה</div>
    </div>
    
            <nav class="header-nav" style="gap: 30px;">
            <a href="#" class="nav-link active-nav" onclick="showConversationsPage(); return false;">שיחות</a>
            <a href="#" class="nav-link" onclick="showAboutPage(); return false;">על הפרויקט</a>
        </nav>
  </header>

    <div id="timeline-grid-wrapper">
        <div id="timeline-axes-container" class="layout-timeline">
            <div id="layout-canvas"></div>
        </div>
    </div>
    
    <!-- Conversation Wizard Container -->
    <div id="conversation-wizard-page" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; z-index: 1000; overflow-y: auto; scrollbar-width: none; -ms-overflow-style: none;">
        <iframe id="conversation-wizard-iframe" src="" style="width: 100%; height: 100%; border: none;"></iframe>
    </div>

    <!-- About Page Container -->
        <div id="about-page" style="display: none; position: fixed; top: 60px; left: 0; width: 100%; height: calc(100% - 60px); background: #f7f9f3; z-index: 500; overflow-y: auto; padding: 60px 40px 40px 40px; scrollbar-width: none; -ms-overflow-style: none;">
        <div style="max-width: 600px; margin: 0 auto; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 0;">
            <h1 style="text-align: center; font-size: 24px; font-weight: 400; color: #333; margin-bottom: 30px;">על הפרויקט</h1>
            
            <div style="margin-bottom: 25px;">
                <h2 style="font-size: 16px; font-weight: 400; color: #333; margin-bottom: 10px; text-align: right;">מוטיבציה</h2>
                <p style="font-size: 14px; line-height: 1.5; color: #555; text-align: right; margin: 0;">
                    הפרויקט נולד מתוך רצון לחקור ולנתח שיחות אנושית דרך עדשת הרגשות. 
                    באמצעות טכנולוגיות מתקדמות של בינה מלאכותית, אנו מסוגלים לזהות, למדוד ולהציג 
                    את הרגשות העולים במהלך שיחות, תוך שמירה על פרטיות המשתתפים. 
                    המטרה היא ליצור כלי שיאפשר הבנה עמוקה יותר של הדינמיקה הרגשית בשיחות.
                </p>
            </div>
            
            <div style="margin-bottom: 25px;">
                <h2 style="font-size: 16px; font-weight: 400; color: #333; margin-bottom: 10px; text-align: right;">מקור דאטה</h2>
                <p style="font-size: 14px; line-height: 1.5; color: #555; text-align: right; margin: 0;">
                    הנתונים מגיעים משיחות אותנטיות שתועדו במהלך מחקר על תקשורת אנושית. 
                    כל שיחה עוברת עיבוד באמצעות אלגוריתמים מתקדמים לזיהוי רגשות, 
                    המסוגלים לזהות מגוון רחב של רגשות כגון שמחה, עצב, כעס, פחד, הפתעה ועוד. 
                    הנתונים מוצגים בצורה ויזואלית אינטראקטיבית המאפשרת חקר מעמיק.
                </p>
            </div>
            
            <div style="margin-bottom: 25px;">
                <h2 style="font-size: 16px; font-weight: 400; color: #333; margin-bottom: 10px; text-align: right;">יצירת הפרויקט</h2>
                <p style="font-size: 14px; line-height: 1.5; color: #555; text-align: right; margin: 0;">
                    הפרויקט פותח באמצעות טכנולוגיות ווב מתקדמות, כולל JavaScript, HTML5 ו-CSS3. 
                    הניתוח הרגשי מתבצע באמצעות מודלים של בינה מלאכותית, 
                    וההצגה הוויזואלית נוצרת באמצעות ספריות גרפיות מתקדמות. 
                    הממשק מתוכנן להיות אינטואיטיבי ונגיש למשתמשים מכל רקע טכני.
                </p>
            </div>
            

        </div>
    </div>
    

    
    <div id="bottom-controls-container" style="display: flex; justify-content: space-between; align-items: center; width: 100%; padding: 0 20px;">
        <!-- Zoom Controls on the LEFT side -->
        <div class="zoom-controls" style="display: flex; align-items: center; gap: 10px; z-index: 1002;">
            <button id="zoom-out-btn" class="zoom-btn" title="הקטן תצוגה">➖</button>
            <span id="zoom-indicator" class="zoom-indicator">100%</span>
            <button id="zoom-in-btn" class="zoom-btn" title="הגדל תצוגה">➕</button>
            <span style="margin-left: 15px; color: #666; font-size: 12px;">|</span>
            <span id="pan-indicator" style="color: #666; font-size: 12px; width: fit-content;">מרכז</span>
        </div>
        
        <!-- Views on the RIGHT side -->
        <div class="view-toggle-buttons nav-slash-style" style="gap: 8px;">
            <button id="timeline-view-btn" class="view-toggle-btn active">ציר זמן</button>
            <span>/</span>
            <button id="people-view-btn" class="view-toggle-btn">אנשים</button>
            <span>/</span>
            <button id="emotions-view-btn" class="view-toggle-btn">רגשות</button>
        </div>

    </div>



    <div id="hover-info-panel"></div>
    <div id="visualization-modal-container"></div>
  
  <!-- Exit Tooltip -->
  <div id="exit-tooltip" class="exit-tooltip">לחץ כדי לסגור</div>
    
    <!-- Audio Prompt removed -->
    
    <!-- Loading Indicator -->
    <div id="loading-indicator" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 8px; z-index: 5002;">
        <div id="loading-text">טוען...</div>
        <div id="loading-details" style="font-size: 14px; margin-top: 10px;"></div>
    </div>

    <script>
        // Hebrew Splash Screen Functions
        function createBackgroundDots() {
            const container = document.getElementById('backgroundDots');
            if (!container) return;
            
            const dotCount = 50;
            
            for (let i = 0; i < dotCount; i++) {
                const dot = document.createElement('div');
                dot.className = 'dot';
                dot.style.left = Math.random() * 100 + '%';
                dot.style.top = Math.random() * 100 + '%';
                dot.style.animationDelay = Math.random() * 3 + 's';
                container.appendChild(dot);
            }
        }
        
        // Animate loading percentage
        function animatePercentage() {
            const percentageEl = document.getElementById('percentage');
            if (!percentageEl) return;
            
            let progress = 0;
            const targetTime = 2500; // 2.5 seconds to reach 100%
            const increment = 100 / (targetTime / 100); // Calculate increment needed
            
            const interval = setInterval(() => {
                progress += increment + (Math.random() * 0.3); // Small random variation
                if (progress >= 100) {
                    progress = 100;
                    percentageEl.textContent = '100%';
                    clearInterval(interval);
                } else {
                    percentageEl.textContent = Math.floor(progress) + '%';
                }
            }, 100);
        }
        
        // Create random flash effects
        function startFlashEffects() {
            const flashInterval = setInterval(() => {
                const splashScreen = document.getElementById('splash-screen');
                if (!splashScreen || splashScreen.classList.contains('hidden')) {
                    clearInterval(flashInterval);
                    return;
                }
                
                if (Math.random() > 0.8) {
                    const flash = document.createElement('div');
                    flash.style.position = 'absolute';
                    flash.style.top = Math.random() * 100 + '%';
                    flash.style.left = Math.random() * 100 + '%';
                    flash.style.width = '3px';
                    flash.style.height = '3px';
                    flash.style.background = '#8B7355';
                    flash.style.borderRadius = '50%';
                    flash.style.opacity = '0.8';
                    flash.style.animation = 'twinkle 0.5s ease-out';
                    flash.style.zIndex = '2';
                    splashScreen.appendChild(flash);
                    
                    setTimeout(() => flash.remove(), 500);
                }
            }, 200);
        }

        document.addEventListener('DOMContentLoaded', async () => {
        // Load emotions config at startup
        await loadHoverEmotionsConfig();
        
        // STATIC BACKGROUND GRID: Handled by CSS and ensureStaticBackgroundGrid function
        
        const splashScreen = document.getElementById('splash-screen');
        
        // Always show splash screen on page load/refresh
        // Initialize Hebrew splash screen animations
        createBackgroundDots();
        animatePercentage();
        startFlashEffects();
        
        setTimeout(async () => {
            splashScreen.classList.add('hidden');
            await window.populateConversationGrid();
        }, 2500);
        
        // Start the logo animation
        startLogoAnimation();
        
        // Initialize hover panel event listeners
        initializeHoverPanel();
        
        // Initialize tooltip control system
        initializeTooltipControl();
    });
    
    // Logo animation function
    function startLogoAnimation() {
        const logoElement = document.getElementById('logo-text');
        const symbols = ['!', '?', '['];
        
        function animateLogo() {
            if (logoElement) {
                // Randomly decide if "1" should be on left or right
                const oneOnLeft = Math.random() < 0.5;
                
                if (oneOnLeft) {
                    // "1" on the left, random symbol on the right
                    const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                    logoElement.textContent = '1' + ':' + randomSymbol;
                } else {
                    // Random symbol on the left, "1" on the right
                    const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                    logoElement.textContent = randomSymbol + ':' + '1';
                }
            }
        }
        
        // Change characters every 2 seconds
        setInterval(animateLogo, 2000);
        
        // Initial animation
        animateLogo();
    }

    

    
    // Debug function to check conversation visibility
    function debugConversationVisibility() {
        const layoutCanvas = document.getElementById('layout-canvas');
        const conversations = document.querySelectorAll('.conversation-grid-item-container');
        
        console.log('🔍 DEBUG: Conversation Visibility Check');
        console.log('📏 Layout Canvas:', {
            element: layoutCanvas,
            exists: !!layoutCanvas,
            dimensions: layoutCanvas ? {
                width: layoutCanvas.offsetWidth,
                height: layoutCanvas.offsetHeight,
                clientWidth: layoutCanvas.clientWidth,
                clientHeight: layoutCanvas.clientHeight,
                scrollWidth: layoutCanvas.scrollWidth,
                scrollHeight: layoutCanvas.scrollHeight
            } : 'N/A',
            style: layoutCanvas ? {
                position: layoutCanvas.style.position,
                top: layoutCanvas.style.top,
                left: layoutCanvas.style.left,
                width: layoutCanvas.style.width,
                height: layoutCanvas.style.height,
                display: layoutCanvas.style.display,
                visibility: layoutCanvas.style.visibility
            } : 'N/A'
        });
        
        console.log('🎬 Conversations Found:', conversations.length);
        conversations.forEach((conv, index) => {
            const rect = conv.getBoundingClientRect();
            console.log(`📍 ${conv.id}:`, {
                index: index,
                dimensions: {
                    width: conv.offsetWidth,
                    height: conv.offsetHeight,
                    clientWidth: conv.clientWidth,
                    clientHeight: conv.clientHeight
                },
                position: {
                    left: conv.style.left,
                    top: conv.style.top,
                    position: conv.style.position
                },
                visibility: {
                    display: conv.style.display,
                    visibility: conv.style.visibility,
                    opacity: conv.style.opacity,
                    zIndex: conv.style.zIndex
                },
                boundingRect: {
                    left: Math.round(rect.left),
                    top: Math.round(rect.top),
                    width: Math.round(rect.width),
                    height: Math.round(rect.height),
                    visible: rect.width > 0 && rect.height > 0
                }
            });
        });
        
        return {
            layoutCanvas: !!layoutCanvas,
            conversationCount: conversations.length,
            visibleConversations: Array.from(conversations).filter(conv => {
                const rect = conv.getBoundingClientRect();
                return rect.width > 0 && rect.height > 0;
            }).length
        };
    }
    
    // Make debug function available globally
    window.debugConversationVisibility = debugConversationVisibility;
    </script>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        // Message listener moved above to handle all iframe messages
        const modalContainer = document.getElementById('visualization-modal-container');
        if (modalContainer) {
            // Show tooltip on hover near edges
            modalContainer.addEventListener('mousemove', (event) => {
                if (event.target === modalContainer) {
                    const rect = modalContainer.getBoundingClientRect();
                    const edgeThreshold = 60; // pixels from edge
                    
                    // Check if mouse is near any edge
                    const nearEdge = event.clientX < edgeThreshold || 
                                   event.clientX > rect.width - edgeThreshold ||
                                   event.clientY < edgeThreshold ||
                                   event.clientY > rect.height - edgeThreshold;
                    
                    if (nearEdge) {
                        showExitTooltip();
                    } else {
                        hideExitTooltip();
                    }
                }
            });
            
            // Hide tooltip when leaving modal
            modalContainer.addEventListener('mouseleave', () => {
                hideExitTooltip();
            });
            
            // Close modal on click outside
            modalContainer.addEventListener('click', (event) => {
                if (event.target === modalContainer) {
                    closeVisualizationModal();
                }
            });
        }
        const viewButtons = document.querySelectorAll('.view-toggle-btn');
        viewButtons.forEach(button => {
            button.addEventListener('click', function() {
                viewButtons.forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                const layout = this.id.split('-')[0];
                console.log(`🎬 ISOTOPE: User clicked ${layout} view button - triggering smooth animations`);
                
                if (layout === 'people') {
                    console.log(`👥 PEOPLE VIEW: Button clicked, switching to people layout`);
                    
                    // DEBUG: Check if people data is available
                    fetch('/config/people_data.json')
                        .then(response => response.json())
                        .then(data => {
                            console.log(`👥 DEBUG: People data loaded:`, data);
                            console.log(`👥 DEBUG: Number of people:`, Object.keys(data.people || {}).length);
                        })
                        .catch(error => console.error(`❌ DEBUG: People data load error:`, error));
                    
                    // DEBUG: Check layout canvas visibility
                    setTimeout(() => {
                        const layoutCanvas = document.getElementById('layout-canvas');
                        const timelineContainer = document.getElementById('timeline-axes-container');
                        console.log(`👥 DEBUG: Layout canvas class:`, layoutCanvas.className);
                        console.log(`👥 DEBUG: Layout canvas style:`, layoutCanvas.style.cssText);
                        console.log(`👥 DEBUG: Timeline container dimensions:`, {
                            width: timelineContainer.clientWidth,
                            height: timelineContainer.clientHeight,
                            offsetWidth: timelineContainer.offsetWidth,
                            offsetHeight: timelineContainer.offsetHeight
                        });
                        
                        // Check for any overlaying elements
                        const allLabels = document.querySelectorAll('.person-name-label');
                        const allMessages = document.querySelectorAll('.people-debug-message');
                        console.log(`👥 DEBUG: Found ${allLabels.length} person labels and ${allMessages.length} debug messages`);
                        
                        // Check z-index issues
                        const highZIndexElements = Array.from(document.querySelectorAll('*')).filter(el => {
                            const zIndex = window.getComputedStyle(el).zIndex;
                            return zIndex && parseInt(zIndex) > 1000;
                        });
                        console.log(`👥 DEBUG: High z-index elements that might cover people view:`, highZIndexElements.map(el => ({
                            element: el.tagName + (el.className ? '.' + el.className : ''),
                            zIndex: window.getComputedStyle(el).zIndex
                        })));
                    }, 500);
                }
                
                // TIMELINE VIEW: No position reset needed - use cached positions
                if (layout === 'timeline') {
                    console.log('🔄 TIMELINE SWITCH: Will use cached positions - no reset needed');
                }
                
                if(typeof window.switchLayout === 'function') window.switchLayout(layout);
            });
        });
        
        // Add special double-click functionality to force refresh timeline positions
        document.addEventListener('dblclick', function(event) {
            if (event.target.classList.contains('view-toggle-btn') && 
                event.target.textContent.includes('Timeline')) {
                console.log('🔄 DOUBLE-CLICK: Force clearing timeline cache and recalculating');
                // Clear timeline cache and force recalculation
                if (window.layoutPositions) {
                    window.layoutPositions.timeline = {}; // Clear cache
                    console.log('🗑️ Timeline position cache cleared');
                }
                // Force fresh calculation
                if (window.conversations && typeof window.renderNewLayout === 'function') {
                    window.renderNewLayout(false);
                    console.log('✅ Timeline positions recalculated after cache clear');
                }
            }
        });

        // Initialize playground mode
        if (typeof initializePlaygroundMode === 'function') {
            initializePlaygroundMode();
        } else {
            console.log('⚠️ Playground mode not available');
        }
      });
    </script>
    

    
    <script>
    // --- UNIFIED CONTROLS SCRIPT ---
    document.addEventListener('DOMContentLoaded', () => {
        // --- Shared variables ---
        const panzoomContainer = document.getElementById('timeline-axes-container');
        const layoutCanvas = document.getElementById('layout-canvas');
        const timelineControls = document.getElementById('bottom-controls-container');

        window.MIN_ZOOM = 0.5;
        window.MAX_ZOOM = 4;
        window.ZOOM_STEP = 0.1;

        // --- Camera and Transform Logic (Shared by all controls) ---
        function updateTransform() {
            if(layoutCanvas) {
                // Apply both zoom and pan transforms
                layoutCanvas.style.transform = `translate(${camera.x}px, ${camera.y}px) scale(${camera.zoom})`;
                layoutCanvas.style.animation = 'none';
                console.log(`🔍 Transform applied: zoom=${camera.zoom}, pan=(${camera.x}, ${camera.y}), layout=${window.activeLayout}`);
            } else {
                console.log('⚠️ No layoutCanvas found for transform');
            }
        }

        // This is defined here so resetCamera can use it.
        let initializeTimeline;

        window.resetCamera = function() {
            camera.x = 0;
            camera.y = 0;
            camera.zoom = 1;
            updateTransform();
            updateZoomIndicator();
            updatePanIndicator();
            if (typeof initializeTimeline === 'function') {
                initializeTimeline();
            }
        }

        // --- Mouse Wheel Zoom Logic ---
        function onWheel(e) {
            // Enable zoom for all layout views (timeline, people, emotions)
            if (window.activeLayout === 'playground') return;
            e.preventDefault();
            const zoomDirection = e.deltaY < 0 ? 'in' : 'out';
            zoom(zoomDirection);
        }

        function zoom(direction) {
            console.log(`🎯 Zoom ${direction} requested in ${window.activeLayout} view`);
            const oldZoom = camera.zoom;
            let newZoom = direction === 'in' ? Math.min(window.MAX_ZOOM, camera.zoom + window.ZOOM_STEP) : Math.max(window.MIN_ZOOM, camera.zoom - window.ZOOM_STEP);
            if (newZoom === oldZoom) {
                console.log(`⚠️ Zoom already at limit: ${newZoom}`);
                return;
            }
            
            camera.zoom = newZoom;
            console.log(`✅ Zoom changed: ${oldZoom} → ${newZoom}`);
            updateTransform();
            updateZoomIndicator();
            updatePanIndicator();
        }

        function updateZoomIndicator() {
            const zoomIndicator = document.getElementById('zoom-indicator');
            if (zoomIndicator) {
                zoomIndicator.textContent = Math.round(camera.zoom * 100) + '%';
            }
        }

        function updatePanIndicator() {
            const panIndicator = document.getElementById('pan-indicator');
            if (panIndicator) {
                if (camera.x === 0 && camera.y === 0) {
                    panIndicator.textContent = 'מרכז';
                } else {
                    const xDir = camera.x > 0 ? 'ימין' : camera.x < 0 ? 'שמאל' : '';
                    const yDir = camera.y > 0 ? 'למטה' : camera.y < 0 ? 'למעלה' : '';
                    const directions = [xDir, yDir].filter(d => d).join(' ');
                    panIndicator.textContent = directions || 'מרכז';
                }
            }
        }

        if (panzoomContainer) {
            panzoomContainer.addEventListener('wheel', onWheel, { passive: false });
        }

        // --- Zoom Button Event Listeners ---
        document.getElementById('zoom-in-btn')?.addEventListener('click', () => {
            zoom('in');
        });

        document.getElementById('zoom-out-btn')?.addEventListener('click', () => {
            zoom('out');
        });

        document.getElementById('zoom-reset-btn')?.addEventListener('click', () => {
            window.resetCamera();
            updateZoomIndicator();
        });

        // Initialize zoom indicator
        updateZoomIndicator();
        updatePanIndicator();

        // --- Mouse Drag Panning Logic ---
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartCameraX = 0;
        let dragStartCameraY = 0;

        function onMouseDown(e) {
            // Only enable dragging for timeline, people, and emotions views
            if (window.activeLayout === 'playground') return;
            
            // Don't start drag if clicking on controls or buttons
            if (e.target.closest('#bottom-controls-container') || 
                e.target.closest('.zoom-controls') ||
                e.target.closest('.view-toggle-buttons') ||
                e.target.closest('button')) {
                return;
            }

            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragStartCameraX = camera.x;
            dragStartCameraY = camera.y;
            
            document.body.style.cursor = 'grabbing';
            e.preventDefault();
        }

        function onMouseMove(e) {
            if (!isDragging) return;
            
            const deltaX = e.clientX - dragStartX;
            const deltaY = e.clientY - dragStartY;
            
            camera.x = dragStartCameraX + deltaX;
            camera.y = dragStartCameraY + deltaY;
            
            updateTransform();
            updatePanIndicator();
            e.preventDefault();
        }

        function onMouseUp() {
            if (isDragging) {
                isDragging = false;
                document.body.style.cursor = 'default';
            }
        }

        // Add mouse event listeners to the panzoom container
        if (panzoomContainer) {
            panzoomContainer.addEventListener('mousedown', onMouseDown);
            panzoomContainer.addEventListener('mousemove', onMouseMove);
            panzoomContainer.addEventListener('mouseup', onMouseUp);
            panzoomContainer.addEventListener('mouseleave', onMouseUp);
            
            // Add hover effect to indicate draggable area
            panzoomContainer.addEventListener('mouseenter', () => {
                if (window.activeLayout !== 'playground') {
                    panzoomContainer.style.cursor = 'grab';
                }
            });
            
            panzoomContainer.addEventListener('mouseleave', () => {
                if (!isDragging) {
                    panzoomContainer.style.cursor = 'default';
                }
            });
            
            // Prevent text selection while dragging
            panzoomContainer.style.userSelect = 'none';
            panzoomContainer.style.webkitUserSelect = 'none';
            panzoomContainer.style.mozUserSelect = 'none';
            panzoomContainer.style.msUserSelect = 'none';
        }

        // --- Keyboard Zoom Shortcuts ---
        document.addEventListener('keydown', (e) => {
            // Only handle zoom shortcuts when not in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            // Ctrl/Cmd + Plus/Minus for zoom
            if ((e.ctrlKey || e.metaKey) && !e.shiftKey) {
                if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    zoom('in');
                } else if (e.key === '-') {
                    e.preventDefault();
                    zoom('out');
                } else if (e.key === '0') {
                    e.preventDefault();
                    window.resetCamera();
                    updateZoomIndicator();
                }
            }
        });
        
        // --- Timeline Brush Logic ---
        if (timelineControls) {
            const track = timelineControls.querySelector('.timeline-track-wrapper');
            const brush = timelineControls.querySelector('.timeline-brush');
            
            // Add null checks for iframe mode where timeline elements may not exist
            if (!brush) {
                console.log('Timeline brush not found - likely in iframe mode with noTimeline=true');
                return; // Exit early if timeline elements don't exist
            }
            
            const handleLeft = brush.querySelector('.timeline-handle.left');
            const handleRight = brush.querySelector('.timeline-handle.right');
            const tooltip = document.querySelector('.timeline-tooltip');
            const dateDisplayLeft = brush.querySelector('.handle-date-display.left');
            const dateDisplayRight = brush.querySelector('.handle-date-display.right');

            let minDate, maxDate, totalDays;
            let isDragging = null;
            let startX, startBrushLeft, startBrushWidth;

            initializeTimeline = function() {
                const dates = window.originalConversationData.map(c => new Date(c.date).getTime());
                minDate = new Date(Math.min.apply(null, dates));
                maxDate = new Date(Math.max.apply(null, dates));
                totalDays = (maxDate - minDate) / (1000 * 60 * 60 * 24);
                brush.style.left = '0%';
                brush.style.width = '100%';
                updateDateDisplays();
            }

            function pctToDate(pct) {
                const date = new Date(minDate);
                date.setDate(date.getDate() + (totalDays * (pct / 100)));
                return date.toLocaleDateString('he-IL', { day: 'numeric', month: 'short' });
            }
            
            function updateDateDisplays() {
                const leftPct = parseFloat(brush.style.left);
                const widthPct = parseFloat(brush.style.width);
                dateDisplayLeft.textContent = pctToDate(leftPct);
                dateDisplayRight.textContent = pctToDate(leftPct + widthPct);
            }

            function updateMainViewFromBrush() {
                const brushWidthPct = parseFloat(brush.style.width) / 100;
                
                const layout = layoutPositions.timeline;
                if (!layout || Object.keys(layout).length === 0) return;
                
                const allX = Object.values(layout).filter(p => p.left !== undefined).map(p => p.left);
                if (allX.length === 0) return;

                const minX = Math.min(...allX);
                const maxX = Math.max(...allX) + 70;
                const totalContentWidth = maxX - minX;
                const viewWidth = totalContentWidth * brushWidthPct;
                const containerWidth = panzoomContainer.clientWidth;
                
                camera.zoom = Math.min(window.MAX_ZOOM, containerWidth / viewWidth * 0.9);
                
                // NO PANNING. camera.x is not changed.
                
                updateTransform();
            }

            function onDragStart(e, type) {
                if (window.activeLayout !== 'timeline') return;
                e.stopPropagation();
                isDragging = type;
                startX = e.clientX;
                startBrushLeft = brush.offsetLeft;
                startBrushWidth = brush.offsetWidth;
                document.body.style.cursor = 'ew-resize';
                window.addEventListener('mousemove', onDrag);
                window.addEventListener('mouseup', onDragEnd);
            }

            function onDrag(e) {
                if (!isDragging) return;
                const deltaX = e.clientX - startX;
                const trackWidth = track.offsetWidth;
                if (isDragging === 'left') {
                    const newLeft = Math.max(0, startBrushLeft + deltaX);
                    const newRight = startBrushLeft + startBrushWidth;
                    const newWidth = newRight - newLeft;
                    if (newWidth / trackWidth * 100 < 2) return;
                    brush.style.left = `${(newLeft / trackWidth) * 100}%`;
                    brush.style.width = `${(newWidth / trackWidth) * 100}%`;
                } else if (isDragging === 'right') {
                    const newWidth = Math.max(10, startBrushWidth + deltaX);
                    const newRight = startBrushLeft + newWidth;
                    if (newRight > trackWidth) return;
                    brush.style.width = `${(newWidth / trackWidth) * 100}%`;
                }
                // 'brush' dragging is disabled.
                updateDateDisplays();
                // This is called onDragEnd for a better UX
            }

            function onDragEnd() {
                isDragging = null;
                document.body.style.cursor = 'default';
                window.removeEventListener('mousemove', onDrag);
                window.removeEventListener('mouseup', onDragEnd);
                updateMainViewFromBrush(); // Update view after dragging is finished
            }

            track.addEventListener('mousemove', (e) => {
                if (isDragging) return;
                const trackRect = track.getBoundingClientRect();
                const x = e.clientX - trackRect.left;
                const pct = (x / track.offsetWidth) * 100;
                tooltip.style.left = `${x}px`;
                tooltip.textContent = pctToDate(pct);
                tooltip.style.display = 'block';
            });
            track.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });
            handleLeft.addEventListener('mousedown', (e) => onDragStart(e, 'left'));
            handleRight.addEventListener('mousedown', (e) => onDragStart(e, 'right'));
            // Event listener for dragging the whole brush is removed to prevent panning.
            
            setTimeout(initializeTimeline, 500);
        }

        // --- General page setup ---
        window.addEventListener('resize', () => {
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(() => {
                if (typeof window.switchLayout === 'function') {
                    window.switchLayout(window.activeLayout, true);
                }
                // Recalculate emotions grid if emotions page is visible
                recalculateEmotionsGrid();
            }, 250);
        });
    });
    </script>
    
    <!-- Live Visualization Script -->
    <script>
// sketch-live.js removed - no longer needed

// Global error handler to prevent RingBuffer/AmplitudeProcessor errors from breaking people view
window.addEventListener('error', function(event) {
    if (event.message && (event.message.includes('RingBuffer') || event.message.includes('AmplitudeProcessor'))) {
        console.warn('🔇 Audio processing error caught and suppressed:', event.message);
        event.preventDefault();
        return false;
    }
});

// Global error handler for unhandled promise rejections
window.addEventListener('unhandledrejection', function(event) {
    if (event.reason && (event.reason.message && (event.reason.message.includes('RingBuffer') || event.reason.message.includes('AmplitudeProcessor')))) {
        console.warn('🔇 Audio processing promise rejection caught and suppressed:', event.reason.message);
        event.preventDefault();
        return false;
    }
});
  </script>
     
     <script>
     // FORCE DISPLAY: Simple backup people view renderer
     window.forceDisplayPeopleView = async function() {
        console.log('🚀 FORCE DISPLAY: Starting simple people view...');
        
        try {
            // 1. Force people layout mode
            window.activeLayout = 'people';
            document.body.className = 'layout-people';
            const layoutCanvas = document.getElementById('layout-canvas');
            layoutCanvas.className = 'people-active';
            
            // 2. Clear any existing content
            layoutCanvas.innerHTML = '';
            
            // 3. Load people data directly
            const response = await fetch('/config/people_data.json');
            if (!response.ok) {
                console.error('❌ Failed to fetch people data:', response.status);
                layoutCanvas.innerHTML = '<div style="color: red; font-size: 24px; padding: 50px; text-align: center;">❌ Failed to load people data (server error)</div>';
                return;
            }
            
            const peopleData = await response.json();
            console.log('📊 Loaded people data:', peopleData);
            
            if (!peopleData || !peopleData.people || Object.keys(peopleData.people).length === 0) {
                console.error('❌ No people data found in response:', peopleData);
                layoutCanvas.innerHTML = '<div style="color: red; font-size: 24px; padding: 50px; text-align: center;">❌ No people found in data file</div>';
                return;
            }
            
            // 4. Create simple list display
            const peopleCount = Object.keys(peopleData.people).length;
            console.log(`✅ Found ${peopleCount} people, creating simple display...`);
            
            let y = 50;
            const leftMargin = 100;
            const rowHeight = 120;
            
            // 5. Create title header
            const header = document.createElement('div');
            header.style.cssText = `
                position: absolute;
                left: ${leftMargin}px;
                top: 20px;
                font-size: 28px;
                font-weight: bold;
                color: #333;
                z-index: 1000;
            `;
            header.innerHTML = `👥 רשימת אנשים (${peopleCount} אנשים)`;
            layoutCanvas.appendChild(header);
            
            // 6. Display each person simply
            Object.entries(peopleData.people).forEach(([personId, person], index) => {
                const conversationCount = person.conversations ? person.conversations.length : 0;
                
                // Person row container
                const personRow = document.createElement('div');
                personRow.style.cssText = `
                    position: absolute;
                    left: ${leftMargin}px;
                    top: ${y}px;
                    width: 800px;
                    height: ${rowHeight - 20}px;
                    background: linear-gradient(135deg, ${person.color}20, ${person.color}10);
                    border: 2px solid ${person.color};
                    border-radius: 12px;
                    padding: 20px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                    z-index: ${1000 + index};
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                `;
                
                // Person info (right side in RTL)
                const personInfo = document.createElement('div');
                personInfo.style.cssText = `
                    text-align: right;
                    direction: rtl;
                `;
                personInfo.innerHTML = `
                    <div style="font-size: 22px; font-weight: bold; color: ${person.color}; margin-bottom: 5px;">
                        ${person.name}
                    </div>
                    <div style="font-size: 16px; color: #666; margin-bottom: 5px;">
                        ${conversationCount} שיחות
                    </div>
                    <div style="font-size: 14px; color: #888;">
                        ${person.description || 'אין תיאור'}
                    </div>
                `;
                
                // Conversation badges (left side)
                const conversationBadges = document.createElement('div');
                conversationBadges.style.cssText = `
                    display: flex;
                    flex-wrap: wrap;
                    gap: 5px;
                    max-width: 400px;
                `;
                
                if (person.conversations && person.conversations.length > 0) {
                    person.conversations.slice(0, 10).forEach(conv => {
                        const badge = document.createElement('span');
                        badge.style.cssText = `
                            background: ${person.color};
                            color: white;
                            padding: 4px 8px;
                            border-radius: 12px;
                            font-size: 12px;
                            font-weight: bold;
                        `;
                        badge.textContent = conv;
                        conversationBadges.appendChild(badge);
                    });
                    
                    if (person.conversations.length > 10) {
                        const moreBadge = document.createElement('span');
                        moreBadge.style.cssText = `
                            background: #999;
                            color: white;
                            padding: 4px 8px;
                            border-radius: 12px;
                            font-size: 12px;
                        `;
                        moreBadge.textContent = `+${person.conversations.length - 10}`;
                        conversationBadges.appendChild(moreBadge);
                    }
                } else {
                    conversationBadges.innerHTML = '<span style="color: #999; font-style: italic;">אין שיחות</span>';
                }
                
                personRow.appendChild(personInfo);
                personRow.appendChild(conversationBadges);
                layoutCanvas.appendChild(personRow);
                
                y += rowHeight;
            });
            
            // 7. Set canvas height
            const totalHeight = y + 50;
            layoutCanvas.style.height = `${totalHeight}px`;
            console.log(`✅ People view displayed successfully with ${peopleCount} people`);
            
            // 8. Add success message
            const successMsg = document.createElement('div');
            successMsg.style.cssText = `
                position: absolute;
                bottom: 20px;
                left: ${leftMargin}px;
                background: #d4edda;
                color: #155724;
                padding: 15px;
                border-radius: 8px;
                border: 1px solid #c3e6cb;
                font-size: 16px;
                z-index: 2000;
            `;
            successMsg.innerHTML = `✅ הצגת ${peopleCount} אנשים הושלמה בהצלחה`;
            layoutCanvas.appendChild(successMsg);
            
            return true;
            
        } catch (error) {
            console.error('❌ Error in force display people view:', error);
            const layoutCanvas = document.getElementById('layout-canvas');
            layoutCanvas.innerHTML = `
                <div style="color: red; font-size: 24px; padding: 50px; text-align: center;">
                    ❌ שגיאה בהצגת רשימת האנשים<br>
                    <small style="font-size: 16px;">${error.message}</small>
                </div>
            `;
            return false;
        }
    };
    </script>



 </body>
 </html>