<!DOCTYPE html>
<html lang="he" dir="rtl" style="height: 100%;">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Emotion Visualizer</title>
  <link rel="icon" href="data:,">

  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.indigo-pink.min.css">
  <script src="https://code.getmdl.io/1.3.0/material.min.js"></script>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js"></script>
  
  
  <script>
    /* ===== ZOOM-RESPONSIVE GRID SYSTEM ===== */
    
    // Initialize dynamic grid system
    let currentZoomLevel = 1;
    let gridSizeUpdateTimeout;
    const baseGridSize = 20; // Base grid size in pixels
    const minGridSize = 5;   // Minimum grid size
    const maxGridSize = 100; // Maximum grid size
    
    // Detect zoom level changes
    function detectZoomLevel() {
        // Method 1: Using window.devicePixelRatio (most reliable)
        const pixelRatio = window.devicePixelRatio || 1;
        
        // Method 2: Using window dimensions vs screen dimensions
        const widthZoom = window.outerWidth / window.innerWidth;
        const heightZoom = window.outerHeight / window.innerHeight;
        
        // Method 3: Create a test element to measure zoom
        const testElement = document.createElement('div');
        testElement.style.cssText = 'position: absolute; left: 0; top: 0; width: 100px; height: 100px; visibility: hidden;';
        document.body.appendChild(testElement);
        const rect = testElement.getBoundingClientRect();
        document.body.removeChild(testElement);
        
        const elementZoom = rect.width / 100;
        
        // Use the most reliable zoom detection method
        let detectedZoom = elementZoom;
        
        // Fallback methods if element zoom fails
        if (Math.abs(detectedZoom - 1) < 0.01) {
            detectedZoom = Math.max(widthZoom, heightZoom);
        }
        
        // Clamp zoom level to reasonable bounds
        return Math.max(0.25, Math.min(5, detectedZoom));
    }
    
    // Update grid size based on zoom level
    function updateGridSize() {
        clearTimeout(gridSizeUpdateTimeout);
        gridSizeUpdateTimeout = setTimeout(() => {
            const newZoomLevel = detectZoomLevel();
            
            // Only update if zoom changed significantly
            if (Math.abs(newZoomLevel - currentZoomLevel) > 0.05) {
                currentZoomLevel = newZoomLevel;
                
                // Calculate new grid size (zoom in = bigger grid, zoom out = smaller grid)
                let newGridSize = baseGridSize * currentZoomLevel;
                
                // Apply bounds
                newGridSize = Math.max(minGridSize, Math.min(maxGridSize, newGridSize));
                
                // Update CSS custom property
                document.documentElement.style.setProperty('--dynamic-grid-size', `${Math.round(newGridSize)}px`);
                
                // Visual feedback for grid size change
                showGridSizeIndicator(newGridSize, currentZoomLevel);
                
                console.log(`üîç Zoom level: ${currentZoomLevel.toFixed(2)}x, Grid size: ${Math.round(newGridSize)}px`);
            }
        }, 100); // Debounce updates
    }
    
    // Set up zoom detection listeners
    function initializeZoomResponsiveGrid() {
        // Initial grid size setup
        document.documentElement.style.setProperty('--dynamic-grid-size', `${baseGridSize}px`);
        
        // Listen for resize events (covers zoom in many browsers)
        window.addEventListener('resize', updateGridSize);
        
        // Listen for wheel events with Ctrl (zoom shortcuts)
        window.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                // Zoom shortcut detected
                setTimeout(updateGridSize, 50);
            }
        });
        
        // Listen for keyboard zoom shortcuts
        window.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '0')) {
                // Zoom shortcut detected
                setTimeout(updateGridSize, 50);
            }
        });
        
        // Poll for zoom changes (fallback for other zoom methods)
        setInterval(updateGridSize, 1000);
        
        // Initial update
        updateGridSize();
        
        console.log('üîç Zoom-responsive grid system initialized');
    }
    
    // Visual feedback for grid size changes
    function showGridSizeIndicator(gridSize, zoomLevel) {
        // Remove existing indicator
        const existingIndicator = document.getElementById('grid-size-indicator');
        if (existingIndicator) {
            existingIndicator.remove();
        }
        
        // Create new indicator
        const indicator = document.createElement('div');
        indicator.id = 'grid-size-indicator';
        indicator.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-family: var(--main-font-family);
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        `;
        
        const getGridSizeDescription = (size) => {
            if (size <= 10) return '◊°◊ï◊§◊® ◊ñ◊ï◊ù-◊ê◊ê◊ï◊ò';
            if (size <= 15) return '◊ñ◊ï◊ù-◊ê◊ê◊ï◊ò';
            if (size <= 25) return '◊®◊í◊ô◊ú';
            if (size <= 40) return '◊ñ◊ï◊ù-◊ê◊ô◊ü';
            if (size <= 60) return '◊ñ◊ï◊ù-◊ê◊ô◊ü ◊í◊ì◊ï◊ú';
            return '◊ñ◊ï◊ù-◊ê◊ô◊ü ◊û◊ß◊°◊ô◊û◊ú◊ô';
        };
        
        indicator.innerHTML = `
            <span>üîç ${getGridSizeDescription(gridSize)}</span>
            <span style="margin: 0 8px;">|</span>
            <span>◊®◊©◊™: ${Math.round(gridSize)}px</span>
            <span style="margin: 0 8px;">|</span>
            <span>◊ñ◊ï◊ù: ${Math.round(zoomLevel * 100)}%</span>
        `;
        
        document.body.appendChild(indicator);
        
        // Show indicator
        requestAnimationFrame(() => {
            indicator.style.opacity = '1';
        });
        
        // Hide after 2 seconds
        setTimeout(() => {
            indicator.style.opacity = '0';
            setTimeout(() => {
                if (indicator.parentNode) {
                    indicator.remove();
                }
            }, 300);
        }, 2000);
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', initializeZoomResponsiveGrid);
    
    // --- Global Variables ---
    let camera = { x: 0, y: 0, zoom: 1 };
    window.activeLayout = 'timeline';
    let layoutPositions = { timeline: null, people: null, emotions: null };
    window.hebrewMonths = ["◊ô◊†◊ï◊ê◊®", "◊§◊ë◊®◊ï◊ê◊®", "◊û◊®◊•", "◊ê◊§◊®◊ô◊ú", "◊û◊ê◊ô", "◊ô◊ï◊†◊ô", "◊ô◊ï◊ú◊ô", "◊ê◊ï◊í◊ï◊°◊ò", "◊°◊§◊ò◊û◊ë◊®", "◊ê◊ï◊ß◊ò◊ï◊ë◊®", "◊†◊ï◊ë◊û◊ë◊®", "◊ì◊¶◊û◊ë◊®"];
    
    // --- UNIFIED MP4 PREVIEW COMPONENT SYSTEM ---
    const MP4_PREVIEW_CONFIG = {
    videoStyles: {
        objectFit: 'cover',
        objectPosition: 'center center',
        display: 'block',
        width: '100%',
        height: '100%',
        margin: '0',
        padding: '0',
        border: 'none',
        borderRadius: '8px',
        position: 'absolute',
        top: '0',
        left: '0',
        transition: 'transform 0.3s ease',
        background: '#f0f0f0',
        filter: 'none',
        boxShadow: 'none',
        transform: 'scale(1)'
    },

    containerStyles: {
        position: 'absolute',
        boxSizing: 'border-box',
        padding: '0',
        margin: '1px',
        display: 'block',
        overflow: 'hidden',
        borderRadius: '0',
        cursor: 'pointer',
        transition: 'transform 0.3s ease, box-shadow 0.3s ease',
        border: 'none',
        background: 'transparent',
        zIndex: '2',
        transformOrigin: 'center center',
        aspectRatio: '1 / 1',
        contain: 'layout style paint',
        backfaceVisibility: 'hidden',
        perspective: '1000px',
        isolation: 'isolate',
        width: '100%',
        height: '100%',
        transform: 'scale(1)',
        boxShadow: 'none'
    },

    hoverEffects: {
        container: {
            transform: 'scale(1.15)',
            zIndex: '10'
        },
        video: {
            filter: 'none',
            boxShadow: 'none'
        }
    }
};

    
    // Helper function to get EXACT Timeline square size
    function getTimelineSquareSize(conversations, container) {
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const totalConversations = conversations.length;
        
        // Use EXACT same calculation as Timeline view
        const padding = 10;
        const availableWidth = containerWidth - (2 * padding);
        const availableHeight = containerHeight - (2 * padding);
        const gapBetweenSquares = 1;
        const totalGapWidth = (totalConversations - 1) * gapBetweenSquares;
        const availableForSquares = availableWidth - totalGapWidth;
        const maxSquareSize = availableForSquares / totalConversations;
        const finalSquareSize = Math.min(maxSquareSize, availableHeight);
        
        return finalSquareSize;
    }
    
    // UNIFIED MP4 PREVIEW COMPONENT CREATOR
    function createMP4PreviewComponent(conv, index) {
        const itemCell = document.createElement('div');
        itemCell.className = 'conversation-grid-item-container';
        itemCell.id = `conv-item-${conv.id}`;
        
        // Apply unified container styles
        Object.assign(itemCell.style, MP4_PREVIEW_CONFIG.containerStyles);
        
        // Add data attributes
        const properName = conv.metadata?.name || conv.displayName || conv.participants || conv.id;
        itemCell.setAttribute('data-conversation', properName);
        itemCell.style.order = index;
        
        // Create video container wrapper for better centering
        const videoContainer = document.createElement('div');
        videoContainer.className = 'video-container-wrapper';
        videoContainer.style.cssText = `
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            background: transparent;
            border-radius: 0;
        `;
        
        // Create video element with unified styling and error handling
        const video = document.createElement('video');
        video.id = `video-preview-${conv.folder}`;
        video.className = 'conversation-video-preview';
        video.src = `videos/${conv.folder}.mp4`;
        video.muted = true;
        video.loop = true;
        video.preload = 'metadata';
        video.loading = 'eager';
        // No poster image - we want to see the actual video content during transitions
        
        // Apply unified video styles
        Object.assign(video.style, MP4_PREVIEW_CONFIG.videoStyles);
        
        // Add error handling for missing videos
        video.addEventListener('error', function() {
            console.warn(`‚ö†Ô∏è Video not found for ${conv.folder}, using iframe fallback`);
            // Replace with iframe visualization fallback
            video.style.display = 'none';
            const iframe = document.createElement('iframe');
            iframe.src = `visualization.html?folder=${conv.folder}&static=true&animate=false&autostart=false&noSidepanel=true&noTimeline=true&visualOnly=true&cleanCapture=true&hideUI=true&canvasOnly=true&t=${Date.now()}`;
            iframe.style.cssText = 'width: 100%; height: 100%; border: none; position: absolute; top: 0; left: 0;';
            iframe.loading = 'lazy';
            videoContainer.appendChild(iframe);
        });
        
        // Add load success handler
        video.addEventListener('loadedmetadata', function() {
            console.log(`‚úÖ Video loaded successfully for ${conv.folder}`);
        });
        
        // Add conversation label (removed weird ◊© letter)
        const label = document.createElement('div');
        label.className = 'conversation-label';
        label.textContent = ''; // Empty - no weird letters
        
        // Assemble component with proper nesting
        videoContainer.appendChild(video);
        itemCell.appendChild(videoContainer);
        itemCell.appendChild(label);
        itemCell.classList.add('video-preview-item');
        
        // Add unified event handlers
        addMP4PreviewEventHandlers(itemCell, conv, video);
        
        return itemCell;
    }
    
    // UNIFIED EVENT HANDLERS for MP4 Preview Components
    function addMP4PreviewEventHandlers(itemCell, conv, video) {
        // Video loading handlers
        video.addEventListener('loadstart', () => {
            console.log(`üé¨ Loading video for ${conv.folder} - src: ${video.src}`);
        });
        
        video.addEventListener('canplay', () => {
            console.log(`‚úÖ Video ready for ${conv.folder} - duration: ${video.duration}`);
        });
        
        video.addEventListener('loadeddata', () => {
            console.log(`üíæ Video data loaded for ${conv.folder} - ensuring first frame is visible`);
            // Ensure the first frame is visible
            video.currentTime = 0;
        });
        
        video.addEventListener('loadedmetadata', () => {
            console.log(`üìä Video metadata loaded for ${conv.folder} - ${video.videoWidth}x${video.videoHeight}`);
            Object.assign(video.style, {
                display: 'block',
                visibility: 'visible',
                opacity: '1'
            });
            
            // ISOTOPE READY: Prepare video content for smooth transitions
            video.currentTime = 0.1; // Use 0.1 to ensure frame is loaded
            
            // Make video ready for isotope animations - show actual content
            const prepareVideoForTransitions = () => {
                // Brief play to load the frame, then pause for static display
                video.play().then(() => {
                    setTimeout(() => {
                        video.pause();
                        video.currentTime = 0.1; // Keep at first frame for isotope transitions
                        console.log(`üé¨ Video ready for isotope transitions: ${conv.folder}`);
                        
                        // Mark video as ready for smooth view transitions
                        video.setAttribute('data-isotope-ready', 'true');
                    }, 80); // Quick frame load for responsiveness
                }).catch(e => {
                    // If autoplay is blocked, just seek to frame
                    video.currentTime = 0.1;
                    video.setAttribute('data-isotope-ready', 'true');
                    console.log(`üéØ Video frame set for isotope: ${conv.folder}`);
                });
            };
            
            // Prepare immediately if video is ready
            if (video.readyState >= 2) {
                prepareVideoForTransitions();
            } else {
                // Wait for video to be ready
                video.addEventListener('canplay', prepareVideoForTransitions, { once: true });
            }
        });
        
        video.addEventListener('error', () => {
            console.warn(`‚ùå Video failed for ${conv.folder}`, video.error);
            const errorOverlay = document.createElement('div');
            errorOverlay.style.cssText = `
                position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(255, 0, 0, 0.1); border: 2px solid red;
                display: flex; align-items: center; justify-content: center;
                color: red; font-size: 12px; font-weight: bold; text-align: center; z-index: 100;
            `;
            errorOverlay.textContent = `Video Error\n${conv.folder}`;
            itemCell.style.position = 'relative';
            itemCell.appendChild(errorOverlay);
        });
        
        // Click handler with zoom effect
        itemCell.addEventListener('click', (e) => {
            e.preventDefault();
            itemCell.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            itemCell.style.transform = 'scale(1.3)';
            itemCell.style.zIndex = '100';
            
            setTimeout(() => {
                openVisualizationInModal(conv.folder);
                setTimeout(() => {
                    itemCell.style.transform = 'scale(1)';
                    itemCell.style.zIndex = '2';
                    setTimeout(() => {
                        itemCell.style.transition = 'all 1.8s cubic-bezier(0.165, 0.84, 0.44, 1)';
                    }, 400);
                }, 100);
            }, 200);
        });
        
        // Hover handlers with unified effects
        itemCell.addEventListener('mouseenter', () => {
            // Apply unified hover effects to container
            Object.assign(itemCell.style, MP4_PREVIEW_CONFIG.hoverEffects.container);
            
            // Apply hover effects to video with safe transitions
            video.style.filter = MP4_PREVIEW_CONFIG.hoverEffects.video.filter;
            video.style.boxShadow = MP4_PREVIEW_CONFIG.hoverEffects.video.boxShadow || '';
            
            // Video playback - more efficient since video is already loaded
            if (video.readyState >= 2) {
                video.play().catch(e => console.log('Video play failed:', e));
            } else {
                video.load();
                video.play().catch(e => console.log('Video play failed:', e));
            }
            
            // Show hover panel
            showHoverPanel(conv);
        });
        
        itemCell.addEventListener('mouseleave', () => {
            // Reset container styles to match default CSS state exactly
            Object.assign(itemCell.style, {
                transform: 'scale(1)', // Reset to no scale
                zIndex: '2', // Reset to default z-index
                boxShadow: 'none', // Remove shadow
                background: 'transparent', // Reset background
                border: 'none', // Reset border
                borderRadius: '0', // Reset border radius
                margin: '1px', // Maintain consistent margin
                width: '100%', // Maintain consistent width
                height: '100%', // Maintain consistent height
                transition: 'transform 0.3s ease, box-shadow 0.3s ease' // Maintain transition
            });
            
            // Reset video styles safely without affecting positioning
            video.style.filter = 'none'; // Reset filter
            video.style.boxShadow = ''; // Reset box shadow
            video.style.transform = 'scale(1)'; // Reset video scale
            
            // Reset video container wrapper styles
            const videoContainer = itemCell.querySelector('.video-container-wrapper');
            if (videoContainer) {
                videoContainer.style.transform = 'scale(1)'; // Reset container scale
            }
            
            // Pause video
            video.pause();
            video.currentTime = 0;
            
            // Hide hover panel
            hideHoverPanel();
        });
    }
    
    // UNIFIED HOVER PANEL FUNCTIONS
    function showHoverPanel(conv) {
        const hoverPanel = document.getElementById('hover-info-panel');
        if (!hoverPanel) return;
        
        const metadata = conv.metadata || {};
        const emotions = conv.mainEmotions?.length ? conv.mainEmotions : conv.summaryFeelings.split(',').map(e => e.trim());
        
        const emotionEmojis = {
            'happiness': 'üòä', 'sadness': 'üò¢', 'anger': 'üò†', 'fear': 'üò®', 'surprise': 'üò≤',
            'disgust': 'ü§¢', 'curiosity': 'ü§î', 'confusion': 'üòµ', 'excitement': 'ü§©', 'neutral': 'üòê',
            'annoyance': 'üò§', 'frustration': 'üò´', 'caring': 'ü§ó'
        };
        
        const tagsHTML = emotions.map(e => {
            const emoji = emotionEmojis[e.trim()] || 'üòê';
            return `<div class="hover-info-tag">${emoji} ${e.trim()}</div>`;
        }).join('');
        
        const date = new Date(conv.date);
        const monthNames = ['◊ô◊†◊ï', '◊§◊ë◊®', '◊û◊®◊•', '◊ê◊§◊®', '◊û◊ê◊ô', '◊ô◊ï◊†', '◊ô◊ï◊ú', '◊ê◊ï◊í', '◊°◊§◊ò', '◊ê◊ï◊ß', '◊†◊ï◊ë', '◊ì◊¶◊û'];
        const formattedDate = `${date.getDate()} ${monthNames[date.getMonth()]} | ${conv.durationMinutes} ◊ì◊ß◊ï◊™`;
        
        const statusIcons = [];
        if (conv.isImportant) statusIcons.push('<span style="color: #f44336;" title="◊©◊ô◊ó◊î ◊ó◊©◊ï◊ë◊î">‚≠ê</span>');
        if (conv.isPrivate) statusIcons.push('<span style="color: #9c27b0;" title="◊©◊ô◊ó◊î ◊§◊®◊ò◊ô◊™">üîí</span>');
        if (conv.needsReview) statusIcons.push('<span style="color: #ff9800;" title="◊ì◊ï◊®◊© ◊ë◊ì◊ô◊ß◊î">‚ö†Ô∏è</span>');
        
        const additionalInfo = [];
        if (metadata.totalWords) additionalInfo.push(`${metadata.totalWords} ◊û◊ô◊ú◊ô◊ù`);
        if (conv.mp3_count) additionalInfo.push(`${conv.mp3_count} ◊ß◊ò◊¢◊ô◊ù`);
        if (metadata.emotionalIntensity) additionalInfo.push(`◊¢◊ï◊¶◊û◊î: ${metadata.emotionalIntensity}/10`);
        
        const additionalInfoHTML = additionalInfo.length > 0 
            ? `<div class="hover-info-additional">${additionalInfo.join(' | ')}</div>` 
            : '';
        
        const tagsHtml = metadata.tags?.length 
            ? `<div class="hover-info-metadata-tags">üè∑Ô∏è ${metadata.tags.join(', ')}</div>` 
            : '';
        
        hoverPanel.innerHTML = `
            <div class="hover-info-title">
                ${conv.displayName || conv.participants} 
                ${statusIcons.join(' ')}
            </div>
            <div class="hover-info-date">${formattedDate}</div>
            ${additionalInfoHTML}
            <div class="hover-info-tags">${tagsHTML}</div>
            ${tagsHtml}
        `;
        hoverPanel.classList.add('visible');
    }
    
    function hideHoverPanel() {
        const hoverPanel = document.getElementById('hover-info-panel');
        if (hoverPanel) {
            setTimeout(() => hoverPanel.classList.remove('visible'), 200);
        }
    }
    
    // GLOBAL MP4 PREVIEW CONFIGURATION UPDATER
    // Use this function to update styling across ALL views at once
    window.updateMP4PreviewConfig = function(newConfig) {
        // Merge new configuration with existing
        if (newConfig.videoStyles) {
            Object.assign(MP4_PREVIEW_CONFIG.videoStyles, newConfig.videoStyles);
        }
        if (newConfig.containerStyles) {
            Object.assign(MP4_PREVIEW_CONFIG.containerStyles, newConfig.containerStyles);
        }
        if (newConfig.hoverEffects) {
            Object.assign(MP4_PREVIEW_CONFIG.hoverEffects, newConfig.hoverEffects);
        }
        
        // Apply updated styles to all existing MP4 preview components
        const allVideoElements = document.querySelectorAll('.conversation-video-preview');
        const allContainerElements = document.querySelectorAll('.conversation-grid-item-container');
        
        allVideoElements.forEach(video => {
            Object.assign(video.style, MP4_PREVIEW_CONFIG.videoStyles);
        });
        
        allContainerElements.forEach(container => {
            Object.assign(container.style, MP4_PREVIEW_CONFIG.containerStyles);
        });
        
        console.log('‚úÖ MP4 Preview configuration updated globally across all views');
        return MP4_PREVIEW_CONFIG;
    };
    
    // Function to reset all conversation containers to default state
    window.resetAllConversationContainers = function() {
        const allContainerElements = document.querySelectorAll('.conversation-grid-item-container');
        const allVideoElements = document.querySelectorAll('.conversation-video-preview');
        const allVideoContainers = document.querySelectorAll('.video-container-wrapper');
        
        allContainerElements.forEach(container => {
            Object.assign(container.style, {
                transform: 'scale(1)',
                zIndex: '2',
                boxShadow: 'none',
                background: 'transparent',
                border: 'none',
                borderRadius: '0',
                margin: '1px',
                width: '100%',
                height: '100%',
                transition: 'transform 0.3s ease, box-shadow 0.3s ease'
            });
        });
        
        allVideoElements.forEach(video => {
            Object.assign(video.style, {
                filter: 'none',
                boxShadow: 'none',
                transform: 'scale(1)'
            });
        });
        
        allVideoContainers.forEach(container => {
            Object.assign(container.style, {
                transform: 'scale(1)'
            });
        });
        
        console.log('‚úÖ All conversation containers reset to default state');
    };
    
    // EXAMPLE: How to update MP4 preview styling globally
    // window.updateMP4PreviewConfig({
    //     videoStyles: {
    //         borderRadius: '8px',
    //         filter: 'contrast(1.2) brightness(1.1) saturate(1.2)'
    //     },
    //     containerStyles: {
    //         borderRadius: '8px',
    //         boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)'
    //     }
    // });
    
    // --- Layout Calculation Functions ---
    
    function getTimelineLayoutPositions(conversations, container) {
        const positions = {};

        const layoutCanvas = document.getElementById('layout-canvas');
        const useContainer = layoutCanvas && window.activeLayout === 'timeline' ? layoutCanvas : container;
        const containerWidth = useContainer.offsetWidth || 1200; 
        const containerHeight = useContainer.clientHeight || 800;
        
        const totalConversations = conversations.length;
        
        // For flexbox timeline layout, calculate optimal size based on available space
        const horizontalPadding = 40; // Account for flexbox padding
        const availableWidth = containerWidth - (2 * horizontalPadding);
        const availableHeight = containerHeight - 40; // Account for vertical padding
        
        // Calculate optimal size for conversations in horizontal layout
        // Leave space between items for justify-content: space-between
        const maxItemWidth = (availableWidth * 0.8) / totalConversations; // 80% of width divided by count
        const maxItemHeight = availableHeight * 0.8; // 80% of available height
        
        // Use smaller dimension to maintain aspect ratio, with reasonable bounds
        let itemSize = Math.max(120, Math.min(200, Math.min(maxItemWidth, maxItemHeight)));
        
        // Adjust for very few or many conversations
        if (totalConversations <= 6) {
            itemSize = Math.min(itemSize, 180); // Cap size for few items
        } else if (totalConversations > 12) {
            itemSize = Math.max(100, itemSize * 0.9); // Reduce size for many items
        }

        // Set CSS custom property for consistent sizing
        document.documentElement.style.setProperty('--timeline-item-size', `${itemSize}px`);

        // Maintain original sort by date
        const sortedConversations = conversations.sort((a, b) => new Date(a.date) - new Date(b.date));

        // For flexbox layout, we don't need to calculate exact positions
        // The CSS will handle distribution with justify-content: space-between
        sortedConversations.forEach((conv, index) => {
            positions[conv.id] = {
                // Flexbox will handle positioning, these are just for metadata
                width: itemSize,
                height: itemSize,
                gridOrder: index,
                flexOrder: index // Use flexbox order instead of absolute positioning
            };
        });

        // Debug info
        console.log(`üìê FLEXBOX Timeline Layout: ${totalConversations} videos, size=${Math.round(itemSize)}px`);
        console.log(`üéØ Container: ${containerWidth}x${containerHeight}px`);
        console.log(`üìä Item size: ${Math.round(itemSize)}px (optimized for ${totalConversations} items)`);
        console.log(`‚ú® Using CSS Flexbox with justify-content: space-between`);
        
        // Fallback for edge cases
        if (Object.keys(positions).length === 0) {
            console.warn('‚ö†Ô∏è No positions calculated, using emergency fallback');
            conversations.forEach((conv, index) => {
                positions[conv.id] = {
                    width: 150,
                    height: 150,
                    gridOrder: index,
                    flexOrder: index
                };
            });
        }

        return positions;
    }

    function getPeopleViewPositions(conversations, container) {
        const positions = {};
        
        // Use layout canvas dimensions for proper sizing
        const layoutCanvas = document.getElementById('layout-canvas');
        const useContainer = layoutCanvas ? layoutCanvas : container;
        // FIXED: Use offsetWidth to get the actual content width (excluding padding)
        const containerWidth = useContainer.offsetWidth || 1200; // Fallback width
        const containerHeight = useContainer.clientHeight || 800; // Fallback height
        
        // Debug container dimensions
        console.log(`üìè People view using layout canvas dimensions: ${containerWidth}x${containerHeight}`);
        
        // If container dimensions are invalid, return empty positions to prevent layout issues
        if (containerWidth < 100 || containerHeight < 100) {
            console.warn(`‚ö†Ô∏è Invalid container dimensions: ${containerWidth}x${containerHeight} - skipping People view layout`);
            return {};
        }
        
        // PEOPLE COLUMN LAYOUT - Dynamically group conversations by actual participants
        const peopleGroups = {};
        
        // Build dynamic groups based on actual participant data from conversations
        conversations.forEach(conv => {
            // Get participant name from metadata
            let participantName = '◊ú◊ê ◊ô◊ì◊ï◊¢'; // Default for unknown participant
            
            if (conv.metadata && conv.metadata.participants && conv.metadata.participants.length > 0) {
                // Use the first participant name (could be enhanced to handle multiple participants)
                participantName = conv.metadata.participants[0];
            } else if (conv.metadata && conv.metadata.customParticipantName) {
                // Use custom participant name
                participantName = conv.metadata.customParticipantName;
            } else if (conv.participants && conv.participants !== conv.displayName) {
                // Use participants field if different from display name
                participantName = conv.participants;
            } else {
                // Try to extract participant from display name
                const name = conv.displayName || conv.metadata?.name || `◊©◊ô◊ó◊î ${conv.conversationNumber}`;
                // If the name contains "◊¢◊ù" (with), extract the participant
                const withMatch = name.match(/◊¢◊ù\s+(.+)/);
                if (withMatch) {
                    participantName = withMatch[1].trim();
                }
            }
            
            // Initialize array for this participant if it doesn't exist
            if (!peopleGroups[participantName]) {
                peopleGroups[participantName] = [];
            }
            
            // Add conversation to participant's group
            peopleGroups[participantName].push(conv.folder);
        });
        
        console.log('üë• Dynamic people groups created:', peopleGroups);
        
        // Safety check: if no people groups found, return empty positions
        if (Object.keys(peopleGroups).length === 0) {
            console.warn('‚ö†Ô∏è No people groups found - returning empty positions');
            return {};
        }
        
        const peopleNames = Object.keys(peopleGroups);
        const totalColumns = peopleNames.length; // Dynamic number of people
        
        // Calculate max conversations per person for layout purposes
        const conversationCounts = Object.values(peopleGroups).map(convs => convs.length);
        const maxConversationsPerPerson = conversationCounts.length > 0 ? Math.max(...conversationCounts) : 0;
        console.log(`üë• People view: ${totalColumns} people, max ${maxConversationsPerPerson} conversations per person`);
        
        // ENHANCED Layout calculations for proper spacing and sizing
        const horizontalPadding = 24; // Match layout canvas padding
        const verticalPadding = 40; // Vertical padding for better fit
        const columnGap = 60; // Gap between person columns  
        const itemGap = 20; // Gap between conversations within a column
        const labelHeight = 40; // Height for person name label
        const labelMargin = 20; // Gap between conversations and label
        const bottomPadding = 100; // Position content above bottom controls
        
        // Calculate column width - Account for horizontal padding
        const availableWidth = containerWidth - (2 * horizontalPadding);
        const totalGaps = (totalColumns - 1) * columnGap;
        const columnWidth = (availableWidth - totalGaps) / totalColumns;
        
        // FORCE EXACT TIMELINE SQUARE SIZE - Use Timeline's exact calculation
        const timelineSquareSize = getTimelineSquareSize(conversations, container);
        const conversationSize = timelineSquareSize; // Use EXACT same size as Timeline
        
        console.log(`üìê Using timeline square size: ${timelineSquareSize}px for people view`);
        
        // Calculate total column height based on max conversations per person (person name at top + conversations below)
        const conversationsHeight = (maxConversationsPerPerson * conversationSize) + ((maxConversationsPerPerson - 1) * itemGap);
        const totalColumnHeight = labelHeight + labelMargin + conversationsHeight; // Person name at top + conversations below
        
        // FIXED: Center within the available width (after padding is applied)
        const startX = horizontalPadding + (availableWidth - (totalColumns * columnWidth + totalGaps)) / 2;
        
        // CRITICAL FIX: NAMES AT BOTTOM - Position person names at bottom of screen, conversations above
        const actualBottomY = containerHeight - bottomPadding; // Bottom edge minus padding
        const personNamesY = actualBottomY - labelHeight; // Person names at bottom of screen
        // Calculate conversationsY based on each person's actual conversation count, not max
        const conversationsY = personNamesY - 8; // Start with just 8px gap from names
        
        // Debug logging for names at bottom alignment with conversations above
        console.log(`üîç NAMES AT BOTTOM DEBUG (CONVERSATIONS ABOVE - COMPACT):
        - Container Height: ${containerHeight}px
        - Conversation Size: ${conversationSize}px
        - Max Conversations Height: ${conversationsHeight}px
        - Label Height: ${labelHeight}px
        - Person Names Y: ${personNamesY}px (at bottom)
        - Base Conversations Y: ${conversationsY}px (8px gap from names)
        - Spacing: 8px between names and conversations
        - Bottom edge: ${actualBottomY}px
        - Each person's conversations positioned individually based on their count`);
        
        // Verify that conversationsY is reasonable (not negative or too high)
        if (conversationsY < 0) {
            console.warn(`‚ö†Ô∏è conversationsY is negative (${conversationsY}) - content might be too tall for container`);
            // Adjust conversationsY to at least 20px from top
            const adjustedConversationsY = 20;
            console.log(`üìê Adjusting conversationsY from ${conversationsY} to ${adjustedConversationsY}`);
            return positions; // Return empty positions if layout doesn't fit
        }
        
        // Position each person's column
        peopleNames.forEach((personName, personIndex) => {
            const columnX = startX + (personIndex * (columnWidth + columnGap));
            const conversationFolders = peopleGroups[personName];
            
            // Find conversations for this person
            const personConversations = conversations.filter(conv => 
                conversationFolders.includes(conv.folder)
            );
            
            // Position each conversation in the person's column ABOVE the person name
            // Calculate position based on this person's actual conversation count
            const personConversationsHeight = personConversations.length * conversationSize + (personConversations.length - 1) * itemGap;
            const personConversationsY = personNamesY - personConversationsHeight - 8; // 8px gap from name
            
            personConversations.forEach((conv, convIndex) => {
                const convY = personConversationsY + (convIndex * (conversationSize + itemGap)); // Above person name
                const convX = columnX + (columnWidth - conversationSize) / 2; // Center in column
                
                positions[conv.id] = {
                    left: convX,
                    top: convY,
                    width: conversationSize,
                    height: conversationSize,
                    personName: personName,
                    personIndex: personIndex,
                    conversationIndex: convIndex,
                    columnX: columnX,
                    columnWidth: columnWidth
                };
                
                // Debug each conversation position
                console.log(`üìç ${conv.folder}: positioned at (${Math.round(convX)}, ${Math.round(convY)}) size ${conversationSize}x${conversationSize} for ${personName} (below name)`);
            });
        });
        
        // Add metadata for people layout
        positions._meta = {
            layout: 'people-columns',
            peopleGroups: peopleGroups,
            peopleNames: peopleNames,
            totalColumns: totalColumns,
            columnWidth: columnWidth,
            conversationSize: conversationSize,
            totalColumnHeight: totalColumnHeight,
            padding: horizontalPadding,
            columnGap: columnGap,
            itemGap: itemGap,
            labelHeight: labelHeight,
            labelMargin: labelMargin,
            bottomPadding: bottomPadding,
            isScrollable: false, // No scrolling needed when bottom-aligned
            // Add person label positions (at the BOTTOM of each column, conversations above)
            personLabels: peopleNames.map((name, index) => ({
                name: name,
                x: startX + (index * (columnWidth + columnGap)),
                y: personNamesY, // At the bottom of each column
                width: columnWidth,
                height: labelHeight,
                debug: `Person ${name} label at (${Math.round(startX + (index * (columnWidth + columnGap)))}, ${Math.round(personNamesY)})`
            }))
        };
        
        console.log(`üìê People Columns Layout NAMES-AT-BOTTOM (COMPACT CONVERSATIONS): ${totalColumns} people, max ${maxConversationsPerPerson} conversations each, columnWidth=${Math.round(columnWidth)}px, convSize=${Math.round(conversationSize)}px, personNamesY=${Math.round(personNamesY)}px, baseConversationsY=${Math.round(conversationsY)}px, spacing=8px, individual positioning`);
        
        return positions;
    }

    function getEmotionsViewPositions(conversations, container) {
        const positions = {};
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // IMPROVED CENTERING: Account for header offset and bottom controls
        const headerHeight = 60; // Header height
        const bottomHeight = 60; // Bottom controls height
        const availableHeight = height - headerHeight - bottomHeight;
        
        // Center in the available space (excluding header and bottom controls)
        const centerX = width / 2;
        const centerY = (availableHeight / 2) + headerHeight; // Offset by header
        
        // USE EXACT TIMELINE SQUARE SIZE - No scaling, perfect squares
        const timelineSquareSize = getTimelineSquareSize(conversations, container);
        
        // üé≠ ENHANCED EMOTIONS VIEW: Group conversations by main emotion
        const emotionGroups = {};
        
        // Group conversations by their main emotions
        conversations.forEach(conv => {
            const mainEmotions = conv.metadata?.mainEmotions || ['neutral'];
            mainEmotions.forEach(emotion => {
                if (!emotionGroups[emotion]) {
                    emotionGroups[emotion] = [];
                }
                emotionGroups[emotion].push(conv);
            });
        });
        
        const emotionTypes = Object.keys(emotionGroups);
        const emotionCount = emotionTypes.length;
        
        console.log(`üé≠ Emotion Groups: ${emotionCount} different emotions found`, emotionGroups);
        
        // Calculate circle arrangements
        const marginBetween = 20; // Space between emotion circles
        const minCircleRadius = 80; // Minimum radius for each emotion circle
        
        // Calculate positions for emotion group centers
        const emotionCenters = [];
        
        if (emotionCount === 1) {
            // Single emotion - center it
            emotionCenters.push({ x: centerX, y: centerY });
        } else if (emotionCount === 2) {
            // Two emotions - side by side
            const offset = Math.min(150, width / 4);
            emotionCenters.push({ x: centerX - offset, y: centerY });
            emotionCenters.push({ x: centerX + offset, y: centerY });
        } else if (emotionCount <= 4) {
            // Up to 4 emotions - arrange in a square pattern
            const offset = Math.min(120, Math.min(width, availableHeight) / 4);
            const positions = [
                { x: centerX - offset, y: centerY - offset }, // Top-left
                { x: centerX + offset, y: centerY - offset }, // Top-right
                { x: centerX - offset, y: centerY + offset }, // Bottom-left
                { x: centerX + offset, y: centerY + offset }  // Bottom-right
            ];
            emotionCenters.push(...positions.slice(0, emotionCount));
        } else {
            // More than 4 emotions - arrange in a circle
            const mainRadius = Math.min(200, Math.min(width, availableHeight) / 3);
            const angleStep = (2 * Math.PI) / emotionCount;
            
            for (let i = 0; i < emotionCount; i++) {
                const angle = i * angleStep - Math.PI / 2; // Start from top
                emotionCenters.push({
                    x: centerX + mainRadius * Math.cos(angle),
                    y: centerY + mainRadius * Math.sin(angle)
                });
            }
        }
        
        // Create completely separate circles for each emotion group
        const emotionCircles = [];
        
        emotionTypes.forEach((emotion, emotionIndex) => {
            const conversations = emotionGroups[emotion];
            const center = emotionCenters[emotionIndex];
            const conversationCount = conversations.length;
            
            // Calculate circle radius based on number of conversations
            const circleRadius = Math.max(
                minCircleRadius,
                (conversationCount * (timelineSquareSize + 10)) / (2 * Math.PI)
            );
            
            // Store circle info for visual rendering
            emotionCircles.push({
                emotion: emotion,
                center: center,
                radius: circleRadius,
                conversations: conversations,
                count: conversationCount
            });
            
            if (conversationCount === 1) {
                // Single conversation - place at center of its own circle
                const conv = conversations[0];
                positions[conv.id] = {
                    left: center.x - (timelineSquareSize / 2),
                    top: center.y - (timelineSquareSize / 2),
                    width: timelineSquareSize,
                    height: timelineSquareSize,
                    emotionGroup: emotion,
                    emotionCenter: center,
                    isEmotionCircle: true,
                    circleRadius: circleRadius
                };
            } else {
                // Multiple conversations - arrange in their own dedicated circle
                const angleStep = (2 * Math.PI) / conversationCount;
                
                conversations.forEach((conv, index) => {
                    const angle = index * angleStep - Math.PI / 2; // Start from top
                    const x = center.x + circleRadius * Math.cos(angle);
                    const y = center.y + circleRadius * Math.sin(angle);
                    
                    positions[conv.id] = {
                        left: x - (timelineSquareSize / 2),
                        top: y - (timelineSquareSize / 2),
                        width: timelineSquareSize,
                        height: timelineSquareSize,
                        emotionGroup: emotion,
                        emotionCenter: center,
                        isEmotionCircle: true,
                        circleRadius: circleRadius
                    };
                });
            }
        });
        
        console.log(`üé≠ Enhanced Emotions Layout: ${emotionCount} emotion circles, conversations distributed by main emotion`);
        
        const itemSize = {
            width: timelineSquareSize,
            height: timelineSquareSize
        };
        
        positions._meta = { 
            staticItems: [], 
            itemSize, 
            emotionGroups,
            emotionCenters,
            emotionCircles,
            centerX, 
            centerY, 
            VIDEO_SCALE: 1.0 
        };
        return positions;
    }

    // --- Core Rendering and State Management ---
    let layoutRenderTimeout;
    let isLayoutRendering = false;
    
    window.renderNewLayout = function(isInitial = false) {
        // Prevent multiple simultaneous renders
        if (isLayoutRendering) {
            console.log('‚ö†Ô∏è Layout render already in progress, skipping...');
            return;
        }
        
        // Debounce rapid calls
        clearTimeout(layoutRenderTimeout);
        layoutRenderTimeout = setTimeout(() => {
            isLayoutRendering = true;
            
            const gridContainer = document.getElementById('timeline-axes-container');
            const layoutCanvas = document.getElementById('layout-canvas');
            if (!gridContainer || !layoutCanvas) {
                isLayoutRendering = false;
                return;
            }
            
            // STATIC BACKGROUND GRID: Ensure it exists before any layout operations
            ensureStaticBackgroundGrid();
            
            const conversations = window.originalConversationData;
            
            // ISOTOPE ANIMATION: Capture current positions before layout change
            const currentPositions = {};
            conversations.forEach((conv) => {
                const itemCell = document.getElementById(`conv-item-${conv.id}`);
                if (itemCell) {
                    const rect = itemCell.getBoundingClientRect();
                    const canvasRect = layoutCanvas.getBoundingClientRect();
                    currentPositions[conv.id] = {
                        left: rect.left - canvasRect.left,
                        top: rect.top - canvasRect.top,
                        width: rect.width,
                        height: rect.height
                    };
                    console.log(`üì∏ Captured ${conv.id} at (${Math.round(currentPositions[conv.id].left)}, ${Math.round(currentPositions[conv.id].top)})`);
                }
            });
            
            // CRITICAL: Clear all previous CSS classes and styles first
            layoutCanvas.className = '';
            gridContainer.className = '';
            
            // Force reflow to clear previous styles
            layoutCanvas.offsetHeight;
            gridContainer.offsetHeight;
            
            // Apply new CSS classes AFTER clearing previous ones
            gridContainer.className = 'layout-' + window.activeLayout;
            
            // Force immediate reflow to ensure CSS classes are applied
            gridContainer.offsetHeight;
            
            console.log(`üßπ Cleared previous CSS, applied new layout class: ${gridContainer.className}`);
            
            // Add isotope-switching class for transition effects
            if (!isInitial && Object.keys(currentPositions).length > 0) {
                gridContainer.classList.add('isotope-switching');
                console.log('üé¨ Added isotope-switching class for smooth transitions');
                
                // Remove isotope-switching class after animations complete
                setTimeout(() => {
                    gridContainer.classList.remove('isotope-switching');
                    console.log('‚úÖ Removed isotope-switching class - transitions complete');
                }, 800); // After all animations should be done
            }
            
            layoutPositions.timeline = getTimelineLayoutPositions(conversations, gridContainer);
            layoutPositions.people = getPeopleViewPositions(conversations, gridContainer);
            layoutPositions.emotions = getEmotionsViewPositions(conversations, gridContainer);
            let targetPositions = layoutPositions[window.activeLayout];
            
            // Set layout canvas class based on active layout
            if (window.activeLayout === 'emotions') {
                layoutCanvas.className = ''; // Clear canvas class to prevent double grid effects
                
                // Add layout class to body for emotions view background
                document.body.className = 'layout-emotions';
                
                // SET TIMELINE SQUARE SIZE CSS VARIABLE for Emotions view
                const timelineSquareSize = getTimelineSquareSize(conversations, gridContainer);
                document.documentElement.style.setProperty('--timeline-square-size', `${timelineSquareSize}px`);
                console.log(`üìê Set --timeline-square-size to ${timelineSquareSize}px for Emotions view`);
            } else if (window.activeLayout === 'people') {
                layoutCanvas.className = 'people-active';
                
                // Clear body class for other layouts
                document.body.className = '';
                
                // SET TIMELINE SQUARE SIZE CSS VARIABLE for People view IMMEDIATELY
                const timelineSquareSize = getTimelineSquareSize(conversations, gridContainer);
                document.documentElement.style.setProperty('--timeline-square-size', `${timelineSquareSize}px`);
                document.documentElement.style.setProperty('--people-square-size', `${timelineSquareSize}px`);
                console.log(`üìê Set --timeline-square-size to ${timelineSquareSize}px for People view (immediate)`);
                
                            // CRITICAL FIX: For People view, recalculate positions AFTER CSS classes are applied
            // This ensures the container has the correct dimensions from the CSS
            setTimeout(() => {
                if (window.activeLayout === 'people') {
                    console.log('üîÑ Recalculating People view positions after CSS application');
                    
                    // Force another reflow
                    gridContainer.offsetHeight;
                    
                    // SET TIMELINE SQUARE SIZE CSS VARIABLE for People view
                    const timelineSquareSize = getTimelineSquareSize(conversations, gridContainer);
                    document.documentElement.style.setProperty('--timeline-square-size', `${timelineSquareSize}px`);
                    console.log(`üìê Set --timeline-square-size to ${timelineSquareSize}px for People view`);
                    
                    // Force CSS variables to apply immediately
                    document.documentElement.style.setProperty('--people-square-size', `${timelineSquareSize}px`);
                    console.log(`üìê Set --people-square-size to ${timelineSquareSize}px for consistency`);
                    
                    // Recalculate positions with the correct container dimensions
                    const updatedPositions = getPeopleViewPositions(conversations, gridContainer);
                    if (Object.keys(updatedPositions).length > 0) {
                        targetPositions = updatedPositions;
                        layoutPositions.people = updatedPositions;
                            
                            // Re-apply positions to existing elements
                            conversations.forEach((conv) => {
                                const pos = targetPositions[conv.id];
                                if (pos) {
                                    const itemCell = document.getElementById(`conv-item-${conv.id}`);
                                    if (itemCell) {
                                        itemCell.style.left = `${pos.left}px`;
                                        itemCell.style.top = `${pos.top}px`;
                                        itemCell.style.width = `${pos.width}px`;
                                        itemCell.style.height = `${pos.height}px`;
                                        console.log(`üîÑ Updated ${conv.id} position: (${Math.round(pos.left)}, ${Math.round(pos.top)})`);
                                    }
                                }
                            });
                            
                            // Update person labels if they exist
                            const existingLabels = layoutCanvas.querySelectorAll('.person-name-label');
                            existingLabels.forEach(label => label.remove());

                            if (targetPositions._meta?.personLabels) {
                                targetPositions._meta.personLabels.forEach(label => {
                                    const labelElement = document.createElement('div');
                                    labelElement.className = 'person-name-label';
                                    labelElement.style.cssText = `
                                        position: absolute;
                                        left: ${label.x}px;
                                        top: ${label.y}px;
                                        width: ${label.width}px;
                                        height: ${label.height}px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        background: initial; /* Reset background */
                                        border: none; /* Remove border */
                                        border-radius: initial; /* Reset border-radius if needed, or remove line entirely */
                                        font-family: '80k', sans-serif; /* Set to '80k' font */
                                        font-size: initial; /* Reset font size */
                                        font-weight: initial; /* Reset font weight */
                                        color: initial; /* Reset text color */
                                        text-align: initial; /* Reset text alignment */
                                        z-index: 1;
                                        box-shadow: none; /* Remove box-shadow */
                                    `;
                                    labelElement.textContent = label.name;
                                    layoutCanvas.appendChild(labelElement);
                                });
                            }
                        }
                    }
                }, 50); // Small delay to ensure CSS has fully applied
            } else {
                layoutCanvas.className = '';
                
                // Clear body class for other layouts
                document.body.className = '';
                
                // CRITICAL FIX: For Timeline view, ensure CSS variables are set
                if (window.activeLayout === 'timeline') {
                    const timelineSquareSize = getTimelineSquareSize(conversations, gridContainer);
                    document.documentElement.style.setProperty('--timeline-square-size', `${timelineSquareSize}px`);
                    console.log(`üìê Set --timeline-square-size to ${timelineSquareSize}px for Timeline view`);
                    
                    // Force recalculation of timeline positions AFTER CSS classes are cleared
                    setTimeout(() => {
                        if (window.activeLayout === 'timeline') {
                            console.log('üîÑ Recalculating Timeline view positions after CSS reset');
                            
                            // Force another reflow to ensure CSS is reset
                            layoutCanvas.offsetHeight;
                            gridContainer.offsetHeight;
                            
                            // Recalculate timeline positions with correct container dimensions
                            const updatedTimelinePositions = getTimelineLayoutPositions(conversations, gridContainer);
                            if (Object.keys(updatedTimelinePositions).length > 0) {
                                targetPositions = updatedTimelinePositions;
                                layoutPositions.timeline = updatedTimelinePositions;
                                
                                // Re-apply positions to existing elements for proper centering
                                conversations.forEach((conv) => {
                                    const pos = targetPositions[conv.id];
                                    if (pos) {
                                        const itemCell = document.getElementById(`conv-item-${conv.id}`);
                                        if (itemCell) {
                                            itemCell.style.left = `${pos.left}px`;
                                            itemCell.style.top = `${pos.top}px`;
                                            itemCell.style.width = `${pos.width}px`;
                                            itemCell.style.height = `${pos.height}px`;
                                            console.log(`üîÑ Updated ${conv.id} timeline position: (${Math.round(pos.left)}, ${Math.round(pos.top)})`);
                                        }
                                    }
                                });
                            }
                        }
                    }, 50); // Small delay to ensure CSS has fully reset
                }
            }
        
        // Update wrapper background for people view - Remove redundant class application
        const timelineWrapper = document.getElementById('timeline-grid-wrapper');
        if (timelineWrapper) {
            // Only set class on main container, not wrapper to prevent double CSS application
            timelineWrapper.className = ''; // Clear class to prevent conflicts
        }
        
        console.log(`üèóÔ∏è Layout updated: gridContainer="${gridContainer.className}", canvas="${layoutCanvas.className}", wrapper="${timelineWrapper?.className}"`);
        // Remove old people view elements and emotion circle labels
        Array.from(layoutCanvas.querySelectorAll('.people-view-header, .people-view-row-item, .person-header, .vertical-line, .emotion-circle-label, .emotion-circle-background, .emotion-inner-circle, .emotion-count-badge')).forEach(el => el.remove());
        
        // Static elements will be created inside setTimeout where metaData is available
        setTimeout(() => {
            // Keep meta data for debugging, will be cleaned up later
            const metaData = targetPositions._meta;
            if (targetPositions._meta) delete targetPositions._meta;
            

            
            // Debug: Log positions for people view
            if (window.activeLayout === 'people') {
                console.log('üéØ People view positions:', targetPositions);
                console.log('üìê Container dimensions:', gridContainer.clientWidth, 'x', gridContainer.clientHeight);
                console.log('üë• Groups:', metaData?.peopleGroups);
                console.log('üè∑Ô∏è Person labels:', metaData?.personLabels?.length);
                console.log('üîç Layout canvas dimensions:', layoutCanvas.clientWidth, 'x', layoutCanvas.clientHeight);
                console.log('üîç Layout canvas position:', layoutCanvas.getBoundingClientRect());
            }
            
            const hoverPanel = document.getElementById('hover-info-panel');
            let hideTimeout;



            // Clear canvas and use ABSOLUTE POSITIONING for ALL layouts
            // NO BACKGROUND ELEMENTS: Body handles all background - clear everything
            if (!layoutCanvas) {
                console.error('‚ùå Layout canvas not found!');
                return;
            }
            console.log(`üéØ Layout canvas found:`, layoutCanvas);
            layoutCanvas.innerHTML = '';
            
            // ENSURE STATIC BACKGROUND GRID: Verify body background is set
            ensureStaticBackgroundGrid();
            
            // Set up scrollable container for people view
            if (window.activeLayout === 'people' && metaData?.isScrollable) {
                layoutCanvas.style.height = `${metaData.totalContentHeight + 2 * metaData.padding}px`;
                layoutCanvas.style.overflowY = 'auto';
                console.log(`üìú People view is scrollable: content height ${metaData.totalContentHeight}px`);
            } else {
                layoutCanvas.style.height = 'calc(100vh - 120px)';
                layoutCanvas.style.overflowY = 'hidden';
            }
            
            // ISOTOPE ANIMATION: Universal layout for all views with smooth transitions
            console.log(`üé¨ Creating ${conversations.length} conversation elements...`);
            console.log(`üéØ Target positions:`, targetPositions);
            
            // EMERGENCY FALLBACK: If no target positions, create simple grid positions
            if (!targetPositions || Object.keys(targetPositions).length === 0) {
                console.warn('‚ö†Ô∏è No target positions available, creating emergency grid positions');
                targetPositions = {};
                conversations.forEach((conv, index) => {
                    const row = Math.floor(index / 4);
                    const col = index % 4;
                    const fallbackSize = 200;
                    const fallbackGap = 20;
                    targetPositions[conv.id] = {
                        left: 50 + (col * (fallbackSize + fallbackGap)),
                        top: 50 + (row * (fallbackSize + fallbackGap)),
                        width: fallbackSize,
                        height: fallbackSize,
                        gridOrder: index
                    };
                });
            }
            
            conversations.forEach((conv, index) => {
                const pos = targetPositions[conv.id];
                if (!pos) {
                    console.warn(`‚ùå No position found for ${conv.id}, using emergency position`);
                    // Create emergency position for this conversation
                    const row = Math.floor(index / 4);
                    const col = index % 4;
                    const fallbackSize = 200;
                    const fallbackGap = 20;
                    pos = {
                        left: 50 + (col * (fallbackSize + fallbackGap)),
                        top: 50 + (row * (fallbackSize + fallbackGap)),
                        width: fallbackSize,
                        height: fallbackSize,
                        gridOrder: index
                    };
                }
                console.log(`‚úÖ Creating conversation ${conv.id} at position (${Math.round(pos.left)}, ${Math.round(pos.top)})`);
                let itemCell = document.getElementById(`conv-item-${conv.id}`);
                if (!itemCell) {
                    // CREATE UNIFIED MP4 PREVIEW COMPONENT
                    console.log(`üé¨ Creating MP4 preview component for ${conv.folder}...`);
                    itemCell = createMP4PreviewComponent(conv, index);
                    
                    // Append to layout canvas
                    layoutCanvas.appendChild(itemCell);
                    
                    console.log(`‚úÖ Created unified MP4 preview component for ${conv.folder}`);
                } else {
                    console.log(`üîÑ Reusing existing component for ${conv.folder}`);
                }
                
                const currentPos = currentPositions[conv.id];
                const isRepositioning = currentPos && !isInitial;
                
                // Apply SMOOTH ISOTOPE-STYLE POSITIONING with ENHANCED ANIMATIONS
                console.log(`üé¨ ${isRepositioning ? 'Animating' : 'Positioning'} ${conv.id} from (${currentPos ? Math.round(currentPos.left) : 'new'}, ${currentPos ? Math.round(currentPos.top) : 'new'}) to (${Math.round(pos.left)}, ${Math.round(pos.top)})`);
                
                // Set isotope-style CSS custom property for staggered animation
                itemCell.style.setProperty('--item-index', index);
                
                // Set absolute positioning
                itemCell.style.position = 'absolute';
                itemCell.style.order = index;
                itemCell.style.zIndex = '10'; // Higher z-index during animation
                itemCell.style.display = 'flex';
                itemCell.style.visibility = 'visible';
                
                // Handle timeline layout with flexbox vs other layouts with absolute positioning
                if (window.activeLayout === 'timeline') {
                    // FLEXBOX TIMELINE: Use flexbox properties instead of absolute positioning
                    itemCell.style.position = 'relative';
                    itemCell.style.left = 'auto';
                    itemCell.style.top = 'auto';
                    itemCell.style.width = `${pos.width}px`;
                    itemCell.style.height = `${pos.height}px`;
                    itemCell.style.order = pos.flexOrder || index;
                    itemCell.style.flex = '0 0 auto';
                    itemCell.style.opacity = '1';
                    itemCell.style.transform = 'scale(1)';
                    itemCell.style.zIndex = '2';
                    
                    console.log(`üéØ FLEXBOX: ${conv.id} set to order ${pos.flexOrder || index}, size ${pos.width}x${pos.height}px`);
                    
                } else if (isRepositioning) {
                    // ISOTOPE ANIMATION: Start from current position, animate to new position
                    
                    // Temporarily disable transitions to snap to current position
                    itemCell.style.transition = 'none';
                    itemCell.style.position = 'absolute';
                    itemCell.style.left = `${currentPos.left}px`;
                    itemCell.style.top = `${currentPos.top}px`;
                    itemCell.style.width = `${currentPos.width}px`;
                    itemCell.style.height = `${currentPos.height}px`;
                    itemCell.style.transform = 'scale(1)';
                    itemCell.style.opacity = '1';
                    
                    // Add isotope transition class
                    itemCell.classList.add('isotope-transitioning');
                    
                    // Force reflow
                    itemCell.offsetHeight;
                    
                    // OPTIMIZED: Fast, smooth transitions with minimal delay
                    const delay = index * 0.02; // Reduced staggered delay
                    itemCell.style.transition = `
                        left 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        top 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        width 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        height 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s,
                        opacity 0.3s ease-out ${delay}s
                    `;
                    
                    // OPTIMIZED: Smooth position and size transitions with simple animation
                    requestAnimationFrame(() => {
                        itemCell.style.left = `${pos.left}px`;
                        itemCell.style.top = `${pos.top}px`;
                        itemCell.style.width = `${pos.width}px`;
                        itemCell.style.height = `${pos.height}px`;
                        itemCell.style.transform = 'scale(1.01)'; // Subtle scale during animation
                        
                        // Final settle animation
                        setTimeout(() => {
                            if (itemCell.classList.contains('isotope-transitioning')) {
                                itemCell.style.transform = 'scale(1)';
                                itemCell.style.zIndex = '2'; // Reset z-index after animation
                                
                                // Remove transition class after animation
                                setTimeout(() => {
                                    itemCell.classList.remove('isotope-transitioning');
                                }, 100);
                            }
                        }, (delay * 1000) + 600); // After main animation completes
                    });
                    
                } else {
                    // ABSOLUTE POSITIONING: Fast initial positioning with minimal animation
                    itemCell.style.position = 'absolute';
                    itemCell.style.transition = `
                        left 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                        top 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                        width 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                        height 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                        transform 0.3s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.01}s,
                        opacity 0.2s ease-out ${index * 0.01}s
                    `;
                    
                    // OPTIMIZED: Fast position and size transitions for initial positioning
                    requestAnimationFrame(() => {
                        itemCell.style.left = `${pos.left}px`;
                        itemCell.style.top = `${pos.top}px`;
                        itemCell.style.width = `${pos.width}px`;
                        itemCell.style.height = `${pos.height}px`;
                        itemCell.style.opacity = '1';
                        itemCell.style.transform = 'scale(1)';
                        itemCell.style.zIndex = '2';
                    });
                }
                
                // Add isotope-style entrance effect
                itemCell.classList.add('isotope-positioned');
            });
            
            /// Create person name labels for People view
            if (window.activeLayout === 'people' && metaData?.personLabels) {
                metaData.personLabels.forEach(label => {
                    const labelElement = document.createElement('div');
                    labelElement.className = 'person-name-label';
                    labelElement.style.cssText = `
                        position: absolute;
                        left: ${label.x}px;
                        top: ${label.y}px;
                        width: ${label.width}px;
                        height: ${label.height}px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        background: initial; /* Reset background */
                        border: none; /* Remove border */
                        border-radius: initial; /* Reset border-radius */
                        font-family: '80k', sans-serif; /* Set to '80k' font */
                        font-size: initial; /* Reset font size */
                        font-weight: initial; /* Reset font weight */
                        color: initial; /* Reset text color */
                        text-align: initial; /* Reset text alignment */
                        z-index: 1;
                        box-shadow: none; /* Remove box-shadow */
                    `;
                    labelElement.textContent = label.name;
                    layoutCanvas.appendChild(labelElement);
                });
            }
            
                    /// Create distinct emotion circles for Emotions view
        if (window.activeLayout === 'emotions' && metaData?.emotionCircles) {
            console.log(`üé≠ Creating ${metaData.emotionCircles.length} distinct emotion circles`);
            
            metaData.emotionCircles.forEach((emotionCircle, index) => {
                const { emotion, center, radius, count } = emotionCircle;
                
                // Enhanced visual styling for each emotion circle
                const circleColors = [
                    '#667eea', '#764ba2', '#f093fb', '#f5576c',
                    '#4facfe', '#00f2fe', '#43e97b', '#38f9d7',
                    '#ffecd2', '#fcb69f', '#a8edea', '#fed6e3'
                ];
                const circleColor = circleColors[index % circleColors.length];
                
                // Create enhanced background circle with emotion-specific styling
                const circleBackground = document.createElement('div');
                circleBackground.className = 'emotion-circle-background';
                circleBackground.style.cssText = `
                    position: absolute;
                    left: ${center.x - radius - 15}px;
                    top: ${center.y - radius - 15}px;
                    width: ${(radius + 15) * 2}px;
                    height: ${(radius + 15) * 2}px;
                    border-radius: 50%;
                    border: 3px solid ${circleColor}40;
                    background: linear-gradient(135deg, ${circleColor}10, ${circleColor}05);
                    box-shadow: 0 4px 20px ${circleColor}20;
                    z-index: 800;
                    pointer-events: none;
                    transition: all 0.3s ease;
                `;
                
                layoutCanvas.appendChild(circleBackground);
                
                // Create inner circle border
                const innerCircle = document.createElement('div');
                innerCircle.className = 'emotion-inner-circle';
                innerCircle.style.cssText = `
                    position: absolute;
                    left: ${center.x - radius}px;
                    top: ${center.y - radius}px;
                    width: ${radius * 2}px;
                    height: ${radius * 2}px;
                    border-radius: 50%;
                    border: 2px dashed ${circleColor}60;
                    z-index: 850;
                    pointer-events: none;
                `;
                
                layoutCanvas.appendChild(innerCircle);
                
                // Create prominent emotion label
                const emotionLabel = document.createElement('div');
                emotionLabel.className = 'emotion-circle-label';
                emotionLabel.textContent = `${emotion}`;
                
                emotionLabel.style.cssText = `
                    position: absolute;
                    left: ${center.x - 100}px;
                    top: ${center.y - radius - 45}px;
                    width: 200px;
                    height: 30px;
                    font-size: 14px;
                    font-weight: bold;
                    color: white;
                    text-align: center;
                    line-height: 30px;
                    background: linear-gradient(135deg, ${circleColor}, ${circleColor}dd);
                    border-radius: 15px;
                    border: 2px solid white;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                    z-index: 1100;
                    pointer-events: none;
                    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
                `;
                
                layoutCanvas.appendChild(emotionLabel);
                
                // Create conversation count badge
                const countBadge = document.createElement('div');
                countBadge.className = 'emotion-count-badge';
                countBadge.textContent = count;
                
                countBadge.style.cssText = `
                    position: absolute;
                    left: ${center.x + 100}px;
                    top: ${center.y - radius - 35}px;
                    width: 30px;
                    height: 30px;
                    font-size: 12px;
                    font-weight: bold;
                    color: white;
                    text-align: center;
                    line-height: 30px;
                    background: ${circleColor};
                    border-radius: 50%;
                    border: 2px solid white;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                    z-index: 1200;
                    pointer-events: none;
                `;
                
                layoutCanvas.appendChild(countBadge);
            });
            
            console.log(`‚úÖ Created ${metaData.emotionCircles.length} distinct emotion circles with enhanced styling`);
        }
            
            // Force reflow to ensure all items are positioned correctly
            layoutCanvas.offsetHeight;
            
            // Log final positions for debugging
            console.log(`‚úÖ Layout complete for ${window.activeLayout} view with ${conversations.length} conversations positioned`);
            let createdCount = 0;
            conversations.forEach((conv, index) => {
                const itemCell = document.getElementById(`conv-item-${conv.id}`);
                if (itemCell) {
                    createdCount++;
                    const rect = itemCell.getBoundingClientRect();
                    console.log(`üìç ${conv.id}: positioned at (${itemCell.style.left}, ${itemCell.style.top}) with size ${itemCell.style.width}x${itemCell.style.height}`);
                } else {
                    console.warn(`‚ùå Missing element for ${conv.id}`);
                }
            });
            console.log(`üìä Created ${createdCount}/${conversations.length} conversation elements`);
        }, 0);
        
        // Render all previews after layout is complete
        setTimeout(() => {
            // Iframe previews load automatically - no need to render manually
            console.log('‚úÖ Layout complete - iframe previews will load automatically');
            
            // Debug conversation visibility after layout
            if (window.debugConversationVisibility) {
                const debugResult = window.debugConversationVisibility();
                console.log('üîç Layout Debug Result:', debugResult);
            }
            
            // Reset the rendering flag
            isLayoutRendering = false;
        }, 100);
        
        }, 50); // End of debounce timeout
    }

    // Add responsive window resize handler
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            console.log('üîÑ Window resized, updating layout...');
            if (window.renderNewLayout) {
                window.renderNewLayout();
                
                // Special handling for People view to ensure consistency
                if (window.activeLayout === 'people') {
                    // Clear any existing stability check
                    if (window.peopleViewStabilityCheck) {
                        clearTimeout(window.peopleViewStabilityCheck);
                    }
                    
                    window.peopleViewStabilityCheck = setTimeout(() => {
                        if (window.renderNewLayout && window.activeLayout === 'people') {
                            console.log('üîÑ People view resize stabilization...');
                            window.renderNewLayout(false);
                        }
                    }, 150);
                }
            }
        }, 300); // Debounce resize events
    });

    // Force layout recalculation after page load to fix initial positioning
    window.addEventListener('load', () => {
        setTimeout(() => {
            console.log('üîÑ Page loaded, forcing layout recalculation...');
            if (window.renderNewLayout) {
                window.renderNewLayout();
                
                // Special handling for People view on page load
                if (window.activeLayout === 'people') {
                    // Clear any existing stability check
                    if (window.peopleViewStabilityCheck) {
                        clearTimeout(window.peopleViewStabilityCheck);
                    }
                    
                    window.peopleViewStabilityCheck = setTimeout(() => {
                        if (window.renderNewLayout && window.activeLayout === 'people') {
                            console.log('üîÑ People view page load stabilization...');
                            window.renderNewLayout(false);
                        }
                    }, 300);
                }
            }
        }, 500); // Wait for DOM to be fully ready
    });

    window.switchLayout = function(newLayout, forceRefresh = true) {
        if (newLayout === window.activeLayout && !forceRefresh) return;
        
        const previousLayout = window.activeLayout;
        window.activeLayout = newLayout;
        
        console.log(`üé¨ ISOTOPE SWITCH: ${previousLayout} ‚Üí ${newLayout}`);
        
        // Reset all conversation containers to default state before layout change
        if (window.resetAllConversationContainers) {
            window.resetAllConversationContainers();
        }
        
        // Add visual feedback for view switching
        const viewButtons = document.querySelectorAll('.view-toggle-btn');
        viewButtons.forEach(btn => {
            btn.style.pointerEvents = 'none'; // Disable during transition
        });
        
        // Re-enable buttons after transition
        setTimeout(() => {
            viewButtons.forEach(btn => {
                btn.style.pointerEvents = 'auto';
            });
        }, 800);

        const timelineTrack = document.querySelector('.timeline-track-wrapper');
        const playgroundContainer = document.getElementById('playground-container');
        const timelineWrapper = document.getElementById('timeline-grid-wrapper');
        
        if (newLayout === 'playground') {
            // Show playground mode
            if (playgroundContainer) playgroundContainer.style.display = 'flex';
            if (timelineWrapper) timelineWrapper.style.display = 'none';
            if (timelineTrack) timelineTrack.style.visibility = 'hidden';
            
            // Start playground sketch
            if (typeof window.startPlaygroundSketch === 'function') {
                window.startPlaygroundSketch();
            }
        } else {
            // Show normal layout modes
            if (playgroundContainer) playgroundContainer.style.display = 'none';
            if (timelineWrapper) timelineWrapper.style.display = 'block';
            if (timelineTrack) {
                timelineTrack.style.visibility = (newLayout === 'timeline') ? 'visible' : 'hidden';
            }
            
            // Stop playground sketch
            if (typeof window.stopPlaygroundSketch === 'function') {
                window.stopPlaygroundSketch();
            }
            
            if (typeof window.resetCamera === 'function') {
                window.resetCamera();
            }
            
            // ENHANCED ISOTOPE ANIMATIONS: Add smooth morphing between views
            console.log(`üé¨ Switching from ${window.activeLayout || 'initial'} to ${newLayout} with isotope-style animation`);
            
            // Add isotope transitioning class for enhanced animations
            const layoutCanvas = document.getElementById('layout-canvas');
            const gridContainer = document.getElementById('timeline-axes-container');
            
            if (layoutCanvas) {
                layoutCanvas.classList.add('isotope-transitioning');
                layoutCanvas.style.transition = 'all 0.6s cubic-bezier(0.23, 1, 0.32, 1)';
            }
            
            if (gridContainer) {
                gridContainer.classList.add('isotope-transitioning');
            }
            
            // ISOTOPE-STYLE SMOOTH VIDEO TRANSITIONS: Show videos moving to new positions
            const allContainers = document.querySelectorAll('.conversation-grid-item-container');
            
            // Phase 1: Prepare containers for smooth isotope animation
            allContainers.forEach((container, index) => {
                container.classList.add('transitioning');
                
                const video = container.querySelector('.conversation-video-preview');
                if (video) {
                    // Keep videos playing during transition for smooth movement effect
                    const wasPlaying = !video.paused;
                    
                    // Show first frame if video isn't playing to ensure content is visible
                    if (!wasPlaying && video.readyState >= 2) {
                        video.currentTime = 0.1;
                    }
                    
                    // Enable smooth video transitions during layout change
                    video.style.transition = 'transform 0.3s ease-out, filter 0.3s ease-out';
                    video.style.willChange = 'transform';
                }
                
                // Add smooth isotope-style transition with fast delays
                container.style.transition = `
                    left 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.03}s,
                    top 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.03}s,
                    width 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.03}s,
                    height 0.8s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.03}s,
                    transform 0.4s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.02}s,
                    opacity 0.3s cubic-bezier(0.23, 1, 0.32, 1) ${index * 0.01}s
                `;
                
                // Add subtle entrance animation for isotope effect
                container.style.transform = `scale(0.96) translateY(10px)`;
                container.style.opacity = '0.85';
                
                // Restore to normal state with staggered timing for organic feel
                setTimeout(() => {
                    container.style.transform = 'scale(1) translateY(0px)';
                    container.style.opacity = '1';
                }, 50 + (index * 30));
                
                // Clean up transition state after animation completes
                setTimeout(() => {
                    container.classList.remove('transitioning');
                    
                    // Reset video transitions to normal hover behavior
                    if (video) {
                        video.style.transition = 'filter 0.3s ease-out';
                        video.style.willChange = 'auto';
                    }
                    
                    // Reset container transitions to normal
                    container.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                }, 2000 + (index * 100)); // Allow time for all animations to complete
            });
            
            // CRITICAL FIX: For People view, ensure proper container dimensions before layout
            if (newLayout === 'people') {
                // Clear any existing stability checks
                if (window.peopleViewStabilityCheck) {
                    clearTimeout(window.peopleViewStabilityCheck);
                }
                
                // Force immediate layout update to set CSS classes with isotope animations
                window.renderNewLayout(false);
                
                // Then wait for container to stabilize and recalculate
                window.peopleViewStabilityCheck = setTimeout(() => {
                    const gridContainer = document.getElementById('timeline-axes-container');
                    
                    if (!gridContainer) return;
                    
                    // Force a reflow to ensure DOM is ready
                    gridContainer.offsetHeight;
                    
                    const currentWidth = gridContainer.clientWidth;
                    const currentHeight = gridContainer.clientHeight;
                    
                    console.log(`üîß People view container stabilization: ${currentWidth}x${currentHeight}`);
                    
                    // Check if dimensions are stable (not zero and reasonable)
                    if (currentWidth > 100 && currentHeight > 100) {
                        console.log(`üîÑ People view STABLE dimensions detected: ${currentWidth}x${currentHeight} - recalculating layout`);
                        
                        if (window.renderNewLayout && window.activeLayout === 'people') {
                            window.renderNewLayout(false);
                        }
                    } else {
                        console.warn(`‚ö†Ô∏è People view dimensions not stable: ${currentWidth}x${currentHeight} - retrying...`);
                        
                        // Retry after another short delay if dimensions aren't stable
                        setTimeout(() => {
                            if (window.renderNewLayout && window.activeLayout === 'people') {
                                console.log(`üîÑ People view retry layout calculation`);
                                window.renderNewLayout(false);
                            }
                        }, 200);
                    }
                }, 150); // Increased delay to ensure CSS has applied
            } else {
                // For other layouts, render immediately with isotope transitions
                window.renderNewLayout(false);
                console.log(`üé¨ Triggered isotope animations for ${newLayout} view`);
                
                // Add completion callback for isotope transitions
                setTimeout(() => {
                    console.log(`‚úÖ Isotope transition to ${newLayout} view completed`);
                    
                    // Clean up isotope transitioning classes
                    if (layoutCanvas) {
                        layoutCanvas.classList.remove('isotope-transitioning');
                    }
                    if (gridContainer) {
                        gridContainer.classList.remove('isotope-transitioning');
                    }
                }, 600); // Match isotope transition duration
            }
            
            // ENHANCED: Global cleanup for isotope classes after all transitions
            setTimeout(() => {
                const allContainers = document.querySelectorAll('.conversation-grid-item-container');
                allContainers.forEach((container, index) => {
                    // Clean up isotope classes
                    container.classList.remove('isotope-positioned', 'transitioning');
                    
                    // Reset transition delays
                    container.style.transitionDelay = '';
                    
                    // Ensure final position is stable
                    container.style.transform = 'scale(1) rotateY(0deg) rotateX(0deg)';
                    
                    // Reset to normal transition for hover effects
                    setTimeout(() => {
                        container.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    }, index * 10);
                });
                
                if (layoutCanvas) {
                    layoutCanvas.classList.remove('isotope-transitioning');
                }
                if (gridContainer) {
                    gridContainer.classList.remove('isotope-transitioning');
                }
                
                console.log(`‚ú® Isotope transition to ${newLayout} view completed with enhanced animations`);
            }, 1000); // Fast cleanup to allow all animations to finish
        }
    }

    function openVisualizationInModal(folder) {
        const modalContainer = document.getElementById('visualization-modal-container');
        if (!modalContainer) return;
        
        // Check if we already have an iframe for this folder
        const existingIframe = modalContainer.querySelector(`iframe[data-folder="${folder}"]`);
        
        if (existingIframe) {
            // If iframe already exists, just show it
            console.log(`‚ôªÔ∏è Reusing existing visualization for ${folder}`);
            modalContainer.style.display = 'flex';
            setTimeout(() => modalContainer.classList.add('visible'), 10);
            return;
        }
        
        // Clear any existing content only if it's a different conversation
        const currentFolder = modalContainer.querySelector('iframe')?.getAttribute('data-folder');
        if (currentFolder && currentFolder !== folder) {
            modalContainer.innerHTML = '';
        }
        
        // Create iframe with enhanced cache-busting
        const iframe = document.createElement('iframe');
        iframe.setAttribute('data-folder', folder);
        
        // Force reload with timestamp to ensure fresh data
        const timestamp = Date.now();
        const randomId = Math.random().toString(36).substr(2, 9);
        iframe.src = `visualization.html?folder=${encodeURIComponent(folder)}&viewMode=iframe&t=${timestamp}&r=${randomId}&force=true`;
        
        // Styles are now handled by CSS, no need to set them here
        iframe.style.backgroundColor = '#f7f9f3';
        
        iframe.onload = () => {
            console.log(`‚úÖ Visualization iframe loaded for ${folder} with cache-busting`);
            // Hide loading indicator if present
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
            
            // Send message to iframe to ensure emotion data is loaded
            setTimeout(() => {
                iframe.contentWindow.postMessage({ 
                    type: 'ensure-emotion-data',
                    folder: folder,
                    timestamp: timestamp
                }, '*');
            }, 500);
        };
        
        modalContainer.appendChild(iframe);
        modalContainer.style.display = 'flex';
        setTimeout(() => modalContainer.classList.add('visible'), 10);
    }
    

    
    // Audio interaction function removed
    
    // Listen for messages from iframe about loading state
    window.addEventListener('message', (event) => {
        if (event.data && (event.data.type === 'close-visualization-modal' || 
                          event.data.type === 'closeVisualization' || 
                          event.data.action === 'closeModal')) {
            closeVisualizationModal();
        } else if (event.data && event.data.type === 'loading-progress') {
            const loadingIndicator = document.getElementById('loading-indicator');
            const loadingText = document.getElementById('loading-text');
            const loadingDetails = document.getElementById('loading-details');
            
            if (event.data.show && loadingIndicator) {
                loadingIndicator.style.display = 'block';
                if (loadingText) loadingText.textContent = event.data.message || '';
                if (loadingDetails) loadingDetails.textContent = event.data.details || '';
            } else if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
        } else if (event.data && event.data.type === 'conversation-deleted') {
            // Handle conversation deletion notification from admin panel
            console.log('üóëÔ∏è Received conversation deletion notification:', event.data.folder);
            
            // Immediately refresh conversations to sync with admin changes
            setTimeout(async () => {
                await loadConversationConfig(true);
            }, 1000); // Small delay to ensure backend has finished processing
        } else if (event.data && event.data.type === 'refresh-conversations') {
            // Handle general refresh request from admin panel
            console.log('üîÑ Received conversation refresh request from admin panel');
            
            setTimeout(async () => {
                await loadConversationConfig(true);
            }, 500);
        }
    });

    function closeVisualizationModal() {
        const modalContainer = document.getElementById('visualization-modal-container');
        if (!modalContainer) return;
        
        // Prevent double closing
        if (modalContainer.dataset.closing === 'true') return;
        modalContainer.dataset.closing = 'true';
        
        // Get the currently open conversation folder from iframe
        const iframe = modalContainer.querySelector('iframe');
        let currentFolder = null;
        if (iframe) {
            const src = iframe.src;
            const folderMatch = src.match(/folder=([^&]+)/);
            if (folderMatch) {
                currentFolder = decodeURIComponent(folderMatch[1]);
            }
        }
        
        modalContainer.classList.remove('visible');
        hideExitTooltip(); // Hide tooltip when closing
        
        // Add zoom-out effect to the conversation item
        if (currentFolder) {
            const conversationItem = document.querySelector(`[id*="${currentFolder}"]`);
            if (conversationItem) {
                conversationItem.style.transition = 'transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                conversationItem.style.transform = 'scale(0.8)';
                conversationItem.style.zIndex = '100';
                
                setTimeout(() => {
                    conversationItem.style.transform = 'scale(1)';
                    conversationItem.style.zIndex = '2';
                    // Restore original transition
                    setTimeout(() => {
                        conversationItem.style.transition = 'all 1.8s cubic-bezier(0.165, 0.84, 0.44, 1)';
                    }, 500);
                }, 100);
            }
        }
        
        setTimeout(() => {
            modalContainer.style.display = 'none';
            modalContainer.innerHTML = '';
            modalContainer.dataset.closing = 'false';
        }, 150);
    }
    
    // Show exit tooltip
    function showExitTooltip() {
        const exitTooltip = document.getElementById('exit-tooltip');
        if (exitTooltip) {
            exitTooltip.classList.add('show');
        }
    }
    
    // Hide exit tooltip
    function hideExitTooltip() {
        const exitTooltip = document.getElementById('exit-tooltip');
        if (exitTooltip) {
            exitTooltip.classList.remove('show');
        }
    }
    
    // Add hover detection for modal container
    document.addEventListener('DOMContentLoaded', () => {
        const modalContainer = document.getElementById('visualization-modal-container');
        if (modalContainer) {
            let hoverTimeout;
            
            // Show tooltip when hovering on the dark overlay (not the iframe)
            modalContainer.addEventListener('mousemove', (event) => {
                // Check if mouse is on the overlay (not on the iframe)
                if (event.target === modalContainer) {
                    clearTimeout(hoverTimeout);
                    showExitTooltip();
                    
                    // Move modal down slightly when hovering outside
                    const iframe = modalContainer.querySelector('iframe');
                    if (iframe) {
                        iframe.style.transform = 'translateY(20px)';
                    }
                } else {
                    // Mouse is over the iframe
                    hideExitTooltip();
                    
                    // Reset modal position
                    const iframe = modalContainer.querySelector('iframe');
                    if (iframe) {
                        iframe.style.transform = 'translateY(0)';
                    }
                }
            });
            
            // Hide tooltip when leaving modal container
            modalContainer.addEventListener('mouseleave', () => {
                hideExitTooltip();
                
                // Reset modal position
                const iframe = modalContainer.querySelector('iframe');
                if (iframe) {
                    iframe.style.transform = 'translateY(0)';
                }
            });
        }
    });
    
    // Add escape key handler
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
            const modalContainer = document.getElementById('visualization-modal-container');
            if (modalContainer && modalContainer.classList.contains('visible')) {
                closeVisualizationModal();
            }
        }
    });
    
    // Add click handler to close modal when clicking outside
    document.addEventListener('click', (event) => {
        const modalContainer = document.getElementById('visualization-modal-container');
        if (modalContainer && modalContainer.classList.contains('visible')) {
            // Check if click is directly on the modal container (not its children)
            if (event.target === modalContainer) {
                closeVisualizationModal();
            }
        }
    });

    // Page switching functions
    function showConversationsPage() {
        document.getElementById('playground-container').style.display = 'none';
        document.getElementById('timeline-grid-wrapper').style.display = 'block';
        
        console.log('üìÑ Switched to conversations page');
    }
    
    // Open live visualization in new window/tab
    function openLiveVisualization() {
        console.log('üé¨ Opening Live Visualization...');
        
        // Open in new window for better performance
        const liveVizWindow = window.open(
            'live_visualization.html',
            'LiveVisualization',
            'width=1200,height=800,scrollbars=no,resizable=yes,status=no,toolbar=no,menubar=no'
        );
        
        if (liveVizWindow) {
            // Send start message after window loads
            setTimeout(() => {
                try {
                    liveVizWindow.postMessage({ type: 'start-live-visualization' }, '*');
                } catch (error) {
                    console.log('Could not send start message to live visualization window');
                }
            }, 1000);
        } else {
            // Fallback: open in same window if popup blocked
            window.location.href = 'live_visualization.html';
        }
    }
    
    // Make function globally available
    window.openLiveVisualization = openLiveVisualization;





    // Initialize animated emotion separators with random emotions
    function initializeEmotionSeparators() {
        const emotionChars = ['‚óè', '‚óâ', '‚óã', '‚óØ', '‚¨¢', '‚¨°', '‚óä', '‚óà', '‚òÖ', '‚òÜ', '‚ú®', '‚ô•', '‚ó¶', '‚Ä¢', '‚àò', '‚äô', '‚äö', '‚äõ'];
        const emotionColors = ['#FFD700', '#FF69B4', '#FF8C00', '#87CEEB', '#FFA500', '#DC143C', '#8B008B', '#228B22'];
        
        const separators = document.querySelectorAll('.emotion-separator');
        
        function updateEmotionChar(separator, index) {
            const randomChar = emotionChars[Math.floor(Math.random() * emotionChars.length)];
            const randomColor = emotionColors[Math.floor(Math.random() * emotionColors.length)];
            separator.textContent = randomChar;
            separator.style.color = randomColor;
        }
        
        // Initial setup
        separators.forEach((separator, index) => {
            updateEmotionChar(separator, index);
            
            // Change emotion character every 3-8 seconds randomly
            const interval = 3000 + Math.random() * 5000;
            setInterval(() => updateEmotionChar(separator, index), interval);
        });
    }

    // Initialize emotion separators when page loads
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(initializeEmotionSeparators, 1000); // Wait for page to load
        setTimeout(initializeHeaderEmotionCircles, 1500); // Wait for header to load
        
        // Ensure People view is properly initialized on DOM ready
        setTimeout(() => {
            if (window.activeLayout === 'people' && window.renderNewLayout) {
                // Clear any existing stability check
                if (window.peopleViewStabilityCheck) {
                    clearTimeout(window.peopleViewStabilityCheck);
                }
                
                window.peopleViewStabilityCheck = setTimeout(() => {
                    if (window.renderNewLayout && window.activeLayout === 'people') {
                        console.log('üîÑ DOM ready - ensuring People view is properly initialized...');
                        window.renderNewLayout(false);
                    }
                }, 100);
            }
        }, 2000); // Wait for all initialization to complete
    });
    
    // Initialize header logo emotion circles with random emotions
    function initializeHeaderEmotionCircles() {
        const emotionChars = ['‚óè', '‚óâ', '‚óã', '‚óØ', '‚¨¢', '‚¨°', '‚óä', '‚óà', '‚òÖ', '‚òÜ', '‚ú®', '‚ô•', '‚ó¶', '‚Ä¢', '‚àò', '‚äô', '‚äö', '‚äõ'];
        const emotionColors = ['#FFD700', '#FF69B4', '#FF8C00', '#87CEEB', '#FFA500', '#DC143C', '#8B008B', '#228B22'];
        
        const logoCircles = document.querySelectorAll('.logo-emotion-circle');
        
        function updateHeaderEmotionChar(circle, index) {
            const randomChar = emotionChars[Math.floor(Math.random() * emotionChars.length)];
            const randomColor = emotionColors[Math.floor(Math.random() * emotionColors.length)];
            circle.textContent = randomChar;
            circle.style.color = randomColor;
        }
        
        // Initial setup
        logoCircles.forEach((circle, index) => {
            updateHeaderEmotionChar(circle, index);
            
            // Change emotion character every 2-6 seconds randomly
            const interval = 2000 + Math.random() * 4000;
            setInterval(() => updateHeaderEmotionChar(circle, index), interval);
        });
        
        console.log('‚ú® Header emotion circles initialized');
    }
  </script>
  
  <style>
            @font-face { font-family: '80k'; src: url('assets/Fonts/80kb_desk/80-kb-Sharp.otf') format('opentype'); font-weight: 400; }
        @font-face { font-family: '80k'; src: url('assets/Fonts/80kb_desk/80-kb-SharpBold.otf') format('opentype'); font-weight: 700; }
    :root { --main-font-family: '80k', sans-serif; }
    html, body { 
        height: 100%; 
        margin: 0; 
        padding: 0; 
        background: #f7f9f3;
        background-image: linear-gradient(to right, rgba(128, 128, 128, 0.08) 1px, transparent 1px), 
                          linear-gradient(to bottom, rgba(128, 128, 128, 0.08) 1px, transparent 1px);
        background-size: var(--dynamic-grid-size, 60px) var(--dynamic-grid-size, 60px) !important;
        background-attachment: fixed !important;
        background-position: 0 0 !important;
        font-family: var(--main-font-family); 
        color: #222; 
        font-size: 14px; 
        overflow: hidden;
    }
    .app-header { width: 100%; background: #f7f9f3 !important; padding: 15px 30px; display: flex; justify-content: space-between; align-items: center; z-index: 1001 !important; position: fixed; top: 0; left: 0; right: 0; box-sizing: border-box; height: 60px; }
    
    /* Bottom controls container - ensure it stays on top of grid */
    #bottom-controls-container { 
        position: fixed !important; 
        bottom: 0 !important; 
        left: 0 !important; 
        right: 0 !important; 
        background: #f7f9f3 !important; 
        z-index: 1001 !important; 
        height: 60px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        box-sizing: border-box !important;
        border-top: 1px solid rgba(128, 128, 128, 0.2) !important;
        gap: 20px !important;
        padding: 0 20px !important;
    }
    
    /* Ensure child elements in bottom controls are properly styled and visible */
    #bottom-controls-container * {
        z-index: inherit !important;
        position: relative !important;
    }
    
    /* Style view toggle buttons to be visible on top of grid */
    .view-toggle-buttons {
        display: flex !important;
        align-items: center !important;
        gap: 15px !important;
        z-index: 1002 !important;
    }
    

    
    .view-toggle-btn {
        background: transparent !important;
        border: 1px solid rgba(128, 128, 128, 0.3) !important;
        padding: 8px 16px !important;
        border-radius: 8px !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        font-family: var(--main-font-family) !important;
        font-size: 14px !important;
        z-index: 1002 !important;
    }
    
    .view-toggle-btn:hover,
    .view-toggle-btn.active {
        background: rgba(128, 128, 128, 0.1) !important;
        border-color: rgba(128, 128, 128, 0.5) !important;
    }
    
    /* Ensure all UI panels and overlays stay on top of the grid */
    .retranscribe-panel,
    .mdl-dialog,
    .mdl-tooltip,
    #playground-container,
    #live-visualization-container {
        z-index: 2000 !important;
    }
    .header-title { display: flex; align-items: center; font-size: 24px; font-weight: 400; }
    .header-nav { display: flex; align-items: center; gap: 20px; }
    .nav-link { cursor: pointer; color: #999; padding-bottom: 2px; text-decoration: none; font-size: 15px; border-bottom: 2px solid transparent; transition: color 0.2s, border-bottom-color 0.2s; font-weight: 400; }
    .nav-link:hover { color: #666; }
    .nav-link.active-nav { 
        color: #000 !important; 
        border-bottom: none; 
        position: relative; 
        font-weight: 500;
    }
    .nav-link.active-nav::before { 
        content: '['; 
        margin-right: 3px; 
        color: #000;
        font-weight: normal;
    }
    .nav-link.active-nav::after { 
        content: ']'; 
        margin-left: 3px; 
        color: #000;
        font-weight: normal;
    }
    #timeline-grid-wrapper { position: absolute; top: 60px; left: 0; right: 0; bottom: 0; background: transparent !important; overflow: hidden; display: flex; flex-direction: column; box-sizing: border-box; }
    
    /* Fix timeline-grid-wrapper in people view to prevent double containers */
    .layout-people #timeline-grid-wrapper {
        position: absolute !important;
        top: 60px !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        background-color: transparent !important;
        overflow: hidden !important;
        display: block !important; /* Change from flex to block */
        padding: 0 !important;
        margin: 0 !important;
        z-index: 0 !important; /* Behind the layout-canvas */
    }
    #timeline-axes-container { 
        position: relative; 
        flex-grow: 1; 
        min-height: 500px; 
        padding: 20px; 
        box-sizing: border-box; 
        overflow-y: auto;
        overflow-x: hidden;
        background: transparent !important; /* Transparent to show body grid */
        background-image: none !important; /* No background patterns */
        background-color: transparent !important; /* Transparent to show body grid */
    }
    
    /* Fix timeline-axes-container in people view to prevent conflicts */
    .layout-people #timeline-axes-container {
        position: relative !important;
        padding: 0 !important; /* Remove padding to prevent positioning conflicts */
        overflow: hidden !important; /* Clean overflow */
        height: 100% !important;
        width: 100% !important;
        background: transparent !important;
        z-index: 0 !important; /* Behind the layout-canvas */
    }

    /* Single Row Grid System - 12 videos in one row with square cells */
    #layout-canvas { 
        position: fixed;
        top: 60px;
        left: 0;
        right: 0;
        bottom: 60px;
        width: 100%;
        height: calc(100vh - 120px);
        display: block; /* Changed from flex to block for absolute positioning */
        padding-left: 24px !important;
        padding-right: 24px !important;
        box-sizing: border-box;
        background: transparent !important; /* Transparent so body grid shows through */
        border: none;
        border-radius: 0;
        overflow: hidden;
        box-shadow: none;
        /* Ensure conversations stay within padding boundaries */
        max-width: calc(100% - 48px) !important; /* Account for 24px padding on each side */
        margin: 0 auto !important; /* Center the content */
    }
    
    /* Override for people view to allow absolute positioning */
    #layout-canvas.people-active {
        display: block !important;
        position: fixed !important; /* Use fixed positioning consistently */
        top: 60px !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 60px !important;
        width: 100% !important;
        height: calc(100vh - 120px) !important;
        overflow: hidden !important;
        align-items: unset !important;
        justify-content: unset !important;
        flex-direction: unset !important;
        min-height: 600px !important;
        z-index: 1 !important;
    }
    
    /* Set CSS custom properties for horizontal line layout */
    #layout-canvas {
        --video-size: 150px;
    }

    /* SIMPLIFIED video containers - Clean and efficient */
    .conversation-grid-item-container { 
        position: absolute; 
        box-sizing: border-box; 
        padding: 0; 
        margin: 1px !important; /* CONSISTENT 1px margin across all views */
        display: flex;
        justify-content: space-between;
        align-items: center;
        overflow: hidden; /* Ensure videos don't overflow */
        border-radius: 8px; /* Subtle rounded corners */
        cursor: pointer;
        transition: transform 0.3s ease, box-shadow 0.3s ease !important; /* Smooth transitions for hover effects */
        background: transparent !important; /* Transparent to show grid behind */
        border: none;
        border-radius: 0;
        overflow: hidden !important; /* CRITICAL: Prevent video overflow */
        cursor: pointer; 
        box-shadow: none;
        z-index: 2;
        will-change: transform, box-shadow !important; /* Enable will-change for smooth animations */
        transform-origin: center center;
        /* ENHANCED: Perfect square filling the entire allocated space */
        aspect-ratio: 1 / 1;
        width: 100% !important; /* Force container to fill allocated width */
        height: 100% !important; /* Force container to fill allocated height */
        /* Performance optimizations */
        contain: layout style paint;
        backface-visibility: hidden;
        perspective: 1000px;
        /* Ensure content stays within bounds */
        isolation: isolate;
    }

    /* Video container wrapper for enhanced centering */
    .video-container-wrapper {
        width: 100% !important;
        height: 100% !important;
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        position: relative !important;
        overflow: hidden !important;
        background: transparent !important;
        border-radius: 0 !important;
        margin: 0 !important;
        padding: 0 !important;
        /* Ensure perfect centering */
        place-items: center !important;
        place-content: center !important;
        /* Performance optimizations */
        contain: layout style paint !important;
        backface-visibility: hidden !important;
        will-change: transform !important; /* Enable will-change for smooth animations */
        transition: transform 0.3s ease !important; /* Smooth transitions for hover effects */
    }
    
    /* Grid cell inner div container - ULTRA ENHANCED */
    .grid-cell-content {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: transparent;
        border-radius: 0;
        overflow: hidden;
        position: relative;
        text-align: center;
        place-items: center;
        /* ULTRA ENHANCED: Maximum cropping and visual quality */
        aspect-ratio: 1 / 1;
        /* Enhanced visual masking for better focus */
        mask: radial-gradient(circle at center, black 85%, transparent 100%);
        -webkit-mask: radial-gradient(circle at center, black 85%, transparent 100%);
        /* Improved rendering */
        will-change: transform !important; /* Enable will-change for smooth animations */
        contain: layout style paint;
        transition: transform 0.3s ease !important; /* Smooth transitions for hover effects */
    }

    .conversation-grid-item-container:hover { 
        transform: scale(1.05) !important; /* Scale up slightly on hover */
        z-index: 10 !important; /* Higher z-index to appear above others */
        background: transparent !important; /* No background color on hover */
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2) !important; /* Subtle shadow on hover */
        border: none !important; /* No border on hover */
        border-radius: 0 !important;
        backdrop-filter: none !important;
        margin: 1px !important; /* MAINTAIN CONSISTENT MARGIN */
        width: 100% !important; /* MAINTAIN CONSISTENT WIDTH */
        height: 100% !important; /* MAINTAIN CONSISTENT HEIGHT */
        transition: transform 0.3s ease, box-shadow 0.3s ease, z-index 0s !important; /* Smooth transition */
    }
    
    .conversation-grid-item-container:hover .grid-cell-content {
        border-radius: 0;
    }

    /* Enhanced hover effects for video container wrapper */
    .conversation-grid-item-container:hover .video-container-wrapper {
        transform: scale(1.05) !important; /* Scale with container */
        background: transparent !important;
        border-radius: 0 !important;
        width: 100% !important; /* MAINTAIN CONSISTENT WIDTH */
        height: 100% !important; /* MAINTAIN CONSISTENT HEIGHT */
        margin: 0 !important; /* MAINTAIN CONSISTENT MARGIN */
    }

    /* CRITICAL: Ensure video preview containers have NO backdrop effects */
    .video-preview-item, 
    .video-preview-item:hover {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
    }

    /* Video wrapper styles removed - videos now display directly */
    
    /* SIMPLIFIED Video styling - Direct and efficient */
    .conversation-video-preview { 
        object-fit: cover; 
        object-position: center center;
        display: block; 
        width: 100%; 
        height: 100%; 
        border: none; 
        border-radius: 8px; /* Match container radius */
        margin: 0;
        padding: 0;
        position: absolute;
        top: 0;
        left: 0;
        transition: transform 0.3s ease !important; /* Smooth transitions for hover effects */
        background: #f0f0f0; /* Light background while loading */
    }
    
    /* CLEAN hover effects - Simple and non-blocking */
    .conversation-grid-item-container:hover .conversation-video-preview {
        opacity: 1.0 !important; /* Keep full opacity, no fade effect */
        transform: scale(1.05) !important; /* Scale video with container */
    }
    
    .conversation-grid-item-container:hover {
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2) !important; /* Subtle shadow on hover */
        border: none !important; /* No border on hover */
        background: transparent !important; /* No background on hover */
        margin: 1px !important; /* MAINTAIN CONSISTENT MARGIN */
        width: 100% !important; /* MAINTAIN CONSISTENT WIDTH */
        height: 100% !important; /* MAINTAIN CONSISTENT HEIGHT */
    }

    /* Hide video error overlays */
    .conversation-grid-item-container div[style*="Video Error"] {
        display: none !important;
    }

    /* Responsive adjustments - Maintain center alignment at all sizes with dynamic sizing */
    @media (max-width: 1400px) {
        #layout-canvas {
            padding-left: 0; /* No padding for maximum space usage */
            padding-right: 0; /* No padding for maximum space usage */
        }
    }

    @media (max-width: 1200px) {
        #layout-canvas {
            padding-left: 0; /* No padding for maximum space usage */
            padding-right: 0; /* No padding for maximum space usage */
        }
    }

    @media (max-width: 768px) {
        #layout-canvas {
            padding-left: 0; /* No padding for maximum space usage */
            padding-right: 0; /* No padding for maximum space usage */
        }
    }

    @media (max-width: 480px) {
        #layout-canvas {
            padding-left: 0; /* No padding for maximum space usage */
            padding-right: 0; /* No padding for maximum space usage */
        }
    }

    /* People view styles are handled above */

    /* People view - Column layout with person names and conversation previews - BOTTOM ALIGNED */
    .layout-people #layout-canvas {
        display: block !important;
        padding: 0 !important; /* Remove padding to let JavaScript handle positioning */
        overflow: hidden !important; /* Clean overflow management */
        max-width: none !important;
        margin: 0 !important;
        position: fixed !important; /* Use fixed positioning like other views */
        top: 60px !important; /* Standard header offset */
        left: 0 !important;
        right: 0 !important;
        bottom: 60px !important; /* Standard footer offset */
        width: 100% !important;
        height: calc(100vh - 120px) !important;
        background: transparent !important; /* Transparent to show body grid background */
        box-sizing: border-box !important;
        z-index: 1 !important; /* Ensure proper layering */
    }

    /* People view containers - FORCE IDENTICAL TO TIMELINE VIEW */
    .layout-people .conversation-grid-item-container {
        /* EXACT COPY of Timeline view styling - ENFORCED */
        position: absolute !important;
        box-sizing: border-box !important;
        padding: 0 !important;
        margin: 1px !important; /* IDENTICAL to Timeline */
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        transition: transform 0.3s ease, box-shadow 0.3s ease !important; /* Smooth transitions for hover effects */
        background: transparent !important; /* Transparent background like Timeline view */
        border: none !important;
        border-radius: 0 !important; /* IDENTICAL square corners */
        overflow: hidden !important;
        cursor: pointer !important;
        box-shadow: none !important;
        z-index: 2 !important;
        will-change: transform, box-shadow !important; /* Enable will-change for smooth animations */
        transform-origin: center center !important;
        /* FORCE IDENTICAL performance optimizations and square shape */
        aspect-ratio: 1 / 1 !important;
        contain: layout style paint !important;
        backface-visibility: hidden !important;
        perspective: 1000px !important;
        isolation: isolate !important;
        /* FORCE square dimensions - width and height must be equal */
        width: var(--timeline-square-size, 150px) !important;
        height: var(--timeline-square-size, 150px) !important;
        min-width: var(--timeline-square-size, 150px) !important;
        min-height: var(--timeline-square-size, 150px) !important;
        max-width: var(--timeline-square-size, 150px) !important;
        max-height: var(--timeline-square-size, 150px) !important;
    }

    .layout-people .conversation-grid-item-container:hover {
    /* SCALING hover effects for better interaction */
    transform: scale(1.05) !important; /* Scale up slightly on hover */
    z-index: 10 !important; /* Higher z-index to appear above others */
    background: transparent !important; /* No background color on hover */
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2) !important; /* Subtle shadow on hover */
    border: none !important; /* No border on hover */
    border-radius: 0 !important;
    backdrop-filter: none !important;
    margin: 1px !important; /* MAINTAIN CONSISTENT MARGIN */
    width: var(--timeline-square-size, 150px) !important; /* MAINTAIN CONSISTENT WIDTH */
    height: var(--timeline-square-size, 150px) !important; /* MAINTAIN CONSISTENT HEIGHT */
}

    /* People view uses UNIFIED COMPONENT SYSTEM - No separate CSS needed */

    /* Person name labels */
    /* Person name labels */
.person-name-label {
    font-family: '80k', sans-serif !important; /* Keep only '80k' font */
    font-size: initial !important; /* Resets to browser default or inherited size */
    font-weight: initial !important; /* Resets to browser default or inherited weight */
    color: initial !important; /* Resets to browser default or inherited color (usually black) */
    text-align: initial !important; /* Resets to browser default or inherited alignment */
    direction: initial !important; /* Resets to browser default or inherited direction */
    unicode-bidi: initial !important; /* Resets to browser default or inherited unicode-bidi */
    transition: none !important; /* Remove all transitions */
    /* If there are any other properties you want to remove, set them to `initial !important;` or `none !important;` */
}

/* Also ensure the :hover state for this label doesn't add unwanted styles */
.person-name-label:hover {
    background: transparent !important; /* Remove hover background */
    border-color: transparent !important; /* Remove hover border color */
    transform: none !important; /* Remove any transform on hover */
    box-shadow: none !important; /* Remove any box-shadow on hover */
}

    /* Hide conversation labels in People view - we use person name labels instead */
    .layout-people .conversation-label {
        display: none !important;
    }

    .layout-emotions #layout-canvas {
        display: block !important; /* Use block for absolute positioning like other views */
        position: relative !important;
        overflow: visible !important;
        transform-origin: center center;
        animation: spin 80s linear infinite;
        background: transparent !important; /* Transparent to show body grid background */
        border: none !important;
        min-height: 600px !important;
    }

    .layout-emotions .conversation-grid-item-container {
        /* FORCE IDENTICAL TO TIMELINE VIEW - Perfect squares */
        position: absolute !important;
        box-sizing: border-box !important;
        padding: 0 !important;
        margin: 1px !important; /* IDENTICAL to Timeline */
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        transition: transform 0.3s ease, box-shadow 0.3s ease !important; /* Smooth transitions for hover effects */
        background: transparent !important; /* Transparent background like Timeline view */
        border: none !important; /* NO BORDER */
        border-radius: 0 !important; /* IDENTICAL square corners */
        overflow: hidden !important;
        cursor: pointer !important;
        box-shadow: none !important; /* NO SHADOW */
        z-index: 2 !important;
        will-change: transform, box-shadow !important; /* Enable will-change for smooth animations */
        transform-origin: center center !important;
        /* FORCE IDENTICAL performance optimizations and square shape */
        aspect-ratio: 1 / 1 !important;
        contain: layout style paint !important;
        backface-visibility: hidden !important;
        perspective: 1000px !important;
        isolation: isolate !important;
        /* FORCE square dimensions - width and height must be equal */
        width: var(--timeline-square-size, 150px) !important;
        height: var(--timeline-square-size, 150px) !important;
        /* Add spinning animation for emotions view */
        animation: spin 80s linear infinite reverse !important;
        transform-style: preserve-3d !important;
    }

    #splash-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #f7f9f3; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; transition: opacity 0.5s ease-out; font-family: var(--main-font-family); color: #333; }
    #splash-screen.hidden { opacity: 0; pointer-events: none; }
    #splash-logo { 
        font-size: 48px; 
        font-weight: bold; 
        margin-bottom: 20px; 
        /* Make logo 1:1 aspect ratio */
        width: 200px;
        height: 200px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 3px solid #8B7355;
        border-radius: 20px;
        background: rgba(247, 249, 243, 0.9);
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 25px rgba(139, 115, 85, 0.2);
    }
    #splash-message { font-size: 20px; }
    #visualization-modal-container { 
      position: fixed; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      background-color: rgba(0, 0, 0, 0.8); 
      backdrop-filter: blur(5px); 
      z-index: 5000; 
      display: none; 
      align-items: center; 
      justify-content: center; 
      opacity: 0; 
      transition: opacity 0.15s ease-in-out; 
      padding: 20px; 
      margin: 0; 
      box-sizing: border-box;
    }
    #visualization-modal-container.visible { 
      display: flex; 
      opacity: 1; 
    }
    #visualization-modal-container iframe { 
      width: 95vw; 
      height: 92vh; 
      max-width: none; 
      max-height: none; 
      border: none; 
      border-radius: 0 !important; 
      box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
      background-color: #f7f9f3;
      transition: transform 0.3s ease;
    }
    
    /* Exit Tooltip Styles */
    .exit-tooltip {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 16px;
        font-family: var(--main-font-family);
        z-index: 5001;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s, visibility 0.3s;
        pointer-events: none;
        direction: rtl;
    }
    
    .exit-tooltip.show {
        opacity: 1;
        visibility: visible;
    }
    /* People view styles removed - using grid layout now */
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    
    /* Video preview styles - ISOTOPE READY VIDEOS */
    .conversation-video-preview {
        border: none !important;
        border-radius: 4px !important;
        box-shadow: none !important;
        background: transparent !important; /* Show actual video content, no fallback */
        /* Optimized for smooth isotope animations */
        contain: layout style paint !important;
        isolation: isolate !important;
        aspect-ratio: 1 / 1 !important; /* Perfect square */
        width: 100% !important;
        height: 100% !important;
        object-fit: cover !important;
        /* Enhanced for smooth video transitions */
        backface-visibility: hidden !important;
        will-change: transform !important; /* Enable smooth transitions */
        transform: translateZ(0) !important; /* Composite layer for smooth movement */
        /* High-quality rendering during animations */
        image-rendering: -webkit-optimize-contrast !important;
        image-rendering: crisp-edges !important;
        /* Ensure smooth playback during transitions */
        transition: transform 0.4s cubic-bezier(0.23, 1, 0.32, 1) !important;
    }
    
    /* Emotions view uses UNIFIED COMPONENT SYSTEM - No separate CSS needed */
    .layout-emotions .conversation-video-preview {
        /* Additional optimizations for spinning animation */
        contain: strict !important;
        /* Smooth rendering during rotation */
        image-rendering: optimizeSpeed !important;
    }
    
    /* Static fallback for emotions view */
    .static-emotions-fallback {
        transition: opacity 0.3s ease;
    }
    
    /* ISOTOPE TRANSITION: Show videos smoothly moving between layouts */
    .conversation-grid-item-container.transitioning .conversation-video-preview {
        opacity: 1 !important; /* Keep videos fully visible during transition */
        visibility: visible !important; /* Keep videos visible */
        display: block !important; /* Keep videos displayed */
        background: transparent !important; /* Show actual video content, not fallbacks */
        /* Enhanced smooth transitions for isotope effect */
        transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1), 
                   filter 0.4s cubic-bezier(0.23, 1, 0.32, 1) !important;
        will-change: transform, filter !important; /* Allow smooth transforms and filters */
        transform: translateZ(0) scale(1) !important; /* Maintain proper scaling during transition */
        backface-visibility: hidden !important; /* Smooth rendering */
    }
    
    /* Isotope container transition styling */
    .conversation-grid-item-container.transitioning {
        opacity: 1 !important; /* Keep containers visible */
        visibility: visible !important; /* Keep containers visible */
        background: #f7f9f3 !important;
        background-image: linear-gradient(to right, rgba(128, 128, 128, 0.08) 1px, transparent 1px), 
                          linear-gradient(to bottom, rgba(128, 128, 128, 0.08) 1px, transparent 1px) !important;
        background-size: 100px 100px !important;
        /* Enhanced z-index during transition for smooth layering */
        z-index: 5 !important;
        /* No shadow during transition */
        box-shadow: none !important;
    }
    
    /* Emotions view: Clean background during transitions (no duplicate grid) */
    .layout-emotions .conversation-grid-item-container.transitioning {
        background: transparent !important;
        background-image: none !important;
        box-shadow: none !important; /* NO SHADOW */
        border: none !important; /* NO BORDER */
    }
    
    /* ISOTOPE TRANSITION EFFECTS */
    .isotope-transitioning {
        /* Clean background during transition (main background grid handles pattern) */
        background: transparent !important;
        background-image: none !important;
        box-shadow: none !important;
        border: none !important;
        z-index: 15 !important; /* Higher during transition */
        /* No glow effect during movement */
        filter: none !important;
        /* No border radius transition */
        border-radius: 0 !important;
    }
    
    /* Emotions view: Clean background during isotope transitions (no duplicate grid) */
    .layout-emotions .isotope-transitioning {
        background: transparent !important;
        background-image: none !important;
        box-shadow: none !important; /* NO SHADOW */
        border: none !important; /* NO BORDER */
        filter: none !important; /* NO FILTER EFFECTS */
    }
    
    .isotope-transitioning .conversation-video-preview {
        /* NO FILTERS - Preserve exact video colors */
        filter: none !important;
        /* Smooth border transition */
        border-radius: 2px !important;
        /* Ensure video stays visible and high quality during movement */
        opacity: 1 !important;
        visibility: visible !important;
        display: block !important;
        /* Keep video playing smoothly during transition */
        image-rendering: -webkit-optimize-contrast !important;
    }
    
    /* Isotope positioned class for smooth entrance */
    .isotope-positioned {
        /* Ensure smooth transitions */
        will-change: transform, left, top, width, height !important;
        backface-visibility: hidden !important;
        transform-style: preserve-3d !important;
    }
    
    /* Layout transition container effects */
    .layout-timeline.isotope-switching #layout-canvas,
    .layout-people.isotope-switching #layout-canvas {
        /* No background effects during transition */
        backdrop-filter: none !important;
        /* Transparent to show body grid during transitions */
        background: transparent !important;
    }
    
    /* Emotions view: Same background during transitions */
    .layout-emotions.isotope-switching #layout-canvas {
        background: transparent !important; /* Transparent to show body grid */
        backdrop-filter: none !important; /* NO BLUR EFFECT */
    }
    
    /* ZOOM-RESPONSIVE DYNAMIC GRID - DISABLED (using main CSS background grid instead) */
    .static-background-grid {
        display: none !important; /* Hidden - main CSS background handles all grid display */
        opacity: 0 !important;
        visibility: hidden !important;
        transform: none !important;
        will-change: background-size !important; /* Only background size can change */
    }
    
    /* Static background grid fallback - only used if body background fails */
    .layout-timeline .static-background-grid,
    .layout-people .static-background-grid,
    .layout-emotions .static-background-grid {
        display: none !important; /* Hidden - body background handles the grid */
        opacity: 0 !important;
    }
    
    /* ALL LAYOUTS: layout-canvas transparent to show body grid, other containers are solid */
    #layout-canvas {
        background: transparent !important; /* Always transparent to show body grid */
        background-image: none !important; /* No background patterns */
    }
    
    #timeline-grid-wrapper,
    #timeline-axes-container {
        background: transparent !important; /* Transparent to show body grid through */
        background-image: none !important; /* No background patterns */
        background-color: transparent !important; /* Transparent to show body grid */
    }
    
    /* Timeline view containers - layout-canvas transparent, others have solid background */
    .layout-timeline #layout-canvas {
        background: transparent !important; /* Transparent so body grid shows through */
    }
    
    .layout-timeline #timeline-grid-wrapper,
    .layout-timeline #timeline-axes-container {
        background: transparent !important; /* Transparent to show body grid */
        background-image: none !important;
        background-color: transparent !important; /* Transparent to show body grid */
    }
    
    /* People view containers */
    .layout-people #layout-canvas {
        background: transparent !important; /* Transparent so body grid shows through */
    }
    
    .layout-people #timeline-grid-wrapper,
    .layout-people #timeline-axes-container {
        background: transparent !important; /* Transparent to show body grid */
        background-image: none !important;
        background-color: transparent !important; /* Transparent to show body grid */
    }
    
    /* Emotions view containers */
    .layout-emotions #layout-canvas {
        background: transparent !important; /* Transparent so body grid shows through */
    }
    
    .layout-emotions #timeline-grid-wrapper,
    .layout-emotions #timeline-axes-container {
        background: transparent !important; /* Transparent to show body grid */
        background-image: none !important;
        background-color: transparent !important; /* Transparent to show body grid */
    }
    
    /* EMOTIONS VIEW: Keep background grid completely static - no rotation */
    .layout-emotions .static-background-grid {
        display: none !important; /* Hide the regular background grid in emotions view */
    }
    
    /* GLOBAL STATIC BACKGROUND - Always visible, completely static */
    body {
        height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        font-family: var(--main-font-family) !important;
        color: #222 !important;
        font-size: 14px !important;
        overflow: hidden !important;
        background: #f7f9f3 !important;
        background-image: linear-gradient(to right, rgba(128, 128, 128, 0.08) 1px, transparent 1px), 
                          linear-gradient(to bottom, rgba(128, 128, 128, 0.08) 1px, transparent 1px) !important;
        background-size: 60px 60px !important;
        background-attachment: fixed !important; /* Grid never moves, ever */
        background-repeat: repeat !important;
        background-position: 0 0 !important; /* Always starts from top-left */
        /* Only grid size transitions, no position changes */
        transition: background-size 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) !important;
        /* PREVENT ANY MOVEMENT OR ANIMATION */
        animation: none !important;
        transform: none !important;
        will-change: background-size !important; /* Only background size can change */
    }
    
    
    
    @keyframes pulse {
        0%, 100% { transform: translateY(-50%) scale(1); opacity: 0.8; }
        50% { transform: translateY(-50%) scale(1.1); opacity: 0.6; }
    }
    
    /* Animated emotion separator styles */
    .emotion-separator {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        margin: 0 8px;
        position: relative;
        animation: emotionSpin 8s linear infinite;
        font-size: 14px;
        color: #8B7355;
        transform-origin: center;
        cursor: default;
        user-select: none;
    }

    @keyframes emotionSpin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    /* Different speeds and directions for variety - like emotions view */
    .emotion-separator:nth-child(2) { 
        animation-duration: 6s; 
        color: #FFD700; /* happiness */
    }
    .emotion-separator:nth-child(4) { 
        animation-duration: 10s; 
        animation-direction: reverse; 
        color: #FF69B4; /* love */
    }
    .emotion-separator:nth-child(6) { 
        animation-duration: 8s; 
        color: #FF8C00; /* curiosity */
    }
    .emotion-separator:nth-child(8) { 
        animation-duration: 12s; 
        animation-direction: reverse; 
        color: #87CEEB; /* hope */
    }

    /* Header logo with 1:1 aspect ratio and emotion circles */
    .header-title-container {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 60px;
        height: 60px;
        border-radius: 12px;
        background: rgba(139, 115, 85, 0.1);
        border: 2px solid rgba(139, 115, 85, 0.2);
        backdrop-filter: blur(10px);
        transition: all 0.3s cubic-bezier(0.165, 0.84, 0.44, 1);
        box-shadow: 0 4px 12px rgba(139, 115, 85, 0.08);
    }
    
    .header-title-container:hover {
        background: rgba(139, 115, 85, 0.15);
        border-color: rgba(139, 115, 85, 0.3);
        transform: scale(1.05);
        box-shadow: 0 8px 25px rgba(139, 115, 85, 0.2);
    }
    
    .header-title {
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        font-weight: 700;
        color: #8B7355;
        position: relative;
        white-space: nowrap;
        direction: rtl;
        font-family: var(--main-font-family);
    }
    
    .logo-emotion-circle {
        display: inline-block;
        font-size: 10px;
        font-weight: bold;
        margin: 0 2px;
        animation: logoEmotionFloat 4s ease-in-out infinite;
        transform-origin: center;
        cursor: default;
        user-select: none;
    }
    
    .logo-emotion-circle.left {
        animation-delay: 0s;
        color: #FFD700;
    }
    
    .logo-emotion-circle.right {
        animation-delay: 2s;
        color: #FF69B4;
    }
    
    @keyframes logoEmotionFloat {
        0%, 100% { 
            transform: translateY(0px) rotate(0deg) scale(1); 
        }
        25% { 
            transform: translateY(-2px) rotate(90deg) scale(1.1); 
            color: #87CEEB; 
        }
        50% { 
            transform: translateY(0px) rotate(180deg) scale(1); 
            color: #FFA500; 
        }
        75% { 
            transform: translateY(2px) rotate(270deg) scale(1.1); 
            color: #DC143C; 
        }
    }
    
    /* Ensure static fallback is properly positioned */
    .live-viz-item .item-image-wrapper {
        position: relative !important;
    }
    
    .emotions-active .item-details-wrapper { display: block; text-align: center; color: #333; font-size: 12px; padding-top: 5px; }
    .emotions-active .item-details-wrapper .conversation-date { display: none; }
    #bottom-controls-container {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: #f7f9f3 !important;
        border-top: none !important;
        display: flex;
        flex-direction: row-reverse;
        align-items: center;
        padding: 0 40px;
        box-sizing: border-box;
        z-index: 1003;
        gap: 30px;
    }
    .timeline-track-wrapper { flex-grow: 1; height: 4px; background-color: #ddd; position: relative; border-radius: 2px; }
    .timeline-brush { position: absolute; height: 100%; background-color: #333; border-radius: 2px; cursor: grab; }
    .timeline-handle { position: absolute; top: 50%; transform: translateY(-50%); width: 10px; height: 20px; background-color: #333; border-radius: 2px; cursor: ew-resize; }
    .timeline-handle.left { left: -5px; }
    .timeline-handle.right { right: -5px; }
    .nav-slash-style { display: flex; align-items: center; gap: 0; }
    .nav-slash-style .slash-sep { color: #bbb; font-size: 1.5rem; margin: 0 10px; font-family: inherit; font-weight: 300; pointer-events: none; user-select: none; }
            .nav-slash-style .view-toggle-btn { background: none; border: none; font-size: 16px; font-family: inherit; font-weight: 400; color: #bbb; padding: 0 2px; cursor: pointer; transition: color 0.2s, font-weight 0.2s; }
        .nav-slash-style .view-toggle-btn.active { color: #111; font-weight: 400; }
        

        

        #hover-info-panel { 
    position: fixed; 
    bottom: 80px; 
    right: 40px; 
    background: #f7f9f3;
    border: 1px solid rgba(139, 115, 85, 0.2); 
    padding: 24px 28px; 
    z-index: 1010; 
    opacity: 0; 
    visibility: hidden; 
    transform: translateY(20px) scale(0.95) rotate(-1deg); 
    transition: all 0.3s cubic-bezier(0.165, 0.84, 0.44, 1);
    animation: tooltipPulse 2s ease-in-out infinite;
    animation-delay: 0.5s; 
    pointer-events: none;
    max-width: 600px;
    min-width: 480px;
    height: 180px;
    box-shadow: 0 20px 60px rgba(139, 115, 85, 0.15), 
                0 8px 32px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
    direction: rtl;
    font-family: var(--main-font-family);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
}

#hover-info-panel::before {
    content: '';
    position: absolute;
    bottom: -8px;
    right: 50px;
    width: 16px;
    height: 16px;
    background: #f7f9f3;
    border: 1px solid rgba(139, 115, 85, 0.2);
    border-top: none;
    border-left: none;
    transform: rotate(45deg);
    /* Removed border-radius for square arrow */
}

#hover-info-panel.visible { 
    opacity: 1; 
    visibility: visible; 
    transform: translateY(0) scale(1) rotate(0deg); 
    transition-delay: 0s, 0s, 0s;
    animation: none;
}

    
    @keyframes tooltipPulse {
        0%, 100% { 
            box-shadow: 0 20px 60px rgba(139, 115, 85, 0.15), 
                        0 8px 32px rgba(0, 0, 0, 0.08),
                        inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }
        50% { 
            box-shadow: 0 25px 70px rgba(139, 115, 85, 0.2), 
                        0 12px 40px rgba(0, 0, 0, 0.12),
                        inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }
    }
    .hover-info-title { 
        font-size: 20px; 
        font-weight: 700; 
        color: #222; 
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
        font-family: var(--main-font-family);
        letter-spacing: -0.3px;
        line-height: 1.3;
    }
    .hover-info-date { 
        font-size: 15px; 
        color: #8B7355; 
        margin-bottom: 12px;
        font-weight: 600;
        font-family: var(--main-font-family);
        letter-spacing: -0.2px;
        background: rgba(139, 115, 85, 0.08);
        padding: 6px 12px;
        border-radius: 8px;
        border: 1px solid rgba(139, 115, 85, 0.15);
        display: inline-block;
    }
    .hover-info-additional {
        font-size: 14px;
        color: #666;
        margin-bottom: 16px;
        padding: 12px 16px;
        background: rgba(255, 255, 255, 0.4);
        border-radius: 10px;
        border: 1px solid rgba(128, 128, 128, 0.12);
        font-family: var(--main-font-family);
        font-weight: 500;
        backdrop-filter: blur(4px);
    }
    .hover-info-tags { 
        display: flex; 
        gap: 8px; 
        flex-wrap: wrap;
        margin-bottom: 12px;
        padding: 4px 0;
    }
    .hover-info-tag { 
        background: linear-gradient(135deg, rgba(139, 115, 85, 0.1), rgba(139, 115, 85, 0.15)); 
        color: #8B7355; 
        padding: 6px 12px; 
        border-radius: 16px; 
        font-size: 13px;
        font-weight: 600;
        font-family: var(--main-font-family);
        border: 1px solid rgba(139, 115, 85, 0.2);
        box-shadow: 0 2px 6px rgba(139, 115, 85, 0.08);
        transition: all 0.2s ease;
        letter-spacing: -0.1px;
        display: inline-flex;
        align-items: center;
        gap: 4px;
    }
    
    .hover-info-tag:hover {
        background: linear-gradient(135deg, rgba(139, 115, 85, 0.15), rgba(139, 115, 85, 0.2));
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(139, 115, 85, 0.15);
        border-color: rgba(139, 115, 85, 0.3);
    }
    .hover-info-metadata-tags {
        font-size: 13px;
        color: #888;
        margin-top: 12px;
        padding: 10px 14px;
        background: rgba(139, 115, 85, 0.05);
        border-radius: 8px;
        border: 1px solid rgba(139, 115, 85, 0.1);
        font-family: var(--main-font-family);
        font-weight: 500;
        font-style: normal;
        letter-spacing: -0.1px;
    }
    .timeline-tooltip {
        position: absolute;
        bottom: 100%; /* Position above the track */
        transform: translateX(-50%);
        background-color: #333;
        color: #fff;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none; /* So it doesn't interfere with mouse events */
        display: none; /* Hidden by default */
        margin-bottom: 10px;
    }

    .handle-date-display {
        position: absolute;
        top: -25px; /* Position above the handle */
        font-size: 12px;
        color: #333;
        white-space: nowrap;
    }
    .handle-date-display.left { left: 0; }
    .handle-date-display.right { right: 0; }
    
    /* Performance and Loading Indicators */
    .loading-indicator {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        text-align: center;
        z-index: 1000;
        display: none;
        font-family: var(--main-font-family);
    }
    
    .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #8B7355;
        border-radius: 50%;
        animation: spin-loader 1s linear infinite;
        margin: 0 auto 15px;
    }
    
    @keyframes spin-loader {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .audio-prompt {
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(139, 115, 85, 0.9);
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        z-index: 1000;
        cursor: pointer;
        transition: all 0.3s ease;
        display: none;
        font-family: var(--main-font-family);
        font-size: 14px;
        border: none;
    }
    
    .audio-prompt:hover {
        background: rgba(139, 115, 85, 1);
        transform: scale(1.05);
    }
    
    /* Re-transcription Floating Panel */
    .retranscribe-panel {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.9);
        background: rgba(255, 255, 255, 0.98);
        border: 2px solid #ddd;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        z-index: 3000;
        display: none;
        width: 90%;
        max-width: 700px;
        max-height: 80vh;
        overflow-y: auto;
        font-family: var(--main-font-family);
        backdrop-filter: blur(20px);
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .retranscribe-panel.visible {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    
    .retranscribe-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 18px 18px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 18px;
        font-weight: 600;
    }
    
    .retranscribe-content {
        padding: 30px;
    }
    
    .retranscribe-options h3 {
        margin: 0 0 20px 0;
        color: #333;
        text-align: center;
        font-size: 20px;
    }
    
    .analysis-option {
        margin-bottom: 30px;
        border: 2px solid #f0f0f0;
        border-radius: 15px;
        padding: 20px;
        background: #fafafa;
    }
    
    .option-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 10px;
    }
    
    .option-icon {
        font-size: 24px;
    }
    
    .option-title {
        font-size: 18px;
        font-weight: 600;
        color: #333;
    }
    
    .option-description {
        color: #666;
        margin: 0 0 15px 36px;
        font-size: 14px;
    }
    
    .conversation-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 15px;
        margin-top: 15px;
    }
    
    .convo-option {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 15px 20px;
        background: white;
        border: 2px solid #e0e0e0;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: inherit;
        text-align: right;
    }
    
    .convo-option:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        border-color: #667eea;
    }
    
    .convo-option.quick-analysis {
        border-left: 5px solid #4CAF50;
    }
    
    .convo-option.quick-analysis:hover {
        border-color: #4CAF50;
        background: #f8fff8;
    }
    
    .convo-option.full-reprocess {
        border-left: 5px solid #FF9800;
    }
    
    .convo-option.full-reprocess:hover {
        border-color: #FF9800;
        background: #fffaf0;
    }
    
    .convo-icon {
        font-size: 28px;
        flex-shrink: 0;
    }
    
    .convo-details {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        flex: 1;
    }
    
    .convo-name {
        font-weight: 600;
        font-size: 16px;
        color: #333;
    }
    
    .convo-count {
        font-size: 13px;
        color: #666;
        margin-top: 2px;
    }
    
    .close-btn {
        background: rgba(255,255,255,0.2);
        border: 1px solid rgba(255,255,255,0.3);
        color: white;
        border-radius: 50%;
        width: 35px;
        height: 35px;
        cursor: pointer;
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
    }
    
    .close-btn:hover {
        background: rgba(255,255,255,0.3);
        transform: scale(1.1);
    }
    
    /* Preview Canvas Styles */
    .conversation-preview-canvas {
        background: #f7f9f3;
        border-radius: 0;
    }
    
    .preview-canvas {
        transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .conversation-grid-item-container:hover .preview-canvas {
        transform: none; /* No scaling on hover */
        box-shadow: none;
    }
    
    .mini-spinner {
        width: 20px;
        height: 20px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #8B7355;
        border-radius: 50%;
        animation: spin-loader 1s linear infinite;
    }
    
    .preview-loading {
        background: rgba(247, 249, 243, 0.9);
        padding: 10px;
        border-radius: 0;
    }
    
    /* Hover effect for preview */
    .conversation-grid-item-container:hover .conversation-preview-canvas {
        box-shadow: none;
        background: transparent; /* Ensure no background color change */
    }
    

    /* Preview Video Styles */
    .preview-video {
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        cursor: pointer;
    }
    
    .conversation-grid-item-container:hover .preview-video {
        transform: none; /* No scaling on hover */
        box-shadow: none; /* No shadow on hover */
    }
    
    .fallback-canvas {
        display: none;
    }



    /* Playground Mode Styles */
    #playground-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f7f9f3;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    #playground-canvas-container {
        position: relative;
        width: 80%;
        max-width: 1200px;
        height: 60%;
        background: #f7f9f3;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        overflow: hidden;
        border: 2px solid #e0e0e0;
    }

    #playground-canvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #playground-controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 15px;
        align-items: center;
        background: rgba(255, 255, 255, 0.9);
        padding: 15px 25px;
        border-radius: 50px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        backdrop-filter: blur(10px);
    }

    .playground-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s ease;
        font-family: var(--main-font-family);
    }

    .playground-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }

    .playground-btn:active {
        transform: translateY(0);
    }

    .playground-btn.recording {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        animation: pulse-recording 2s infinite;
    }

    @keyframes pulse-recording {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .mic-status {
        font-size: 14px;
        color: #666;
        font-weight: 500;
        font-family: var(--main-font-family);
    }

    .mic-status.active {
        color: #27ae60;
        font-weight: 600;
    }

    .audio-level-display {
        font-size: 12px;
        color: #888;
        font-family: var(--main-font-family);
        min-width: 80px;
        text-align: center;
    }

    .audio-level-display.active {
        color: #3498db;
        font-weight: 600;
    }

    /* Playground Navigation Button Styles */
    .playground-nav-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
        color: white !important;
        border: none !important;
        cursor: pointer;
        transition: all 0.3s ease;
        text-decoration: none !important;
        padding: 8px 16px !important;
        border-radius: 20px !important;
        font-size: 14px !important;
        font-weight: 600 !important;
        margin-right: 10px !important;
    }

    .playground-nav-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%) !important;
        color: white !important;
        border-bottom: 2px solid transparent !important;
    }

    .playground-nav-btn.active {
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%) !important;
        color: white !important;
        border-bottom: 2px solid transparent !important;
    }

    /* ENHANCED ISOTOPE-STYLE ANIMATED TRANSITIONS BETWEEN VIEWS */
    .conversation-grid-item-container {
        /* OPTIMIZED transition for smooth view switching */
        transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1) !important;
        /* Smooth 3D morphing between layouts */
        transform-style: preserve-3d !important;
        will-change: transform, left, top, width, height, opacity !important;
        /* Enhanced visual effects during transitions */
        backface-visibility: hidden !important;
        perspective: 1000px !important;
    }
    
    /* Enhanced transition states for view switching */
    .conversation-grid-item-container.transitioning {
        /* Smooth morphing animation */
        transition: left 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   top 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   width 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   height 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   transform 1.5s cubic-bezier(0.23, 1, 0.32, 1),
                   opacity 1.0s cubic-bezier(0.23, 1, 0.32, 1) !important;
        /* 3D transformation effects */
        transform-origin: center center !important;
        transform-style: preserve-3d !important;
        /* Smooth opacity transition */
        opacity: 1 !important;
    }
    
    /* Staggered animation delays for isotope effect */
    .conversation-grid-item-container:nth-child(1) { animation-delay: 0.0s !important; }
    .conversation-grid-item-container:nth-child(2) { animation-delay: 0.1s !important; }
    .conversation-grid-item-container:nth-child(3) { animation-delay: 0.2s !important; }
    .conversation-grid-item-container:nth-child(4) { animation-delay: 0.3s !important; }
    .conversation-grid-item-container:nth-child(5) { animation-delay: 0.4s !important; }
    .conversation-grid-item-container:nth-child(6) { animation-delay: 0.5s !important; }
    .conversation-grid-item-container:nth-child(7) { animation-delay: 0.6s !important; }
    .conversation-grid-item-container:nth-child(8) { animation-delay: 0.7s !important; }
    .conversation-grid-item-container:nth-child(9) { animation-delay: 0.8s !important; }
    .conversation-grid-item-container:nth-child(10) { animation-delay: 0.9s !important; }
    .conversation-grid-item-container:nth-child(11) { animation-delay: 1.0s !important; }
    .conversation-grid-item-container:nth-child(12) { animation-delay: 1.1s !important; }
    .conversation-grid-item-container:nth-child(13) { animation-delay: 1.2s !important; }
    
    .layout-timeline .conversation-grid-item-container {
  /* Use CSS custom property for size */
  width: var(--timeline-item-size, 150px) !important;
  height: var(--timeline-item-size, 150px) !important;
  min-width: 100px !important;
  min-height: 100px !important;
  max-width: 200px !important;
  max-height: 200px !important;
  flex: 0 0 auto; /* Don't grow/shrink, auto basis */
  box-sizing: border-box;
  /* Maintain aspect ratio */
  aspect-ratio: 1 / 1;
  /* Smooth transitions */
  transition: transform 0.3s, opacity 0.3s, width 0.3s, height 0.3s;
  /* Remove absolute positioning for flexbox */
  position: relative !important;
  /* Ensure proper spacing */
  margin: 0 !important;
}

    
    /* People view - OPTIMIZED transitions */
    .layout-people .conversation-grid-item-container {
        /* Fast, smooth positioning transitions */
        transition: left 0.6s cubic-bezier(0.23, 1, 0.32, 1), 
                   top 0.6s cubic-bezier(0.23, 1, 0.32, 1),
                   width 0.6s cubic-bezier(0.23, 1, 0.32, 1),
                   height 0.6s cubic-bezier(0.23, 1, 0.32, 1),
                   transform 0.3s cubic-bezier(0.23, 1, 0.32, 1),
                   opacity 0.4s cubic-bezier(0.23, 1, 0.32, 1) !important;
        /* Reduced staggered animation delay */
        animation-delay: calc(var(--item-index, 0) * 0.02s) !important;
    }
    
    /* OPTIMIZED container transitions */
    #timeline-axes-container {
        transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1) !important;
    }
    
    #layout-canvas {
        transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1) !important;
    }
    
    /* Enhanced isotope view switching animation */
    .layout-timeline #layout-canvas {
        transform-origin: center center !important;
        transition: transform 0.8s cubic-bezier(0.23, 1, 0.32, 1) !important;
        /* Flexbox layout for horizontal distribution */
        display: flex !important;
        justify-content: space-between !important;
        align-items: center !important;
        flex-direction: row !important;
        padding: 20px !important;
        box-sizing: border-box !important;
    }
    
    .layout-people #layout-canvas {
        transform-origin: center bottom !important;
        transition: transform 0.8s cubic-bezier(0.23, 1, 0.32, 1) !important;
    }
    
    /* Isotope-style entrance animations */
    @keyframes isotopeEnter {
        0% {
            opacity: 0;
            transform: scale(0.6) rotateY(180deg);
        }
        50% {
            opacity: 0.8;
            transform: scale(1.1) rotateY(90deg);
        }
        100% {
            opacity: 1;
            transform: scale(1) rotateY(0deg);
        }
    }
    
    /* Isotope-style exit animations */
    @keyframes isotopeExit {
        0% {
            opacity: 1;
            transform: scale(1) rotateY(0deg);
        }
        50% {
            opacity: 0.3;
            transform: scale(0.8) rotateY(-90deg);
        }
        100% {
            opacity: 0;
            transform: scale(0.4) rotateY(-180deg);
        }
    }
    
    /* Apply isotope animations during view transitions */
    .isotope-transitioning .conversation-grid-item-container {
        animation: isotopeEnter 1.2s cubic-bezier(0.23, 1, 0.32, 1) forwards !important;
    }

    /* Live Visualization Styles - Minimalistic & Clean */
    #live-visualization-container {
        position: fixed;
        top: 60px;
        left: 0;
        right: 0;
        bottom: 60px;
        background: #f7f9f3;
        background-image: linear-gradient(to right, rgba(128, 128, 128, 0.08) 1px, transparent 1px), 
                          linear-gradient(to bottom, rgba(128, 128, 128, 0.08) 1px, transparent 1px);
        background-size: 100px 100px;
        z-index: 1000;
        overflow: hidden;
        display: none;
        flex-direction: column;
    }

    #live-viz-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
    }

    /* Minimalistic Header */
    #live-viz-header {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 50px;
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(8px);
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 25px;
        z-index: 1001;
        transition: all 0.3s ease;
    }

    .live-viz-title {
        display: flex;
        align-items: center;
        gap: 10px;
        direction: rtl;
    }

    .live-viz-icon {
        font-size: 20px;
        opacity: 0.8;
    }

    .live-viz-title h1 {
        font-size: 18px;
        font-weight: 500;
        color: #333;
        margin: 0;
        font-family: '80-kb-Sharp', Arial, sans-serif;
    }

    .live-viz-subtitle {
        font-size: 12px;
        color: #888;
        font-weight: 400;
        margin-right: 8px;
        opacity: 0.8;
    }

    /* Minimalistic Controls */
    .live-viz-controls {
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .live-control-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 20px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: '80-kb-Sharp', Arial, sans-serif;
        display: flex;
        align-items: center;
        gap: 6px;
        min-width: auto;
    }

    .live-control-btn.primary {
        background: #4CAF50;
        color: white;
        box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);
    }

    .live-control-btn.primary:hover {
        background: #45a049;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
    }

    .live-control-btn.secondary {
        background: #f44336;
        color: white;
        box-shadow: 0 2px 8px rgba(244, 67, 54, 0.2);
    }

    .live-control-btn.secondary:hover {
        background: #d32f2f;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(244, 67, 54, 0.3);
    }

    .live-control-btn.close {
        background: transparent;
        color: #999;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        padding: 0;
        font-size: 16px;
        justify-content: center;
        border: 1px solid rgba(0, 0, 0, 0.1);
    }

    .live-control-btn.close:hover {
        background: rgba(0, 0, 0, 0.05);
        color: #666;
        transform: scale(1.05);
    }

    /* Canvas Container */
    #live-canvas-container {
        position: absolute;
        top: 50px;
        left: 0;
        right: 0;
        bottom: 80px;
        background: #f7f9f3;
        background-image: linear-gradient(to right, rgba(128, 128, 128, 0.08) 1px, transparent 1px), 
                          linear-gradient(to bottom, rgba(128, 128, 128, 0.08) 1px, transparent 1px);
        background-size: 100px 100px;
        background-attachment: fixed;
        overflow: hidden;
    }

    /* Minimalistic Status Panel */
    #live-status-panel {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 80px;
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(8px);
        border-top: 1px solid rgba(0, 0, 0, 0.05);
        padding: 15px 25px;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1001;
    }

    .status-section {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 25px;
        width: 100%;
        max-width: 800px;
    }

    .status-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        text-align: center;
    }

    .status-label {
        font-size: 11px;
        font-weight: 500;
        color: #888;
        font-family: '80-kb-Sharp', Arial, sans-serif;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .status-value {
        font-size: 14px;
        font-weight: 600;
        color: #333;
        padding: 4px 8px;
        background: rgba(0, 0, 0, 0.03);
        border-radius: 8px;
        min-width: 50px;
        font-family: '80-kb-Sharp', Arial, sans-serif;
        transition: all 0.2s ease;
    }

    .status-value.active {
        background: #4CAF50;
        color: white;
    }

    .status-value.recording {
        background: #f44336;
        color: white;
        animation: pulse-glow 2s infinite;
    }

    .status-value.emotion-display {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
    }

    /* Subtle Animations */
    @keyframes pulse-glow {
        0%, 100% { 
            opacity: 1; 
            box-shadow: 0 0 0 rgba(244, 67, 54, 0.3);
        }
        50% { 
            opacity: 0.8; 
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.4);
        }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
        .status-section {
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }
        
        .status-item:nth-child(n+4) {
            display: none;
        }
        
        #live-viz-header {
            padding: 0 15px;
        }
        
        .live-viz-title h1 {
            font-size: 16px;
        }
        
        .live-viz-subtitle {
            display: none;
        }
    }
  </style>
</head>

<body>

  <div id="header-container"></div>
  <script src="components/header.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
        // Wait for header.js to load before calling renderHeader
        if (typeof renderHeader === 'function') {
            renderHeader('index.html');
        } else {
            // Fallback: wait a bit more for the script to load
            setTimeout(() => {
                if (typeof renderHeader === 'function') {
                    renderHeader('index.html');
                } else {
                    console.warn('renderHeader function not found, header.js may not have loaded properly');
                }
            }, 100);
        }
    });
  </script>

  <script>
    // Dynamic conversation data - loaded from auto-generated configuration
    let conversationDataGlobal = [];
    window.originalConversationData = [];
    
    // Load conversation configuration dynamically
    async function loadConversationConfig(isRefresh = false) {
        try {
            // Add cache-busting for refresh calls
            const cacheBuster = isRefresh ? `?t=${Date.now()}` : '';
            const response = await fetch(`config/conversations_config.json${cacheBuster}`);
            const config = await response.json();
            
            // Convert configuration to the format expected by the frontend - FILTER AND SORT
            const allConversationData = Object.entries(config.conversations)
                .map(([folder, data], index) => {
                    // Use enhanced metadata if available
                    const metadata = data.metadata || {};
                    
                    // Get display name - prioritize metadata name
                    const displayName = metadata.name || `◊©◊ô◊ó◊î ${data.number}`;
                    
                    // Get participants info - use metadata if available
                    const participants = metadata.participants?.length 
                        ? metadata.participants.join(', ') 
                        : displayName;
                    
                    // Get date - use metadata date if available
                    const conversationDate = metadata.date || '2024-06-26';
                    
                    // Get duration - use calculated duration if available
                    const duration = metadata.duration || `${Math.round(data.mp3_count * 0.5)} ◊ì◊ß◊ï◊™`;
                    
                    // Get emotions - use main emotions if available
                    const mainEmotions = metadata.mainEmotions?.length 
                        ? metadata.mainEmotions 
                        : ['◊†◊ô◊™◊ï◊ó ◊®◊í◊©◊ô'];
                    
                    // Create summary feelings from main emotions and word count
                    const emotionSummary = mainEmotions.join(', ');
                    const wordCount = metadata.totalWords ? ` | ${metadata.totalWords} ◊û◊ô◊ú◊ô◊ù` : '';
                    const summaryFeelings = `${emotionSummary}${wordCount}`;
                    
                    // Parse duration to get minutes (if in MM:SS format)
                    let durationMinutes = Math.round(data.mp3_count * 0.5);
                    if (metadata.duration && metadata.duration.includes(':')) {
                        const [minutes, seconds] = metadata.duration.split(':').map(Number);
                        durationMinutes = minutes + Math.round(seconds / 60);
                    }
                    
                    return {
                        id: `conv${data.number}`,
                        folder: folder,
                        date: conversationDate,
                        time: '12:00',
                        participants: participants,
                        summaryFeelings: summaryFeelings,
                        durationMinutes: durationMinutes,
                        emotionFile: data.ai_file || data.emotion_file,
                        mp3_count: data.mp3_count,
                        conversationNumber: data.number,
                        // Include metadata for advanced features
                        metadata: metadata,
                        displayName: displayName,
                        mainEmotions: mainEmotions,
                        isImportant: metadata.isImportant || false,
                        isPrivate: metadata.isPrivate || false,
                        needsReview: metadata.needsReview || false
                    };
                })
                .sort((a, b) => a.conversationNumber - b.conversationNumber);
            
            // FILTER OUT CONVERSATIONS WITH INSUFFICIENT CONTENT
            const newConversationData = allConversationData.filter(conv => {
                // Minimum requirements for display
                const hasEnoughContent = conv.mp3_count >= 3; // At least 3 MP3 files
                
                if (!hasEnoughContent) {
                    console.log(`‚ö†Ô∏è Filtering out ${conv.folder}: insufficient content (${conv.mp3_count} MP3s)`);
                    return false;
                }
                
                return true;
            });
            
            // Check if there are any changes (for refresh scenarios)
            const hasChanges = JSON.stringify(newConversationData) !== JSON.stringify(conversationDataGlobal);
            
                            if (hasChanges || !isRefresh) {
                conversationDataGlobal = newConversationData;
                window.originalConversationData = JSON.parse(JSON.stringify(conversationDataGlobal));
                
                // Enhanced logging to show filtered conversations
                const totalFromConfig = allConversationData.length;
                const displayedCount = conversationDataGlobal.length;
                const filteredOut = totalFromConfig - displayedCount;
                
                console.log(`üìä Conversation Filtering Results:`);
                console.log(`   üìÅ Total in config: ${totalFromConfig}`);
                console.log(`   ‚úÖ Displaying: ${displayedCount}`);
                console.log(`   üö´ Filtered out: ${filteredOut}`);
                console.log(`   üé¨ Displayed conversations: ${conversationDataGlobal.map(c => c.folder).join(', ')}`);
                
                if (isRefresh && hasChanges) {
                    console.log(`üîÑ Detected ${conversationDataGlobal.length} conversations (updated from admin changes)`);
                    
                    // Remove deleted conversation items from DOM
                    removeDeletedConversationItems();
                    
                    // Re-render the layout with updated data
                    if (typeof window.renderNewLayout === 'function') {
                        window.renderNewLayout(false);
                    }
                    
                    // Show notification about the change
                    showConversationUpdateNotification();
                } else {
                    console.log(`‚úÖ Loaded ${conversationDataGlobal.length} conversations dynamically`);
                }
            }
            
            return true;
        } catch (error) {
            console.error('‚ùå Failed to load conversation config, using fallback:', error);
            
            // Fallback to hardcoded data if config file doesn't exist - ONLY VALID CONVERSATIONS WITH VIDEOS
            conversationDataGlobal = [
                { id: 'conv1', folder: 'convo1', date: '2024-04-05', time: '11:00', participants: '◊©◊ô◊ó◊î 1', summaryFeelings: '◊©◊û◊ó◊î, ◊¢◊†◊ô◊ô◊ü', durationMinutes: 37, mp3_count: 73 },
                { id: 'conv2', folder: 'convo2', date: '2024-05-15', time: '16:00', participants: '◊©◊ô◊ó◊î 2', summaryFeelings: '◊†◊ô◊™◊ï◊ó, ◊°◊ß◊®◊†◊ï◊™', durationMinutes: 87, mp3_count: 174 },
                { id: 'conv3', folder: 'convo3', date: '2024-06-24', time: '21:10', participants: '◊©◊ô◊ó◊î 3', summaryFeelings: '◊©◊ô◊ó◊î ◊ß◊¶◊®◊î', durationMinutes: 2, mp3_count: 4 },
                { id: 'conv4', folder: 'convo4', date: '2024-07-01', time: '10:00', participants: '◊©◊ô◊ó◊î 4', summaryFeelings: '◊°◊ß◊®◊†◊ï◊™, ◊†◊ô◊™◊ï◊ó', durationMinutes: 10, mp3_count: 20 },
                { id: 'conv5', folder: 'convo5', date: '2024-07-10', time: '14:30', participants: '◊©◊ô◊ó◊î 5', summaryFeelings: '◊ì◊ô◊ï◊ü ◊û◊¢◊û◊ô◊ß', durationMinutes: 37, mp3_count: 73 },
                { id: 'conv6', folder: 'convo6', date: '2024-07-15', time: '09:15', participants: '◊©◊ô◊ó◊î 6', summaryFeelings: '◊©◊ô◊ó◊î ◊ê◊®◊ï◊õ◊î', durationMinutes: 52, mp3_count: 104 },
                { id: 'conv7', folder: 'convo7', date: '2024-07-20', time: '16:45', participants: '◊©◊ô◊ó◊î 7', summaryFeelings: '◊©◊ô◊ó◊î ◊ë◊ô◊†◊ï◊†◊ô◊™', durationMinutes: 35, mp3_count: 68 },
                { id: 'conv8', folder: 'convo8', date: '2024-07-25', time: '12:00', participants: '◊©◊ô◊ó◊î 8', summaryFeelings: '◊©◊ô◊ó◊î ◊ß◊¶◊®◊î', durationMinutes: 8, mp3_count: 14 },
                { id: 'conv10', folder: 'convo10', date: '2024-08-01', time: '13:30', participants: '◊§◊®◊ô◊ì◊î ◊û◊í◊ô◊ú◊ô◊ë◊®', summaryFeelings: '◊©◊ô◊ó◊î ◊ê◊®◊ï◊õ◊î', durationMinutes: 52, mp3_count: 104 },
                { id: 'conv12', folder: 'convo12', date: '2024-08-10', time: '16:30', participants: '◊û◊ß◊ú◊ô◊ò ◊ë◊ú◊ò◊ú◊§◊ï◊ü', summaryFeelings: '◊©◊ô◊ó◊î ◊ß◊¶◊®◊î', durationMinutes: 7, mp3_count: 14 },
                { id: 'conv13', folder: 'convo13', date: '2024-08-15', time: '18:00', participants: '◊û◊ß◊ú◊ô◊ò ◊ë◊ú◊ò◊ú◊§◊ï◊ü', summaryFeelings: '◊©◊ô◊ó◊î ◊ß◊¶◊®◊î', durationMinutes: 4, mp3_count: 8 },

            ];
            window.originalConversationData = JSON.parse(JSON.stringify(conversationDataGlobal));
            return false;
        }
    }
    
    // Helper function to remove deleted conversation items from DOM
    function removeDeletedConversationItems() {
        const layoutCanvas = document.getElementById('layout-canvas');
        if (!layoutCanvas) return;
        
        // Get list of current conversation folders
        const currentFolders = new Set(conversationDataGlobal.map(conv => conv.folder));
        
        // Find and remove conversation items that no longer exist
        const allConvItems = layoutCanvas.querySelectorAll('[id^="conv-item-"]');
        allConvItems.forEach(item => {
            const convId = item.id.replace('conv-item-', '');
            const convData = conversationDataGlobal.find(c => c.id === convId);
            
            if (!convData) {
                console.log(`üóëÔ∏è Removing deleted conversation item: ${convId}`);
                item.remove();
            }
        });
    }
    
    // Show notification when conversations are updated
    function showConversationUpdateNotification() {
        // Create or show notification
        let notification = document.getElementById('conversation-update-notification');
        if (!notification) {
            notification = document.createElement('div');
            notification.id = 'conversation-update-notification';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #4CAF50, #45a049);
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 10000;
                font-size: 14px;
                max-width: 300px;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
                direction: rtl;
            `;
            document.body.appendChild(notification);
        }
        
        notification.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 18px;">‚úÖ</span>
                <span>◊î◊©◊ô◊ó◊ï◊™ ◊¢◊ï◊ì◊õ◊†◊ï ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™</span>
            </div>
            <div style="font-size: 12px; margin-top: 5px; opacity: 0.9;">
                ◊©◊ô◊†◊ï◊ô◊ô◊ù ◊û◊î◊§◊ê◊†◊ú ◊î◊†◊ô◊î◊ï◊ú ◊°◊ï◊†◊õ◊®◊†◊ï
            </div>
        `;
        
        // Show notification
        setTimeout(() => {
            notification.style.opacity = '1';
            notification.style.transform = 'translateX(0)';
        }, 100);
        
        // Hide notification after 3 seconds
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    
    // Periodic refresh to check for admin panel changes
    let refreshInterval;
    function startConversationSync() {
        // Check for changes every 60 seconds instead of 10 to reduce load
        refreshInterval = setInterval(async () => {
            try {
                await loadConversationConfig(true);
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to sync conversations:', error);
            }
        }, 60000); // 60 seconds (was 10 seconds)
    }
    
    function stopConversationSync() {
        if (refreshInterval) {
            clearInterval(refreshInterval);
            refreshInterval = null;
        }
    }
    
    // Manual refresh function (can be called from admin panel)
    window.refreshConversations = async function() {
        console.log('üîÑ Manual conversation refresh requested');
        await loadConversationConfig(true);
    };
    
    window.populateConversationGrid = async function() {
        // Skip conversation loading if in lab mode
        if (window.isLabMode || window.skipConversationLoading) {
            console.log('üß™ Skipping conversation loading - Lab mode active');
            return;
        }
        
        // Load configuration first if not already loaded
        if (conversationDataGlobal.length === 0) {
            await loadConversationConfig();
        }
        
        // Populate re-transcription options dynamically
        populateRetranscriptionOptions();
        
        if (typeof window.renderNewLayout === 'function') {
             window.renderNewLayout(true);
        }
        
        // Start automatic synchronization
        startConversationSync();
        
        // Set up BroadcastChannel for cross-tab communication
        setupCrossTabSync();
    };
    
    // Set up cross-tab communication with admin panel
    function setupCrossTabSync() {
        if (typeof BroadcastChannel !== 'undefined') {
            const channel = new BroadcastChannel('conversation-sync');
            
            channel.addEventListener('message', async (event) => {
                const { type, folder, timestamp } = event.data;
                
                if (type === 'conversation-deleted') {
                    console.log(`üìª Received deletion broadcast for ${folder}`);
                    // Immediately refresh to sync changes
                    setTimeout(async () => {
                        await loadConversationConfig(true);
                    }, 1000);
                } else if (type === 'refresh-conversations') {
                    console.log(`üìª Received refresh broadcast from admin panel`);
                    setTimeout(async () => {
                        await loadConversationConfig(true);
                    }, 500);
                }
            });
            
            console.log('üìª BroadcastChannel setup complete for conversation sync');
            
            // Clean up on page unload
            window.addEventListener('beforeunload', () => {
                channel.close();
            });
        }
    }
    
    // Function to populate re-transcription options dynamically
    function populateRetranscriptionOptions() {
        const quickAnalysisContainer = document.getElementById('quick-analysis-options');
        const fullReprocessContainer = document.getElementById('full-reprocess-options');
        
        if (!quickAnalysisContainer || !fullReprocessContainer) return;
        
        // Clear existing content
        quickAnalysisContainer.innerHTML = '';
        fullReprocessContainer.innerHTML = '';
        
        // Generate options for each conversation
        conversationDataGlobal.forEach(conv => {
            // Quick analysis option
            const quickButton = document.createElement('button');
            quickButton.className = 'convo-option quick-analysis';
            quickButton.onclick = () => retranscribeConversation(conv.folder, false);
            quickButton.innerHTML = `
                <span class="convo-icon">üéµ</span>
                <span class="convo-details">
                    <span class="convo-name">${conv.participants}</span>
                    <span class="convo-count">${conv.mp3_count || 'N/A'} ◊ß◊ò◊¢◊ô◊ù</span>
                </span>
            `;
            quickAnalysisContainer.appendChild(quickButton);
            
            // Full reprocess option
            const fullButton = document.createElement('button');
            fullButton.className = 'convo-option full-reprocess';
            fullButton.onclick = () => reprocessMP3Files(conv.folder);
            fullButton.innerHTML = `
                <span class="convo-icon">üîä</span>
                <span class="convo-details">
                    <span class="convo-name">${conv.participants} - ◊™◊û◊ú◊ï◊ú ◊û◊ú◊ê</span>
                    <span class="convo-count">${conv.mp3_count || 'N/A'} ◊ß◊ë◊¶◊ô MP3</span>
                </span>
            `;
            fullReprocessContainer.appendChild(fullButton);
        });
    }
  </script>

  <div id="splash-screen">
    <div id="splash-logo">◊ê◊†◊ô◊û◊ò◊ô◊ß◊°</div>
    <div id="splash-message"></div>
  </div>

  <!-- Main Navigation Header -->
  <header class="app-header">
    <div class="header-title-container">
      <div class="header-title">
        <span class="header-logo">üé≠</span>
        <span>◊ê◊†◊ô◊û◊ò◊ô◊ß◊°</span>
      </div>
    </div>
    
    <nav class="header-nav">
      <a href="#" class="nav-link active-nav" onclick="showConversationsPage(); return false;">◊©◊ô◊ó◊ï◊™</a>
      <a href="#" class="nav-link" onclick="openLiveVisualization(); return false;">◊ï◊ô◊ñ◊ï◊ê◊ú◊ô◊ñ◊¶◊ô◊î ◊ó◊ô◊î</a>
      <a href="admin_panel.html" class="nav-link" target="_blank">◊†◊ô◊î◊ï◊ú</a>
      <a href="video_manager.html" class="nav-link" target="_blank">◊ï◊ô◊ì◊ê◊ï</a>
    </nav>
  </header>

    <div id="timeline-grid-wrapper">
        <div id="timeline-axes-container" class="layout-timeline">
            <div id="layout-canvas"></div>
        </div>
    </div>
    
    <div id="bottom-controls-container">
        <div class="view-toggle-buttons nav-slash-style">
            <button id="timeline-view-btn" class="view-toggle-btn active">◊¶◊ô◊® ◊ñ◊û◊ü</button>
            <span class="emotion-separator">‚óè</span>
            <button id="people-view-btn" class="view-toggle-btn">◊ê◊†◊©◊ô◊ù</button>
            <span class="emotion-separator">‚óâ</span>
            <button id="emotions-view-btn" class="view-toggle-btn">◊®◊í◊©◊ï◊™</button>
        </div>
        

        <div class="timeline-track-wrapper">
            <div class="timeline-brush">
                <div class="handle-date-display left"></div>
                <div class="timeline-handle left"></div>
                <div class="handle-date-display right"></div>
                <div class="timeline-handle right"></div>
            </div>
            <div class="timeline-tooltip"></div>
        </div>
    </div>

    <!-- Playground Mode Container -->
    <div id="playground-container" style="display: none;">
        <div id="playground-canvas-container">
            <canvas id="playground-canvas"></canvas>
        </div>
        <div id="playground-controls">
            <button id="mic-toggle-btn" class="playground-btn">üé§ ◊î◊§◊¢◊ú ◊û◊ô◊ß◊®◊ï◊§◊ï◊ü</button>
            <button id="mic-stop-btn" class="playground-btn" style="display: none;">üõë ◊¢◊¶◊ï◊® ◊û◊ô◊ß◊®◊ï◊§◊ï◊ü</button>
            <div id="mic-status" class="mic-status">◊û◊ô◊ß◊®◊ï◊§◊ï◊ü ◊õ◊ë◊ï◊ô</div>
            <div id="audio-level-display" class="audio-level-display">◊®◊û◊™ ◊©◊û◊¢: 0%</div>
        </div>
    </div>

    <!-- Live Visualization Container -->
    <div id="live-visualization-container" style="display: none;">
        <div id="live-viz-wrapper">
            <!-- Header -->
            <div id="live-viz-header">
                <div class="live-viz-title">
                    <span class="live-viz-icon">üé¨</span>
                    <div>
                        <h1◊ï◊ê◊ú◊ô◊ñ◊¶◊ô◊î ◊ó◊ô◊î>◊ï◊ô◊ñ</h1>
                        <div class="live-viz-subtitle">◊î◊ß◊ú◊ò◊î ◊ë◊ñ◊û◊ü ◊ê◊û◊™ ◊û◊î◊û◊ô◊ß◊®◊ï◊§◊ï◊ü</div>
                    </div>
                </div>
                
                <div class="live-viz-controls">
                    <button id="live-start-btn" class="live-control-btn primary">
                        üé§ ◊î◊™◊ó◊ú ◊î◊ß◊ú◊ò◊î
                    </button>
                    <button id="live-stop-btn" class="live-control-btn secondary" style="display: none;">
                        üõë ◊¢◊¶◊ï◊® ◊î◊ß◊ú◊ò◊î
                    </button>
                    <button id="close-live-viz-btn" class="live-control-btn close" title="◊°◊í◊ï◊®">
                        ‚úï
                    </button>
                </div>
            </div>
            
            <!-- Canvas Container for p5.js -->
            <div id="live-canvas-container">
                <!-- p5.js canvas will be inserted here -->
            </div>
            
            <!-- Status Panel -->
            <div id="live-status-panel">
                <div class="status-section">
                    <div class="status-item">
                        <span class="status-label">üé§ ◊û◊ô◊ß◊®◊ï◊§◊ï◊ü</span>
                        <span id="live-mic-status" class="status-value">◊õ◊ë◊ï◊ô</span>
                    </div>
                    
                    <div class="status-item">
                        <span class="status-label">üìä ◊®◊û◊™ ◊©◊û◊¢</span>
                        <span id="live-audio-level" class="status-value">0%</span>
                    </div>
                    
                    <div class="status-item">
                        <span class="status-label">üë• ◊ì◊ï◊ë◊® ◊†◊ï◊õ◊ó◊ô</span>
                        <span id="live-current-speaker" class="status-value">◊ê◊ô◊ü</span>
                    </div>
                    
                    <div class="status-item">
                        <span class="status-label">üòä ◊®◊í◊©</span>
                        <span id="live-emotion-display" class="status-value emotion-display">◊†◊ô◊ô◊ò◊®◊ú◊ô</span>
                    </div>
                    
                    <div class="status-item">
                        <span class="status-label">‚ö° ◊¢◊ï◊¶◊û◊™ ◊®◊í◊©</span>
                        <span id="live-emotion-intensity" class="status-value">◊†◊û◊ï◊õ◊î</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Live Visualization Container -->
    <div id="live-visualization-container" style="display: none;">
        <div id="live-viz-wrapper">
            <!-- Live Visualization Header -->
            <div id="live-viz-header">
                <div class="live-viz-title">
                    <span class="live-viz-icon">üé¨</span>
                    <h1>◊ï◊ô◊ñ◊ï◊ê◊ú◊ô◊ñ◊¶◊ô◊î ◊ó◊ô◊î</h1>
                    <span class="live-viz-subtitle">◊î◊ß◊ú◊ò◊î ◊ï◊ô◊ñ◊ï◊ê◊ú◊ô◊ñ◊¶◊ô◊î ◊ë◊®◊í◊© ◊ñ◊û◊ü ◊ê◊û◊™</span>
                </div>
                <div class="live-viz-controls">
                    <button id="live-start-btn" class="live-control-btn primary">◊î◊™◊ó◊ú ◊î◊ß◊ú◊ò◊î</button>
                    <button id="live-stop-btn" class="live-control-btn secondary" style="display: none;">◊¢◊¶◊ï◊® ◊î◊ß◊ú◊ò◊î</button>
                    <button id="close-live-viz-btn" class="live-control-btn close">‚úï</button>
                </div>
            </div>
            
            <!-- Live Visualization Canvas Container -->
            <div id="live-canvas-container">
                <!-- Canvas will be inserted here by p5.js -->
            </div>
            
            <!-- Live Visualization Status Panel -->
            <div id="live-status-panel">
                <div class="status-section">
                    <div class="status-item">
                        <span class="status-label">◊°◊ò◊ò◊ï◊° ◊û◊ô◊ß◊®◊ï◊§◊ï◊ü:</span>
                        <span id="live-mic-status" class="status-value">◊õ◊ë◊ï◊ô</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">◊®◊û◊™ ◊©◊û◊¢:</span>
                        <span id="live-audio-level" class="status-value">0%</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">◊ì◊ï◊ë◊® ◊†◊ï◊õ◊ó◊ô:</span>
                        <span id="live-current-speaker" class="status-value">◊ê◊ô◊ü</span>
                    </div>
                </div>
                <div class="status-section">
                    <div class="status-item">
                        <span class="status-label">◊®◊í◊©:</span>
                        <span id="live-emotion-display" class="status-value emotion-display">◊†◊ô◊ô◊ò◊®◊ú◊ô</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">◊¢◊ï◊¶◊û◊™ ◊®◊í◊©:</span>
                        <span id="live-emotion-intensity" class="status-value">◊†◊û◊ï◊õ◊î</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="hover-info-panel"></div>
    <div id="visualization-modal-container"></div>
  
  <!-- Exit Tooltip -->
  <div id="exit-tooltip" class="exit-tooltip">◊ú◊ó◊• ◊õ◊ì◊ô ◊ú◊°◊í◊ï◊®</div>
    
    <!-- Audio Prompt removed -->
    
    <!-- Loading Indicator -->
    <div id="loading-indicator" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 8px; z-index: 5002;">
        <div id="loading-text">◊ò◊ï◊¢◊ü...</div>
        <div id="loading-details" style="font-size: 14px; margin-top: 10px;"></div>
    </div>

    <script>
            document.addEventListener('DOMContentLoaded', async () => {
        // STATIC BACKGROUND GRID: Create immediately and never remove
        createStaticBackgroundGrid();
        
        const splashScreen = document.getElementById('splash-screen');
        if (sessionStorage.getItem('splashShown') === 'true') {
            splashScreen.style.display = 'none';
            await window.populateConversationGrid();
        } else {
            setTimeout(async () => {
                splashScreen.classList.add('hidden');
                sessionStorage.setItem('splashShown', 'true');
                await window.populateConversationGrid();
            }, 1500);
        }
    });
    
    // STATIC BACKGROUND GRID: Simplified - uses body background only
    function createStaticBackgroundGrid() {
        // No longer create elements - body background handles everything
        console.log('‚úÖ Static background grid handled by body element - no additional elements needed');
        return null;
    }
    
    // ENSURE BACKGROUND GRID: Simplified - just verify body background is set
    function ensureStaticBackgroundGrid() {
        // Ensure body has the CSS variable set for grid size
        const currentGridSize = document.documentElement.style.getPropertyValue('--dynamic-grid-size');
        if (!currentGridSize) {
            document.documentElement.style.setProperty('--dynamic-grid-size', '100px');
        }
        
        console.log('‚úÖ Static background grid ensured via body element');
        return null;
    }
    
    // Grid size control function
    function updateGridSize(size) {
        const gridSize = size + 'px';
        document.documentElement.style.setProperty('--dynamic-grid-size', gridSize);
        const gridSizeElement = document.getElementById('grid-size-value');
        if (gridSizeElement) {
            gridSizeElement.textContent = gridSize;
        }
        console.log(`üîß Grid size updated to: ${gridSize}`);
    }
    
    // Debug function to check conversation visibility
    function debugConversationVisibility() {
        const layoutCanvas = document.getElementById('layout-canvas');
        const conversations = document.querySelectorAll('.conversation-grid-item-container');
        
        console.log('üîç DEBUG: Conversation Visibility Check');
        console.log('üìè Layout Canvas:', {
            element: layoutCanvas,
            exists: !!layoutCanvas,
            dimensions: layoutCanvas ? {
                width: layoutCanvas.offsetWidth,
                height: layoutCanvas.offsetHeight,
                clientWidth: layoutCanvas.clientWidth,
                clientHeight: layoutCanvas.clientHeight,
                scrollWidth: layoutCanvas.scrollWidth,
                scrollHeight: layoutCanvas.scrollHeight
            } : 'N/A',
            style: layoutCanvas ? {
                position: layoutCanvas.style.position,
                top: layoutCanvas.style.top,
                left: layoutCanvas.style.left,
                width: layoutCanvas.style.width,
                height: layoutCanvas.style.height,
                display: layoutCanvas.style.display,
                visibility: layoutCanvas.style.visibility
            } : 'N/A'
        });
        
        console.log('üé¨ Conversations Found:', conversations.length);
        conversations.forEach((conv, index) => {
            const rect = conv.getBoundingClientRect();
            console.log(`üìç ${conv.id}:`, {
                index: index,
                dimensions: {
                    width: conv.offsetWidth,
                    height: conv.offsetHeight,
                    clientWidth: conv.clientWidth,
                    clientHeight: conv.clientHeight
                },
                position: {
                    left: conv.style.left,
                    top: conv.style.top,
                    position: conv.style.position
                },
                visibility: {
                    display: conv.style.display,
                    visibility: conv.style.visibility,
                    opacity: conv.style.opacity,
                    zIndex: conv.style.zIndex
                },
                boundingRect: {
                    left: Math.round(rect.left),
                    top: Math.round(rect.top),
                    width: Math.round(rect.width),
                    height: Math.round(rect.height),
                    visible: rect.width > 0 && rect.height > 0
                }
            });
        });
        
        return {
            layoutCanvas: !!layoutCanvas,
            conversationCount: conversations.length,
            visibleConversations: Array.from(conversations).filter(conv => {
                const rect = conv.getBoundingClientRect();
                return rect.width > 0 && rect.height > 0;
            }).length
        };
    }
    
    // Make debug function available globally
    window.debugConversationVisibility = debugConversationVisibility;
    </script>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        // Message listener moved above to handle all iframe messages
        const modalContainer = document.getElementById('visualization-modal-container');
        if (modalContainer) {
            // Show tooltip on hover near edges
            modalContainer.addEventListener('mousemove', (event) => {
                if (event.target === modalContainer) {
                    const rect = modalContainer.getBoundingClientRect();
                    const edgeThreshold = 60; // pixels from edge
                    
                    // Check if mouse is near any edge
                    const nearEdge = event.clientX < edgeThreshold || 
                                   event.clientX > rect.width - edgeThreshold ||
                                   event.clientY < edgeThreshold ||
                                   event.clientY > rect.height - edgeThreshold;
                    
                    if (nearEdge) {
                        showExitTooltip();
                    } else {
                        hideExitTooltip();
                    }
                }
            });
            
            // Hide tooltip when leaving modal
            modalContainer.addEventListener('mouseleave', () => {
                hideExitTooltip();
            });
            
            // Close modal on click outside
            modalContainer.addEventListener('click', (event) => {
                if (event.target === modalContainer) {
                    closeVisualizationModal();
                }
            });
        }
        const viewButtons = document.querySelectorAll('.view-toggle-btn');
        viewButtons.forEach(button => {
            button.addEventListener('click', function() {
                viewButtons.forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                const layout = this.id.split('-')[0];
                console.log(`üé¨ ISOTOPE: User clicked ${layout} view button - triggering smooth animations`);
                if(typeof window.switchLayout === 'function') window.switchLayout(layout);
            });
        });
        
        // Initialize playground mode
        if (typeof initializePlaygroundMode === 'function') {
            initializePlaygroundMode();
        } else {
            console.log('‚ö†Ô∏è Playground mode not available');
        }
      });
    </script>
    

    
    <script>
    // --- UNIFIED CONTROLS SCRIPT ---
    document.addEventListener('DOMContentLoaded', () => {
        // --- Shared variables ---
        const panzoomContainer = document.getElementById('timeline-axes-container');
        const layoutCanvas = document.getElementById('layout-canvas');
        const timelineControls = document.getElementById('bottom-controls-container');

        window.MIN_ZOOM = 0.5;
        window.MAX_ZOOM = 4;
        window.ZOOM_STEP = 0.1;

        // --- Camera and Transform Logic (Shared by all controls) ---
        function updateTransform() {
            if(layoutCanvas) {
                // Pan is disabled. We only scale from the center (as defined in CSS).
                layoutCanvas.style.transform = `scale(${camera.zoom})`;
            }
        }

        // This is defined here so resetCamera can use it.
        let initializeTimeline;

        window.resetCamera = function() {
            camera.x = 0; // Stays 0
            camera.y = 0; // Stays 0
            camera.zoom = 1;
            updateTransform();
            if (typeof initializeTimeline === 'function') {
                initializeTimeline();
            }
        }

        // --- Mouse Wheel Zoom Logic ---
        function onWheel(e) {
            if (window.activeLayout === 'emotions' || window.activeLayout !== 'timeline') return;
            e.preventDefault();
            const zoomDirection = e.deltaY < 0 ? 'in' : 'out';
            zoom(zoomDirection);
        }

        function zoom(direction) {
            const oldZoom = camera.zoom;
            let newZoom = direction === 'in' ? Math.min(window.MAX_ZOOM, camera.zoom + window.ZOOM_STEP) : Math.max(window.MIN_ZOOM, camera.zoom - window.ZOOM_STEP);
            if (newZoom === oldZoom) return;
            
            camera.zoom = newZoom;
            updateTransform();
        }

        if (panzoomContainer) {
            panzoomContainer.addEventListener('wheel', onWheel, { passive: false });
        }
        
        // --- Timeline Brush Logic ---
        if (timelineControls) {
            const track = timelineControls.querySelector('.timeline-track-wrapper');
            const brush = timelineControls.querySelector('.timeline-brush');
            const handleLeft = brush.querySelector('.timeline-handle.left');
            const handleRight = brush.querySelector('.timeline-handle.right');
            const tooltip = document.querySelector('.timeline-tooltip');
            const dateDisplayLeft = brush.querySelector('.handle-date-display.left');
            const dateDisplayRight = brush.querySelector('.handle-date-display.right');

            let minDate, maxDate, totalDays;
            let isDragging = null;
            let startX, startBrushLeft, startBrushWidth;

            initializeTimeline = function() {
                const dates = window.originalConversationData.map(c => new Date(c.date).getTime());
                minDate = new Date(Math.min.apply(null, dates));
                maxDate = new Date(Math.max.apply(null, dates));
                totalDays = (maxDate - minDate) / (1000 * 60 * 60 * 24);
                brush.style.left = '0%';
                brush.style.width = '100%';
                updateDateDisplays();
            }

            function pctToDate(pct) {
                const date = new Date(minDate);
                date.setDate(date.getDate() + (totalDays * (pct / 100)));
                return date.toLocaleDateString('he-IL', { day: 'numeric', month: 'short' });
            }
            
            function updateDateDisplays() {
                const leftPct = parseFloat(brush.style.left);
                const widthPct = parseFloat(brush.style.width);
                dateDisplayLeft.textContent = pctToDate(leftPct);
                dateDisplayRight.textContent = pctToDate(leftPct + widthPct);
            }

            function updateMainViewFromBrush() {
                const brushWidthPct = parseFloat(brush.style.width) / 100;
                
                const layout = layoutPositions.timeline;
                if (!layout || Object.keys(layout).length === 0) return;
                
                const allX = Object.values(layout).filter(p => p.left !== undefined).map(p => p.left);
                if (allX.length === 0) return;

                const minX = Math.min(...allX);
                const maxX = Math.max(...allX) + 70;
                const totalContentWidth = maxX - minX;
                const viewWidth = totalContentWidth * brushWidthPct;
                const containerWidth = panzoomContainer.clientWidth;
                
                camera.zoom = Math.min(window.MAX_ZOOM, containerWidth / viewWidth * 0.9);
                
                // NO PANNING. camera.x is not changed.
                
                updateTransform();
            }

            function onDragStart(e, type) {
                if (window.activeLayout !== 'timeline') return;
                e.stopPropagation();
                isDragging = type;
                startX = e.clientX;
                startBrushLeft = brush.offsetLeft;
                startBrushWidth = brush.offsetWidth;
                document.body.style.cursor = 'ew-resize';
                window.addEventListener('mousemove', onDrag);
                window.addEventListener('mouseup', onDragEnd);
            }

            function onDrag(e) {
                if (!isDragging) return;
                const deltaX = e.clientX - startX;
                const trackWidth = track.offsetWidth;
                if (isDragging === 'left') {
                    const newLeft = Math.max(0, startBrushLeft + deltaX);
                    const newRight = startBrushLeft + startBrushWidth;
                    const newWidth = newRight - newLeft;
                    if (newWidth / trackWidth * 100 < 2) return;
                    brush.style.left = `${(newLeft / trackWidth) * 100}%`;
                    brush.style.width = `${(newWidth / trackWidth) * 100}%`;
                } else if (isDragging === 'right') {
                    const newWidth = Math.max(10, startBrushWidth + deltaX);
                    const newRight = startBrushLeft + newWidth;
                    if (newRight > trackWidth) return;
                    brush.style.width = `${(newWidth / trackWidth) * 100}%`;
                }
                // 'brush' dragging is disabled.
                updateDateDisplays();
                // This is called onDragEnd for a better UX
            }

            function onDragEnd() {
                isDragging = null;
                document.body.style.cursor = 'default';
                window.removeEventListener('mousemove', onDrag);
                window.removeEventListener('mouseup', onDragEnd);
                updateMainViewFromBrush(); // Update view after dragging is finished
            }

            track.addEventListener('mousemove', (e) => {
                if (isDragging) return;
                const trackRect = track.getBoundingClientRect();
                const x = e.clientX - trackRect.left;
                const pct = (x / track.offsetWidth) * 100;
                tooltip.style.left = `${x}px`;
                tooltip.textContent = pctToDate(pct);
                tooltip.style.display = 'block';
            });
            track.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });
            handleLeft.addEventListener('mousedown', (e) => onDragStart(e, 'left'));
            handleRight.addEventListener('mousedown', (e) => onDragStart(e, 'right'));
            // Event listener for dragging the whole brush is removed to prevent panning.
            
            setTimeout(initializeTimeline, 500);
        }

        // --- General page setup ---
        window.addEventListener('resize', () => {
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(() => {
                if (typeof window.switchLayout === 'function') {
                    window.switchLayout(window.activeLayout, true);
                }
            }, 250);
        });
    });
    </script>
    
    <!-- Live Visualization Script -->
    <script src="frontend/sketch-live.js"></script>

    <script>
    // Re-transcription panel functionality
    function toggleRetranscribePanel() {
        const panel = document.getElementById('retranscribe-panel');
        if (panel) {
            if (panel.style.display === 'none' || panel.style.display === '') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }
    }
    
    // Enhanced retranscription function with confirmation
    window.retranscribeConversation = async function(folder) {
        // Hide the panel first
        const panel = document.getElementById('retranscribe-panel');
        if (panel) {
            panel.classList.remove('visible');
            setTimeout(() => panel.style.display = 'none', 300);
        }
        
        // --- DYNAMICALLY FIND FILE PATH ---
        const convData = window.conversationDataGlobal.find(c => c.folder === folder);
        if (!convData || !convData.emotionFile) {
            alert(`◊©◊í◊ô◊ê◊î: ◊ú◊ê ◊†◊û◊¶◊ê ◊ß◊ï◊ë◊• ◊†◊ô◊™◊ï◊ó ◊¢◊ë◊ï◊® '${folder}'`);
            return;
        }
        const filePath = `conversations/${folder}/${convData.emotionFile}`;
        const segments = convData.mp3_count;
        const estimatedTime = Math.ceil(segments / 15); // More realistic estimate

        const confirmed = confirm(
            `üîÑ ◊™◊û◊ú◊ï◊ú ◊û◊ó◊ì◊© - ${folder}\n\n` +
            `üìä ◊ß◊ò◊¢◊ô◊ù: ${segments}\n` +
            `‚è±Ô∏è ◊ñ◊û◊ü ◊û◊©◊ï◊¢◊®: ${estimatedTime} ◊ì◊ß◊ï◊™\n\n` +
            `◊§◊¢◊ï◊ú◊î ◊ñ◊ï ◊™◊™◊û◊ú◊ú ◊û◊ó◊ì◊© ◊ê◊™ ◊î◊©◊û◊¢ ◊ë◊ê◊û◊¶◊¢◊ï◊™ Whisper ◊ï◊™◊®◊ô◊• ◊†◊ô◊™◊ï◊ó AI. ◊î◊ê◊ù ◊ú◊î◊™◊ó◊ô◊ú?`
        );
        
        if (!confirmed) return;
        
        // Show loading indicator
        const loadingIndicator = document.getElementById('loading-indicator');
        const loadingText = document.getElementById('loading-text');
        const loadingDetails = document.getElementById('loading-details');
        
        if (loadingIndicator) {
            loadingIndicator.style.display = 'block';
            if (loadingText) loadingText.textContent = `üîÑ ◊û◊™◊û◊ú◊ú ◊û◊ó◊ì◊© ${folder}...`;
            if (loadingDetails) loadingDetails.textContent = '◊û◊õ◊ô◊ü ◊ê◊™ ◊î◊†◊ô◊™◊ï◊ó ◊î◊û◊™◊ß◊ì◊ù';
        }
        
        try {
            const response = await fetch('/api/analyze', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    filePath: filePath,
                    useWhisper: true // Always use Whisper for re-analysis from this button
                })
            });
            
            if (!response.ok) {
                throw new Error(`◊©◊í◊ô◊ê◊™ ◊©◊®◊™: ${response.status}`);
            }
            
            const result = await response.json();
            
            if (loadingIndicator) {
                if (loadingText) loadingText.textContent = '‚úÖ ◊™◊û◊ú◊ï◊ú ◊î◊ï◊©◊ú◊ù ◊ë◊î◊¶◊ú◊ó◊î!';
                if (loadingDetails) loadingDetails.textContent = '◊û◊ï◊®◊ì ◊ß◊ï◊ë◊• ◊û◊¢◊ï◊ì◊õ◊ü...';
            }
            
            // Download the updated file
            const downloadUrl = `/api/download/${encodeURIComponent(result.output_file)}`;
            const downloadLink = document.createElement('a');
            downloadLink.href = downloadUrl;
            downloadLink.download = result.output_file.split('/').pop();
            downloadLink.click();
            
            setTimeout(() => {
                if (loadingIndicator) loadingIndicator.style.display = 'none';
                alert(`‚úÖ ◊™◊û◊ú◊ï◊ú ${folder} ◊î◊ï◊©◊ú◊ù ◊ë◊î◊¶◊ú◊ó◊î!\nüìÅ ◊î◊ß◊ï◊ë◊• ◊î◊û◊¢◊ï◊ì◊õ◊ü ◊î◊ï◊®◊ì ◊ú◊û◊ó◊©◊ë`);
            }, 1000);
            
        } catch (error) {
            console.error('◊©◊í◊ô◊ê◊î ◊ë◊™◊û◊ú◊ï◊ú:', error);
            if (loadingIndicator) loadingIndicator.style.display = 'none';
            alert(`‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊™◊û◊ú◊ï◊ú: ${error.message}`);
        }
    };

    // New function for full MP3 re-processing
    window.reprocessMP3Files = async function(folder) {
        // Hide the panel first
        const panel = document.getElementById('retranscribe-panel');
        if (panel) {
            panel.classList.remove('visible');
            setTimeout(() => panel.style.display = 'none', 300);
        }
        
        // --- DYNAMICALLY FIND FOLDER INFO ---
        const convData = window.conversationDataGlobal.find(c => c.folder === folder);
        if (!convData) {
            alert(`◊©◊í◊ô◊ê◊î: ◊™◊ô◊ß◊ô◊ô◊™ ◊©◊ô◊ó◊î ◊ú◊ê ◊†◊û◊¶◊ê◊î ◊¢◊ë◊ï◊® '${folder}'`);
            return;
        }
        
        const folderPath = `conversations/${folder}`;
        const mp3Count = convData.mp3_count;
        const estimatedTime = Math.ceil(mp3Count * 0.5); // 30 seconds per MP3 estimated

        const confirmed = confirm(
            `üé§ ◊™◊û◊ú◊ï◊ú ◊û◊ú◊ê ◊û◊ß◊ë◊¶◊ô MP3 - ${folder}\n\n` +
            `üîä ◊ß◊ë◊¶◊ô MP3: ${mp3Count}\n` +
            `‚è±Ô∏è ◊ñ◊û◊ü ◊û◊©◊ï◊¢◊®: ${estimatedTime} ◊ì◊ß◊ï◊™\n\n` +
            `◊§◊¢◊ï◊ú◊î ◊ñ◊ï ◊™◊™◊û◊ú◊ú ◊û◊ó◊ì◊© ◊ê◊™ ◊õ◊ú ◊ß◊ë◊¶◊ô ◊î-MP3 ◊ë◊ê◊û◊¶◊¢◊ï◊™ WhisperX. ◊î◊ê◊ù ◊ú◊î◊™◊ó◊ô◊ú?`
        );
        
        if (!confirmed) return;
        
        alert('◊û◊™◊û◊ú◊ú ◊û◊ß◊ë◊¶◊ô MP3...');
    };

    // Live Visualization Integration Functions
    let liveP5Instance = null;
    let isLiveVisualizationActive = false;

    // Function to show live visualization (called from navigation)
    window.openLiveVisualization = function() {
        console.log('üé¨ Opening Live Visualization in main app');
        
        // Hide main content
        const timelineWrapper = document.getElementById('timeline-grid-wrapper');
        const playgroundContainer = document.getElementById('playground-container');
        const bottomControls = document.getElementById('bottom-controls-container');
        
        if (timelineWrapper) timelineWrapper.style.display = 'none';
        if (playgroundContainer) playgroundContainer.style.display = 'none';
        if (bottomControls) bottomControls.style.display = 'none'; // Hide timeline and view controls
        
        // Show live visualization container
        const liveContainer = document.getElementById('live-visualization-container');
        if (liveContainer) {
            liveContainer.style.display = 'flex';
            isLiveVisualizationActive = true;
            
            // Initialize live visualization after a brief delay
            setTimeout(() => {
                initializeLiveVisualization();
            }, 100);
        }
    };

    // Function to close live visualization
    function closeLiveVisualization() {
        console.log('üö™ Closing Live Visualization');
        
        // Stop any active audio
        if (liveP5Instance && liveP5Instance.stopMicrophone) {
            liveP5Instance.stopMicrophone();
        }
        
        // Hide live visualization container
        const liveContainer = document.getElementById('live-visualization-container');
        if (liveContainer) {
            liveContainer.style.display = 'none';
            isLiveVisualizationActive = false;
        }
        
        // Show main content and restore all controls
        showConversationsPage();
    }

    // Page switching functions
    function showConversationsPage() {
        const timelineWrapper = document.getElementById('timeline-grid-wrapper');
        const playgroundContainer = document.getElementById('playground-container');
        const liveContainer = document.getElementById('live-visualization-container');
        const bottomControls = document.getElementById('bottom-controls-container');
        
        if (timelineWrapper) timelineWrapper.style.display = 'block';
        if (playgroundContainer) playgroundContainer.style.display = 'none';
        if (liveContainer) liveContainer.style.display = 'none';
        if (bottomControls) bottomControls.style.display = 'block'; // Show timeline and view controls
        
        isLiveVisualizationActive = false;
        
        console.log('üìÑ Switched to conversations page');
    }

    // Initialize live visualization p5 instance
    function initializeLiveVisualization() {
        if (liveP5Instance) {
            console.log('üé® Live visualization already initialized');
            return;
        }
        
        console.log('üé® Initializing live visualization p5 instance...');
        
        const canvasContainer = document.getElementById('live-canvas-container');
        if (!canvasContainer) {
            console.error('‚ùå Live canvas container not found');
            return;
        }
        
        try {
            // Create p5 instance for live visualization
            if (typeof p5SketchLiveFunction !== 'undefined') {
                liveP5Instance = new p5(p5SketchLiveFunction, 'live-canvas-container');
                
                // Set up control event listeners after a short delay
                setTimeout(() => {
                    setupLiveVisualizationControls();
                }, 500);
                
                console.log('‚úÖ Live visualization initialized successfully');
            } else {
                console.error('‚ùå p5SketchLiveFunction not found - sketch-live.js may not have loaded');
            }
        } catch (error) {
            console.error('‚ùå Failed to initialize live visualization:', error);
        }
    }

    // Set up live visualization controls
    function setupLiveVisualizationControls() {
        const startBtn = document.getElementById('live-start-btn');
        const stopBtn = document.getElementById('live-stop-btn');
        const closeBtn = document.getElementById('close-live-viz-btn');
        
        // Start recording button
        if (startBtn) {
            startBtn.addEventListener('click', () => {
                console.log('üé§ Starting live visualization...');
                
                if (liveP5Instance && liveP5Instance.startMicrophone) {
                    liveP5Instance.startMicrophone();
                    
                    // Update UI
                    startBtn.style.display = 'none';
                    if (stopBtn) stopBtn.style.display = 'block';
                    
                    updateLiveStatus('live-mic-status', '◊§◊¢◊ô◊ú', '#4CAF50');
                } else {
                    console.error('‚ùå Live visualization not ready');
                    updateLiveStatus('live-mic-status', '◊©◊í◊ô◊ê◊î', '#f44336');
                }
            });
        }
        
        // Stop recording button
        if (stopBtn) {
            stopBtn.addEventListener('click', () => {
                console.log('üõë Stopping live visualization...');
                
                if (liveP5Instance && liveP5Instance.stopMicrophone) {
                    liveP5Instance.stopMicrophone();
                    
                    // Update UI
                    stopBtn.style.display = 'none';
                    if (startBtn) startBtn.style.display = 'block';
                    
                    updateLiveStatus('live-mic-status', '◊õ◊ë◊ï◊ô', '#666');
                    updateLiveStatus('live-audio-level', '0%', '#666');
                    updateLiveStatus('live-current-speaker', '◊ê◊ô◊ü', '#666');
                    updateLiveStatus('live-emotion-display', '◊†◊ô◊ô◊ò◊®◊ú◊ô', '#667eea');
                    updateLiveStatus('live-emotion-intensity', '◊†◊û◊ï◊õ◊î', '#666');
                }
            });
        }
        
        // Close button
        if (closeBtn) {
            closeBtn.addEventListener('click', closeLiveVisualization);
        }
        
        // Set up status update listener
        setupLiveStatusUpdater();
    }

    // Helper function to update live status displays
    function updateLiveStatus(elementId, text, color = null) {
        const element = document.getElementById(elementId);
        if (element) {
            element.textContent = text;
            if (color && element.classList.contains('status-value')) {
                element.style.color = color;
            }
        }
    }

    // Set up automatic status updates from p5 instance
    function setupLiveStatusUpdater() {
        // Update status every 100ms while live visualization is active
        const statusUpdateInterval = setInterval(() => {
            if (!isLiveVisualizationActive || !liveP5Instance) {
                return;
            }
            
            // Get status from p5 instance if available
            if (liveP5Instance.getAudioLevel) {
                const audioLevel = Math.round(liveP5Instance.getAudioLevel() * 100);
                updateLiveStatus('live-audio-level', `${audioLevel}%`);
            }
            
            if (liveP5Instance.getCurrentSpeaker) {
                const speaker = liveP5Instance.getCurrentSpeaker();
                const speakerText = speaker === 0 ? '◊ì◊ï◊ë◊® 1' : speaker === 1 ? '◊ì◊ï◊ë◊® 2' : '◊ê◊ô◊ü';
                updateLiveStatus('live-current-speaker', speakerText);
            }
            
            if (liveP5Instance.getCurrentEmotion) {
                const emotion = liveP5Instance.getCurrentEmotion();
                const emotionText = getHebrewEmotionName(emotion);
                updateLiveStatus('live-emotion-display', emotionText);
            }
            
            if (liveP5Instance.getEmotionIntensity) {
                const intensity = liveP5Instance.getEmotionIntensity();
                const intensityText = intensity > 0.7 ? '◊í◊ë◊ï◊î◊î' : intensity > 0.4 ? '◊ë◊ô◊†◊ï◊†◊ô◊™' : '◊†◊û◊ï◊õ◊î';
                updateLiveStatus('live-emotion-intensity', intensityText);
            }
        }, 100);
        
        // Clean up interval when page unloads
        window.addEventListener('beforeunload', () => {
            clearInterval(statusUpdateInterval);
        });
    }

    // Helper function to translate emotions to Hebrew
    function getHebrewEmotionName(emotion) {
        const emotionMap = {
            'neutral': '◊†◊ô◊ô◊ò◊®◊ú◊ô',
            'curiosity': '◊°◊ß◊®◊†◊ï◊™',
            'happiness': '◊©◊û◊ó◊î',
            'excitement': '◊î◊™◊®◊í◊©◊ï◊™',
            'focus': '◊û◊ô◊ß◊ï◊ì',
            'energy': '◊ê◊†◊®◊í◊ô◊î',
            'joy': '◊©◊û◊ó◊î',
            'sadness': '◊¢◊¶◊ë',
            'anger': '◊õ◊¢◊°',
            'fear': '◊§◊ó◊ì',
            'surprise': '◊î◊§◊™◊¢◊î',
            'disgust': '◊í◊ï◊¢◊ú'
        };
        return emotionMap[emotion] || emotion;
    }

    // Listen for emotion color updates from admin panel via BroadcastChannel
    if (typeof BroadcastChannel !== 'undefined') {
        const emotionColorsChannel = new BroadcastChannel('emotion-colors-sync');
        emotionColorsChannel.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'updateEmotions') {
                console.log('üé® [Index] Received emotion color update via BroadcastChannel');
                
                // Forward the message to all iframes and p5 instances on this page
                const iframes = document.querySelectorAll('iframe');
                iframes.forEach(iframe => {
                    try {
                        iframe.contentWindow.postMessage(event.data, '*');
                        console.log('üé® [Index] Forwarded color update to iframe');
                    } catch (error) {
                        console.warn('Could not forward color update to iframe:', error);
                    }
                });
                
                // Send to the main window as well (in case it has direct p5 instances)
                window.postMessage(event.data, '*');
                console.log('üé® [Index] Sent color update to main window');
            }
        });
        
        console.log('üé® [Index] BroadcastChannel listener for emotion colors initialized');
    }

    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        console.log('üé¨ Live visualization system ready');
        
        // Also listen for direct messages (for cases where BroadcastChannel isn't available)
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'updateEmotions') {
                console.log('üé® [Index] Received emotion color update via postMessage');
                
                // Forward to all visualization components
                const iframes = document.querySelectorAll('iframe');
                iframes.forEach(iframe => {
                    try {
                        iframe.contentWindow.postMessage(event.data, '*');
                    } catch (error) {
                        console.warn('Could not forward color update to iframe:', error);
                    }
                });
            }
        });
    });
    </script>

</body>
</html>

                                                                                                                                                            