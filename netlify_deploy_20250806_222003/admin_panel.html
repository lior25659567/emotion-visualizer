<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎛️ Admin Panel - Emotion Analyzer</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' fill='%23667eea'/%3E%3Ctext x='16' y='22' text-anchor='middle' font-family='Arial' font-size='16' fill='white'%3E⚙️%3C/text%3E%3C/svg%3E">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <script src="performance_monitor.js?v=2.3&bust=1751295800"></script>
    <script src="fix_tooltip_hover.js"></script>

    <script>
        // Define functions globally to ensure they're available for onclick handlers
        window.switchTab = function(tabName) {
            console.log('switchTab called with:', tabName);
            
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
            });
            
            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });
            
            // Show the selected tab content
            const selectedTabContent = document.getElementById(`${tabName}-tab`);
            if (selectedTabContent) {
                selectedTabContent.classList.add('active');
                selectedTabContent.style.display = 'block';
            }
            
            // Add active class to the clicked tab button
            const clickedButton = event ? event.target.closest('.tab-button') : 
                document.querySelector(`.tab-button[onclick*="${tabName}"]`);
            if (clickedButton) {
                clickedButton.classList.add('active');
            }
            
            // Initialize specific tab functionality
            if (tabName === 'editor') {
                setTimeout(() => {
                    if (typeof initializeEditor === 'function') {
                        initializeEditor();
                    }
                }, 100);
            } else if (tabName === 'upload') {
                setTimeout(() => {
                    if (typeof initializeUpload === 'function') {
                        initializeUpload();
                    }
                }, 100);
            } else if (tabName === 'experiments') {
                setTimeout(() => {
                    if (typeof initializeExperiments === 'function') {
                        initializeExperiments();
                    }
                }, 100);
            } else if (tabName === 'metadata') {
                setTimeout(() => {
                    if (typeof initializeMetadata === 'function') {
                        initializeMetadata();
                    }
                }, 100);
            } else if (tabName === 'people') {
                setTimeout(() => {
                    if (typeof initializePeople === 'function') {
                        initializePeople();
                    }
                }, 100);
            } else if (tabName === 'emotions') {
                setTimeout(() => {
                    if (typeof initializeEmotions === 'function') {
                        initializeEmotions();
                    }
                }, 100);
            }
        };
        
        // Removed duplicate function - see proper definition below
        
        window.openConfigEditor = function() {
            console.log('Opening config editor...');
            // Ask user confirmation before navigating to avoid accidental navigation
            if (confirm('פתח עורך הגדרות AI? (זה יעזוב את הדף הנוכחי)')) {
                window.location.href = 'config_editor.html';
            }
        };
    </script>
    <style>
        /* Base styles */
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: #f0f2f5;
            direction: rtl;
            color: #1a1a1a;
        }
        
        /* Modern Enhanced Edit Parameters Tab Styles */
        .modern-conversation-card {
            background: white;
            border-radius: 12px;
            margin-bottom: 0.75rem;
            overflow: hidden;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            cursor: pointer;
            position: relative;
        }

        .modern-conversation-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
            border-color: rgba(102, 126, 234, 0.2);
        }

        .modern-conversation-card.active {
            border-color: #667eea;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.2);
            transform: translateY(-1px);
        }

        .conversation-card-header {
            padding: 1rem;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-bottom: 1px solid #e9ecef;
        }

        .conversation-card-title {
            font-weight: 600;
            font-size: 1rem;
            color: #2c3e50;
            margin: 0 0 0.25rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .conversation-card-meta {
            font-size: 0.8rem;
            color: #6c757d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .conversation-card-body {
            padding: 0.75rem 1rem;
        }

        .conversation-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            color: #6c757d;
        }

        .modern-segment-card {
            background: white;
            border-radius: 10px;
            margin-bottom: 0.75rem;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
            overflow: hidden;
            cursor: pointer;
            position: relative;
        }

        .modern-segment-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }

        .modern-segment-card.active {
            border-color: #667eea;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.15);
            background: linear-gradient(135deg, #fff 0%, #f8f9ff 100%);
        }

        .segment-card-header {
            padding: 0.75rem 1rem;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .segment-card-title {
            font-weight: 600;
            font-size: 0.9rem;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .segment-card-body {
            padding: 0.75rem 1rem;
        }

        .segment-emotions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-bottom: 0.5rem;
        }

        .emotion-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .segment-transcript-preview {
            font-size: 0.8rem;
            color: #6c757d;
            line-height: 1.4;
            max-height: 2.8rem;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .modern-parameter-editor {
            background: white;
            border-radius: 16px;
            padding: 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }

        .parameter-editor-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            position: relative;
        }

        .parameter-editor-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin: 0 0 0.5rem 0;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .parameter-editor-subtitle {
            opacity: 0.9;
            font-size: 0.9rem;
            margin: 0;
        }

        .parameter-editor-body {
            padding: 0;
        }

        .parameter-section {
            border-bottom: 1px solid #f1f3f4;
            transition: all 0.3s ease;
        }

        .parameter-section:last-child {
            border-bottom: none;
        }

        .parameter-section-header {
            background: #f8f9fa;
            padding: 1rem 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            border-bottom: 1px solid #e9ecef;
        }

        .parameter-section-header:hover {
            background: #e9ecef;
        }

        .parameter-section-title {
            font-weight: 600;
            font-size: 1rem;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .parameter-section-toggle {
            color: #667eea;
            transition: transform 0.3s ease;
        }

        .parameter-section.collapsed .parameter-section-toggle {
            transform: rotate(-90deg);
        }

        .parameter-section-body {
            padding: 1.5rem;
            background: white;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .parameter-section.collapsed .parameter-section-body {
            max-height: 0;
            padding: 0 1.5rem;
        }

        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .parameter-grid-2 {
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        }

        .parameter-grid-3 {
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        }

        .parameter-item {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
        }

        .parameter-item:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
        }

        .parameter-label {
            font-weight: 600;
            font-size: 0.9rem;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .parameter-help {
            color: #6c757d;
            cursor: help;
            font-size: 0.8rem;
        }

        .modern-input {
            width: 100%;
            padding: 0.6rem 0.8rem;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            background: white;
        }

        .modern-input:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            outline: none;
        }

        .modern-select {
            width: 100%;
            padding: 0.6rem 0.8rem;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            background: white;
            cursor: pointer;
        }

        .modern-select:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            outline: none;
        }

        .modern-range {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            outline: none;
            transition: all 0.3s ease;
            margin: 0.5rem 0;
        }

        .modern-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
        }

        .modern-range::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .modern-range::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);
        }

        .range-value {
            background: #667eea;
            color: white;
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            min-width: 40px;
            text-align: center;
        }

        /* ✨ ENHANCED SLIDERS - Modern, responsive design with smooth animations */
        .enhanced-slider {
            flex: 1;
            height: 24px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            border-radius: 12px;
            outline: none;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            margin: 2px 0;
        }

        .enhanced-slider::-webkit-slider-track {
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, var(--slider-color, #667eea) 0%, var(--slider-color, #667eea) var(--slider-percent, 50%), #e9ecef var(--slider-percent, 50%), #e9ecef 100%);
            transition: all 0.2s ease;
            border: none;
        }

        .enhanced-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-color, #667eea);
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
            transform: translateY(-6px);
        }

        .enhanced-slider::-webkit-slider-thumb:hover {
            transform: translateY(-6px) scale(1.15);
            box-shadow: 0 6px 20px rgba(0,0,0,0.25), 0 4px 8px rgba(0,0,0,0.15);
        }

        .enhanced-slider::-webkit-slider-thumb:active {
            transform: translateY(-6px) scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        /* Firefox styles */
        .enhanced-slider::-moz-range-track {
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, var(--slider-color, #667eea) 0%, var(--slider-color, #667eea) var(--slider-percent, 50%), #e9ecef var(--slider-percent, 50%), #e9ecef 100%);
            border: none;
        }

        .enhanced-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-color, #667eea);
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }

        .enhanced-slider:hover {
            transform: translateY(-1px);
        }

        .enhanced-slider:focus {
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        /* 📋 COMPACT DROPDOWN SELECTS - For segment quick controls */
        .modern-select-compact {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            background: #fff;
            font-size: 0.8rem;
            color: #495057;
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
            font-family: inherit;
            direction: rtl;
        }

        .modern-select-compact:hover {
            border-color: #667eea;
            background: #f8f9ff;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.1);
        }

        .modern-select-compact:focus {
            border-color: #667eea;
            background: #fff;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.15);
            transform: translateY(-1px);
        }

        .modern-select-compact option {
            padding: 8px;
            background: #fff;
            color: #495057;
            direction: rtl;
        }

        .modern-select-compact option:hover {
            background: #f8f9ff;
        }

        .modern-checkbox {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
            font-size: 0.9rem;
            color: #2c3e50;
        }

        .modern-checkbox input[type="checkbox"] {
            appearance: none;
            width: 20px;
            height: 20px;
            border: 2px solid #e9ecef;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modern-checkbox input[type="checkbox"]:checked {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
        }

        .modern-checkbox input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .transcript-editor {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 1rem;
            min-height: 100px;
            font-size: 0.9rem;
            line-height: 1.6;
            transition: all 0.3s ease;
            direction: rtl;
        }

        .transcript-editor:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            outline: none;
        }

        .transcript-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
            align-items: center;
        }

        .modern-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
        }

        .modern-btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .modern-btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .modern-btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .modern-btn-success:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .modern-btn-info {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
        }

        .modern-btn-info:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(23, 162, 184, 0.3);
        }

        .modern-btn-secondary {
            background: #f8f9fa;
            color: #6c757d;
            border: 1px solid #e9ecef;
        }

        .modern-btn-secondary:hover {
            background: #e9ecef;
            color: #495057;
        }

        .modern-btn-sm {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        .emotion-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .emotion-option {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 20px;
            padding: 0.4rem 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
            user-select: none;
        }

        .emotion-option:hover {
            border-color: #667eea;
            background: #f0f8ff;
        }

        .emotion-option.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }

        .visual-effects-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .effect-control {
            text-align: center;
        }

        .effect-control-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .effect-value-display {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: 600;
            margin-top: 0.5rem;
            display: inline-block;
        }

        .advanced-parameters {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            z-index: 10;
        }

        .modern-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .progress-bar {
            background: #e9ecef;
            border-radius: 10px;
            height: 8px;
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .progress-fill {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .status-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #28a745;
        }

        .status-indicator.pending {
            background: #ffc107;
            animation: pulse 2s infinite;
        }

        .status-indicator.error {
            background: #dc3545;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        .modern-analysis-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            transition: all 0.3s ease;
        }

        .analysis-panel-title {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .analysis-settings {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .analysis-setting {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
        }

        .analysis-setting input[type="checkbox"] {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }

        .analysis-setting input[type="checkbox"]:checked {
            background: white;
            border-color: white;
        }

        .analysis-setting input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #667eea;
            font-size: 10px;
            font-weight: bold;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            margin: 0;
            font-size: 2rem;
            font-weight: 300;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .header p {
            margin: 0.5rem 0 0 0;
            opacity: 0.9;
        }
        
        /* Tab navigation */
        .tab-nav {
            background: white;
            padding: 0 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            gap: 1rem;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .tab-button {
            background: none;
            border: none;
            padding: 1rem 2rem;
            cursor: pointer;
            font-size: 1rem;
            color: #666;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }
        
        .tab-button:hover {
            color: #333;
            background: #f8f9fa;
        }
        
        .tab-button.active {
            color: #667eea;
            border-bottom-color: #667eea;
            font-weight: 600;
        }
        
        .tab-button i {
            font-size: 1.2rem;
        }
        
        /* Tab content */
        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
            min-height: calc(100vh - 200px);
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Common panel styles */
        .panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 2rem;
            margin: 1rem;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #f0f2f5;
        }
        
        .panel-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
            margin: 0;
        }
        
        /* Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5a67d8;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        .btn-secondary {
            background: #e0e0e0;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #d0d0d0;
        }
        
        .btn-success {
            background: #48bb78;
            color: white;
        }
        
        .btn-success:hover {
            background: #38a169;
        }
        
        .btn-danger {
            background: #f56565;
            color: white;
        }
        
        .btn-danger:hover {
            background: #e53e3e;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        /* Form elements */
        input, textarea, select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s ease;
            font-family: inherit;
        }
        
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #555;
        }
        
        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        
        .loading-spinner {
            background: white;
            padding: 2rem 3rem;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Status messages */
        .status-message {
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .status-success {
            background: #c6f6d5;
            color: #276749;
            border: 1px solid #9ae6b4;
        }
        
        .status-error {
            background: #fed7d7;
            color: #742a2a;
            border: 1px solid #feb2b2;
        }
        
        .status-info {
            background: #bee3f8;
            color: #2a4e7c;
            border: 1px solid #90cdf4;
        }
        
        /* Refresh button */
        .refresh-all-btn {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            background: #f56565;
            color: white;
            padding: 1rem;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(245, 101, 101, 0.3);
            transition: all 0.2s ease;
            z-index: 1000;
            width: 72px;
            height: 72px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .refresh-all-btn:hover {
            background: #e53e3e;
            transform: translateY(-2px) rotate(180deg);
            box-shadow: 0 6px 16px rgba(245, 101, 101, 0.4);
        }
        
        .refresh-all-btn i {
            font-size: 1.5rem;
        }
        
        /* Conversation list styles */
        .conversation-item {
            background: #f8f9fa;
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .conversation-item:hover {
            background: #e9ecef;
            transform: none; /* Removed transform that interferes with tooltips */
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
        }
        
        .conversation-item.active {
            background: #e8f0fe;
            border-color: #667eea;
        }
        
        /* Improved tooltip behavior */
        .conversation-item {
            position: relative;
            transition: all 0.3s ease;
        }
        
        /* Custom tooltip styles */
        .custom-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            white-space: pre-wrap;
            max-width: 350px;
            z-index: 10000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: tooltipFadeIn 0.2s ease-in-out;
        }
        
        @keyframes tooltipFadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .conversation-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.85rem;
            color: #666;
        }
        
        /* Segment styles */
        .segment-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .segment-item:hover {
            background-color: #f5f5f5;
            border-color: #d0d0d0;
        }
        
        .segment-item.active {
            background-color: #e3f2fd;
            border-color: #2196F3;
            box-shadow: 0 2px 4px rgba(33, 150, 243, 0.2);
        }
        
        /* Emotion tags */
        .emotion-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0;
        }
        
        .emotion-tag {
            background: #e3f2fd;
            color: #1976d2;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .emotion-tag:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .emotion-tag .remove-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 0;
            margin-right: -0.25rem;
            font-size: 1rem;
        }
        
        .emotion-tag .remove-btn:hover {
            color: #d32f2f;
        }
        
        /* Upload area */
        .upload-area.dragover {
            background: #e8eaf6;
            border-color: #5c6bc0;
        }
        
        /* Small button variant */
        .btn-sm {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }
        
        /* Speaker indicators */
        .speaker-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .speaker-0 { background-color: #FF6B6B; }
        .speaker-1 { background-color: #4ECDC4; }
        
        /* Process option buttons */
        .process-option {
            padding: 0.75rem;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            font-weight: 500;
        }
        
        .process-option:hover {
            background: #e9ecef;
            border-color: #667eea;
            transform: translateY(-2px);
        }
        
        /* Conversation Topics Styling */
        #conversation-topics {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid #e8f0fe;
        }
        
        #conversation-topics label {
            background: rgba(102, 126, 234, 0.05);
            padding: 0.5rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        #conversation-topics label:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }
        
        #conversation-topics input[type="checkbox"]:checked + span {
            font-weight: 600;
            color: #667eea;
        }
        
        #custom-topics {
            margin-top: 0.5rem;
            border: 2px dashed #d0d0d0;
            padding: 0.75rem;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
        }
        
        #custom-topics:focus {
            border-color: #667eea;
            background: white;
        }
        
        /* Enhanced Main Emotions Styling */
        #main-emotions-selector {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid #ffeaea;
        }
        
        #main-emotions-selector label {
            background: rgba(229, 62, 62, 0.05);
            padding: 0.5rem;
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        #main-emotions-selector label:hover {
            background: rgba(229, 62, 62, 0.1);
            transform: translateY(-1px);
        }
        
        #main-emotions-selector input[type="checkbox"]:checked + span {
            font-weight: 600;
            color: #e53e3e;
        }

        /* Parameter inputs styling */
        .segment-content input[type="number"],
        .segment-content select,
        .segment-content textarea {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        
        .segment-content input[type="number"]:focus,
        .segment-content select:focus,
        .segment-content textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }
        
        .segment-content label {
            display: block;
            margin-bottom: 4px;
            font-size: 13px;
            font-weight: 600;
            color: #495057;
        }
        
        .segment-content input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        /* Character size group styling */
        .segment-content > div[style*="background: #f0f8ff"] {
            margin-top: 10px;
        }
        
        /* Transcript editor styles */
        .transcript-box {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
            font-family: inherit;
            font-size: 14px;
            line-height: 1.6;
            transition: border-color 0.3s;
        }
        
        .transcript-box:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }
        
        .transcript-box[data-changed="true"] {
            border-color: #ff9800;
        }
        
        .transcript-actions {
            display: flex;
            gap: 10px;
            margin-top: 8px;
            align-items: center;
        }
        
        .transcript-status {
            font-size: 12px;
            color: #666;
            margin-left: auto;
        }
        
        /* Loop button active state */
        .btn.active {
            background-color: #f44336 !important;
            color: white !important;
        }
        
        /* Hide scrollbars for transcript containers */
        #conversations-list::-webkit-scrollbar {
            display: none;
        }
        
        #segments-list-container::-webkit-scrollbar {
            display: none;
        }
        
        #people-list::-webkit-scrollbar {
            display: none;
        }
        
        #metadata-conversations-list::-webkit-scrollbar {
            display: none;
        }
        
        #conversation-grid-container::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <h1>
            <i class="material-icons">admin_panel_settings</i>
            Admin Panel - Emotion Analyzer
        </h1>
        <p>ניהול מלא של השיחות, עריכת פרמטרים, העלאה וניסויים</p>
    </header>

    <!-- Tab Navigation -->
    <nav class="tab-nav">
        <button class="tab-button active" onclick="switchTab('editor')">
            <i class="material-icons">edit_note</i>
            עורך פרמטרים
        </button>
        <button class="tab-button" onclick="switchTab('upload')">
            <i class="material-icons">cloud_upload</i>
            העלאה ועיבוד
        </button>
        <button class="tab-button" onclick="switchTab('experiments')">
            <i class="material-icons">science</i>
            ניסויים
        </button>
        <button class="tab-button" onclick="switchTab('metadata')">
            <i class="material-icons">info</i>
            נתוני שיחות
        </button>
        <button class="tab-button" onclick="switchTab('people')">
            <i class="material-icons">people</i>
            ניהול אנשים
        </button>
        <button class="tab-button" onclick="switchTab('videos')">
            <i class="material-icons">videocam</i>
            ייצור וידאו
        </button>
        <button class="tab-button" onclick="switchTab('settings')">
            <i class="material-icons">settings</i>
            הגדרות
        </button>
        <button class="tab-button" onclick="switchTab('emotions')">
            <i class="material-icons">emoji_emotions</i>
            ניהול רגשות
        </button>
        <button class="tab-button" onclick="window.open('video_manager.html', '_blank')" style="background: linear-gradient(135deg, #e74c3c, #c0392b); color: white;">
            <i class="material-icons">movie</i>
            מנהל סרטונים
        </button>
        <button type="button" class="tab-button" onclick="openConfigEditor()">
            <i class="material-icons">tune</i>
            עורך הגדרות AI
        </button>
        <button type="button" class="tab-button" onclick="window.open('modern_parameters_editor.html', '_blank')" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white;">
            <i class="material-icons">palette</i>
            עורך פרמטרים מודרני
        </button>
    </nav>

    <!-- Tab 1: Enhanced Editor -->
    <div id="editor-tab" class="tab-content active">
        <div style="display: flex; height: calc(100vh - 180px); gap: 1rem; padding: 1rem;">
            <!-- Left Panel - Conversations List (Smaller) -->
            <div class="panel" style="flex: 0 0 280px; padding: 0; display: flex; flex-direction: column;">
                <div class="panel-header" style="padding: 1.5rem; margin: 0;">
                    <h2 class="panel-title">שיחות זמינות</h2>
                    <div style="display: flex; gap: 0.5rem;">
                        <button type="button" onclick="openConversationVisualSelector('editor')" class="btn btn-primary" title="בחירה ויזואלית">
                            <i class="material-icons">visibility</i>
                            בחירה ויזואלית
                        </button>
                        <button type="button" onclick="refreshConversationsList()" class="btn btn-secondary">
                            <i class="material-icons">refresh</i>
                            רענן
                        </button>
                        <button type="button" onclick="hideLoading(); showStatus('בוטל', 'info');" class="btn btn-secondary" title="בטל טעינה">
                            <i class="material-icons">cancel</i>
                        </button>
                    </div>
                </div>
                <div id="conversations-list" style="flex: 1; overflow-y: auto; padding: 0 1rem 1rem; scrollbar-width: none; -ms-overflow-style: none;">
                    <!-- Conversations will be loaded here -->
                </div>
            </div>
            
            <!-- Middle Panel - Segments List (Much Larger) -->
            <div class="panel" style="flex: 1; padding: 0; display: flex; flex-direction: column; min-width: 500px;">
                <div id="no-selection" style="text-align: center; padding: 4rem; color: #999;">
                    <i class="material-icons" style="font-size: 64px; display: block; margin-bottom: 1rem;">folder_open</i>
                    <p style="font-size: 1.2rem;">בחר שיחה מהרשימה</p>
                </div>
                
                <div id="conversation-editor" style="display: none; flex: 1;">
                    <div class="panel" style="display: flex; flex-direction: column; height: 100%;">
                        <div class="panel-header" style="flex-shrink: 0;">
                            <div>
                                <h2 class="panel-title" id="conversation-title">שיחה</h2>
                                <div id="analysis-progress" style="display: none; margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <div class="spinner" style="width: 20px; height: 20px; margin: 0;"></div>
                                        <span id="analysis-progress-text">מנתח...</span>
                                    </div>
                                </div>
                            </div>
                            <!-- Modern Analysis Panel - Simplified -->
                            <div class="modern-analysis-panel" id="analysis-panel" style="margin-bottom: 0.5rem;">
                                <button type="button" class="modern-btn modern-btn-primary" onclick="analyzeEntireConversationComprehensive()" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem; flex-direction: column; margin-bottom: 0.5rem;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <i class="material-icons">auto_awesome</i>
                                        ניתוח מלא עם AI - כל השיחה
                                    </div>
                                    <small style="opacity: 0.8; font-size: 0.85em;">(רגשות מרובים + ניתוח אודיו + כל 92 הרגשות)</small>
                                </button>
                                <button type="button" class="modern-btn modern-btn-warning" onclick="transcribeAndAnalyzeEntireConversation()" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem; flex-direction: column; margin-bottom: 0.5rem;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <i class="material-icons">record_voice_over</i>
                                        תמלול + ניתוח מלא עם AI - כל השיחה
                                    </div>
                                    <small style="opacity: 0.8; font-size: 0.85em;">(תמלול חכם + רגשות מרובים + ניתוח אודיו + כל 92 הרגשות)</small>
                                </button>
                                
                                <!-- AI Summary and Insights Buttons -->
                                <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                                    <button type="button" class="modern-btn modern-btn-info" onclick="generateCurrentConversationSummary()" style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem;">
                                        <i class="material-icons">summarize</i>
                                        צור סיכום AI
                                    </button>
                                    <button type="button" class="modern-btn modern-btn-success" onclick="generateCurrentConversationInsights()" style="flex: 1; display: flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem;">
                                        <i class="material-icons">lightbulb</i>
                                        צור תובנות AI
                                    </button>
                                </div>
                                
                                <button type="button" class="modern-btn modern-btn-secondary" onclick="generateCurrentConversationBoth()" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem;">
                                    <i class="material-icons">psychology</i>
                                    צור סיכום ותובנות יחד
                                </button>

                            </div>
                            
                            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <!-- Auto-Analysis Toggle -->
                                <button type="button" class="modern-btn modern-btn-sm" id="auto-analysis-toggle" onclick="toggleAutoAnalysis()" 
                                        style="background: linear-gradient(135deg, #28a745, #20c997); color: white;"
                                        title="ניתוח אוטומטי כשמעדכנים טרנסקריפט">
                                    <i class="material-icons">smart_toy</i>
                                    ניתוח אוטומטי: פעיל
                                </button>
                                                    <button type="button" class="modern-btn modern-btn-success modern-btn-sm" onclick="saveAllChanges()" id="save-all-btn" disabled>
                        <i class="material-icons">save</i>
                        שמור שינויים
                    </button>
                    <button type="button" class="modern-btn modern-btn-warning modern-btn-sm" onclick="applyEnhancedEffectsToAllSegments()" 
                            style="background: linear-gradient(135deg, #e83e8c, #fd7e14);"
                            title="שפר אפקטים ויזואליים (טשטוש, ברק, הומור) לכל הקטעים הקיימים">
                        🎨 שפר אפקטים לכולם
                    </button>
                    <button type="button" class="modern-btn modern-btn-info modern-btn-sm" onclick="generateAllPreviewVideos()" 
                            style="background: linear-gradient(135deg, #17a2b8, #138496);"
                            title="צור וידאו preview בן 15 שניות ללא פאנל צד עבור כל השיחות">
                        🎬 צור Preview לכל השיחות
                    </button>
                                <button type="button" class="modern-btn modern-btn-secondary modern-btn-sm" onclick="exportConversationData()">
                                    <i class="material-icons">download</i>
                                    ייצא נתונים
                                </button>
                                <button type="button" class="modern-btn modern-btn-secondary modern-btn-sm" onclick="playAllSegmentsSequentially()" title="נגן את כל הקטעים ברצף">
                                    <i class="material-icons">playlist_play</i>
                                    נגן רצף
                                </button>
                            </div>
                        </div>
                        
                        <!-- Segments List -->
                        <div id="segments-list-container" style="flex: 1; overflow-y: auto; padding: 0.5rem; scrollbar-width: none; -ms-overflow-style: none;">
                            <div id="segments-container">
                                <!-- Initial helpful message -->
                                <div style="text-align: center; padding: 60px 20px; color: #6c757d;">
                                    <div style="font-size: 3rem; margin-bottom: 20px;">🎵</div>
                                    <h3 style="color: #495057; margin-bottom: 15px;">ברוכים הבאים לעורך הפרמטרים</h3>
                                    <p style="margin-bottom: 20px; line-height: 1.6;">
                                        בחר שיחה מהרשימה בצד שמאל כדי להתחיל עריכת פרמטרים
                                    </p>
                                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: right;">
                                        <h4 style="color: #495057; margin-bottom: 10px;">📋 מה אפשר לעשות כאן:</h4>
                                        <ul style="list-style: none; padding: 0;">
                                            <li style="margin-bottom: 8px;">🎭 עריכת רגשות לכל קטע</li>
                                            <li style="margin-bottom: 8px;">🎨 שינוי אפקטים ויזואליים</li>
                                            <li style="margin-bottom: 8px;">📝 עריכת טרנסקריפטים</li>
                                            <li style="margin-bottom: 8px;">🤖 ניתוח עם ChatGPT מתקדם</li>
                                            <li style="margin-bottom: 8px;">🔊 השמעה והתאמת פרמטרי אודיו</li>
                                        </ul>
                                    </div>
                                    <div style="color: #007bff; font-weight: 600;">
                                        👈 התחל על ידי בחירת שיחה מהרשימה בצד שמאל
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel - Segment Editor and Live Preview (Smaller) -->
            <div class="panel" style="flex: 0 0 400px; padding: 0; display: flex; flex-direction: column; min-width: 350px;">
                <div id="no-segment-selected" style="text-align: center; padding: 4rem; color: #999;">
                    <i class="material-icons" style="font-size: 64px; display: block; margin-bottom: 1rem;">edit</i>
                    <p style="font-size: 1.2rem;">בחר קטע לעריכה</p>
                </div>
                
                <div id="segment-editor-panel" style="display: none; height: 100%; display: flex; flex-direction: column;">
                    <!-- Live Preview at Top -->
                    <div style="height: 300px; border-bottom: 2px solid #e0e0e0; position: relative;">
                        <div style="position: absolute; top: 10px; right: 10px; z-index: 100; display: flex; gap: 10px;">
                            <button onclick="toggleSegmentLoop()" class="btn btn-sm" id="main-loop-btn" style="background: #4CAF50; color: white;">
                                <i class="material-icons">loop</i>
                                לולאה רציפה
                            </button>
                            <button onclick="playCurrentSegment()" class="btn btn-sm btn-primary">
                                <i class="material-icons">play_arrow</i>
                                נגן
                            </button>
                        </div>
                        <iframe id="segment-preview-iframe" style="width: 100%; height: 100%; border: none;">
                        </iframe>
                    </div>
                    
                    <!-- Segment Editor Content -->
                    <div style="flex: 1; overflow-y: auto; padding: 1.5rem;">
                        <div id="active-segment-editor">
                            <!-- Active segment editor will be loaded here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tab 2: Upload & Process -->
    <div id="upload-tab" class="tab-content">
        <div style="max-width: 1200px; margin: 0 auto; padding: 2rem;">
            <div class="panel">
                <div class="panel-header">
                    <h2 class="panel-title">🎵 העלאת קובץ אודיו חדש</h2>
                    <p style="color: #666; margin: 0;">העלה קובץ אודיו ועבד אותו עם תמלול וניתוח רגשות מתקדם</p>
                </div>
                
                <!-- File Upload Area -->
                <div class="upload-area" id="upload-area" style="border: 3px dashed #667eea; border-radius: 12px; padding: 3rem; text-align: center; background: #f8f9ff; cursor: pointer; transition: all 0.3s ease;">
                    <i class="material-icons" style="font-size: 64px; color: #667eea; display: block; margin-bottom: 1rem;">cloud_upload</i>
                    <h3 style="margin: 0 0 0.5rem 0; color: #667eea;">גרור קובץ אודיו לכאן או לחץ לבחירה</h3>
                    <p style="color: #666; margin: 0;">תומך ב: MP3, M4A, WAV, FLAC, AAC, OGG • מקסימום 100MB</p>
                    <input type="file" id="fileInput" accept=".mp3,.m4a,.wav,.flac,.aac,.ogg" style="display: none;">
                </div>
                
                <!-- Upload Status -->
                <div id="upload-status" style="margin-top: 1rem;"></div>

                <!-- Processing Options -->
                <div id="processing-options" style="display: none; margin-top: 2rem;">
                    <div style="background: #f0f8ff; padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem;">
                        <h3 style="margin: 0 0 1rem 0; color: #2196f3;">🎵 קובץ הועלה בהצלחה</h3>
                        <div id="file-info" style="margin-bottom: 1rem;">
                            <!-- File information will appear here -->
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                            <div>
                                <label>שם השיחה החדשה:</label>
                                <input type="text" id="new-conversation-name" placeholder="לדוגמה: שיחה עם דני" style="width: 100%;">
                            </div>
                            <div>
                                <label>סוג השיחה:</label>
                                <select id="conversation-type" style="width: 100%;">
                                    <option value="general">שיחה כללית</option>
                                    <option value="therapy">שיחת טיפול</option>
                                    <option value="interview">ראיון</option>
                                    <option value="meeting">פגישה</option>
                                    <option value="lecture">הרצאה</option>
                                    <option value="other">אחר</option>
                                </select>
                            </div>
                        </div>

                        <!-- Enhanced Transcription Quality Options -->
                        <div style="background: #e8f5e8; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
                            <h4 style="margin: 0 0 0.5rem 0; color: #2e7d32;">🎯 איכות תמלול וניתוח</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                                <div class="quality-option" onclick="selectQuality('chatgpt4_best')" style="border: 2px solid #e0e0e0; border-radius: 8px; padding: 1rem; cursor: pointer; transition: all 0.3s ease; background: white;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                        <i class="material-icons" style="color: #4caf50;">star</i>
                                        <strong>הכי טוב - ChatGPT-4</strong>
                                    </div>
                                    <p style="margin: 0; font-size: 0.9rem; color: #666;">תמלול מתקדם עם GPT-4 לעברית מושלמת</p>
                                </div>
                                <div class="quality-option" onclick="selectQuality('whisper_accurate')" style="border: 2px solid #e0e0e0; border-radius: 8px; padding: 1rem; cursor: pointer; transition: all 0.3s ease; background: white;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                        <i class="material-icons" style="color: #2196f3;">auto_awesome</i>
                                        <strong>מדויק - Whisper + GPT-4</strong>
                                    </div>
                                    <p style="margin: 0; font-size: 0.9rem; color: #666;">Whisper עם שיפור GPT-4 לעברית</p>
                                </div>
                                <div class="quality-option" onclick="selectQuality('openai_fast')" style="border: 2px solid #e0e0e0; border-radius: 8px; padding: 1rem; cursor: pointer; transition: all 0.3s ease; background: white;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                        <i class="material-icons" style="color: #ff9800;">flash_on</i>
                                        <strong>מהיר - OpenAI Whisper</strong>
                                    </div>
                                    <p style="margin: 0; font-size: 0.9rem; color: #666;">תמלול מהיר עם שיפור בסיסי</p>
                                </div>
                            </div>
                            <input type="hidden" id="selected-quality" value="chatgpt4_best">
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                            <div>
                                <label>אורך קטע (שניות):</label>
                                <select id="segment-length">
                                    <option value="10">10 שניות (מפורט מאוד)</option>
                                    <option value="15">15 שניות (מפורט)</option>
                                    <option value="20" selected>20 שניות (רגיל)</option>
                                    <option value="30">30 שניות (כללי)</option>
                                    <option value="60">60 שניות (בסיסי)</option>
                                </select>
                            </div>
                            <div>
                                <label>ניתוח רגשות:</label>
                                <select id="emotion-analysis-level">
                                    <option value="comprehensive" selected>מקיף (כל 92 הרגשות)</option>
                                    <option value="standard">רגיל (רגשות בסיסיים)</option>
                                    <option value="minimal">מינימלי (רגשות ראשיים)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Processing Progress -->
                    <div id="processing-progress" style="display: none; background: #fff3cd; padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem;">
                        <h4 style="margin: 0 0 1rem 0; color: #856404;">⚙️ מעבד שיחה חדשה...</h4>
                        
                        <!-- Enhanced Progress Info -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1rem; font-size: 0.9rem;">
                            <div style="text-align: center; padding: 0.5rem; background: #f8f9fa; border-radius: 4px;">
                                <div style="font-weight: bold; color: #007bff;" id="progress-percentage">0%</div>
                                <div style="color: #666;">התקדמות</div>
                            </div>
                            <div style="text-align: center; padding: 0.5rem; background: #f8f9fa; border-radius: 4px;">
                                <div style="font-weight: bold; color: #28a745;" id="time-elapsed">00:00</div>
                                <div style="color: #666;">זמן שעבר</div>
                            </div>
                            <div style="text-align: center; padding: 0.5rem; background: #f8f9fa; border-radius: 4px;">
                                <div style="font-weight: bold; color: #ffc107;" id="time-remaining">--:--</div>
                                <div style="color: #666;">זמן נותר</div>
                            </div>
                        </div>

                        <!-- Main Progress Bar -->
                        <div style="margin-bottom: 1rem;">
                            <div style="background: #e0e0e0; height: 12px; border-radius: 6px; overflow: hidden; position: relative;">
                                <div id="progress-bar" style="background: linear-gradient(45deg, #4caf50, #81c784); height: 100%; width: 0%; transition: width 0.3s ease; position: relative;">
                                    <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent); animation: shimmer 2s infinite;"></div>
                                </div>
                            </div>
                            <div id="progress-text" style="text-align: center; margin-top: 0.5rem; font-size: 0.9rem; color: #666; font-weight: 500;">
                                מכין לעיבוד...
                            </div>
                        </div>

                        <!-- Sub-task Progress (for transcription/analysis) -->
                        <div id="sub-progress-container" style="display: none; margin-bottom: 1rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                <span id="sub-progress-title" style="font-size: 0.85rem; color: #555; font-weight: 500;">מתמלל קטעים...</span>
                                <span id="sub-progress-counter" style="font-size: 0.85rem; color: #666;">0/0</span>
                            </div>
                            <div style="background: #e0e0e0; height: 6px; border-radius: 3px; overflow: hidden;">
                                <div id="sub-progress-bar" style="background: #17a2b8; height: 100%; width: 0%; transition: width 0.2s ease;"></div>
                            </div>
                        </div>

                        <!-- Processing Steps Log -->
                        <div id="progress-steps" style="max-height: 150px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 4px; padding: 0.75rem; background: #f8f9fa; font-size: 0.85rem;">
                            <!-- Processing steps will appear here -->
                        </div>
                    </div>

                    <style>
                        @keyframes shimmer {
                            0% { transform: translateX(-100%); }
                            100% { transform: translateX(100%); }
                        }
                        #progress-steps::-webkit-scrollbar {
                            width: 6px;
                        }
                        #progress-steps::-webkit-scrollbar-track {
                            background: #f1f1f1;
                            border-radius: 3px;
                        }
                        #progress-steps::-webkit-scrollbar-thumb {
                            background: #c1c1c1;
                            border-radius: 3px;
                        }
                        #progress-steps::-webkit-scrollbar-thumb:hover {
                            background: #a8a8a8;
                        }
                    </style>

                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 1rem;">
                        <button id="start-processing-btn" class="btn btn-success" style="flex: 1;">
                            <i class="material-icons">auto_awesome</i>
                            צור שיחה חדשה ועבד
                        </button>
                        <button id="cancel-upload-btn" class="btn btn-secondary">
                            <i class="material-icons">cancel</i>
                            בטל
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Quick Actions Section -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">⚡ ניתוח מהיר (ללא תמלול)</h3>
                    </div>
                    <p style="color: #666; margin-bottom: 1rem;">ניתוח רגשות בלבד על בסיס התמלול הקיים</p>
                    <div id="quick-analysis-options" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem;">
                        <!-- Options will be loaded here -->
                    </div>
                </div>
                
                <div class="panel">
                    <div class="panel-header">
                        <h3 class="panel-title">🔄 תמלול וניתוח מלא</h3>
                    </div>
                    <p style="color: #666; margin-bottom: 1rem;">תמלול מחדש עם Whisper וניתוח רגשות</p>
                    <div id="full-reprocess-options" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem;">
                        <!-- Options will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tab 3: Experiments -->
    <div id="experiments-tab" class="tab-content">
        <div style="max-width: 1000px; margin: 0 auto; padding: 2rem;">
            <div class="panel">
                <div class="panel-header">
                    <h2 class="panel-title">סביבת ניסויים לניתוח רגשות</h2>
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <label>הזן טקסט לניתוח:</label>
                    <textarea id="test-text-input" rows="4" placeholder="הקלד כאן טקסט לניתוח בזמן אמת...">חחח איזה קורע, אבל לא מסכים עם זה בכלל</textarea>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                    <div>
                        <label>סף רגישות:</label>
                        <input type="range" id="sensitivity-slider" min="0" max="1" step="0.1" value="0.5">
                        <span id="sensitivity-value">0.5</span>
                    </div>
                    <div>
                        <label>מצב ניתוח:</label>
                        <select id="analysis-mode">
                            <option value="standard">רגיל</option>
                            <option value="strict">מחמיר</option>
                            <option value="lenient">מקל</option>
                        </select>
                    </div>
                </div>
                
                <h3>תוצאות הניתוח:</h3>
                <div style="background: #2d3436; color: #dfe6e9; padding: 1.5rem; border-radius: 8px; font-family: 'Courier New', monospace; white-space: pre-wrap; min-height: 300px;" id="analysis-output">
התוצאות יופיעו כאן...
                </div>
            </div>
        </div>
    </div>

    <!-- Tab 4: Metadata -->
    <div id="metadata-tab" class="tab-content">
    
    <!-- Tab 5: People Management -->
    <div id="people-tab" class="tab-content">
        <div style="display: flex; height: calc(100vh - 180px); gap: 1rem; padding: 1rem;">
            <!-- Left Panel - People List -->
            <div class="panel" style="flex: 0 0 400px; padding: 0; display: flex; flex-direction: column;">
                <div class="panel-header" style="padding: 1.5rem; margin: 0;">
                    <h2 class="panel-title">ניהול אנשים</h2>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="addNewPerson()" class="btn btn-success btn-sm">
                            <i class="material-icons">person_add</i>
                            הוסף אדם
                        </button>
                        <button onclick="refreshPeopleList()" class="btn btn-secondary btn-sm">
                            <i class="material-icons">refresh</i>
                            רענן
                        </button>
                    </div>
                </div>
                <div id="people-list" style="flex: 1; overflow-y: auto; padding: 0 1rem 1rem;">
                    <!-- People items will be loaded here -->
                </div>
            </div>

            <!-- Right Panel - Person Editor -->
            <div class="panel" style="flex: 1; padding: 0; display: flex; flex-direction: column;">
                <div id="no-person-selection" style="text-align: center; padding: 4rem; color: #999;">
                    <i class="material-icons" style="font-size: 64px; display: block; margin-bottom: 1rem;">person</i>
                    <p style="font-size: 1.2rem;">בחר אדם לעריכה או צור אדם חדש</p>
                </div>

                <div id="person-editor-panel" style="display: none; flex: 1; padding: 2rem;">
                    <div class="panel-header" style="margin: 0 0 2rem 0;">
                        <h2 class="panel-title" id="person-editor-title">עריכת אדם</h2>
                        <div style="display: flex; gap: 1rem;">
                            <button type="button" onclick="savePerson()" class="btn btn-success" id="save-person-btn">
                                <i class="material-icons">save</i>
                                שמור אדם
                            </button>
                            <button type="button" onclick="deletePerson()" class="btn btn-danger" id="delete-person-btn">
                                <i class="material-icons">delete</i>
                                מחק אדם
                            </button>
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem;">
                        <!-- Person Info -->
                        <div style="background: #f8f9ff; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin: 0 0 1rem 0; color: #667eea;">מידע בסיסי</h3>
                            
                            <label>שם האדם:</label>
                            <input type="text" id="person-name" placeholder="הזן שם מלא" style="margin-bottom: 1rem; width: 100%;">
                            
                            <label>תיאור קצר:</label>
                            <textarea id="person-description" placeholder="תיאור קצר של האדם (אופציונלי)" style="margin-bottom: 1rem; width: 100%; height: 80px; resize: vertical;"></textarea>
                            
                            <label>צבע ייחודי:</label>
                            <input type="color" id="person-color" value="#667eea" style="margin-bottom: 1rem; width: 100%; height: 40px;">
                            
                            <label>סטטוס:</label>
                            <select id="person-status" style="margin-bottom: 1rem; width: 100%;">
                                <option value="active">פעיל</option>
                                <option value="inactive">לא פעיל</option>
                                <option value="archived">בארכיון</option>
                            </select>
                        </div>

                        <!-- Assigned Conversations -->
                        <div style="background: #fff5f5; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin: 0 0 1rem 0; color: #e53e3e;">שיחות ותפקידי דובר</h3>
                            
                            <div style="margin-bottom: 1rem;">
                                <label>בחר שיחות לשיוך:</label>
                                <div id="available-conversations" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem;">
                                    <!-- Available conversations will be loaded here -->
                                </div>
                            </div>
                            
                            <div>
                                <label>שיחות משויכות עם תפקיד דובר:</label>
                                <div id="assigned-conversations" style="max-height: 250px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem; background: #f8f9fa;">
                                    <!-- Currently assigned conversations will be shown here -->
                                </div>
                            </div>
                            
                            <div style="margin-top: 1rem; padding: 1rem; background: rgba(102, 126, 234, 0.1); border-radius: 6px;">
                                <h4 style="margin: 0 0 0.5rem 0; color: #667eea;">ניהול דוברים</h4>
                                <p style="font-size: 0.9rem; color: #666; margin: 0 0 1rem 0;">
                                    הגדר איזה דובר (0, 1, 2...) מייצג את האדם הזה בכל שיחה
                                </p>
                                <div>
                                    <label>דובר ברירת מחדל:</label>
                                    <select id="person-default-speaker" style="width: 100%; margin-top: 0.25rem;">
                                        <option value="0">דובר 0 (בדרך כלל ראשי)</option>
                                        <option value="1">דובר 1 (בדרך כלל שני)</option>
                                        <option value="2">דובר 2</option>
                                        <option value="3">דובר 3</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Statistics -->
                    <div style="background: #f0f8ff; padding: 1.5rem; border-radius: 8px;">
                        <h3 style="margin: 0 0 1rem 0; color: #2196f3;">סטטיסטיקות</h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem;">
                            <div>
                                <label>מספר שיחות:</label>
                                <div id="person-conversations-count" style="font-size: 1.2rem; font-weight: bold; color: #2196f3;">
                                    0
                                </div>
                            </div>
                            <div>
                                <label>סה"כ קטעים:</label>
                                <div id="person-segments-count" style="font-size: 1.2rem; font-weight: bold; color: #2196f3;">
                                    0
                                </div>
                            </div>
                            <div>
                                <label>משך כולל:</label>
                                <div id="person-total-duration" style="font-size: 1.2rem; font-weight: bold; color: #2196f3;">
                                    0:00
                                </div>
                            </div>
                            <div>
                                <label>סטטוס:</label>
                                <div id="person-status-display" style="font-size: 1.2rem; font-weight: bold; color: #2196f3;">
                                    פעיל
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
        <div style="display: flex; height: calc(100vh - 180px); gap: 1rem; padding: 1rem;">
            <!-- Left Panel - Conversations List for Metadata -->
            <div class="panel" style="flex: 0 0 350px; padding: 0; display: flex; flex-direction: column;">
                <div class="panel-header" style="padding: 1.5rem; margin: 0;">
                    <h2 class="panel-title">בחר שיחה לעריכה</h2>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="refreshMetadataList()" class="btn btn-secondary">
                            <i class="material-icons">refresh</i>
                            רענן
                        </button>
                        <button onclick="calculateAllDurations()" class="btn btn-primary btn-sm">
                            <i class="material-icons">timer</i>
                            חשב משכים
                        </button>
                        <button onclick="showDeleteAllConfirm()" class="btn btn-danger btn-sm" title="מחק שיחות מרובות">
                            <i class="material-icons">delete_sweep</i>
                            מחיקה מרובה
                        </button>
                    </div>
                </div>
                <div id="metadata-conversations-list" style="flex: 1; overflow-y: auto; padding: 0 1rem 1rem;">
                    <!-- Conversation items with metadata preview will be loaded here -->
                </div>
            </div>

            <!-- Right Panel - Metadata Editor -->
            <div class="panel" style="flex: 1; padding: 0; display: flex; flex-direction: column;">
                <div id="no-metadata-selection" style="text-align: center; padding: 4rem; color: #999;">
                    <i class="material-icons" style="font-size: 64px; display: block; margin-bottom: 1rem;">info</i>
                    <p style="font-size: 1.2rem;">בחר שיחה לעריכת הנתונים</p>
                </div>

                <div id="metadata-editor-panel" style="display: none; flex: 1; padding: 2rem;">
                    <div class="panel-header" style="margin: 0 0 2rem 0;">
                        <h2 class="panel-title" id="metadata-conversation-title">נתוני שיחה</h2>
                        <div style="display: flex; gap: 1rem;">
                            <button type="button" onclick="saveMetadata()" class="btn btn-success" id="save-metadata-btn">
                                <i class="material-icons">save</i>
                                שמור נתונים
                            </button>
                            <button type="button" onclick="previewMetadata()" class="btn btn-primary">
                                <i class="material-icons">preview</i>
                                תצוגה מקדימה
                            </button>
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem;">
                        <!-- Basic Info -->
                        <div style="background: #f8f9ff; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin: 0 0 1rem 0; color: #667eea;">מידע בסיסי</h3>
                            
                            <label>תאריך השיחה:</label>
                            <input type="date" id="conversation-date" style="margin-bottom: 1rem;">
                            
                            <label>שם השיחה:</label>
                            <input type="text" id="conversation-name" placeholder="שם מותאם לשיחה" style="margin-bottom: 1rem;">
                            
                            <!-- Speaker Names Section -->
                            <div style="background: #f0f8ff; padding: 1rem; border-radius: 6px; margin-bottom: 1rem;">
                                <h4 style="margin: 0 0 0.5rem 0; color: #1976d2; font-size: 14px;">שמות הדוברים</h4>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                    <div>
                                        <label style="font-size: 13px; color: #d32f2f;">דובר 1 (אדום):</label>
                                        <input type="text" id="speaker-1-name" placeholder="שם דובר 1" style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                    </div>
                                    <div>
                                        <label style="font-size: 13px; color: #00796b;">דובר 2 (טורקיז):</label>
                                        <input type="text" id="speaker-2-name" placeholder="שם דובר 2" style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                    </div>
                                </div>
                                <small style="color: #666; font-size: 12px; margin-top: 0.5rem; display: block;">השמות יוצגו במקום "דובר 1" ו"דובר 2" בכל השיחה</small>
                            </div>
                            
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">
                                <div style="flex: 1;">
                                    <label>משתתף עיקרי בשיחה:</label>
                                    <select id="main-participant" style="width: 100%;">
                                        <option value="">בחר משתתף...</option>
                                        <!-- Dynamic options will be loaded here -->
                                    </select>
                                </div>
                                <button type="button" onclick="openPeopleManager()" class="btn btn-secondary btn-sm" title="נהל רשימת אנשים" style="margin-top: 20px;">
                                    <i class="material-icons">people</i>
                                </button>
                            </div>
                            
                            <div id="custom-participant-input" style="display: none; margin-bottom: 1rem;">
                                <label>שם מותאם:</label>
                                <input type="text" id="custom-participant-name" placeholder="הזן שם מותאם">
                            </div>

                            <label>נושאי השיחה העיקריים:</label>
                            <div id="conversation-topics" style="margin-bottom: 1rem;">
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; margin-bottom: 0.5rem;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="family">👨‍👩‍👧‍👦 משפחה
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="work">💼 עבודה
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="relationships">❤️ יחסים
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="health">🏥 בריאות
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="personal">🌱 אישי
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="therapy">🛋️ טיפול
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="memories">💭 זיכרונות
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="future">🔮 עתיד
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="emotions">💫 רגשות
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                                        <input type="checkbox" value="decisions">⚖️ החלטות
                                    </label>
                                </div>
                                <input type="text" id="custom-topics" placeholder="נושאים נוספים (מופרדים בפסיקים)" style="width: 100%; font-size: 0.9rem;">
                            </div>
                        </div>

                        <!-- Emotional Profile -->
                        <div style="background: #fff5f5; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="margin: 0 0 1rem 0; color: #e53e3e;">פרופיל רגשי</h3>
                            
                            <label>רגשות עיקריים בשיחה (כל 92 הרגשות):</label>
                            
                            <!-- Search and filter controls -->
                            <div style="margin-bottom: 0.5rem; display: flex; gap: 0.5rem; align-items: center;">
                                <input type="text" id="emotions-search" placeholder="חפש רגש..." style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9rem;">
                                <button type="button" onclick="selectAllEmotions()" class="btn btn-secondary btn-sm" style="padding: 0.5rem 0.75rem; font-size: 0.8rem;">
                                    בחר הכל
                                </button>
                                <button type="button" onclick="clearAllEmotions()" class="btn btn-secondary btn-sm" style="padding: 0.5rem 0.75rem; font-size: 0.8rem;">
                                    נקה הכל
                                </button>
                                                <button type="button" onclick="forceLoadEmotions()" class="btn btn-info btn-sm" style="padding: 0.5rem 0.75rem; font-size: 0.8rem;" title="טען רגשות מחדש אם לא נטענו">
                    🔄 טען רגשות
                </button>
                            </div>
                            
                            <!-- ChatGPT Main Emotion Analysis Button -->
                            <div style="margin-bottom: 1rem; padding: 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px;">
                                <button type="button" onclick="analyzeMainEmotionWithChatGPT()" class="btn" style="width: 100%; background: white; color: #667eea; border: none; padding: 0.75rem; border-radius: 6px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                                    <i class="material-icons">psychology</i>
                                    ניתוח הרגש העיקרי עם ChatGPT
                                </button>
                                <div id="main-emotion-analysis-result" style="margin-top: 0.75rem; padding: 0.75rem; background: rgba(255,255,255,0.1); border-radius: 6px; color: white; font-size: 0.9rem; display: none;">
                                    <div style="font-weight: 600; margin-bottom: 0.25rem;">הרגש העיקרי שזוהה:</div>
                                    <div id="detected-main-emotion" style="font-size: 1.1rem; font-weight: bold; margin-bottom: 0.5rem;"></div>
                                    <div id="emotion-explanation" style="font-size: 0.85rem; opacity: 0.9; line-height: 1.4; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.2);"></div>
                                    <div id="analysis-stats" style="font-size: 0.75rem; opacity: 0.7; margin-top: 0.5rem; display: flex; gap: 1rem;">
                                        <span id="segments-count"></span>
                                        <span id="confidence-score"></span>
                                    </div>
                                </div>
                            </div>
                            
                            <div id="main-emotions-selector" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 0.4rem; margin-bottom: 1rem; border: 1px solid #f0f0f0; padding: 1rem; border-radius: 8px;">
                                <!-- Emotions will be loaded dynamically from config/emotions_config.json -->
                                <div style="grid-column: 1/-1; text-align: center; color: #999; font-style: italic; padding: 2rem;">
                                    טוען רגשות...
                                </div>
                            </div>
                            
                            <label>אינטנסיביות רגשית (1-10):</label>
                            <input type="range" id="emotional-intensity" min="1" max="10" value="5" style="width: 100%; margin-bottom: 0.5rem;">
                            <div style="text-align: center; font-size: 0.9rem; color: #666;">
                                <span id="intensity-display">5</span> / 10
                            </div>
                        </div>
                    </div>




                </div>
            </div>
        </div>
    </div>

    <!-- Tab 5: Enhanced Video Management -->
    <div id="videos-tab" class="tab-content">
        <div style="max-width: 1200px; margin: 0 auto; padding: 2rem;">
            <!-- Video Generation Panel -->
            <div class="panel">
                <div class="panel-header">
                    <h2 class="panel-title">🎬 ניהול וידאו מתקדם</h2>
                    <div style="display: flex; gap: 1rem;">
                        <button onclick="generateAllVideos()" class="btn btn-primary">
                            <i class="material-icons">video_library</i>
                            צור מהמערכת
                        </button>
                        <button onclick="refreshVideoList()" class="btn btn-secondary">
                            <i class="material-icons">refresh</i>
                            רענן רשימה
                        </button>
                        <button onclick="deleteAllVideos()" class="btn btn-danger">
                            <i class="material-icons">delete</i>
                            מחק הכל
                        </button>
                    </div>
                </div>
                
                <!-- Video Mode Selection -->
                <div style="margin-bottom: 2rem;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <!-- Enhanced System Generation Panel -->
                        <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 12px; border: 2px solid #e9ecef;">
                            <h3 style="color: #495057; margin: 0 0 1rem 0; display: flex; align-items: center; gap: 0.5rem;">
                                <i class="material-icons" style="color: #007bff;">smart_display</i>
                                ייצור אוטומטי מתקדם מהמערכת
                            </h3>
                            <p style="color: #6c757d; margin-bottom: 1rem; font-size: 0.9rem;">
                                צור קבצי MP4 מהוויזואליזציות עם בקרה מלאה על איכות, גודל ואזור הקלטה
                            </p>
                            
                            <!-- Conversation Selection for System Generation -->
                            <div style="background: #e3f2fd; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                                <label style="display: block; margin-bottom: 0.5rem; color: #1976d2; font-weight: 500;">
                                    <i class="material-icons" style="font-size: 1.2rem; vertical-align: middle;">chat</i>
                                    בחר שיחה לייצור וידאו:
                                </label>
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <select id="generation-conversation-select" style="flex: 1; padding: 0.75rem; border: 1px solid #90caf9; border-radius: 6px; background: white;">
                                        <option value="all">כל השיחות</option>
                                        <option value="">-- בחר שיחה ספציפית --</option>
                                    </select>
                                    <button onclick="openConversationVisualSelector('generation')" style="padding: 0.75rem 1rem; background: #2196f3; color: white; border: none; border-radius: 6px; cursor: pointer; white-space: nowrap;">
                                        <i class="material-icons" style="font-size: 1rem; vertical-align: middle;">visibility</i>
                                        בחירה ויזואלית
                                    </button>
                                    <button onclick="openVisualCropSelector()" style="padding: 0.75rem 1rem; background: #ff9800; color: white; border: none; border-radius: 6px; cursor: pointer; white-space: nowrap;">
                                        <i class="material-icons" style="font-size: 1rem; vertical-align: middle;">crop</i>
                                        חיתוך ויזואלי
                                    </button>
                                </div>
                                <div id="generation-conversation-info" style="margin-top: 0.5rem; padding: 0.5rem; background: rgba(33, 150, 243, 0.1); border-radius: 4px; display: none;">
                                    <small style="color: #1976d2; font-weight: 500;">נבחר: <span id="generation-conversation-name"></span></small>
                                </div>
                            </div>
                            
                            <!-- Basic Settings Row -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 1rem;">
                                <label style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="font-size: 0.9rem; color: #495057; min-width: 60px;">איכות:</span>
                                    <select id="video-quality" style="flex: 1; padding: 0.5rem; border: 1px solid #ced4da; border-radius: 4px;">
                                        <option value="720">720p (מהיר)</option>
                                        <option value="1080" selected>1080p (איכות גבוהה)</option>
                                        <option value="1440">1440p (איכות מירבית)</option>
                                        <option value="2160">4K (איכות מקסימלית)</option>
                                    </select>
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="font-size: 0.9rem; color: #495057; min-width: 60px;">FPS:</span>
                                    <select id="video-fps" style="flex: 1; padding: 0.5rem; border: 1px solid #ced4da; border-radius: 4px;">
                                        <option value="15">15 FPS (חסכוני)</option>
                                        <option value="24">24 FPS (סטנדרטי)</option>
                                        <option value="30" selected>30 FPS (חלק)</option>
                                        <option value="60">60 FPS (משובח)</option>
                                        <option value="120">120 FPS (פרימיום)</option>
                                    </select>
                                </label>
                            </div>
                            
                            <!-- Duration Control -->
                            <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">
                                <span style="font-size: 0.9rem; color: #495057; min-width: 60px;">משך:</span>
                                <input type="range" id="video-duration" min="5" max="60" value="12" style="flex: 1;" oninput="updateDurationDisplay(this.value)">
                                <span id="duration-display" style="font-size: 0.9rem; color: #495057; min-width: 70px;">12 שניות</span>
                            </label>
                            
                            <!-- Frame Size & Crop Area Settings -->
                            <div style="background: #e3f2fd; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                                <h4 style="margin: 0 0 0.75rem 0; color: #1976d2; font-size: 0.95rem; display: flex; align-items: center; gap: 0.5rem;">
                                    <i class="material-icons" style="font-size: 1.1rem;">crop</i>
                                    גודל מסגרת ואזור הקלטה
                                </h4>
                                
                                <!-- Frame Size Presets -->
                                <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                                    <span style="font-size: 0.9rem; color: #1976d2; min-width: 80px;">גודל מסגרת:</span>
                                    <select id="frame-size-preset" onchange="updateFrameSizeFields()" style="flex: 1; padding: 0.5rem; border: 1px solid #90caf9; border-radius: 4px;">
                                        <option value="full">מסך מלא (ברירת מחדל)</option>
                                        <option value="16:9">16:9 (רחב סטנדרטי)</option>
                                        <option value="4:3">4:3 (קלאסי)</option>
                                        <option value="1:1">1:1 (ריבוע)</option>
                                        <option value="9:16">9:16 (אנכי)</option>
                                        <option value="21:9">21:9 (קולנוע רחב)</option>
                                        <option value="custom">מותאם אישית</option>
                                    </select>
                                </label>
                                
                                <!-- Custom Dimensions -->
                                <div id="custom-dimensions" style="display: none;">
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.75rem;">
                                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                                            <span style="font-size: 0.9rem; color: #1976d2;">רוחב:</span>
                                            <input type="number" id="custom-width" value="1920" min="480" max="3840" step="16" style="flex: 1; padding: 0.4rem; border: 1px solid #90caf9; border-radius: 4px;">
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                                            <span style="font-size: 0.9rem; color: #1976d2;">גובה:</span>
                                            <input type="number" id="custom-height" value="1080" min="270" max="2160" step="16" style="flex: 1; padding: 0.4rem; border: 1px solid #90caf9; border-radius: 4px;">
                                        </label>
                                    </div>
                                </div>
                                
                                <!-- Crop Area Controls -->
                                <div style="background: rgba(25, 118, 210, 0.1); padding: 0.75rem; border-radius: 6px;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                        <input type="checkbox" id="enable-crop" onchange="toggleCropControls()">
                                        <span style="font-size: 0.9rem; color: #1976d2; font-weight: 500;">אזור הקלטה מותאם אישית</span>
                                    </label>
                                    <div id="crop-controls" style="display: none;">
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.5rem;">
                                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                                <span style="font-size: 0.85rem; color: #1976d2;">X (משמאל):</span>
                                                <input type="number" id="crop-x" value="0" min="0" max="1920" style="flex: 1; padding: 0.3rem; border: 1px solid #90caf9; border-radius: 3px; font-size: 0.85rem;">
                                            </label>
                                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                                <span style="font-size: 0.85rem; color: #1976d2;">Y (מלמעלה):</span>
                                                <input type="number" id="crop-y" value="0" min="0" max="1080" style="flex: 1; padding: 0.3rem; border: 1px solid #90caf9; border-radius: 3px; font-size: 0.85rem;">
                                            </label>
                                        </div>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                                <span style="font-size: 0.85rem; color: #1976d2;">רוחב:</span>
                                                <input type="number" id="crop-width" value="1920" min="100" max="1920" style="flex: 1; padding: 0.3rem; border: 1px solid #90caf9; border-radius: 3px; font-size: 0.85rem;">
                                            </label>
                                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                                <span style="font-size: 0.85rem; color: #1976d2;">גובה:</span>
                                                <input type="number" id="crop-height" value="1080" min="100" max="1080" style="flex: 1; padding: 0.3rem; border: 1px solid #90caf9; border-radius: 3px; font-size: 0.85rem;">
                                            </label>
                                        </div>
                                        <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem;">
                                            <button onclick="previewCropArea()" class="btn btn-sm btn-secondary" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                                                <i class="material-icons" style="font-size: 1rem;">visibility</i>
                                                תצוגה מקדימה
                                            </button>
                                            <button onclick="centerCropArea()" class="btn btn-sm btn-secondary" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                                                <i class="material-icons" style="font-size: 1rem;">center_focus_strong</i>
                                                מרכז
                                            </button>
                                            <button onclick="resetCropArea()" class="btn btn-sm btn-secondary" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                                                <i class="material-icons" style="font-size: 1rem;">refresh</i>
                                                איפוס
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Advanced Options -->
                            <div style="background: #fff3e0; padding: 1rem; border-radius: 8px;">
                                <h4 style="margin: 0 0 0.75rem 0; color: #f57c00; font-size: 0.95rem; display: flex; align-items: center; gap: 0.5rem;">
                                    <i class="material-icons" style="font-size: 1.1rem;">tune</i>
                                    אפשרויות מתקדמות
                                </h4>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="checkbox" id="enable-smooth-motion" checked>
                                        <span style="font-size: 0.9rem; color: #f57c00;">תנועה חלקה</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="checkbox" id="enable-background-blur">
                                        <span style="font-size: 0.9rem; color: #f57c00;">טשטוש רקע</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="checkbox" id="enable-fade-effects" checked>
                                        <span style="font-size: 0.9rem; color: #f57c00;">אפקטי דהייה</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="checkbox" id="enable-audio-sync">
                                        <span style="font-size: 0.9rem; color: #f57c00;">סנכרון אודיו</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Enhanced Custom Upload Panel with Conversation Selection -->
                        <div style="background: #fff3cd; padding: 1.5rem; border-radius: 12px; border: 2px solid #ffeaa7;">
                            <h3 style="color: #856404; margin: 0 0 1rem 0; display: flex; align-items: center; gap: 0.5rem;">
                                <i class="material-icons" style="color: #f39c12;">cloud_upload</i>
                                העלאה מותאמת אישית עם בחירת שיחה
                            </h3>
                            <p style="color: #856404; margin-bottom: 1rem; font-size: 0.9rem;">
                                העלה קבצי וידאו משלך ובחר לאיזו שיחה להקצות אותם
                            </p>
                            
                            <!-- Conversation Selection for Upload -->
                            <div style="background: rgba(243, 156, 18, 0.1); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                                <label style="display: block; margin-bottom: 0.5rem; color: #f39c12; font-weight: 500;">
                                    <i class="material-icons" style="font-size: 1.2rem; vertical-align: middle;">chat</i>
                                    בחר שיחה לצירוף הוידאו:
                                </label>
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <select id="upload-conversation-select" style="flex: 1; padding: 0.75rem; border: 1px solid #f39c12; border-radius: 6px; background: white;">
                                        <option value="">-- בחר שיחה --</option>
                                    </select>
                                    <button onclick="openConversationVisualSelector('upload')" style="padding: 0.75rem 1rem; background: #f39c12; color: white; border: none; border-radius: 6px; cursor: pointer; white-space: nowrap;">
                                        <i class="material-icons" style="font-size: 1rem; vertical-align: middle;">visibility</i>
                                        בחירה ויזואלית
                                    </button>
                                </div>
                                <div id="selected-conversation-info" style="margin-top: 0.5rem; padding: 0.5rem; background: rgba(243, 156, 18, 0.2); border-radius: 4px; display: none;">
                                    <small style="color: #e67e22; font-weight: 500;">שיחה נבחרה: <span id="selected-conversation-name"></span></small>
                                </div>
                            </div>
                            
                            <div id="custom-upload-area" style="
                                border: 2px dashed #f39c12; 
                                border-radius: 8px; 
                                padding: 2rem; 
                                text-align: center; 
                                background: rgba(255, 193, 7, 0.1);
                                cursor: pointer;
                                transition: all 0.3s ease;
                            " onclick="handleUploadAreaClick()">
                                <i class="material-icons" style="font-size: 3rem; color: #f39c12; margin-bottom: 1rem;">video_file</i>
                                <p style="margin: 0; color: #856404; font-weight: 500;">לחץ או גרור קבצי וידאו לכאן</p>
                                <p style="margin: 0.5rem 0 0 0; color: #856404; font-size: 0.8rem;">נתמך: MP4, MOV, AVI, WebM (עד 100MB)</p>
                            </div>
                            <input type="file" id="custom-video-input" accept="video/*" multiple style="display: none;" onchange="handleCustomVideoUpload(this.files)">
                        </div>
                    </div>
                </div>
                
                <div style="background: #f0f8ff; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;">
                    <h3 style="margin: 0 0 1rem 0; color: #2196f3;">📹 למה וידאו?</h3>
                    <p style="margin: 0 0 1rem 0; color: #666; line-height: 1.6;">
                        המרת הוויזואליזציות לקבצי וידאו תשפר משמעותית את הביצועים:
                        <strong>95% חיסכון בעומס</strong> על הדפדפן, טעינה מיידית של התצוגות המקדימות,
                        תמיכה טובה יותר במובייל, ושמירת הגרפיקה בזיכרון המטמון.
                    </p>
                    <p style="margin: 1rem 0 0 0; color: #4a5568; font-weight: bold;">
                        ✨ הוידאו יכלול רק את הוויזואליזציה עצמה - ללא פאנל צד לתוצאה נקייה וממוקדת
                    </p>
                    <div id="video-status-info" style="margin-top: 1rem; padding: 1rem; background: #fff; border-radius: 6px; border: 1px solid #ddd;">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <span style="font-weight: bold;">סטטוס יכולות ייצור וידאו:</span>
                            <button onclick="checkVideoStatus()" class="btn btn-sm btn-secondary" style="padding: 0.25rem 0.5rem;">
                                <i class="material-icons" style="font-size: 16px;">refresh</i>
                                בדוק
                            </button>
                        </div>
                        <div id="video-status-details">טוען...</div>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem;">
                    <div>
                        <h3>הגדרות וידאו</h3>
                        <div style="margin-bottom: 1rem;">
                            <label>איכות וידאו:</label>
                            <select id="video-quality" style="width: 100%;">
                                <option value="480">480p (קטן, מהיר)</option>
                                <option value="720" selected>720p (איכות טובה)</option>
                                <option value="1080">1080p (איכות גבוהה)</option>
                            </select>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label>משך וידאו (שניות):</label>
                            <input type="range" id="video-duration" min="5" max="60" value="15" style="width: 100%;">
                            <span id="duration-value">15</span> שניות
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label>FPS:</label>
                            <select id="video-fps" style="width: 100%;">
                                <option value="10">10 FPS (קטן)</option>
                                <option value="15" selected>15 FPS (מותאם)</option>
                                <option value="24">24 FPS (סיניי)</option>
                                <option value="30">30 FPS (חלק)</option>
                            </select>
                        </div>
                    </div>
                    
                    <div>
                        <h3>הגדרות התנהגות</h3>
                        <div style="margin-bottom: 1rem;">
                            <label>
                                <input type="checkbox" id="auto-start" checked>
                                הפעל אוטומטית במחוות
                            </label>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label>
                                <input type="checkbox" id="loop-video" checked>
                                לולאה רציפה
                            </label>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label>
                                <input type="checkbox" id="mute-video" checked>
                                השתק וידאו (רק גרפיקה)
                            </label>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label>
                                <input type="checkbox" id="hover-only">
                                הפעל רק במעבר עכבר
                            </label>
                        </div>
                    </div>
                </div>
                
                <div id="video-generation-progress" style="display: none; background: #fff3cd; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;">
                    <h4 style="margin: 0 0 1rem 0; color: #856404;">🎬 יוצר קבצי וידאו...</h4>
                    <div id="video-progress-steps">
                        <!-- Progress steps will appear here -->
                    </div>
                    <div style="margin-top: 1rem;">
                        <div style="background: #e0e0e0; height: 8px; border-radius: 4px; overflow: hidden;">
                            <div id="video-progress-bar" style="background: #4caf50; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                        </div>
                        <div id="video-progress-text" style="text-align: center; margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
                            מכין...
                        </div>
                    </div>
                </div>
                
                <!-- Enhanced Video Management Grid -->
                <div style="margin-top: 2rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <h3 style="margin: 0; color: #333;">📋 רשימת וידאו עם ניהול מתקדם</h3>
                        <div style="display: flex; gap: 0.5rem;">
                            <select id="video-filter" onchange="filterVideoList()" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="all">הכל</option>
                                <option value="system">מערכת</option>
                                <option value="custom">מותאם אישית</option>
                                <option value="missing">חסרים</option>
                            </select>
                            <button onclick="exportVideoList()" class="btn btn-secondary btn-sm">
                                <i class="material-icons">download</i>
                                יצא רשימה
                            </button>
                        </div>
                    </div>
                    
                    <div id="video-management-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem;">
                        <!-- Video management cards will be generated here -->
                    </div>
                    
                    <!-- Bulk Operations Panel -->
                    <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-top: 2rem;">
                        <h4 style="margin: 0 0 1rem 0; color: #495057;">פעולות מרובות</h4>
                        <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                            <button onclick="selectAllVideos()" class="btn btn-secondary btn-sm">
                                <i class="material-icons">select_all</i>
                                בחר הכל
                            </button>
                            <button onclick="deselectAllVideos()" class="btn btn-secondary btn-sm">
                                <i class="material-icons">deselect</i>
                                בטל בחירה
                            </button>
                            <button onclick="regenerateSelectedVideos()" class="btn btn-primary btn-sm">
                                <i class="material-icons">refresh</i>
                                צור מחדש נבחרים
                            </button>
                            <button onclick="downloadSelectedVideos()" class="btn btn-success btn-sm">
                                <i class="material-icons">download</i>
                                הורד נבחרים
                            </button>
                            <button onclick="deleteSelectedVideos()" class="btn btn-danger btn-sm">
                                <i class="material-icons">delete</i>
                                מחק נבחרים
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tab 6: Settings -->
    <div id="settings-tab" class="tab-content">
        <div style="max-width: 800px; margin: 0 auto; padding: 2rem;">
            <div class="panel">
                <div class="panel-header">
                    <h2 class="panel-title">הגדרות מערכת</h2>
                </div>
                
                <div style="margin-bottom: 2rem;">
                    <h3>הגדרות API</h3>
                    <label>כתובת שרת:</label>
                    <input type="text" id="api-server" value="http://localhost:8000" style="margin-bottom: 1rem;">
                    
                    <label>API Key (אופציונלי):</label>
                    <input type="password" id="api-key" placeholder="הזן API key אם נדרש">
                </div>
                
                <div style="margin-bottom: 2rem;">
                    <h3>הגדרות תצוגה</h3>
                    <label>
                        <input type="checkbox" id="auto-refresh" checked>
                        רענון אוטומטי של התצוגה המקדימה
                    </label>
                    <br><br>
                    <label>
                        <input type="checkbox" id="show-debug" checked>
                        הצג מידע דיבאג
                    </label>
                </div>
                
                <button type="button" onclick="saveSettings()" class="btn btn-primary">
                    <i class="material-icons">save</i>
                    שמור הגדרות
                </button>
            </div>
        </div>
    </div>

    <!-- Tab 7: Emotions Management -->
    <div id="emotions-tab" class="tab-content">
        <div style="max-width: 1200px; margin: 0 auto; padding: 2rem;">
            <div class="panel">
                <div class="panel-header">
                    <h2 class="panel-title">ניהול רגשות ומערכת צבעים</h2>
                    <div style="display: flex; gap: 1rem;">
                        <button type="button" onclick="addNewEmotion()" class="btn btn-primary">
                            <i class="material-icons">add_circle</i>
                            הוסף רגש חדש
                        </button>
                        <button type="button" onclick="resetEmotionsToDefault()" class="btn btn-secondary">
                            <i class="material-icons">restore</i>
                            שחזר לברירת מחדל
                        </button>
                        <button type="button" onclick="manualSaveEmotions()" class="btn btn-success">
                            <i class="material-icons">save</i>
                            שמור הגדרות (ידני)
                        </button>
                        <button type="button" onclick="loadEmotionsConfig()" class="btn btn-info" title="טען מחדש את הגדרות הצבעים מהשרת">
                            <i class="material-icons">refresh</i>
                            רענן צבעים
                        </button>
                        <button type="button" onclick="testEmotionColors()" class="btn btn-secondary">
                            <i class="material-icons">bug_report</i>
                            בדוק צבעים
                        </button>
                        <button type="button" onclick="forceColorUpdate()" class="btn btn-warning">
                            <i class="material-icons">palette</i>
                            אלץ עדכון צבעים
                        </button>
                        <button type="button" onclick="testColorPersistence()" class="btn btn-info">
                            <i class="material-icons">storage</i>
                            בדוק שמירת צבעים
                        </button>
                        <button type="button" onclick="immediateVisualRefresh()" class="btn btn-success">
                            <i class="material-icons">visibility</i>
                            רענן תצוגה עכשיו
                        </button>
                        <button type="button" onclick="verifyColorSave()" class="btn btn-warning">
                            <i class="material-icons">check_circle</i>
                            בדוק שמירה
                        </button>
                        <button type="button" onclick="reloadVisualizationColors()" class="btn btn-primary">
                            <i class="material-icons">sync</i>
                            טען צבעים מחדש
                        </button>
                        <button type="button" onclick="forceVisualizationReload()" class="btn btn-danger">
                            <i class="material-icons">refresh</i>
                            רענן ויזואליזציה
                        </button>
                        <button type="button" onclick="testDirectColorUpdate()" class="btn btn-secondary">
                            <i class="material-icons">colorize</i>
                            עדכון ישיר
                        </button>
                        <button type="button" onclick="testConversationColors()" class="btn btn-info">
                            <i class="material-icons">play_circle</i>
                            בדוק שיחה
                        </button>
                        <button type="button" onclick="testIndexPageColors()" class="btn btn-success">
                            <i class="material-icons">dashboard</i>
                            בדוק עמוד ראשי
                        </button>
                    </div>
                </div>
                
                <div style="background: #f0f8ff; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;">
                    <h3 style="margin: 0 0 1rem 0; color: #2196f3;">🎨 אודות ניהול רגשות</h3>
                    <p style="margin: 0 0 1rem 0; color: #666; line-height: 1.6;">
                        כאן ניתן לנהל את כל הרגשות הזמינים במערכת, לערוך את הצבעים שלהם ולהוסיף רגשות חדשים.
                        השינויים יחולו על כל הוויזואליזציות והממשק.
                    </p>
                    <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                        <div style="background: white; padding: 1rem; border-radius: 6px; flex: 1;">
                            <strong>📊 סה"כ רגשות במערכת:</strong>
                            <span id="total-emotions-count">--</span>
                        </div>
                        <div style="background: white; padding: 1rem; border-radius: 6px; flex: 1;">
                            <strong>🎯 רגשות פעילים:</strong>
                            <span id="active-emotions-count">--</span>
                        </div>
                        <div style="background: white; padding: 1rem; border-radius: 6px; flex: 1;">
                            <strong>🎨 צבעים מותאמים:</strong>
                            <span id="custom-colors-count">--</span>
                        </div>
                    </div>
                </div>
                
                <!-- Enhanced Emotions View Controls -->
                <div style="background: white; border-radius: 8px; padding: 2rem; margin-bottom: 2rem; border: 2px solid #667eea;">
                    <h3 style="margin: 0 0 1.5rem 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 0.5rem; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;">🎭</span>
                        תצוגת רגשות מעגלית משופרת
                    </h3>
                    
                    <div style="background: #f8f9ff; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;">
                        <p style="margin: 0 0 1rem 0; color: #666; line-height: 1.6;">
                            <strong>תצוגה חדשה!</strong> תצוגת הרגשות עכשיו מקבצת שיחות לפי הרגש הראשי שלהן ומציגה אותן במעגלים נפרדים.
                            כל רגש מקבל מעגל משלו עם כל השיחות השייכות אליו.
                        </p>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-top: 1rem;">
                            <div style="background: white; padding: 1rem; border-radius: 6px; border-left: 4px solid #667eea;">
                                <strong>📊 ניתוח רגשות בשיחות:</strong>
                                <div id="emotion-analysis-stats">טוען...</div>
                            </div>
                            <div style="background: white; padding: 1rem; border-radius: 6px; border-left: 4px solid #764ba2;">
                                <strong>🎯 מעגלי רגשות:</strong>
                                <div id="emotion-circles-stats">טוען...</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 1rem; margin-bottom: 2rem;">
                        <button type="button" onclick="analyzeConversationEmotions()" class="btn btn-primary">
                            <i class="material-icons">analytics</i>
                            נתח רגשות בשיחות
                        </button>
                        <button type="button" onclick="generateEmotionReport()" class="btn btn-secondary">
                            <i class="material-icons">assessment</i>
                            הפק דוח רגשות
                        </button>
                        <button type="button" onclick="refreshEmotionView()" class="btn btn-success">
                            <i class="material-icons">refresh</i>
                            רענן תצוגת רגשות
                        </button>
                        <button type="button" onclick="window.open('index.html#emotions', '_blank')" class="btn" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white;">
                            <i class="material-icons">visibility</i>
                            צפה בתצוגת רגשות
                        </button>
                    </div>
                    
                    <div id="emotion-groups-preview" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem;">
                        <!-- Emotion groups preview will be loaded here -->
                    </div>
                </div>

                <!-- Emotions List -->
                <div style="background: white; border-radius: 8px; padding: 2rem; margin-bottom: 2rem;">
                    <h3 style="margin: 0 0 1.5rem 0;">🎭 רשימת רגשות</h3>
                    <div style="margin-bottom: 1rem;">
                        <input type="text" id="emotions-search" placeholder="חפש רגש..." 
                               style="width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 6px;"
                               onkeyup="filterEmotions(this.value)">
                    </div>
                    <div id="emotions-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem;">
                        <!-- Emotions will be loaded here -->
                    </div>
                </div>
                
                <!-- Color Palette -->
                <div style="background: white; border-radius: 8px; padding: 2rem;">
                    <h3 style="margin: 0 0 1.5rem 0;">🎨 פלטת צבעים מומלצת</h3>
                    <div style="margin-bottom: 1rem;">
                        <p style="color: #666; margin: 0;">לחץ על צבע כדי להעתיק את הקוד שלו</p>
                    </div>
                    <div id="color-palette" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 1rem;">
                        <!-- Color palette will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>



    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner">
            <div class="spinner"></div>
            <p id="loading-text">טוען...</p>
        </div>
        
        <!-- Enhanced Progress Display -->
        <div id="analysisProgressContainer" style="display: none; margin-top: 2rem; background: rgba(255,255,255,0.95); padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); max-width: 500px; width: 90%;">
            <div id="analysisProgressText" style="font-size: 1.1rem; font-weight: 600; margin-bottom: 1rem; color: #333; text-align: center;"></div>
            
            <!-- Progress Bar -->
            <div style="background: #e0e0e0; border-radius: 25px; overflow: hidden; margin-bottom: 1rem; height: 30px; position: relative;">
                <div id="analysisProgressBar" style="background: linear-gradient(90deg, #4CAF50 0%, #2196F3 100%); height: 100%; width: 0%; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; border-radius: 25px;"></div>
            </div>
            
            <!-- Progress Details -->
            <div id="analysisProgressDetails" style="font-size: 0.9rem; color: #555; line-height: 1.4; background: #f5f5f5; padding: 1rem; border-radius: 8px; text-align: right;">
                <div>🔄 מתכונן לניתוח...</div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentConversation = null;
        let conversationsData = {};
        let uploadedFile = null;
        let apiBaseUrl = '';
        let emotionData = {};
        let pendingChanges = {};
        let hasUnsavedChanges = false;
        let currentLoopingAudio = null;
        let currentLoopingSegment = null;
        let currentSelectedSegment = null;
        let refreshInterval;
        let autoSaveTimeout;
        let lastAutoSaveTime = 0; // Track last auto-save time for smart debouncing
        let emotionConfigAutoSaveTimeout;
        let isLoadingEmotionData = false;
        let currentEmotionController = null;
        let conversationSelectTimeout = null;
        let isSelectingConversation = false;
        let lastRequestTime = 0;
        const MIN_REQUEST_INTERVAL = 1000; // Minimum 1 second between requests

        // Get all available emotions from emotions management
        function getAvailableEmotions() {
            // Get all emotions from emotions config (both active and inactive)
            if (emotionsConfig && Object.keys(emotionsConfig).length > 0) {
                return Object.keys(emotionsConfig).sort();
            }
            
            // Fallback to default emotions if config not loaded
            return Object.keys(DEFAULT_EMOTIONS).sort();
        }

        // Auto-sync configuration
        const AUTO_SYNC_ENABLED = false; // Set to true to enable sync to production (requires sync_to_production.py script)
        const SYNC_SCRIPT_URL = `${apiBaseUrl}/api/sync-to-production`;
        
        // Check if we're running on production server
        function isRunningOnProduction() {
            return window.location.hostname.includes('1on1.website') || 
                   window.location.hostname.includes('167.172.51.184');
        }
        
        // Auto-sync functions
        async function syncToProduction(conversationFolder = 'all', syncType = 'incremental') {
            if (!AUTO_SYNC_ENABLED) {
                console.log('ℹ️ Auto-sync disabled - changes saved locally only');
                return { success: true, message: 'Changes saved locally - sync disabled' };
            }
            
            // If running on production, files are already where they need to be
            if (isRunningOnProduction()) {
                console.log('✅ Running on production server - files already synchronized');
                updateSyncStatus('✅ פועל על שרת הפקה - הקבצים כבר מסונכרנים!', 'success');
                return { success: true, message: 'Already on production server' };
            }
            
            try {
                console.log(`🔄 Starting sync to production: ${conversationFolder} (${syncType})`);
                updateSyncStatus('🔄 מסנכרן לשרת הפקה...', 'info');
                
                // Try the API endpoint first with timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
                
                const response = await fetch(SYNC_SCRIPT_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        conversation: conversationFolder,
                        type: syncType
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.success) {
                        if (result.sync_skipped) {
                            console.log('ℹ️ Sync to production skipped - script not found');
                            updateSyncStatus('ℹ️ שינויים נשמרו מקומית - סינכרון לשרת דולג', 'info');
                        } else {
                            console.log('✅ Sync to production completed successfully');
                            updateSyncStatus('✅ סינכרון לשרת הפקה הושלם בהצלחה!', 'success');
                        }
                        return result;
                    } else {
                        console.error('❌ Sync failed:', result.error);
                        // Only show sync error in status, don't fail the entire operation
                        updateSyncStatus(`⚠️ סינכרון נכשל: ${result.error || 'שגיאה לא ידועה'}`, 'warning');
                        return result;
                    }
                } else {
                    throw new Error(`Sync API failed: ${response.status}`);
                }
                
            } catch (error) {
                console.warn('⚠️ Sync to production unavailable:', error);
                
                // Handle different types of errors  
                let errorMessage = 'ℹ️ שינויים נשמרו מקומית - סינכרון אוטומטי לא זמין';
                if (error.name === 'AbortError') {
                    errorMessage = 'ℹ️ שינויים נשמרו מקומית - סינכרון הופסק (זמן תגובה ארוך)';
                } else if (error.message.includes('ERR_CONNECTION_REFUSED')) {
                    errorMessage = 'ℹ️ שינויים נשמרו מקומית - שרת הסינכרון לא זמין';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMessage = 'ℹ️ שינויים נשמרו מקומית - בעיה בחיבור לשרת הסינכרון';
                }
                
                updateSyncStatus(errorMessage, 'info');
                
                return { success: false, error: error.message, fallback: true };
            }
        }
        
        // Show sync status in UI
        function createSyncStatusIndicator() {
            const syncIndicator = document.createElement('div');
            syncIndicator.id = 'sync-status-indicator';
            syncIndicator.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 10px 15px;
                border-radius: 8px;
                background: #e3f2fd;
                color: #1976d2;
                border: 1px solid #bbdefb;
                font-size: 14px;
                z-index: 1000;
                display: none;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            `;
            
            document.body.appendChild(syncIndicator);
            return syncIndicator;
        }
        
        // Update sync status indicator
        function updateSyncStatus(message, type = 'info') {
            let indicator = document.getElementById('sync-status-indicator');
            if (!indicator) {
                indicator = createSyncStatusIndicator();
            }
            
            const colors = {
                info: { bg: '#e3f2fd', border: '#bbdefb', text: '#1976d2' },
                success: { bg: '#e8f5e8', border: '#c8e6c8', text: '#2e7d32' },
                error: { bg: '#ffebee', border: '#ffcdd2', text: '#c62828' },
                warning: { bg: '#fff3e0', border: '#ffcc02', text: '#f57c00' }
            };
            
            const color = colors[type] || colors.info;
            indicator.style.background = color.bg;
            indicator.style.borderColor = color.border;
            indicator.style.color = color.text;
            indicator.innerHTML = message;
            indicator.style.display = 'block';
            
            // Auto-hide after 5 seconds for success/info messages
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 5000);
            }
        }
        
        // Add manual sync button to admin panel
        function addManualSyncButton() {
            const header = document.querySelector('.admin-header') || document.querySelector('h1')?.parentElement;
            if (header) {
                const syncButton = document.createElement('button');
                
                // Different button text based on where we're running
                if (isRunningOnProduction()) {
                    syncButton.innerHTML = '✅ על שרת הפקה';
                    syncButton.className = 'btn btn-success btn-sm';
                    syncButton.title = 'אתה כבר פועל על שרת הפקה - אין צורך בסינכרון';
                } else {
                    syncButton.innerHTML = '🔄 סנכרן לפקה';
                    syncButton.className = 'btn btn-primary btn-sm';
                    syncButton.title = 'סנכרן את כל השיחות לשרת הפקה';
                }
                
                syncButton.style.cssText = 'margin-left: 10px; position: relative; z-index: 1000;';
                
                syncButton.onclick = async () => {
                    // Check if we're on production server
                    if (isRunningOnProduction()) {
                        alert(`✅ אתה כבר פועל על שרת הפקה!

🌐 כתובת נוכחית: ${window.location.hostname}

כל השינויים שאתה עושה כאן מופיעים מיד באתר:
• https://1on1.website - האתר הראשי
• https://admin.1on1.website - הפאנל הזה

אין צורך בסינכרון נוסף! 🎉`);
                        return;
                    }
                    
                    syncButton.disabled = true;
                    syncButton.innerHTML = '🔄 מסנכרן...';
                    
                    try {
                        const result = await syncToProduction('all', 'incremental');
                        
                        if (result.fallback) {
                            // Show instructions for manual sync
                            const instructions = `
לסינכרון ידני מהמחשב המקומי, הרץ אחד מהפקודות הבאות בטרמינל:

1. סינכרון מהיר של כל השיחות:
   python3 sync_to_production.py

2. סינכרון של שיחה ספציפית:
   python3 sync_to_production.py convo1

3. סינכרון מלא (מחק קבצים ישנים):
   python3 sync_to_production.py all full

4. או השתמש ב-rsync ישירות:
   rsync -av conversations/ root@167.172.51.184:/root/emotion-visualizer/conversations/
                            `;
                            
                            alert(instructions);
                        }
                        
                    } catch (error) {
                        console.error('Manual sync error:', error);
                        updateSyncStatus(`❌ שגיאה בסינכרון ידני: ${error.message}`, 'error');
                    } finally {
                        syncButton.disabled = false;
                        syncButton.innerHTML = '🔄 סנכרן לפקה';
                    }
                };
                
                header.appendChild(syncButton);
                console.log('✅ Manual sync button added to admin panel');
            } else {
                console.warn('⚠️ Could not find suitable location for sync button');
            }
        }

        // Global error handler
        window.addEventListener('error', function(e) {
            console.error('💥 Global JavaScript Error:', e.error);
            console.error('📍 Location:', e.filename, 'Line:', e.lineno, 'Column:', e.colno);
        });

        window.addEventListener('unhandledrejection', function(e) {
            console.error('💥 Unhandled Promise Rejection:', e.reason);
        });

        // Helper functions for save management
        function updateSaveButtonState() {
            const saveBtn = document.getElementById('save-all-btn');
            const changeCount = Object.keys(pendingChanges).length;
            
            if (saveBtn) {
                if (changeCount > 0) {
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = `<i class="material-icons">save</i> שמור שינויים (${changeCount})`;
                } else {
                    saveBtn.disabled = true;
                    saveBtn.innerHTML = `<i class="material-icons">save</i> שמור שינויים`;
                }
            }
        }
        
        function scheduleAutoSave() {
            // Clear existing timeout
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }
            
            // ✅ SMART DEBOUNCING: Prevent excessive auto-saves
            // Increase delay and track last save to avoid rapid firing
            const now = Date.now();
            const timeSinceLastSave = now - (lastAutoSaveTime || 0);
            
            // If we just saved recently (within 5 seconds), extend the delay significantly
            const baseDelay = 10000; // Increased from 5 to 10 seconds
            const extendedDelay = timeSinceLastSave < 5000 ? 15000 : baseDelay; // Much longer delays
            
            console.log(`⏱️ Scheduling auto-save in ${extendedDelay}ms (last save: ${timeSinceLastSave}ms ago)`);
            
            // Schedule auto-save after calculated delay
            autoSaveTimeout = setTimeout(async () => {
                if (hasUnsavedChanges && Object.keys(pendingChanges).length > 0) {
                    console.log('🤖 Auto-saving changes...');
                    lastAutoSaveTime = Date.now(); // Track save time
                    try {
                        await saveAllChanges();
                        showStatus('השינויים נשמרו אוטומטית', 'success');
                    } catch (error) {
                        console.error('Auto-save failed:', error);
                        showStatus('שגיאה בשמירה אוטומטית', 'error');
                    }
                }
            }, extendedDelay);
        }
        
        function scheduleEmotionConfigAutoSave() {
            // Clear existing timeout
            if (emotionConfigAutoSaveTimeout) {
                clearTimeout(emotionConfigAutoSaveTimeout);
            }
            
            // Schedule auto-save after 2 seconds of inactivity
            emotionConfigAutoSaveTimeout = setTimeout(async () => {
                console.log('🎨 Auto-saving emotion configuration...');
                try {
                    await saveEmotionsConfig(true); // isAutoSave = true
                    console.log('✅ Emotion configuration auto-saved successfully');
                    
                    // Show brief success message
                    const statusDiv = document.createElement('div');
                    statusDiv.style.cssText = `
                        position: fixed; top: 20px; right: 20px; 
                        background: #c8e6c8; color: #2e7d32; 
                        padding: 8px 12px; border-radius: 4px; 
                        font-size: 0.85rem; z-index: 10001;
                        border: 1px solid #a5d6a7;
                    `;
                    statusDiv.textContent = '💾 צבעי רגשות נשמרו';
                    document.body.appendChild(statusDiv);
                    
                    setTimeout(() => {
                        if (statusDiv.parentNode) {
                            statusDiv.remove();
                        }
                    }, 2000);
                    
                    // Automatically trigger color updates after auto-save
                    setTimeout(() => {
                        console.log('🎨 Auto-triggering color updates after auto-save...');
                        updateVisualizationColors();
                        
                        // Send update to main index page
                        if (window.opener) {
                            try {
                                window.opener.postMessage({
                                    type: 'emotionColorsUpdated',
                                    autoTrigger: true,
                                    timestamp: Date.now()
                                }, '*');
                                console.log('📤 Auto-sent color update to main index page');
                            } catch (e) {
                                console.log('📤 Could not send to opener:', e.message);
                            }
                        }
                        
                        // Broadcast to all tabs
                        try {
                            const bc = new BroadcastChannel('emotion-updates');
                            bc.postMessage({
                                type: 'emotionColorsUpdated', 
                                autoTrigger: true,
                                timestamp: Date.now()
                            });
                            bc.close();
                            console.log('📻 Auto-broadcast color update to all tabs');
                        } catch (e) {
                            console.log('📻 BroadcastChannel not available');
                        }
                    }, 1000);
                    
                } catch (error) {
                    console.error('❌ Emotion config auto-save failed:', error);
                    showStatus('שגיאה בשמירה אוטומטית של הגדרות רגשות', 'error');
                }
            }, 2000);
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', async () => {
            // Add small delays between initialization steps to avoid rate limiting
            await detectApiServer();
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            
            console.log('🚀 Admin panel initializing with fresh conversation data...');
            await loadConversations(true); // Force refresh on admin panel page load
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            
            // Load emotion configuration early to ensure colors are available
            await loadEmotionsConfig();
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            
            populateRetranscriptionOptions();
            setupEventListeners();
            initializeExperiments();
            
            // Initialize auto-sync functionality
            addManualSyncButton();
            
            // Set up emotion color synchronization
            setupEmotionColorSync();
            
            // Initialize auto-analysis toggle
            initializeAutoAnalysis();
            
            // ✨ Initialize enhanced sliders on page load and standardize AI behavior
            setTimeout(() => {
                // Ensure consistent AI analysis behavior across all conversations and segments
                standardizeAIAnalysisBehavior();
                
                // Apply enhanced visual effects to existing segments
                applyEnhancedEffectsToAllSegments();
                
                initializeEnhancedSliders();
            }, 200);
            createSyncStatusIndicator();
            console.log('🔄 Auto-sync functionality initialized');
            
            // Smart auto-refresh with focus detection
            let isPageVisible = true;
            let lastRefreshTime = Date.now();
            
            // Detect page visibility
            document.addEventListener('visibilitychange', () => {
                isPageVisible = !document.hidden;
                if (isPageVisible && Date.now() - lastRefreshTime > 60000 && !isLoadingEmotionData) {
                    // Refresh if page becomes visible and hasn't refreshed in 60s
                    refreshEmotionData();
                }
            });
            
            // Smart refresh interval - only when page is visible and no loading in progress
            refreshInterval = setInterval(async () => {
                if (currentConversation && !hasUnsavedChanges && isPageVisible && !isLoadingEmotionData) {
                    await refreshEmotionData();
                    lastRefreshTime = Date.now();
                }
            }, 120000); // Refresh every 2 minutes to reduce server load
        });

        // Detect API server
        async function detectApiServer() {
            // First try the current page's origin
            try {
                const currentOrigin = window.location.origin;
                const url = `${currentOrigin}/config/conversations_config.json`;
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout
                
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    apiBaseUrl = currentOrigin;
                    console.log(`✅ API server detected at current origin: ${apiBaseUrl}`);
                    showStatus(`✅ שרת API זוהה בהצלחה`, 'success');
                    return;
                }
            } catch (error) {
                console.log('Current origin not available, trying ports...');
            }
            
            // Then try common ports
            const ports = [8001, 8002, 8003, 8004, 8000]; // Try 8000 last since it often fails
            for (const port of ports) {
                try {
                    // Just check if we can reach the server with shorter timeout
                    const url = `http://localhost:${port}/config/conversations_config.json`;
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 1500); // Shorter timeout
                    
                    const response = await fetch(url, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        apiBaseUrl = `http://localhost:${port}`;
                        console.log(`✅ API server detected at ${apiBaseUrl}`);
                        showStatus(`✅ שרת API זוהה בהצלחה בפורט ${port}`, 'success');
                        return;
                    }
                } catch (error) {
                    // Connection failed, try next port
                    console.log(`Port ${port} unavailable:`, error.message);
                    continue;
                }
            }
            // If no server detected, use current origin as fallback
            apiBaseUrl = window.location.origin || 'http://localhost:8000';
            console.warn('⚠️ No API server detected. Using fallback:', apiBaseUrl);
            showStatus('⚠️ שרת API לא זוהה - משתמש בהגדרות ברירת מחדל', 'warning');
        }


        // Loading overlay
        function showLoading(text = 'טוען...') {
            document.getElementById('loading-text').textContent = text;
            document.getElementById('loading-overlay').style.display = 'flex';
            // Reset progress display
            const progressContainer = document.getElementById('analysisProgressContainer');
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
        }

        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
            // Hide progress display
            const progressContainer = document.getElementById('analysisProgressContainer');
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
        }

        function showAnalysisProgress(current, total, currentSegment, analysisType) {
            const progressContainer = document.getElementById('analysisProgressContainer');
            const progressBar = document.getElementById('analysisProgressBar');
            const progressText = document.getElementById('analysisProgressText');
            const progressDetails = document.getElementById('analysisProgressDetails');
            
            if (progressContainer && progressBar && progressText) {
                progressContainer.style.display = 'block';
                
                const percentage = Math.round((current / total) * 100);
                progressBar.style.width = `${percentage}%`;
                progressBar.textContent = `${percentage}%`;
                
                progressText.textContent = `מנתח קטע ${current} מתוך ${total}`;
                
                if (progressDetails) {
                    progressDetails.innerHTML = `
                        <div>📂 קטע נוכחי: <strong>${currentSegment}</strong></div>
                        <div>🎯 סוג ניתוח: <strong>${analysisType}</strong></div>
                        <div>⏳ נותרו: <strong>${total - current}</strong> קטעים</div>
                    `;
                }
            }
        }

        // Show status message
        function showStatus(message, type = 'info') {
            try {
                console.log(`📢 Status [${type}]: ${message}`);
                
                const statusDiv = document.createElement('div');
                statusDiv.className = `status-message status-${type}`;
                statusDiv.innerHTML = `
                    <i class="material-icons">${type === 'success' ? 'check_circle' : type === 'error' ? 'error' : 'info'}</i>
                    ${message}
                `;
                
                // Find a suitable container - with fallback
                let container = document.querySelector('.tab-content.active .panel');
                if (!container) {
                    container = document.querySelector('.tab-content.active');
                }
                if (!container) {
                    container = document.body;
                }
                
                if (container) {
                    if (container === document.body) {
                        // Position at top if adding to body
                        statusDiv.style.position = 'fixed';
                        statusDiv.style.top = '20px';
                        statusDiv.style.left = '50%';
                        statusDiv.style.transform = 'translateX(-50%)';
                        statusDiv.style.zIndex = '10000';
                    }
                    
                    container.insertBefore(statusDiv, container.firstChild);
                    setTimeout(() => {
                        if (statusDiv.parentNode) {
                            statusDiv.remove();
                        }
                    }, 5000);
                } else {
                    console.warn('⚠️ Could not find container for status message, using alert');
                    alert(`${type.toUpperCase()}: ${message}`);
                }
            } catch (error) {
                console.error('❌ Error showing status:', error);
                // Fallback to alert if status system fails
                    alert(`${type.toUpperCase()}: ${message}`);
            }
        }

        // Enhanced Editor Functions
        async function loadConversations(forceRefresh = false) {
            try {
                showLoading('טוען רשימת שיחות...');
                
                // Add timeout and retry logic
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                
                // 🔍 ENHANCED CACHE-BUSTING for edit parameters tab
                const cacheBuster = forceRefresh ? `?v=${Date.now()}&refresh=true` : `?v=${Date.now()}`;
                const configUrl = `${apiBaseUrl}/config/conversations_config.json${cacheBuster}`;
                
                console.log(`📡 Editor loading conversations from: ${configUrl}`);
                
                const response = await fetch(configUrl, {
                    signal: controller.signal,
                    cache: 'no-cache',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const responseText = await response.text();
                if (!responseText) {
                    throw new Error('Empty response received');
                }
                
                let config;
                try {
                    config = JSON.parse(responseText);
                } catch (parseError) {
                    throw new Error(`Invalid JSON: ${parseError.message}`);
                }
                
                if (config && config.conversations) {
                    conversationsData = config.conversations;
                    displayConversations();
                } else {
                    throw new Error('Invalid configuration format');
                }
            } catch (error) {
                console.error('Error loading conversations:', error);
                if (error.name === 'AbortError') {
                    showStatus('שרת לא מגיב - בדוק שהשרת פועל', 'error');
                } else {
                    showStatus(`שגיאה בטעינת השיחות: ${error.message}`, 'error');
                }
            } finally {
                hideLoading();
            }
        }

        function displayConversations() {
            const container = document.getElementById('conversations-list');
            container.innerHTML = '';

            // Check if we have conversations data
            if (!conversationsData || Object.keys(conversationsData).length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: #999;">
                        <i class="material-icons" style="font-size: 48px; display: block; margin-bottom: 1rem;">chat_bubble_outline</i>
                        <p style="font-size: 1.1rem; margin-bottom: 1rem;">אין שיחות זמינות</p>
                        <button onclick="loadConversations()" class="btn btn-primary btn-sm">
                            <i class="material-icons">refresh</i>
                            נסה שוב
                        </button>
                    </div>
                `;
                return;
            }

            const sortedConvos = Object.entries(conversationsData)
                .sort(([,a], [,b]) => a.number - b.number);

            if (sortedConvos.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: #999;">
                        <p>אין שיחות להצגה</p>
                    </div>
                `;
                return;
            }

            sortedConvos.forEach(([folder, data]) => {
                const metadata = data.metadata || {};
                const item = document.createElement('div');
                item.className = 'conversation-item';
                item.onclick = () => selectConversation(folder);
                
                // Create enhanced tooltip with metadata
                const tooltipContent = createConversationTooltip(folder, data);
                item.title = tooltipContent;
                
                // Enhanced display with metadata
                const displayName = metadata.name || `שיחה ${data.number}`;
                const participantInfo = metadata.participants?.length ? 
                    ` | משתתפים: ${metadata.participants.join(', ')}` : '';
                const durationInfo = metadata.duration ? ` | ⏱️ ${metadata.duration}` : '';
                const emotionEmojis = metadata.mainEmotions?.length ? 
                    metadata.mainEmotions.map(e => getEmotionEmoji(e)).join('') : '';
                
                // Check if AI content exists
                const hasAISummary = metadata.ai_summary ? '🤖' : '';
                const hasAIInsights = metadata.ai_insights ? '🤖' : '';
                
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                        <div style="flex: 1;">
                            <h4 style="margin: 0 0 0.5rem 0; display: flex; align-items: center; gap: 0.5rem;">
                                ${displayName}
                                ${metadata.isImportant ? '<span style="color: #f44336;" title="שיחה חשובה">⭐</span>' : ''}
                                ${metadata.isPrivate ? '<span style="color: #9c27b0;" title="שיחה פרטית">🔒</span>' : ''}
                                ${metadata.needsReview ? '<span style="color: #ff9800;" title="דורש בדיקה">⚠️</span>' : ''}
                            </h4>
                            <div style="font-size: 0.85rem; color: #666;">
                                📅 ${metadata.date || 'ללא תאריך'}${durationInfo}${participantInfo}
                            </div>
                            ${emotionEmojis ? `<div style="margin-top: 0.3rem;">${emotionEmojis} ${metadata.mainEmotions.join(', ')}</div>` : ''}
                        </div>
                        <div style="text-align: right; font-size: 0.8rem; color: #999;">
                            📁 ${folder}
                        </div>
                    </div>
                    <div class="conversation-stats">
                        <span>🎵 ${data.mp3_count || 0} קטעים</span>
                        <span>📝 ${metadata.totalWords || 0} מילים</span>
                        ${metadata.tags?.length ? `<span>🏷️ ${metadata.tags.slice(0, 2).join(', ')}${metadata.tags.length > 2 ? '...' : ''}</span>` : ''}
                        <span style="margin-right: auto;">
                            ${hasAISummary ? '<span title="סיכום AI קיים">📝🤖</span>' : ''}
                            ${hasAIInsights ? '<span title="תובנות AI קיימות">💡🤖</span>' : ''}
                        </span>
                    </div>
                    <div class="ai-actions" style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #eee; display: flex; gap: 0.25rem; flex-wrap: wrap;">
                        <button onclick="event.stopPropagation(); generateConversationSummary('${folder}')" 
                                class="btn btn-sm ${hasAISummary ? 'btn-success' : 'btn-outline-primary'}" 
                                style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" 
                                title="${hasAISummary ? 'עדכן סיכום AI' : 'צור סיכום AI'}">
                            📝 ${hasAISummary ? 'עדכן סיכום' : 'צור סיכום'}
                        </button>
                        <button onclick="event.stopPropagation(); generateConversationInsights('${folder}')" 
                                class="btn btn-sm ${hasAIInsights ? 'btn-success' : 'btn-outline-info'}" 
                                style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" 
                                title="${hasAIInsights ? 'עדכן תובנות AI' : 'צור תובנות AI'}">
                            💡 ${hasAIInsights ? 'עדכן תובנות' : 'צור תובנות'}
                        </button>
                        <button onclick="event.stopPropagation(); generateBothForConversation('${folder}')" 
                                class="btn btn-sm ${hasAISummary && hasAIInsights ? 'btn-success' : 'btn-outline-secondary'}" 
                                style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" 
                                title="צור/עדכן סיכום ותובנות">
                            🤖 ${hasAISummary && hasAIInsights ? 'עדכן הכל' : 'צור הכל'}
                        </button>
                    </div>
                `;
                
                container.appendChild(item);
            });

            console.log(`✅ Displayed ${sortedConvos.length} conversations with enhanced metadata`);
        }
        
        // Create detailed tooltip for conversation hover
        function createConversationTooltip(folder, data) {
            const metadata = data.metadata || {};
            
            const lines = [
                `📝 ${metadata.name || `שיחה ${data.number}`}`,
                `📁 תיקייה: ${folder}`,
                metadata.date ? `📅 תאריך: ${metadata.date}` : '📅 תאריך: לא הוגדר',
                metadata.participants?.length ? `👥 משתתפים: ${metadata.participants.join(', ')}` : '👥 משתתפים: לא הוגדר',
                metadata.duration ? `⏱️ משך: ${metadata.duration}` : '⏱️ משך: לא מחושב',
                `🎵 ${data.mp3_count || 0} קטעים | 📝 ${metadata.totalWords || 0} מילים`,
                metadata.mainEmotions?.length ? `😊 רגשות עיקריים: ${metadata.mainEmotions.join(', ')}` : '😊 רגשות עיקריים: לא הוגדר',
                metadata.emotionalIntensity ? `📊 עוצמה רגשית: ${metadata.emotionalIntensity}/10` : '📊 עוצמה רגשית: 5/10'
            ];
            
            if (metadata.tags?.length) {
                lines.push(`🏷️ תגיות: ${metadata.tags.join(', ')}`);
            }
            
            if (metadata.notes) {
                lines.push(`📋 הערות: ${metadata.notes.substring(0, 100)}${metadata.notes.length > 100 ? '...' : ''}`);
            }
            
            // Add status flags
            const flags = [];
            if (metadata.isImportant) flags.push('⭐ שיחה חשובה');
            if (metadata.isPrivate) flags.push('🔒 שיחה פרטית');
            if (metadata.needsReview) flags.push('⚠️ דורש בדיקה');
            
            if (flags.length > 0) {
                lines.push('', ...flags);
            }
            
            return lines.join('\n');
        }

        // Function to refresh conversations list
        window.refreshConversationsList = async function refreshConversationsList() {
            try {
                showLoading('מרענן רשימת שיחות...');
                await loadConversations(true); // Force refresh for edit parameters tab
                
                // Also refresh metadata if it's loaded - FORCE REFRESH to bypass cache
                if (Object.keys(conversationMetadata).length > 0) {
                    await loadConversationMetadata(true); // Force refresh
                    displayMetadataConversations();
                }
                
                showStatus('רשימת השיחות עודכנה בהצלחה', 'success');
            } catch (error) {
                console.error('Error refreshing conversations:', error);
                showStatus(`שגיאה ברענון: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }
        
        // 🔍 DEBUG FUNCTION: Test save/load cycle
        window.testSaveLoadCycle = async function(conversationFolder, newName) {
            console.log(`🧪 Testing save/load cycle for ${conversationFolder} with name: ${newName}`);
            
            try {
                // Load current metadata
                await loadConversationMetadata(true);
                const originalName = conversationMetadata[conversationFolder]?.metadata?.name;
                console.log(`📝 Original name: ${originalName}`);
                
                // Update the name
                if (conversationMetadata[conversationFolder]) {
                    conversationMetadata[conversationFolder].metadata.name = newName;
                    
                    // Save to server
                    const updatedConfig = {
                        conversations: conversationMetadata,
                        total_conversations: Object.keys(conversationMetadata).length,
                        file_mappings: Object.fromEntries(
                            Object.entries(conversationMetadata).map(([folder, data]) => [
                                folder,
                                data.emotion_file || `conversations/${folder}/emotions${data.number}.json`
                            ])
                        ),
                        last_metadata_update: new Date().toISOString()
                    };
                    
                    const response = await fetch(`${apiBaseUrl}/api/save-config`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            filename: 'config/conversations_config.json',
                            content: updatedConfig
                        })
                    });
                    
                    if (response.ok) {
                        console.log('✅ Save successful');
                        
                        // Wait a moment, then reload
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        await loadConversationMetadata(true);
                        
                        const reloadedName = conversationMetadata[conversationFolder]?.metadata?.name;
                        console.log(`📝 Reloaded name: ${reloadedName}`);
                        
                        if (reloadedName === newName) {
                            console.log('✅ Save/load cycle successful!');
                            return true;
                        } else {
                            console.error('❌ Save/load cycle failed - names do not match');
                            return false;
                        }
                    } else {
                        console.error('❌ Save failed:', response.status);
                        return false;
                    }
                } else {
                    console.error('❌ Conversation not found:', conversationFolder);
                    return false;
                }
                         } catch (error) {
                 console.error('❌ Test failed:', error);
                 return false;
             }
         }
         
         // 🧪 COMPREHENSIVE TEST FUNCTION: Test name persistence across all components
         window.testNamePersistenceAcrossComponents = async function(conversationFolder = 'convo1', testName = null) {
             const uniqueTestName = testName || `Test Name ${Date.now()}`;
             console.log(`🧪 COMPREHENSIVE TEST: Testing name persistence for ${conversationFolder} with name: "${uniqueTestName}"`);
             
             try {
                 // Step 1: Save the name via metadata
                 console.log('📝 Step 1: Saving name via metadata system...');
                 
                 await loadConversationMetadata(true);
                 if (!conversationMetadata[conversationFolder]) {
                     console.error(`❌ Conversation ${conversationFolder} not found`);
                     return false;
                 }
                 
                 const originalName = conversationMetadata[conversationFolder].metadata.name;
                 console.log(`📝 Original name: "${originalName}"`);
                 
                 // Update the name
                 conversationMetadata[conversationFolder].metadata.name = uniqueTestName;
                 
                 const updatedConfig = {
                     conversations: conversationMetadata,
                     total_conversations: Object.keys(conversationMetadata).length,
                     file_mappings: Object.fromEntries(
                         Object.entries(conversationMetadata).map(([folder, data]) => [
                             folder,
                             data.emotion_file || `conversations/${folder}/emotions${data.number}.json`
                         ])
                     ),
                     last_metadata_update: new Date().toISOString()
                 };
                 
                 const saveResponse = await fetch(`${apiBaseUrl}/api/save-config`, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({
                         filename: 'config/conversations_config.json',
                         content: updatedConfig
                     })
                 });
                 
                 if (!saveResponse.ok) {
                     console.error('❌ Save failed:', saveResponse.status);
                     return false;
                 }
                 
                 console.log('✅ Step 1 completed: Name saved to server');
                 
                 // Step 2: Test metadata tab reload
                 console.log('🔄 Step 2: Testing metadata tab reload...');
                 await new Promise(resolve => setTimeout(resolve, 500));
                 await loadConversationMetadata(true);
                 
                 const metadataReloadName = conversationMetadata[conversationFolder]?.metadata?.name;
                 console.log(`📝 Metadata reload name: "${metadataReloadName}"`);
                 
                 if (metadataReloadName !== uniqueTestName) {
                     console.error('❌ Step 2 failed: Metadata tab reload name mismatch');
                     return false;
                 }
                 console.log('✅ Step 2 completed: Metadata tab reload successful');
                 
                 // Step 3: Test edit parameters tab reload  
                 console.log('🔄 Step 3: Testing edit parameters tab reload...');
                 await loadConversations(true);
                 
                 const editTabReloadName = conversationsData[conversationFolder]?.metadata?.name;
                 console.log(`📝 Edit tab reload name: "${editTabReloadName}"`);
                 
                 if (editTabReloadName !== uniqueTestName) {
                     console.error('❌ Step 3 failed: Edit parameters tab reload name mismatch');
                     return false;
                 }
                 console.log('✅ Step 3 completed: Edit parameters tab reload successful');
                 
                 // Step 4: Test config file direct read
                 console.log('🔄 Step 4: Testing direct config file read...');
                 const directConfigResponse = await fetch(`${apiBaseUrl}/config/conversations_config.json?v=${Date.now()}`, {
                     cache: 'no-cache',
                     headers: {
                         'Cache-Control': 'no-cache, no-store, must-revalidate',
                         'Pragma': 'no-cache',
                         'Expires': '0'
                     }
                 });
                 
                 if (!directConfigResponse.ok) {
                     console.error('❌ Step 4 failed: Could not read config file directly');
                     return false;
                 }
                 
                 const directConfig = await directConfigResponse.json();
                 const directConfigName = directConfig.conversations[conversationFolder]?.metadata?.name;
                 console.log(`📝 Direct config name: "${directConfigName}"`);
                 
                 if (directConfigName !== uniqueTestName) {
                     console.error('❌ Step 4 failed: Direct config file read name mismatch');
                     return false;
                 }
                 console.log('✅ Step 4 completed: Direct config file read successful');
                 
                 // Step 5: Restore original name
                 console.log('🔄 Step 5: Restoring original name...');
                 conversationMetadata[conversationFolder].metadata.name = originalName;
                 
                 const restoreConfig = {
                     conversations: conversationMetadata,
                     total_conversations: Object.keys(conversationMetadata).length,
                     file_mappings: Object.fromEntries(
                         Object.entries(conversationMetadata).map(([folder, data]) => [
                             folder,
                             data.emotion_file || `conversations/${folder}/emotions${data.number}.json`
                         ])
                     ),
                     last_metadata_update: new Date().toISOString()
                 };
                 
                 const restoreResponse = await fetch(`${apiBaseUrl}/api/save-config`, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({
                         filename: 'config/conversations_config.json',
                         content: restoreConfig
                     })
                 });
                 
                 if (restoreResponse.ok) {
                     console.log('✅ Step 5 completed: Original name restored');
                 } else {
                     console.warn('⚠️ Step 5 warning: Could not restore original name');
                 }
                 
                 console.log('🎉 COMPREHENSIVE TEST PASSED: Name persistence works across all components!');
                 return true;
                 
             } catch (error) {
                 console.error('❌ COMPREHENSIVE TEST FAILED:', error);
                 return false;
             }
         }

        async function selectConversation(folder) {
            // Debounce to prevent rapid clicking
            if (conversationSelectTimeout) {
                clearTimeout(conversationSelectTimeout);
            }
            
            conversationSelectTimeout = setTimeout(async () => {
                await selectConversationImmediate(folder);
            }, 300); // 300ms debounce
        }
        
        async function selectConversationImmediate(folder) {
            // Prevent multiple simultaneous selections
            if (isSelectingConversation) {
                console.log('⏳ Already selecting conversation, skipping...');
                return;
            }
            
            // Don't reselect the same conversation
            if (currentConversation === folder) {
                console.log(`📝 Conversation ${folder} is already selected`);
                return;
            }
            
            console.log(`Selecting conversation: ${folder}`);
            isSelectingConversation = true;
            
            try {
                // Stop any current loops when switching conversations
            if (currentLoopingSegment) {
                stopLoop();
                const loopBtns = document.querySelectorAll('.loop-button');
                loopBtns.forEach(btn => {
                    btn.classList.remove('active');
                    btn.title = 'לולאה';
                });
            }
            
            // Clear pending changes
            pendingChanges = {};
            hasUnsavedChanges = false;
            
            // Update save button state
            updateSaveButtonState();
            
            // Ensure emotions config is loaded before showing conversation
            if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                console.log('🎨 Emotions config not loaded, loading now...');
                await loadEmotionsConfig();
            }
            
            // Update UI - find the conversation item by folder and mark it as active
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.remove('active');
                // Check if this item corresponds to the selected folder by looking at the folder span
                const conversationStats = item.querySelector('.conversation-stats');
                if (conversationStats) {
                    const folderSpan = conversationStats.querySelector('span');
                    if (folderSpan && folderSpan.textContent === `📁 ${folder}`) {
                        item.classList.add('active');
                    }
                }
            });

            currentConversation = folder;
            const convData = conversationsData[folder];
            
            if (!convData) {
                console.error(`No conversation data found for ${folder}`);
                showStatus(`לא נמצאו נתונים עבור ${folder}`, 'error');
                return;
            }
            
            // Show editor
            document.getElementById('no-selection').style.display = 'none';
            document.getElementById('conversation-editor').style.display = 'flex';
            document.getElementById('conversation-title').textContent = `שיחה ${convData.number}`;

            // Clear existing segments and show loading
            const segmentsContainer = document.getElementById('segments-container');
            if (segmentsContainer) {
                segmentsContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666;">
                        <div style="margin-bottom: 20px;">🔄</div>
                        <div>טוען קטעי שיחה ${folder}...</div>
                    </div>
                `;
            }

            // Load emotion data
            await loadEmotionData(folder);
            
            // Ensure segments are displayed after loading
            if (emotionData && Object.keys(emotionData).length > 0) {
                console.log(`✅ Successfully loaded conversation ${folder} with ${Object.keys(emotionData).length} items`);
                displaySegments();
                
                // Show success message with segment count
                const mp3Count = Object.keys(emotionData).filter(key => key.endsWith('.mp3')).length;
                showStatus(`✅ נטענה שיחה ${folder} עם ${mp3Count} קטעי אודיו`, 'success');
            } else {
                console.warn(`⚠️ No emotion data loaded for ${folder}`);
                if (segmentsContainer) {
                    segmentsContainer.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #999;">
                            <div style="margin-bottom: 20px;">⚠️</div>
                            <div>לא נמצאו קטעי שיחה עבור ${folder}</div>
                            <button class="btn btn-primary" onclick="loadEmotionData('${folder}')" style="margin-top: 15px;">
                                🔄 נסה שוב
                            </button>
                        </div>
                    `;
                }
                showStatus(`⚠️ לא נמצאו נתוני רגשות עבור ${folder}`, 'warning');
            }
            } finally {
                isSelectingConversation = false;
            }
        }

        async function loadEmotionData(folder) {
            // Prevent multiple concurrent loads
            if (isLoadingEmotionData) {
                console.log('⏳ Already loading emotion data, skipping...');
                return;
            }
            
            // Rate limiting to prevent server overload
            const now = Date.now();
            if (now - lastRequestTime < MIN_REQUEST_INTERVAL) {
                console.log('🚦 Rate limiting: waiting before next request');
                await new Promise(resolve => setTimeout(resolve, MIN_REQUEST_INTERVAL - (now - lastRequestTime)));
            }
            lastRequestTime = Date.now();
            
            // Cancel any existing request
            if (currentEmotionController) {
                console.log('🚫 Canceling previous emotion data request');
                currentEmotionController.abort();
                currentEmotionController = null;
            }
            
            try {
                isLoadingEmotionData = true;
                showLoading('טוען נתוני רגשות...');
                const convData = conversationsData[folder];
                let emotionFile = convData.ai_file || convData.emotion_file || `emotions${convData.number}_ai_analyzed.json`;
                
                // Fix path - ensure we don't double the conversations/folder part
                if (!emotionFile.startsWith('conversations/')) {
                    emotionFile = `conversations/${folder}/${emotionFile}`;
                }
                
                // Create new controller for this request
                currentEmotionController = new AbortController();
                const timeoutId = setTimeout(() => {
                    if (currentEmotionController) {
                        console.log('⏰ Request timed out after 15 seconds');
                        currentEmotionController.abort();
                    }
                }, 45000); // Increased to 45 second timeout for large files
                
                console.log(`Loading emotion data from: ${apiBaseUrl}/${emotionFile}`);
                
                // Add cache-busting for fresh data after transcription
                const timestamp = new Date().getTime();
                const cacheBuster = Math.random().toString(36).substring(7);
                const fileUrl = `${apiBaseUrl}/${emotionFile}?t=${timestamp}&r=${cacheBuster}&v=3`;
                
                const response = await fetch(fileUrl, {
                    signal: currentEmotionController.signal,
                    cache: 'no-store', // Force fresh data to show transcription updates
                    headers: {
                        'Accept': 'application/json',
                        'Accept-Encoding': 'gzip, deflate'
                    }
                });
                console.log(`🔄 Loading with cache-busting: t=${timestamp}&r=${cacheBuster}`);
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`Failed to load emotion data: ${response.status} ${response.statusText}`);
                }
                
                // Store ETag for future requests
                const etag = response.headers.get('ETag');
                if (etag) {
                    emotionDataETag = etag;
                }
                
                const responseText = await response.text();
                if (!responseText || responseText.trim() === '') {
                    throw new Error('Empty emotion data response');
                }
                
                console.log(`Response text length: ${responseText.length} characters`);
                console.log(`Response preview: ${responseText.substring(0, 100)}...`);
                
                try {
                    emotionData = JSON.parse(responseText);
                } catch (parseError) {
                    console.error('JSON Parse Error Details:', {
                        error: parseError.message,
                        responseLength: responseText.length,
                        responseStart: responseText.substring(0, 200),
                        responseEnd: responseText.substring(Math.max(0, responseText.length - 200))
                    });
                    throw new Error(`Invalid emotion data JSON: ${parseError.message}. Response length: ${responseText.length}`);
                }
                console.log(`Successfully loaded ${Object.keys(emotionData).length} items`);
                
                // Load speaker info for this conversation
                await loadSpeakerInfo(folder);
                
                // Update current conversation tracker for speaker names
                if (currentConversation !== folder) {
                    currentConversation = folder;
                    console.log(`🔄 Updated current conversation to: ${folder}`);
                }
                
                displaySegments();
            } catch (error) {
                console.error('Error loading emotion data:', error);
                if (error.name === 'AbortError') {
                    // Check if this was a timeout or a manual cancellation
                    if (currentEmotionController === null) {
                        console.log('📝 Request was cancelled for new selection');
                        return; // Don't show error for cancelled requests
                    } else {
                        showStatus('הטעינה לקחה יותר מדי זמן (15 שניות). בדוק את החיבור לאינטרנט.', 'error');
                    }
                } else if (error.message.includes('JSON')) {
                    showStatus('שגיאה בפורמט הנתונים. הקובץ עלול להיות פגום. נסה ליצור מחדש עם AI.', 'error');
                } else {
                    showStatus(`שגיאה בטעינת נתוני הרגשות: ${error.message}`, 'error');
                }
                
                // Clear the segments container on error
                const container = document.getElementById('segments-container');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #999;">
                            <p>⚠️ שגיאה בטעינת הנתונים</p>
                            <button class="btn btn-primary" onclick="loadEmotionData('${currentConversation}')">
                                🔄 נסה שוב
                            </button>
                        </div>
                    `;
                }
            } finally {
                isLoadingEmotionData = false;
                currentEmotionController = null;
                hideLoading();
            }
        }

        // Load speaker info for current conversation
        async function loadSpeakerInfo(conversationId) {
            try {
                const response = await fetch(`${apiBaseUrl}/api/get-speaker-info/${conversationId}`);
                if (response.ok) {
                    const data = await response.json();
                    window.speakerInfo = data.speakers;
                    console.log('🎭 Speaker info loaded:', window.speakerInfo);
                    
                    // Refresh any existing displays that might use speaker names
                    refreshSpeakerDisplays();
                } else {
                    console.warn('⚠️ Failed to load speaker info');
                    window.speakerInfo = {};
                }
            } catch (error) {
                console.warn('⚠️ Error loading speaker info:', error);
                window.speakerInfo = {};
            }
        }

        // Refresh speaker displays throughout the interface
        function refreshSpeakerDisplays() {
            // Update all speaker indicators and tooltips
            document.querySelectorAll('.speaker-indicator').forEach(indicator => {
                const mp3File = indicator.id.replace('speaker-indicator-', '');
                if (emotionData && emotionData[mp3File]) {
                    const speaker = emotionData[mp3File].speaker || 0;
                    indicator.title = getSpeakerName(speaker);
                }
            });
            
            // Update all speaker display elements
            document.querySelectorAll('[id^="speaker-display-"]').forEach(element => {
                const mp3File = element.id.replace('speaker-display-', '');
                if (emotionData && emotionData[mp3File]) {
                    const speaker = emotionData[mp3File].speaker || 0;
                    element.textContent = `🔊 ${getSpeakerName(speaker)}`;
                }
            });
        }

        // Get speaker name with fallback to default
        function getSpeakerName(speakerNumber) {
            // First try window.speakerInfo (from API)
            if (window.speakerInfo && window.speakerInfo[speakerNumber.toString()]) {
                return window.speakerInfo[speakerNumber.toString()].name;
            }
            
            // Then try conversation metadata (current conversation)
            if (!currentMetadataConversation || !conversationMetadata[currentMetadataConversation]) {
                return speakerNumber === 0 ? 'דובר 1' : 'דובר 2';
            }
            
            const metadata = conversationMetadata[currentMetadataConversation].metadata || {};
            const speakerName = speakerNumber === 0 ? metadata.speaker1Name : metadata.speaker2Name;
            
            if (speakerName && speakerName.trim()) {
                return speakerName.trim();
            }
            
            return speakerNumber === 0 ? 'דובר 1' : 'דובר 2';
        }

        function displaySegments() {
            const container = document.getElementById('segments-container');
            if (!container) {
                console.error('❌ segments-container not found!');
                return;
            }
            
            container.innerHTML = '';

            // Filter out non-mp3 entries and sort them
            const mp3Files = Object.keys(emotionData || {})
                .filter(key => key.endsWith('.mp3'))
                .sort((a, b) => {
                    try {
                        return a.localeCompare(b, 'he', { numeric: true });
                    } catch(e) {
                        return a > b ? 1 : -1;
                    }
                });
            
            console.log(`📊 Displaying ${mp3Files.length} MP3 segments:`, mp3Files.slice(0, 5));
            
            if (mp3Files.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #999;">
                        <div style="margin-bottom: 20px;">📂</div>
                        <div>אין קטעי MP3 זמינים בשיחה זו</div>
                        <div style="font-size: 0.9rem; margin-top: 10px; color: #666;">
                            ייתכן שהשיחה עדיין לא עובדה או שאין בה קטעי אודיו
                        </div>
                    </div>
                `;
                return;
            }

            // Add header with segment count
            const headerDiv = document.createElement('div');
            headerDiv.innerHTML = `
                <div style="background: #f8f9fa; padding: 15px; margin-bottom: 15px; border-radius: 8px; border: 1px solid #e9ecef;">
                    <h4 style="margin: 0; color: #495057;">
                        🎵 קטעי השיחה (${mp3Files.length})
                    </h4>
                    <div style="font-size: 0.9rem; color: #6c757d; margin-top: 5px;">
                        לחץ על קטע כדי לערוך את הפרמטרים שלו
                    </div>
                </div>
            `;
            container.appendChild(headerDiv);

            // Create segment elements
            mp3Files.forEach((mp3File, index) => {
                const segment = emotionData[mp3File];
                if (!segment) {
                    console.warn(`⚠️ No segment data found for ${mp3File}`);
                    return;
                }
                
                const segmentDiv = createSegmentElement(segment, index);
                container.appendChild(segmentDiv);
            });
            
            console.log(`✅ Successfully displayed ${mp3Files.length} segments in UI`);
            
            // Populate all emotion dropdowns after segments are displayed and sync all UI elements
            setTimeout(() => {
                populateAllEmotionDropdowns();
                
                // ✅ COMPREHENSIVE SYNC: Ensure all segments' UI elements are synchronized after display
                mp3Files.forEach(mp3File => {
                    if (emotionData[mp3File]) {
                        // Apply AI constraints before sync
                        applyAIConstraintsToSegment(mp3File);
                        syncAllSegmentElements(mp3File);
                    }
                });
                
                // ✨ Initialize enhanced sliders after segments are displayed
                initializeEnhancedSliders();
            }, 100);
        }

        function createSegmentElement(segment, index) {
            const mp3Files = Object.keys(emotionData || {}).filter(key => key.endsWith('.mp3')).sort((a, b) => {
                try {
                    return a.localeCompare(b, 'he', { numeric: true });
                } catch(e) {
                    return a > b ? 1 : -1;
                }
            });
            const mp3File = mp3Files[index];
            
            if (!mp3File) {
                console.error(`❌ No MP3 file found at index ${index}`);
                return document.createElement('div');
            }
            
            const div = document.createElement('div');
            div.className = 'segment-item';
            div.id = `segment-${mp3File}`;
            
            const speakerClass = `speaker-${segment.speaker || 0}`;
            const emotions = segment.emotions || ['neutral'];
            const isAIAnalyzed = segment.ai_analyzed || false;
            const transcript = segment.transcript || segment.words || '';
            
            // Create emotion display with proper names from emotions config
            const emotionDisplay = emotions.map(e => {
                const config = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                const emoji = config.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                const hebrew = config.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                return emoji ? `${emoji} ${hebrew}` : hebrew;
            }).join(', ');
            
            // Create effects display
            const effects = [];
            if (segment.blur > 0) effects.push(`🌫️ טשטוש: ${segment.blur}`);
            if (segment.humor > 0) effects.push(`😄 הומור: ${segment.humor}`);
            if (segment.shine > 0) effects.push(`✨ ברק: ${segment.shine}`);
            
            // Get all available emotions for dropdown
            const allEmotions = emotionsConfig ? 
                Object.keys(emotionsConfig).filter(emotion => emotionsConfig[emotion].active) :
                ['happiness', 'sadness', 'anger', 'fear', 'surprise', 'disgust', 'neutral', 'curiosity', 'excitement'];
            
            const emotionOptions = allEmotions.map(emotion => {
                const config = (emotionsConfig && emotionsConfig[emotion]) || {};
                const displayName = config.hebrew ? `${config.emoji || ''} ${config.hebrew}` : emotion;
                return `<option value="${emotion}">${displayName}</option>`;
            }).join('');
            
            div.innerHTML = `
                <div class="enhanced-segment-card" style="background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%); border: 2px solid #e9ecef; border-radius: 12px; margin-bottom: 12px; overflow: hidden; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); position: relative; box-shadow: 0 2px 8px rgba(0,0,0,0.04);">
                    
                    <!-- Header Section -->
                    <div class="segment-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 1.1rem; font-weight: 600;">🎵 ${mp3File}</span>
                                <div class="speaker-selector" style="display: flex; align-items: center; gap: 6px;">
                                    <span style="font-size: 0.85rem; opacity: 0.9;">דובר:</span>
                                    <select onchange="updateParam('${mp3File}', 'speaker', this.value); updateSpeakerIndicator('${mp3File}', this.value)" 
                                            onclick="event.stopPropagation()"
                                            style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; color: white; padding: 4px 8px; font-size: 0.85rem; cursor: pointer; outline: none; transition: all 0.2s ease;">
                                                                        <option value="0" ${segment.speaker === 0 ? 'selected' : ''} style="color: #333;">${getSpeakerName(0)}</option>
                                <option value="1" ${segment.speaker === 1 ? 'selected' : ''} style="color: #333;">${getSpeakerName(1)}</option>
                                    </select>
                                                                          <span class="speaker-indicator" id="speaker-indicator-${mp3File}" style="display: inline-block; width: 14px; height: 14px; border-radius: 50%; background: ${segment.speaker === 1 ? '#4ECDC4' : '#FF6B6B'}; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.2);" title="${getSpeakerName(segment.speaker || 0)}"></span>
                                </div>
                            </div>
                            ${isAIAnalyzed ? '<span title="נותח על ידי AI" style="background: rgba(76, 175, 80, 0.2); padding: 4px 8px; border-radius: 8px; font-size: 0.8rem; display: flex; align-items: center; gap: 4px;"><span>🤖</span> AI</span>' : '<span style="background: rgba(158, 158, 158, 0.2); padding: 4px 8px; border-radius: 8px; font-size: 0.8rem; display: flex; align-items: center; gap: 4px;"><span>⚙️</span> Manual</span>'}
                        </div>
                        <div style="display: flex; gap: 6px; align-items: center;">
                            <button onclick="event.stopPropagation(); selectSegment('${mp3File}', emotionData['${mp3File}'])" 
                                    style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 6px 10px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;"
                                    onmouseover="this.style.background='rgba(255,255,255,0.3)'"
                                    onmouseout="this.style.background='rgba(255,255,255,0.2)'"
                                    title="עריכה מתקדמת">
                                <span>🔧</span> מתקדם
                            </button>
                            <button onclick="event.stopPropagation(); playSegmentAudio('${mp3File}')" 
                                    style="background: rgba(23, 162, 184, 0.8); border: none; color: white; padding: 6px 10px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;"
                                    onmouseover="this.style.background='rgba(23, 162, 184, 1)'"
                                    onmouseout="this.style.background='rgba(23, 162, 184, 0.8)'"
                                    title="השמע קטע זה">
                                <span>▶️</span> נגן
                            </button>
                        </div>
                    </div>
                    
                    <!-- Content Section -->
                    <div class="segment-content" style="padding: 16px;">
                        
                        <!-- Inline Editable Transcript -->
                        <div class="transcript-section" style="margin-bottom: 16px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <span style="font-weight: 600; color: #495057; font-size: 0.9rem;">📝 טקסט:</span>
                                <span style="font-size: 0.8rem; color: #6c757d; opacity: 0.8;">לחץ לעריכה</span>
                            </div>
                            <div class="editable-transcript" 
                                 contenteditable="true"
                                 data-mp3="${mp3File}"
                                 onblur="updateTranscript('${mp3File}', this.textContent.trim())"
                                 oninput="markTranscriptAsModified('${mp3File}', this)"
                                 onkeydown="handleTranscriptKeydown(event, '${mp3File}')"
                                 onclick="event.stopPropagation()"
                                 placeholder="הקלד כאן את הטרנסקריפט..."
                                 style="background: #f8f9fa; border: 2px solid #e9ecef; border-radius: 8px; padding: 12px; min-height: 60px; font-size: 0.9rem; line-height: 1.4; direction: rtl; text-align: right; transition: all 0.2s ease; cursor: text; color: #495057;"
                                 onfocus="this.style.borderColor='#667eea'; this.style.background='#fff'; this.style.boxShadow='0 0 0 3px rgba(102, 126, 234, 0.1)'"
                                 onblur="this.style.borderColor='#e9ecef'; this.style.background='#f8f9fa'; this.style.boxShadow='none'">${transcript}</div>
                            <div class="transcript-status" id="transcript-status-${mp3File}" style="font-size: 0.75rem; color: #28a745; margin-top: 4px; opacity: 0; transition: opacity 0.2s ease;"></div>
                        </div>
                        
                        <!-- Emotions Display -->
                        ${emotions.length > 0 ? `
                        <div style="margin-bottom: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <span style="font-weight: 600; color: #495057; font-size: 0.9rem;">🎭 רגשות:</span>
                            </div>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                ${emotions.map(e => {
                                    const config = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                                    const color = config.color || DEFAULT_EMOTIONS[e]?.color || '#667eea';
                                    const emoji = config.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                                    const hebrew = config.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                                    return `<span style="background: linear-gradient(135deg, ${color}20, ${color}10); border: 1px solid ${color}40; color: ${color}; padding: 4px 8px; border-radius: 6px; font-size: 0.8rem; display: flex; align-items: center; gap: 4px;">${emoji} ${hebrew}</span>`;
                                }).join('')}
                            </div>
                        </div>` : ''}
                        
                        <!-- Effects Display -->
                        ${effects.length > 0 ? `
                        <div style="margin-bottom: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <span style="font-weight: 600; color: #495057; font-size: 0.9rem;">🎨 אפקטים:</span>
                            </div>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                ${effects.map(effect => `<span style="background: linear-gradient(135deg, #17a2b820, #17a2b810); border: 1px solid #17a2b840; color: #17a2b8; padding: 4px 8px; border-radius: 6px; font-size: 0.8rem;">${effect}</span>`).join('')}
                            </div>
                        </div>` : ''}
                        
                        <!-- Inline Parameter Editor -->
                        <div style="margin-bottom: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <span style="font-weight: 600; color: #495057; font-size: 0.9rem;">⚙️ פרמטרים:</span>
                                <span style="font-size: 0.75rem; color: #6c757d; opacity: 0.8;">בחירה מהירה</span>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                <!-- Blob Size -->
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">🔵 גודל Blob:</span>
                                    <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                        <select id="blob-size-${mp3File}" 
                                                class="modern-select-compact"
                                                onchange="updateParam('${mp3File}', 'blobSizeScale', this.value); showDropdownFeedback('${mp3File}', 'גודל Blob');"
                                                onclick="event.stopPropagation()"
                                                style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                            <option value="0.5" ${(segment.blobSizeScale || 3) == 0.5 ? 'selected' : ''}>0.5 - קטן מאוד</option>
                                            <option value="1" ${(segment.blobSizeScale || 3) == 1 ? 'selected' : ''}>1.0 - קטן</option>
                                            <option value="1.5" ${(segment.blobSizeScale || 3) == 1.5 ? 'selected' : ''}>1.5 - קטן-בינוני</option>
                                            <option value="2" ${(segment.blobSizeScale || 3) == 2 ? 'selected' : ''}>2.0 - בינוני קטן</option>
                                            <option value="3" ${(segment.blobSizeScale || 3) == 3 ? 'selected' : ''}>3.0 - בינוני</option>
                                            <option value="4" ${(segment.blobSizeScale || 3) == 4 ? 'selected' : ''}>4.0 - בינוני גדול</option>
                                            <option value="5" ${(segment.blobSizeScale || 3) == 5 ? 'selected' : ''}>5.0 - גדול</option>
                                            <option value="6" ${(segment.blobSizeScale || 3) == 6 ? 'selected' : ''}>6.0 - גדול מאוד</option>
                                            <option value="7" ${(segment.blobSizeScale || 3) == 7 ? 'selected' : ''}>7.0 - ענק</option>
                                            <option value="8" ${(segment.blobSizeScale || 3) == 8 ? 'selected' : ''}>8.0 - מקסימלי</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <!-- Emotion Char Size -->
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">🎭 תו רגש:</span>
                                    <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                        <select id="emotion-char-size-${mp3File}" 
                                                class="modern-select-compact"
                                                onchange="updateParam('${mp3File}', 'coloredCircleCharSize', this.value); showDropdownFeedback('${mp3File}', 'תו רגש');"
                                                onclick="event.stopPropagation()"
                                                style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                            <option value="0.8" ${(segment.coloredCircleCharSize || 1.2) == 0.8 ? 'selected' : ''}>0.8 - זעיר</option>
                                            <option value="1.0" ${(segment.coloredCircleCharSize || 1.2) == 1.0 ? 'selected' : ''}>1.0 - קטן</option>
                                            <option value="1.2" ${(segment.coloredCircleCharSize || 1.2) == 1.2 ? 'selected' : ''}>1.2 - רגיל</option>
                                            <option value="1.5" ${(segment.coloredCircleCharSize || 1.2) == 1.5 ? 'selected' : ''}>1.5 - בינוני</option>
                                            <option value="2.0" ${(segment.coloredCircleCharSize || 1.2) == 2.0 ? 'selected' : ''}>2.0 - גדול</option>
                                            <option value="3.0" ${(segment.coloredCircleCharSize || 1.2) == 3.0 ? 'selected' : ''}>3.0 - גדול מאוד</option>
                                            <option value="4.0" ${(segment.coloredCircleCharSize || 1.2) == 4.0 ? 'selected' : ''}>4.0 - ענק</option>
                                            <option value="5.0" ${(segment.coloredCircleCharSize || 1.2) == 5.0 ? 'selected' : ''}>5.0 - ענקי</option>
                                            <option value="6.0" ${(segment.coloredCircleCharSize || 1.2) == 6.0 ? 'selected' : ''}>6.0 - מסיבי</option>
                                            <option value="8.0" ${(segment.coloredCircleCharSize || 1.2) == 8.0 ? 'selected' : ''}>8.0 - מקסימלי</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <!-- Regular Char Size -->
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">📝 תו רגיל:</span>
                                    <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                        <select id="regular-char-size-${mp3File}" 
                                                class="modern-select-compact"
                                                onchange="updateParam('${mp3File}', 'regularAsciiCharSize', this.value); showDropdownFeedback('${mp3File}', 'תו רגיל');"
                                                onclick="event.stopPropagation()"
                                                style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                            <option value="0.5" ${(segment.regularAsciiCharSize || 1.0) == 0.5 ? 'selected' : ''}>0.5 - זעיר</option>
                                            <option value="0.8" ${(segment.regularAsciiCharSize || 1.0) == 0.8 ? 'selected' : ''}>0.8 - קטן מאוד</option>
                                            <option value="1.0" ${(segment.regularAsciiCharSize || 1.0) == 1.0 ? 'selected' : ''}>1.0 - רגיל</option>
                                            <option value="1.2" ${(segment.regularAsciiCharSize || 1.0) == 1.2 ? 'selected' : ''}>1.2 - בינוני קטן</option>
                                            <option value="1.5" ${(segment.regularAsciiCharSize || 1.0) == 1.5 ? 'selected' : ''}>1.5 - בינוני</option>
                                            <option value="2.0" ${(segment.regularAsciiCharSize || 1.0) == 2.0 ? 'selected' : ''}>2.0 - גדול</option>
                                            <option value="3.0" ${(segment.regularAsciiCharSize || 1.0) == 3.0 ? 'selected' : ''}>3.0 - גדול מאוד</option>
                                            <option value="4.0" ${(segment.regularAsciiCharSize || 1.0) == 4.0 ? 'selected' : ''}>4.0 - ענק</option>
                                            <option value="5.0" ${(segment.regularAsciiCharSize || 1.0) == 5.0 ? 'selected' : ''}>5.0 - ענקי</option>
                                            <option value="6.0" ${(segment.regularAsciiCharSize || 1.0) == 6.0 ? 'selected' : ''}>6.0 - מקסימלי</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <!-- Emotion Amount -->
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">🎨 כמות רגש:</span>
                                    <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                        <select id="emotion-amount-${mp3File}" 
                                                class="modern-select-compact"
                                                onchange="updateParam('${mp3File}', 'emotionCharAmount', this.value); showDropdownFeedback('${mp3File}', 'כמות רגש');"
                                                onclick="event.stopPropagation()"
                                                style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                            <option value="10" ${(segment.emotionCharAmount || 50) == 10 ? 'selected' : ''}>10% - מינימלי</option>
                                            <option value="25" ${(segment.emotionCharAmount || 50) == 25 ? 'selected' : ''}>25% - קטן</option>
                                            <option value="40" ${(segment.emotionCharAmount || 50) == 40 ? 'selected' : ''}>40% - בינוני נמוך</option>
                                            <option value="50" ${(segment.emotionCharAmount || 50) == 50 ? 'selected' : ''}>50% - בינוני</option>
                                            <option value="75" ${(segment.emotionCharAmount || 50) == 75 ? 'selected' : ''}>75% - גבוה</option>
                                            <option value="100" ${(segment.emotionCharAmount || 50) == 100 ? 'selected' : ''}>100% - גבוה מאוד</option>
                                            <option value="125" ${(segment.emotionCharAmount || 50) == 125 ? 'selected' : ''}>125% - אינטנסיבי</option>
                                            <option value="150" ${(segment.emotionCharAmount || 50) == 150 ? 'selected' : ''}>150% - קיצוני</option>
                                            <option value="200" ${(segment.emotionCharAmount || 50) == 200 ? 'selected' : ''}>200% - מרבי</option>
                                            <option value="300" ${(segment.emotionCharAmount || 50) == 300 ? 'selected' : ''}>300% - מקסימלי</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Visual Effects Section -->
                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e9ecef;">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="font-weight: 600; color: #495057; font-size: 0.9rem;">🎨 אפקטים ויזואליים:</span>
                                    <span style="font-size: 0.75rem; color: #6c757d; opacity: 0.8;">בקרה מתקדמת</span>
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                    <!-- Blobiness -->
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">🫧 Blobiness:</span>
                                        <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                            <select id="blobiness-${mp3File}" 
                                                    class="modern-select-compact"
                                                    onchange="updateParam('${mp3File}', 'blobiness', this.value); showDropdownFeedback('${mp3File}', 'Blobiness');"
                                                    onclick="event.stopPropagation()"
                                                    style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                                <option value="1.0" ${(segment.blobiness || 3.5) == 1.0 ? 'selected' : ''}>1.0 - חד</option>
                                                <option value="1.5" ${(segment.blobiness || 3.5) == 1.5 ? 'selected' : ''}>1.5 - קשיח</option>
                                                <option value="2.0" ${(segment.blobiness || 3.5) == 2.0 ? 'selected' : ''}>2.0 - מוצק</option>
                                                <option value="2.5" ${(segment.blobiness || 3.5) == 2.5 ? 'selected' : ''}>2.5 - קל רך</option>
                                                <option value="3.0" ${(segment.blobiness || 3.5) == 3.0 ? 'selected' : ''}>3.0 - רך</option>
                                                <option value="3.5" ${(segment.blobiness || 3.5) == 3.5 ? 'selected' : ''}>3.5 - רגיל</option>
                                                <option value="4.0" ${(segment.blobiness || 3.5) == 4.0 ? 'selected' : ''}>4.0 - נוזלי</option>
                                                <option value="5.0" ${(segment.blobiness || 3.5) == 5.0 ? 'selected' : ''}>5.0 - נוזלי מאוד</option>
                                                <option value="6.0" ${(segment.blobiness || 3.5) == 6.0 ? 'selected' : ''}>6.0 - זורם</option>
                                                <option value="8.0" ${(segment.blobiness || 3.5) == 8.0 ? 'selected' : ''}>8.0 - נוזל קיצוני</option>
                                                <option value="10.0" ${(segment.blobiness || 3.5) == 10.0 ? 'selected' : ''}>10.0 - מקסימלי</option>
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <!-- Humor -->
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">😄 הומור:</span>
                                        <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                            <select id="humor-${mp3File}" 
                                                    class="modern-select-compact"
                                                    onchange="updateParam('${mp3File}', 'humor', this.value); showDropdownFeedback('${mp3File}', 'הומור');"
                                                    onclick="event.stopPropagation()"
                                                    style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                                <option value="0" ${(segment.humor || 0) == 0 ? 'selected' : ''}>0 - ללא</option>
                                                <option value="1" ${(segment.humor || 0) == 1 ? 'selected' : ''}>1 - מעט</option>
                                                <option value="2" ${(segment.humor || 0) == 2 ? 'selected' : ''}>2 - קל</option>
                                                <option value="3" ${(segment.humor || 0) == 3 ? 'selected' : ''}>3 - בינוני</option>
                                                <option value="4" ${(segment.humor || 0) == 4 ? 'selected' : ''}>4 - טוב</option>
                                                <option value="5" ${(segment.humor || 0) == 5 ? 'selected' : ''}>5 - גבוה</option>
                                                <option value="6" ${(segment.humor || 0) == 6 ? 'selected' : ''}>6 - מצחיק</option>
                                                <option value="7" ${(segment.humor || 0) == 7 ? 'selected' : ''}>7 - מאוד מצחיק</option>
                                                <option value="8" ${(segment.humor || 0) == 8 ? 'selected' : ''}>8 - הילריטי</option>
                                                <option value="9" ${(segment.humor || 0) == 9 ? 'selected' : ''}>9 - קומדיה</option>
                                                <option value="10" ${(segment.humor || 0) == 10 ? 'selected' : ''}>10 - מקסימלי</option>
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <!-- Blur (טשטוש) -->
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">🌫️ טשטוש:</span>
                                        <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                            <select id="blur-${mp3File}" 
                                                    class="modern-select-compact"
                                                    onchange="updateParam('${mp3File}', 'blur', this.value); showDropdownFeedback('${mp3File}', 'טשטוש');"
                                                    onclick="event.stopPropagation()"
                                                    style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                                <option value="0" ${(segment.blur || 0) == 0 ? 'selected' : ''}>0 - ללא</option>
                                                <option value="1" ${(segment.blur || 0) == 1 ? 'selected' : ''}>1 - מעט</option>
                                                <option value="2" ${(segment.blur || 0) == 2 ? 'selected' : ''}>2 - קל</option>
                                                <option value="3" ${(segment.blur || 0) == 3 ? 'selected' : ''}>3 - בינוני נמוך</option>
                                                <option value="4" ${(segment.blur || 0) == 4 ? 'selected' : ''}>4 - בינוני</option>
                                                <option value="5" ${(segment.blur || 0) == 5 ? 'selected' : ''}>5 - בינוני גבוה</option>
                                                <option value="6" ${(segment.blur || 0) == 6 ? 'selected' : ''}>6 - מטושטש</option>
                                                <option value="7" ${(segment.blur || 0) == 7 ? 'selected' : ''}>7 - מאוד מטושטש</option>
                                                <option value="8" ${(segment.blur || 0) == 8 ? 'selected' : ''}>8 - חלומי</option>
                                                <option value="10" ${(segment.blur || 0) == 10 ? 'selected' : ''}>10 - קיצוני</option>
                                                <option value="12" ${(segment.blur || 0) == 12 ? 'selected' : ''}>12 - מקסימלי</option>
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <!-- Shine (ברק) -->
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <span style="font-size: 0.8rem; color: #495057; min-width: 80px;">✨ ברק:</span>
                                        <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                                            <select id="shine-${mp3File}" 
                                                    class="modern-select-compact"
                                                    onchange="updateParam('${mp3File}', 'shine', this.value); showDropdownFeedback('${mp3File}', 'ברק');"
                                                    onclick="event.stopPropagation()"
                                                    style="flex: 1; padding: 4px 8px; border: 1px solid #e9ecef; border-radius: 4px; background: #fff; font-size: 0.8rem; color: #495057;">
                                                <option value="0" ${(segment.shine || 0) == 0 ? 'selected' : ''}>0 - ללא</option>
                                                <option value="1" ${(segment.shine || 0) == 1 ? 'selected' : ''}>1 - נצנוץ</option>
                                                <option value="2" ${(segment.shine || 0) == 2 ? 'selected' : ''}>2 - קל</option>
                                                <option value="3" ${(segment.shine || 0) == 3 ? 'selected' : ''}>3 - בינוני</option>
                                                <option value="4" ${(segment.shine || 0) == 4 ? 'selected' : ''}>4 - בוהק</option>
                                                <option value="5" ${(segment.shine || 0) == 5 ? 'selected' : ''}>5 - מבריק</option>
                                                <option value="6" ${(segment.shine || 0) == 6 ? 'selected' : ''}>6 - זוהר</option>
                                                <option value="7" ${(segment.shine || 0) == 7 ? 'selected' : ''}>7 - מזהיר</option>
                                                <option value="8" ${(segment.shine || 0) == 8 ? 'selected' : ''}>8 - מסנוור</option>
                                                <option value="9" ${(segment.shine || 0) == 9 ? 'selected' : ''}>9 - קיצוני</option>
                                                <option value="10" ${(segment.shine || 0) == 10 ? 'selected' : ''}>10 - מקסימלי</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                <div id="visual-effects-status-${mp3File}" style="font-size: 0.7rem; color: #28a745; margin-top: 4px; opacity: 0; transition: opacity 0.2s ease;">✨ אפקטים עודכנו</div>
                            </div>
                            <div id="param-status-${mp3File}" style="font-size: 0.7rem; color: #28a745; margin-top: 4px; opacity: 0; transition: opacity 0.2s ease;">✅ פרמטרים עודכנו</div>
                            <div style="font-size: 0.75rem; color: #6c757d; margin-top: 4px; padding: 4px 8px; background: #f8f9fa; border-radius: 4px;">
                                <i class="material-icons" style="font-size: 12px; vertical-align: text-bottom;">info</i>
                                בחר מהרשימה לשינוי מהיר או השתמש בעורך המתקדם
                            </div>
                        </div>
                        
                        <!-- Quick Actions -->
                        <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 12px; border-top: 1px solid #e9ecef;">
                            <div style="display: flex; gap: 8px;">
                                <button onclick="event.stopPropagation(); completeAIAnalysis('${mp3File}')" 
                                        style="background: linear-gradient(135deg, #28a745, #20c997); color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;"
                                        onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(40, 167, 69, 0.3)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'"
                                        title="ניתוח מלא עם AI">
                                    <span>🤖</span> ניתוח AI
                                </button>
                                <button onclick="event.stopPropagation(); transcribeAndAnalyzeSegment('${mp3File}')" 
                                        style="background: linear-gradient(135deg, #fd7e14, #ffc107); color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;"
                                        onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(253, 126, 20, 0.3)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'"
                                        title="תמלול + ניתוח מלא עם AI">
                                    <span>🎤🤖</span> תמלול+AI
                                </button>
                                <button onclick="event.stopPropagation(); toggleSegmentLoop('${mp3File}')" 
                                        style="background: linear-gradient(135deg, #6f42c1, #e83e8c); color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;"
                                        onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(111, 66, 193, 0.3)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'"
                                        title="לולאה רציפה"
                                        id="loop-btn-${mp3File}">
                                    <span>🔁</span> לולאה
                                </button>
                            </div>
                            <div style="font-size: 0.75rem; color: #6c757d;">
                                <span id="save-indicator-${mp3File}" style="opacity: 0; transition: opacity 0.2s ease;">💾 נשמר</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add enhanced hover effects
            div.addEventListener('mouseenter', () => {
                const card = div.querySelector('.enhanced-segment-card');
                card.style.transform = 'translateY(-4px)';
                card.style.boxShadow = '0 8px 25px rgba(102, 126, 234, 0.15)';
                card.style.borderColor = '#667eea';
            });
            
            div.addEventListener('mouseleave', () => {
                const card = div.querySelector('.enhanced-segment-card');
                card.style.transform = 'translateY(0)';
                card.style.boxShadow = '0 2px 8px rgba(0,0,0,0.04)';
                card.style.borderColor = '#e9ecef';
            });
            
            return div;
        }
        
        // Helper functions for enhanced segment functionality
        function updateSpeakerIndicator(mp3File, speakerValue) {
            const indicator = document.getElementById(`speaker-indicator-${mp3File}`);
            if (indicator) {
                indicator.style.background = speakerValue == 1 ? '#4ECDC4' : '#FF6B6B';
                indicator.title = `דובר ${parseInt(speakerValue) + 1}`;
            }
            
            // Show save indicator
            showSaveIndicator(mp3File);
        }
        
        function markTranscriptAsModified(mp3File, element) {
            // Add visual feedback for unsaved changes
            element.style.borderColor = '#ffc107';
            element.style.background = '#fff9e6';
            
            // Clear any existing timeout
            if (element.saveTimeout) {
                clearTimeout(element.saveTimeout);
            }
            
            // Set a timeout to auto-save after user stops typing
            element.saveTimeout = setTimeout(() => {
                updateTranscript(mp3File, element.textContent.trim());
                element.style.borderColor = '#28a745';
                element.style.background = '#f0f9f0';
                showSaveIndicator(mp3File);
                
                // Reset to normal after a moment
                setTimeout(() => {
                    element.style.borderColor = '#e9ecef';
                    element.style.background = '#f8f9fa';
                }, 1500);
            }, 1000);
        }
        
        function handleTranscriptKeydown(event, mp3File) {
            // Save on Ctrl+Enter or Cmd+Enter
            if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                event.preventDefault();
                const element = event.target;
                updateTranscript(mp3File, element.textContent.trim());
                element.blur();
                showSaveIndicator(mp3File);
            }
        }
        
        function showSaveIndicator(mp3File) {
            const indicator = document.getElementById(`save-indicator-${mp3File}`);
            if (indicator) {
                indicator.style.opacity = '1';
                setTimeout(() => {
                    indicator.style.opacity = '0';
                }, 2000);
            }
        }

        function createSegmentContent(segment, index) {
            const mp3File = Object.keys(emotionData).filter(key => key.endsWith('.mp3'))[index];
            const emotions = segment.emotions || [];
            
            // Create emotion tags with colors from emotions management
            const emotionTags = emotions.map((e, i) => {
                // Ensure we have emotions config loaded, fallback to DEFAULT_EMOTIONS
                const emotionConfig = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                const color = emotionConfig.color || DEFAULT_EMOTIONS[e]?.color || '#e3f2fd';
                const emoji = emotionConfig.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                const hebrew = emotionConfig.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                
                return `
                    <div class="emotion-tag" style="background-color: ${color}15; border: 1px solid ${color}; color: ${color};">
                        ${emoji} ${hebrew}
                        <button class="remove-btn" onclick="removeEmotion('${mp3File}', ${i})">×</button>
                    </div>
                `;
            }).join('');
            
            // Get all available emotions from emotions config, with fallback
            const allEmotions = emotionsConfig ? 
                Object.keys(emotionsConfig).filter(emotion => emotionsConfig[emotion].active) :
                ['happiness', 'sadness', 'anger', 'fear', 'surprise', 'disgust', 'neutral', 'curiosity', 'excitement'];
            
            const emotionOptions = allEmotions.map(emotion => {
                const config = (emotionsConfig && emotionsConfig[emotion]) || {};
                const displayName = config.hebrew ? `${config.emoji} ${config.hebrew}` : emotion;
                return `<option value="${emotion}">${displayName}</option>`;
            }).join('');

            return `
                <!-- Enhanced Transcript Editor -->
                <div class="transcript-section">
                    <h4>📝 טרנסקריפט</h4>
                    <div class="transcript-box" contenteditable="true" 
                         onblur="updateTranscript('${mp3File}', this.textContent)"
                         oninput="markTranscriptChanged('${mp3File}')"
                         placeholder="הקלד כאן את הטרנסקריפט..."
                         style="direction: rtl;">${segment.transcript || segment.words || ''}</div>
                    <div class="transcript-actions">
                        <button class="btn btn-sm" onclick="clearTranscript('${mp3File}')">🗑️ נקה</button>
                        <button class="btn btn-sm" onclick="capitalizeTranscript('${mp3File}')">🔤 אותיות גדולות</button>
                        <span class="transcript-status" id="transcript-status-${mp3File}"></span>
                    </div>
                </div>
                
                <div style="margin-bottom: 1rem;">
                    <label>רגשות:</label>
                    <div class="emotion-tags">
                        ${emotionTags}
                    </div>
                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                        <select id="emotion-select-${mp3File}">
                            <option value="">בחר רגש...</option>
                            <!-- Options will be populated by JavaScript -->
                        </select>
                        <button class="btn btn-secondary btn-sm" onclick="addEmotion('${mp3File}')">
                            <i class="material-icons">add</i>
                            הוסף
                        </button>
                    </div>
                </div>
                
                <!-- Character Size Controls -->
                <div style="background: #f0f8ff; border: 1px solid #b3d9ff; border-radius: 6px; padding: 15px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #0066cc; font-size: 14px;">📝 גדלי תווים</h4>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                        <div>
                            <label>גודל תו רגיל:</label>
                            <input type="number" 
                                   value="${segment.regularAsciiCharSize || 0.25}" 
                                   step="0.05" min="0.1" max="3"
                                   onchange="updateParam('${mp3File}', 'regularAsciiCharSize', this.value)">
                        </div>
                        <div>
                            <label>גודל תו רגש:</label>
                            <input type="number" 
                                   value="${segment.coloredCircleCharSize || 0.25}" 
                                   step="0.05" min="0.1" max="3"
                                   onchange="updateParam('${mp3File}', 'coloredCircleCharSize', this.value)">
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <label>כמות תווי רגש (0-200%):</label>
                        <input type="range" min="0" max="200" value="${segment.emotionCharAmount || 50}" 
                               onchange="updateParam('${mp3File}', 'emotionCharAmount', this.value); document.getElementById('emotion-amount-value-${mp3File}').textContent = this.value + '%';"
                               style="width: 100%; margin: 5px 0;">
                        <div style="text-align: center; font-size: 0.9rem; color: #666;">
                            <span id="emotion-amount-value-${mp3File}">${segment.emotionCharAmount || 50}%</span>
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <label>רזולוציית גריד (20-150):</label>
                        <input type="range" min="20" max="150" value="${segment.gridResolution || 50}" 
                               onchange="updateParam('${mp3File}', 'gridResolution', this.value); document.getElementById('grid-resolution-value-${mp3File}').textContent = this.value;"
                               style="width: 100%; margin: 5px 0;">
                        <div style="text-align: center; font-size: 0.9rem; color: #666;">
                            <span id="grid-resolution-value-${mp3File}">${segment.gridResolution || 50}</span> (נמוך=מהיר, גבוה=מפורט)
                        </div>
                    </div>
                </div>
                
                <!-- Main Parameters -->
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
                    <div>
                        <label>דובר:</label>
                        <select onchange="updateParam('${mp3File}', 'speaker', this.value)">
                                                                        <option value="0" ${segment.speaker === 0 ? 'selected' : ''}>${getSpeakerName(0)}</option>
                                            <option value="1" ${segment.speaker === 1 ? 'selected' : ''}>${getSpeakerName(1)}</option>
                        </select>
                    </div>
                    
                    <div>
                        <label>גודל Blob:</label>
                        <input type="number" 
                               value="${segment.blobSizeScale || 4}" 
                               step="0.5" min="1" max="20"
                               onchange="updateParam('${mp3File}', 'blobSizeScale', this.value)">
                    </div>
                    
                    <div>
                        <label>עוצמת Blob:</label>
                        <input type="number" 
                               value="${segment.blobStrength || 450}" 
                               step="50" min="100" max="5000"
                               onchange="updateParam('${mp3File}', 'blobStrength', this.value)">
                    </div>
                    
                    <div>
                        <label>השפעת עוצמה:</label>
                        <input type="number" 
                               value="${segment.volumeImpact || 3000}" 
                               step="50" min="3000" max="3000"
                               onchange="updateParam('${mp3File}', 'volumeImpact', this.value)">
                    </div>
                    
                    <div>
                        <label>טשטוש (blur):</label>
                        <input type="number" 
                               value="${segment.blur || 0}" 
                               step="1" min="0" max="12"
                               onchange="updateParam('${mp3File}', 'blur', this.value)">
                    </div>
                    
                    <div>
                        <label>הומור:</label>
                        <input type="number" 
                               value="${segment.humor || 0}" 
                               step="1" min="0" max="10"
                               onchange="updateParam('${mp3File}', 'humor', this.value)">
                    </div>
                    
                    <div>
                        <label>ברק (shine):</label>
                        <input type="number" 
                               value="${segment.shine || 0}" 
                               step="1" min="0" max="10"
                               onchange="updateParam('${mp3File}', 'shine', this.value)">
                    </div>
                    
                    <div>
                        <label>Blobiness:</label>
                        <input type="number" 
                               value="${segment.blobiness || 3.5}" 
                               step="0.5" min="1" max="10"
                               onchange="updateParam('${mp3File}', 'blobiness', this.value)">
                    </div>
                    
                    <div>
                        <label>אזור בית:</label>
                        <select onchange="updateParam('${mp3File}', 'blobHomeRegion', this.value)">
                            <option value="center-left" ${segment.blobHomeRegion === 'center-left' ? 'selected' : ''}>מרכז שמאל</option>
                            <option value="center-right" ${segment.blobHomeRegion === 'center-right' ? 'selected' : ''}>מרכז ימין</option>
                            <option value="center" ${segment.blobHomeRegion === 'center' ? 'selected' : ''}>מרכז</option>
                            <option value="top-center" ${segment.blobHomeRegion === 'top-center' ? 'selected' : ''}>מרכז עליון</option>
                            <option value="bottom-center" ${segment.blobHomeRegion === 'bottom-center' ? 'selected' : ''}>מרכז תחתון</option>
                            <option value="top-left" ${segment.blobHomeRegion === 'top-left' ? 'selected' : ''}>שמאל עליון</option>
                            <option value="top-right" ${segment.blobHomeRegion === 'top-right' ? 'selected' : ''}>ימין עליון</option>
                            <option value="bottom-left" ${segment.blobHomeRegion === 'bottom-left' ? 'selected' : ''}>שמאל תחתון</option>
                            <option value="bottom-right" ${segment.blobHomeRegion === 'bottom-right' ? 'selected' : ''}>ימין תחתון</option>
                        </select>
                    </div>
                    
                    <div>
                        <label>מרווח Blob:</label>
                        <select onchange="updateParam('${mp3File}', 'minBlobSpacing', this.value)">
                            <option value="together" ${segment.minBlobSpacing === 'together' ? 'selected' : ''}>יחד (0px)</option>
                            <option value="close" ${segment.minBlobSpacing === 'close' ? 'selected' : ''}>קרוב (300px)</option>
                            <option value="far away" ${segment.minBlobSpacing === 'far away' ? 'selected' : ''}>רחוק (900px)</option>
                        </select>
                    </div>
                    
                    <div>
                        <label>דפוס צמיחה:</label>
                        <select onchange="updateParam('${mp3File}', 'blobGrowthPattern', this.value)">
                            <option value="hesitant" ${segment.blobGrowthPattern === 'hesitant' ? 'selected' : ''}>מהסס</option>
                            <option value="steady" ${segment.blobGrowthPattern === 'steady' ? 'selected' : ''}>יציב</option>
                            <option value="explosive" ${segment.blobGrowthPattern === 'explosive' ? 'selected' : ''}>מתפרץ</option>
                            <option value="building" ${segment.blobGrowthPattern === 'building' ? 'selected' : ''}>בונה</option>
                            <option value="curious" ${segment.blobGrowthPattern === 'curious' ? 'selected' : ''}>סקרן</option>
                            <option value="playful" ${segment.blobGrowthPattern === 'playful' ? 'selected' : ''}>שובב</option>
                        </select>
                    </div>
                    
                    <div>
                        <label>חיבורים:</label>
                        <input type="checkbox" 
                               ${segment.connectBlobs ? 'checked' : ''}
                               onchange="updateParam('${mp3File}', 'connectBlobs', this.checked)">
                    </div>
                    
                    <div>
                        <label>נראות Blobs:</label>
                        <input type="checkbox" 
                               ${segment.blobsVisible !== false ? 'checked' : ''}
                               onchange="updateParam('${mp3File}', 'blobsVisible', this.checked)">
                    </div>
                </div>
                
                <!-- Individual Segment Visualization -->
                <div class="segment-visualization">
                    <h4>🎨 ויזואליזציה של הקטע</h4>
                    <div class="segment-viz-container">
                        <iframe id="segment-viz-${mp3File}" 
                                width="100%" 
                                height="150px" 
                                style="border: 2px solid #e0e0e0; border-radius: 8px; background: #f9f9f9; margin-bottom: 10px; display: none;"
                                onload="handleSegmentVizLoad('${mp3File}')"
                                onerror="handleSegmentVizError('${mp3File}')">
                        </iframe>
                        <button class="load-viz-btn" onclick="loadSegmentVisualization('${mp3File}')" 
                                style="width: 100%; height: 150px; border: 2px dashed #ccc; background: #f9f9f9; border-radius: 8px; cursor: pointer; color: #666;">
                            🎨 לחץ לטעינת ויזואליזציה
                        </button>
                    </div>
                    <div class="segment-viz-status" id="segment-viz-status-${mp3File}" style="font-size: 12px; color: #666;">
                        רגשות: ${emotions.join(', ')} | לחץ כדי לראות ויזואליזציה
                    </div>
                </div>
                
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
                    <button class="btn btn-secondary btn-sm" onclick="playSegment('${mp3File}')">
                        <i class="material-icons">play_arrow</i>
                        השמע
                    </button>
                    <button class="btn btn-secondary btn-sm loop-button" onclick="toggleLoop('${mp3File}')" id="loop-btn-${mp3File}" title="לולאה">
                        <i class="material-icons">loop</i>
                        לולאה
                    </button>
                </div>
            `;
        }

        function selectSegment(mp3File, segment) {
            // Update selected state in UI
            document.querySelectorAll('.segment-item').forEach(item => {
                item.classList.remove('active');
            });
            document.getElementById(`segment-${mp3File}`).classList.add('active');
            
            currentSelectedSegment = mp3File;
            
            // Show the segment editor panel
            document.getElementById('no-segment-selected').style.display = 'none';
            document.getElementById('segment-editor-panel').style.display = 'flex';
            
            // Load the segment content in the editor
            loadSegmentEditor(mp3File, segment);
            
            // Load the visualization for this segment
            loadSegmentVisualization(mp3File);
        }
        
        function loadSegmentEditor(mp3File, segment) {
            const editorContainer = document.getElementById('active-segment-editor');
            editorContainer.innerHTML = createSegmentEditorContent(mp3File, segment);
            
            // ✅ COMPREHENSIVE SYNC: Ensure all UI elements are synchronized when segment is loaded
            setTimeout(() => {
                // Apply AI constraints when loading segment
                applyAIConstraintsToSegment(mp3File);
                
                syncAllSegmentElements(mp3File);
                
                // ✨ Initialize enhanced sliders for this segment
                initializeEnhancedSliders();
            }, 100); // Small delay to ensure DOM is updated
        }

        /**
         * Apply AI analysis constraints to a segment to ensure consistency
         */
        function applyAIConstraintsToSegment(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            let hasChanges = false;
            const updates = {};
            
            // ✅ Blob size constraint: max 5
            if (segment.blobSizeScale && segment.blobSizeScale > 5) {
                updates.blobSizeScale = 5;
                updates.blob_size = 5;
                hasChanges = true;
                console.log(`🎯 Applied blob size constraint to ${mp3File}: ${segment.blobSizeScale} → 5`);
            }
            
            // ✅ Character size constraints: min 1.0
            if (segment.coloredCircleCharSize && segment.coloredCircleCharSize < 1.0) {
                updates.coloredCircleCharSize = 1.0;
                updates.godel_to_regesh = 1.0;
                hasChanges = true;
                console.log(`🎯 Applied emotion char size constraint to ${mp3File}: ${segment.coloredCircleCharSize} → 1.0`);
            }
            
            if (segment.regularAsciiCharSize && segment.regularAsciiCharSize < 1.0) {
                updates.regularAsciiCharSize = 1.0;
                updates.godel_to_regular = 1.0;
                hasChanges = true;
                console.log(`🎯 Applied regular char size constraint to ${mp3File}: ${segment.regularAsciiCharSize} → 1.0`);
            }
            
            // Apply updates if any constraints were violated
            if (hasChanges) {
                Object.assign(emotionData[mp3File], updates);
                console.log(`✅ Applied AI constraints to segment ${mp3File}`);
            }
        }

        /**
         * Apply AI constraints to all segments in the current conversation
         */
        function applyAIConstraintsToAllSegments() {
            console.log('🎯 Applying AI constraints to all segments...');
            let totalConstraintsApplied = 0;
            
            Object.keys(emotionData).forEach(mp3File => {
                const segment = emotionData[mp3File];
                if (!segment || !mp3File.endsWith('.mp3')) return;
                
                let constraintsApplied = 0;
                
                // Check and fix blob size
                if (segment.blobSizeScale && segment.blobSizeScale > 5) {
                    segment.blobSizeScale = 5;
                    segment.blob_size = 5;
                    constraintsApplied++;
                }
                
                // Check and fix character sizes
                if (segment.coloredCircleCharSize && segment.coloredCircleCharSize < 1.0) {
                    segment.coloredCircleCharSize = 1.0;
                    segment.godel_to_regesh = 1.0;
                    constraintsApplied++;
                }
                
                if (segment.regularAsciiCharSize && segment.regularAsciiCharSize < 1.0) {
                    segment.regularAsciiCharSize = 1.0;
                    segment.godel_to_regular = 1.0;
                    constraintsApplied++;
                }
                
                totalConstraintsApplied += constraintsApplied;
            });
            
            if (totalConstraintsApplied > 0) {
                console.log(`✅ Applied ${totalConstraintsApplied} AI constraints across all segments`);
                showStatus(`🎯 הוחלו ${totalConstraintsApplied} אילוצים חכמים על כל הקטעים`, 'info');
            }
        }

        /**
         * Standardize AI analysis behavior across all conversations and segments
         * Ensures consistent parameter ranges and constraints are applied everywhere
         */
        function standardizeAIAnalysisBehavior() {
            console.log('🎯 Standardizing AI analysis behavior across conversation...');
            
            // Apply constraints to all current segments
            applyAIConstraintsToAllSegments();
            
            // Ensure all dropdowns are initialized with proper values
            initializeDropdownValues();
            
            // Log the standardization
            const segmentCount = Object.keys(emotionData).filter(key => key.endsWith('.mp3')).length;
            console.log(`✅ Standardized AI behavior for ${segmentCount} segments with constraints: blobSize≤5, charSizes≥1.0`);
        }
        
        function createSegmentEditorContent(mp3File, segment) {
            const emotions = segment.emotions || [];
            
            // Create emotion tags with colors from emotions management
            const emotionTags = emotions.map((e, i) => {
                // Ensure we have emotions config loaded, fallback to DEFAULT_EMOTIONS
                const emotionConfig = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                const color = emotionConfig.color || DEFAULT_EMOTIONS[e]?.color || '#e3f2fd';
                const emoji = emotionConfig.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                const hebrew = emotionConfig.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                
                return `
                    <div class="emotion-tag" style="background-color: ${color}15; border: 1px solid ${color}; color: ${color};">
                        ${emoji} ${hebrew}
                        <button class="remove-btn" onclick="removeEmotion('${mp3File}', ${i})">×</button>
                    </div>
                `;
            }).join('');
            
            // Get all available emotions from emotions config, with fallback
            const allEmotions = emotionsConfig ? 
                Object.keys(emotionsConfig).filter(emotion => emotionsConfig[emotion].active) :
                ['happiness', 'sadness', 'anger', 'fear', 'surprise', 'disgust', 'neutral', 'curiosity', 'excitement'];
            
            const emotionOptions = allEmotions.map(emotion => {
                const config = (emotionsConfig && emotionsConfig[emotion]) || {};
                const displayName = config.hebrew ? `${config.emoji} ${config.hebrew}` : emotion;
                return `<option value="${emotion}">${displayName}</option>`;
            }).join('');

            return `
                <div class="modern-parameter-editor">
                    <div class="parameter-editor-header">
                        <h2 class="parameter-editor-title">
                            <i class="material-icons">edit</i>
                            עריכת ${mp3File}
                        </h2>
                        <p class="parameter-editor-subtitle">ערוך פרמטרים, רגשות ואפקטים ויזואליים</p>
                    </div>
                    
                    <div class="parameter-editor-body">
                        <!-- Transcript Section -->
                        <div class="parameter-section">
                            <div class="parameter-section-header" onclick="toggleParameterSection(this)">
                                <div class="parameter-section-title">
                                    <i class="material-icons">text_fields</i>
                                    טרנסקריפט ותוכן
                                </div>
                                <i class="material-icons parameter-section-toggle">expand_more</i>
                            </div>
                            <div class="parameter-section-body">
                                <div class="transcript-editor" contenteditable="true" 
                                     onblur="updateTranscript('${mp3File}', this.textContent)"
                                     oninput="markTranscriptChanged('${mp3File}')"
                                     placeholder="הקלד כאן את הטרנסקריפט...">${segment.transcript || segment.words || ''}</div>
                                <div class="transcript-actions">
                                    <button class="modern-btn modern-btn-secondary modern-btn-sm" onclick="clearTranscript('${mp3File}')">
                                        <i class="material-icons">clear</i> נקה
                                    </button>
                                    <button class="modern-btn modern-btn-secondary modern-btn-sm" onclick="capitalizeTranscript('${mp3File}')">
                                        <i class="material-icons">format_size</i> אותיות גדולות
                                    </button>
                                    <button class="modern-btn modern-btn-success modern-btn-sm" onclick="completeAIAnalysis('${mp3File}')">
                                        <i class="material-icons">psychology</i> ניתוח מלא עם AI
                                    </button>
                                    <span class="transcript-status" id="transcript-status-${mp3File}"></span>
                                </div>
                                <div style="font-size: 0.85rem; color: #6c757d; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 6px;">
                                    <i class="material-icons" style="font-size: 16px; vertical-align: text-bottom;">info</i>
                                    <strong>טיפ:</strong> ערוך את הטקסט ולחץ "ניתוח מלא עם AI" כדי לנתח את האודיו והטקסט ולעדכן את כל הפרמטרים
                                </div>
                            </div>
                        </div>
                
                        <!-- Emotions Section -->
                        <div class="parameter-section">
                            <div class="parameter-section-header" onclick="toggleParameterSection(this)">
                                <div class="parameter-section-title">
                                    <i class="material-icons">sentiment_satisfied</i>
                                    רגשות ומצב רוח
                                </div>
                                <i class="material-icons parameter-section-toggle">expand_more</i>
                            </div>
                            <div class="parameter-section-body">
                                <div class="parameter-item">
                                    <div class="parameter-label">
                                        רגשות נוכחיים
                                        <span class="parameter-help" title="ניתן להוסיף מספר רגשות">?</span>
                                    </div>
                                    <div class="emotion-tags" style="margin-bottom: 1rem;">
                                        ${emotionTags}
                                    </div>
                                    <div style="display: flex; gap: 0.5rem;">
                                        <select id="emotion-select-${mp3File}" class="modern-select" style="flex: 1;">
                                            <option value="">בחר רגש להוספה...</option>
                                            <!-- Options will be populated by JavaScript -->
                                        </select>
                                        <button class="modern-btn modern-btn-secondary modern-btn-sm" onclick="addEmotion('${mp3File}')">
                                            <i class="material-icons">add</i>
                                            הוסף
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Visual Effects Section -->
                        <div class="parameter-section">
                            <div class="parameter-section-header" onclick="toggleParameterSection(this)">
                                <div class="parameter-section-title">
                                    <i class="material-icons">auto_fix_high</i>
                                    אפקטים ויזואליים
                                </div>
                                <i class="material-icons parameter-section-toggle">expand_more</i>
                            </div>
                            <div class="parameter-section-body">
                                <div class="visual-effects-grid">
                                    <div class="effect-control">
                                        <div class="effect-control-label">🫧 Blobiness</div>
                                        <input type="range" min="1" max="10" step="0.5" value="${segment.blobiness || 3.5}" 
                                               class="enhanced-slider"
                                               oninput="updateParam('${mp3File}', 'blobiness', this.value); document.getElementById('blobiness-value-${mp3File}').textContent = this.value; updateSliderBackground(this); syncCardVisualEffects('${mp3File}');"
                                               data-color="#3498db"
                                               data-unit="">
                                        <div class="effect-value-display" id="blobiness-value-${mp3File}">${segment.blobiness || 3.5}</div>
                                    </div>
                                    <div class="effect-control">
                                        <div class="effect-control-label">🌫️ טשטוש</div>
                                        <input type="range" min="0" max="15" value="${segment.blur || 0}" 
                                               class="enhanced-slider"
                                               oninput="updateParam('${mp3File}', 'blur', this.value); document.getElementById('blur-value-${mp3File}').textContent = this.value; updateSliderBackground(this); syncCardVisualEffects('${mp3File}');"
                                               data-color="#9b59b6"
                                               data-unit="">
                                        <div class="effect-value-display" id="blur-value-${mp3File}">${segment.blur || 0}</div>
                                    </div>
                                    <div class="effect-control">
                                        <div class="effect-control-label">😄 הומור</div>
                                        <input type="range" min="0" max="15" value="${segment.humor || 0}" 
                                               class="enhanced-slider"
                                               oninput="updateParam('${mp3File}', 'humor', this.value); document.getElementById('humor-value-${mp3File}').textContent = this.value; updateSliderBackground(this); syncCardVisualEffects('${mp3File}');"
                                               data-color="#f39c12"
                                               data-unit="">
                                        <div class="effect-value-display" id="humor-value-${mp3File}">${segment.humor || 0}</div>
                                    </div>
                                    <div class="effect-control">
                                        <div class="effect-control-label">✨ ברק</div>
                                        <input type="range" min="0" max="15" value="${segment.shine || 0}" 
                                               class="enhanced-slider"
                                               oninput="updateParam('${mp3File}', 'shine', this.value); document.getElementById('shine-value-${mp3File}').textContent = this.value; updateSliderBackground(this); syncCardVisualEffects('${mp3File}');"
                                               data-color="#f1c40f"
                                               data-unit="">
                                        <div class="effect-value-display" id="shine-value-${mp3File}">${segment.shine || 0}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                
                        <!-- Character Sizes Section -->
                        <div class="parameter-section">
                            <div class="parameter-section-header" onclick="toggleParameterSection(this)">
                                <div class="parameter-section-title">
                                    <i class="material-icons">format_size</i>
                                    גדלי תווים ורזולוציה
                                </div>
                                <i class="material-icons parameter-section-toggle">expand_more</i>
                            </div>
                            <div class="parameter-section-body">
                                <div class="parameter-grid parameter-grid-2">
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            גודל תו רגיל
                                            <span class="parameter-help" title="גודל תווי ASCII רגילים">?</span>
                                        </div>
                                        <input type="number" 
                                               class="modern-input"
                                               value="${segment.regularAsciiCharSize || 0.25}" 
                                               step="0.05" min="0.1" max="3"
                                               onchange="updateParam('${mp3File}', 'regularAsciiCharSize', this.value)">
                                    </div>
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            גודל תו רגש
                                            <span class="parameter-help" title="גודל תווי רגש צבעוניים">?</span>
                                        </div>
                                        <input type="number" 
                                               class="modern-input"
                                               value="${segment.coloredCircleCharSize || 0.25}" 
                                               step="0.05" min="0.1" max="3"
                                               onchange="updateParam('${mp3File}', 'coloredCircleCharSize', this.value)">
                                    </div>
                                </div>
                                <div class="parameter-item">
                                    <div class="parameter-label">
                                        כמות תווי רגש
                                        <span class="range-value" id="emotion-char-amount-${mp3File}">${segment.emotionCharAmount || 50}%</span>
                                    </div>
                                    <input type="range" min="10" max="300" value="${segment.emotionCharAmount || 50}" 
                                           class="enhanced-slider"
                                           oninput="updateParam('${mp3File}', 'emotionCharAmount', this.value); document.getElementById('emotion-char-amount-${mp3File}').textContent = this.value + '%'; updateSliderBackground(this);"
                                           data-color="#e83e8c"
                                           data-unit="%">
                                </div>
                                <div class="parameter-item">
                                    <div class="parameter-label">
                                        רזולוציית גריד
                                        <span class="range-value" id="grid-res-${mp3File}">${segment.gridResolution || 50}</span>
                                    </div>
                                    <input type="range" min="15" max="200" value="${segment.gridResolution || 50}" 
                                           class="enhanced-slider"
                                           oninput="updateParam('${mp3File}', 'gridResolution', this.value); document.getElementById('grid-res-${mp3File}').textContent = this.value; updateSliderBackground(this);"
                                           data-color="#17a2b8"
                                           data-unit="">
                                    <div style="text-align: center; font-size: 0.8rem; color: #6c757d; margin-top: 0.5rem;">
                                        נמוך=מהיר, גבוה=מפורט
                                    </div>
                                </div>
                            </div>
                        </div>
                
                        <!-- Blob Parameters Section -->
                        <div class="parameter-section">
                            <div class="parameter-section-header" onclick="toggleParameterSection(this)">
                                <div class="parameter-section-title">
                                    <i class="material-icons">bubble_chart</i>
                                    פרמטרי Blob ואודיו
                                </div>
                                <i class="material-icons parameter-section-toggle">expand_more</i>
                            </div>
                            <div class="parameter-section-body">
                                <div class="parameter-grid parameter-grid-3">
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            דובר
                                            <span class="parameter-help" title="זיהוי דובר לצבע ומיקום">?</span>
                                        </div>
                                        <select class="modern-select" onchange="updateParam('${mp3File}', 'speaker', this.value)">
                                            <option value="0" ${segment.speaker === 0 ? 'selected' : ''}>${getSpeakerName(0)} (אדום)</option>
                                            <option value="1" ${segment.speaker === 1 ? 'selected' : ''}>${getSpeakerName(1)} (טורקיז)</option>
                                        </select>
                                    </div>
                                    
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            גודל Blob
                                            <span class="range-value" id="blob-size-scale-${mp3File}">${segment.blobSizeScale || 4}</span>
                                        </div>
                                        <input type="range" 
                                               class="enhanced-slider"
                                               value="${segment.blobSizeScale || 4}" 
                                               step="0.1" min="0.5" max="15"
                                               oninput="updateParam('${mp3File}', 'blobSizeScale', this.value); document.getElementById('blob-size-scale-${mp3File}').textContent = this.value; updateSliderBackground(this);"
                                               data-color="#667eea"
                                               data-unit="">
                                    </div>
                                    
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            עוצמת Blob
                                            <span class="range-value" id="blob-strength-${mp3File}">${segment.blobStrength || 450}</span>
                                        </div>
                                        <input type="range" 
                                               class="enhanced-slider"
                                               value="${segment.blobStrength || 450}" 
                                               step="25" min="50" max="2000"
                                               oninput="updateParam('${mp3File}', 'blobStrength', this.value); document.getElementById('blob-strength-${mp3File}').textContent = this.value; updateSliderBackground(this);"
                                               data-color="#e74c3c"
                                               data-unit="">
                                    </div>
                                    
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            השפעת עוצמה
                                            <span class="range-value" id="volume-impact-${mp3File}">${segment.volumeImpact || 3000}</span>
                                        </div>
                                        <input type="range" 
                                               class="enhanced-slider"
                                               value="${segment.volumeImpact || 3000}" 
                                               step="100" min="1000" max="6000"
                                               oninput="updateParam('${mp3File}', 'volumeImpact', this.value); document.getElementById('volume-impact-${mp3File}').textContent = this.value; updateSliderBackground(this);"
                                               data-color="#2ecc71"
                                               data-unit="">
                                    </div>
                                    
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            Blobiness
                                            <span class="parameter-help" title="רמת הנזילות והעיוות">?</span>
                                        </div>
                                        <input type="number" 
                                               class="modern-input"
                                               value="${segment.blobiness || 3.5}" 
                                               step="0.5" min="1" max="10"
                                               onchange="updateParam('${mp3File}', 'blobiness', this.value)">
                                    </div>
                                    
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            אזור בית
                                            <span class="parameter-help" title="מיקום בסיסי של ה-Blob">?</span>
                                        </div>
                                        <select class="modern-select" onchange="updateParam('${mp3File}', 'blobHomeRegion', this.value)">
                                            <option value="center-left" ${segment.blobHomeRegion === 'center-left' ? 'selected' : ''}>מרכז שמאל</option>
                                            <option value="center-right" ${segment.blobHomeRegion === 'center-right' ? 'selected' : ''}>מרכז ימין</option>
                                            <option value="center" ${segment.blobHomeRegion === 'center' ? 'selected' : ''}>מרכז</option>
                                            <option value="top-center" ${segment.blobHomeRegion === 'top-center' ? 'selected' : ''}>מרכז עליון</option>
                                            <option value="bottom-center" ${segment.blobHomeRegion === 'bottom-center' ? 'selected' : ''}>מרכז תחתון</option>
                                        </select>
                                    </div>
                        
                        <div>
                            <label>מרווח Blob</label>
                            <select onchange="updateParam('${mp3File}', 'minBlobSpacing', this.value)">
                                <option value="together" ${segment.minBlobSpacing === 'together' ? 'selected' : ''}>יחד (0px)</option>
                                <option value="close" ${segment.minBlobSpacing === 'close' ? 'selected' : ''}>קרוב (300px)</option>
                                <option value="far away" ${segment.minBlobSpacing === 'far away' ? 'selected' : ''}>רחוק (900px)</option>
                            </select>
                        </div>
                        
                                    <div class="parameter-item">
                                        <div class="parameter-label">
                                            דפוס צמיחה
                                            <span class="parameter-help" title="אופן התפתחות ה-Blob לאורך זמן">?</span>
                                        </div>
                                        <select class="modern-select" onchange="updateParam('${mp3File}', 'blobGrowthPattern', this.value)">
                                            <option value="hesitant" ${segment.blobGrowthPattern === 'hesitant' ? 'selected' : ''}>מהסס</option>
                                            <option value="steady" ${segment.blobGrowthPattern === 'steady' ? 'selected' : ''}>יציב</option>
                                            <option value="explosive" ${segment.blobGrowthPattern === 'explosive' ? 'selected' : ''}>מתפרץ</option>
                                            <option value="building" ${segment.blobGrowthPattern === 'building' ? 'selected' : ''}>בונה</option>
                                            <option value="curious" ${segment.blobGrowthPattern === 'curious' ? 'selected' : ''}>סקרן</option>
                                            <option value="playful" ${segment.blobGrowthPattern === 'playful' ? 'selected' : ''}>שובב</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <div class="parameter-grid parameter-grid-2" style="margin-top: 1rem;">
                                    <label class="modern-checkbox">
                                        <input type="checkbox" 
                                               ${segment.connectBlobs ? 'checked' : ''}
                                               onchange="updateParam('${mp3File}', 'connectBlobs', this.checked)">
                                        חיבורים בין Blobs
                                    </label>
                                    
                                    <label class="modern-checkbox">
                                        <input type="checkbox" 
                                               ${segment.blobsVisible !== false ? 'checked' : ''}
                                               onchange="updateParam('${mp3File}', 'blobsVisible', this.checked)">
                                        הצג Blobs
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Advanced Analysis Results -->
                ${segment.ai_analyzed || segment.volume_analyzed || segment.advanced_params ? `
                <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin: 20px 0;">
                    <h4 style="margin: 0 0 15px 0; color: #495057; display: flex; align-items: center; gap: 0.5rem;">
                        <i class="material-icons">science</i>
                        תוצאות ניתוח מתקדם
                    </h4>
                    
                    ${segment.ai_analyzed ? `
                    <div style="margin-bottom: 10px;">
                        <span style="background: #e8f5e8; color: #2e7d32; padding: 2px 8px; border-radius: 12px; font-size: 0.8rem;">
                            🤖 נותח על ידי AI ${segment.ai_analysis_date ? new Date(segment.ai_analysis_date).toLocaleDateString('he-IL') : ''}
                        </span>
                    </div>
                    ` : ''}
                    
                    ${segment.volume_mean !== undefined ? `
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 15px; font-size: 0.9rem;">
                        <div style="background: white; padding: 8px; border-radius: 4px;">
                            <strong>🔊 עוצמת קול ממוצעת:</strong> ${(segment.volume_mean * 100).toFixed(1)}%
                        </div>
                        <div style="background: white; padding: 8px; border-radius: 4px;">
                            <strong>📊 עוצמה מקסימלית:</strong> ${(segment.volume_max * 100).toFixed(1)}%
                        </div>
                        <div style="background: white; padding: 8px; border-radius: 4px;">
                            <strong>⚡ אנרגיה:</strong> ${(segment.volume_energy * 100).toFixed(1)}%
                        </div>
                        <div style="background: white; padding: 8px; border-radius: 4px;">
                            <strong>⏱️ משך (שניות):</strong> ${segment.audio_duration ? segment.audio_duration.toFixed(2) : 'N/A'}
                        </div>
                    </div>
                    ` : ''}
                    
                    ${segment.tone || segment.intention || segment.godel_to_regesh ? `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 15px; font-size: 0.85rem;">
                        ${segment.tone ? `<div style="background: #fff3e0; padding: 6px; border-radius: 4px; text-align: center;"><strong>טון:</strong> ${segment.tone}</div>` : ''}
                        ${segment.intention ? `<div style="background: #e3f2fd; padding: 6px; border-radius: 4px; text-align: center;"><strong>כוונה:</strong> ${segment.intention}</div>` : ''}
                        ${segment.godel_to_regesh ? `<div style="background: #f3e5f5; padding: 6px; border-radius: 4px; text-align: center;"><strong>עוצמת רגש:</strong> ${segment.godel_to_regesh}</div>` : ''}
                        ${segment.proximity ? `<div style="background: #e8f5e8; padding: 6px; border-radius: 4px; text-align: center;"><strong>קרבה:</strong> ${segment.proximity}</div>` : ''}
                    </div>
                    ` : ''}
                    
                    ${segment.blob_size || segment.blob_intensity || segment.dominance ? `
                    <div style="font-size: 0.8rem; color: #6c757d; border-top: 1px solid #dee2e6; padding-top: 10px;">
                        <strong>פרמטרים ויזואליים מתקדמים:</strong>
                        ${segment.blob_size ? ` גודל Blob: ${segment.blob_size} |` : ''}
                        ${segment.blob_intensity ? ` עוצמת Blob: ${segment.blob_intensity} |` : ''}
                        ${segment.dominance ? ` דומיננטיות: ${segment.dominance} |` : ''}
                        ${segment.blobiness ? ` Blobiness: ${segment.blobiness}` : ''}
                    </div>
                    ` : ''}
                </div>
                ` : ''}
                
                <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.5rem;">
                        <button class="btn btn-secondary" onclick="analyzeSegmentAdvanced('${mp3File}')">
                            <i class="material-icons">science</i>
                            ניתוח מתקדם + קול
                        </button>
                        <button class="btn btn-info" onclick="analyzeVolumeOnly('${mp3File}')">
                            <i class="material-icons">volume_up</i>
                            נתח קול בלבד
                        </button>
                    </div>
                </div>
            `;
        }

        // Segment editing functions
        function updateTranscript(mp3File, value) {
            if (!emotionData[mp3File]) {
                console.error(`No emotion data found for ${mp3File}`);
                return;
            }
            
            // Check if transcript actually changed
            const currentTranscript = emotionData[mp3File].transcript || emotionData[mp3File].words || '';
            if (currentTranscript === value) {
                console.log(`No change in transcript for ${mp3File}`);
                return; // No change, don't add to pending
            }
            
            // Initialize pending changes for this file if not exists
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            
            pendingChanges[mp3File].transcript = value;
            pendingChanges[mp3File].words = value; // Update both fields
            emotionData[mp3File].transcript = value;
            emotionData[mp3File].words = value;
            hasUnsavedChanges = true;
            
            console.log(`Updated transcript for ${mp3File}:`, value.substring(0, 50) + (value.length > 50 ? '...' : ''));
            
            // Update save button state and schedule auto-save
            updateSaveButtonState();
            scheduleAutoSave();
            
            // ✅ COMPREHENSIVE SYNC: Sync with all editor types for complete synchronization
            syncInlineEditor(mp3File);
            syncSegmentEditor(mp3File);
            
            // Update the segment displays
            updateSegmentDisplays(mp3File);
            
            // ✅ SYNC TRANSCRIPT EDITORS: Update all transcript editor fields in all sections
            syncAllTranscriptEditors(mp3File, value);
            
            // ✅ AUTO AI ANALYSIS: Automatically trigger AI analysis when transcript changes
            // Check if auto-analysis is enabled (controlled by user setting)
            const shouldAutoAnalyze = window.autoAnalysisEnabled !== undefined ? window.autoAnalysisEnabled : true;
            if (shouldAutoAnalyze && value && value.trim().length > 0) {
                console.log(`🤖 Auto-triggering AI analysis for ${mp3File} due to transcript change`);
                // Delay slightly to allow UI to update, then trigger analysis
                setTimeout(async () => {
                    try {
                        await completeAIAnalysis(mp3File);
                        showStatus(`🤖 ניתוח אוטומטי הושלם עבור ${mp3File}`, 'success');
                    } catch (error) {
                        console.error('Auto AI Analysis Error:', error);
                        showStatus(`⚠️ ניתוח אוטומטי נכשל עבור ${mp3File} - לחץ על כפתור AI לניתוח ידני`, 'warning');
                    }
                }, 1000); // 1 second delay
            }
            
            // Remove visual feedback
            const transcriptBox = document.querySelector('#active-segment-editor .transcript-box');
            if (transcriptBox) {
                transcriptBox.removeAttribute('data-changed');
            }
            
            // Update status
            const statusElement = document.getElementById(`transcript-status-${mp3File}`);
            if (statusElement) {
                statusElement.textContent = 'שמור ✓';
                setTimeout(() => {
                    statusElement.textContent = '';
                }, 2000);
            }
            
            // Update individual segment visualization in real-time
            updateSegmentVisualization(mp3File);
            
            // If this segment is currently looping, update the main visualization in real-time
            if (currentLoopingSegment === mp3File) {
                updateLoopingVisualization(mp3File);
            }
        }
        
        function markTranscriptChanged(mp3File) {
            const statusEl = document.getElementById(`transcript-status-${mp3File}`);
            if (statusEl) {
                statusEl.textContent = '✏️ עריכה...';
                statusEl.style.color = '#ff9800';
            }
            
            // Add visual feedback to the transcript box
            const transcriptBox = document.querySelector('#active-segment-editor .transcript-box');
            if (transcriptBox) {
                transcriptBox.setAttribute('data-changed', 'true');
            }
        }
        
        function clearTranscript(mp3File) {
            const transcriptBox = document.querySelector('#active-segment-editor .transcript-box');
            if (transcriptBox) {
                transcriptBox.textContent = '';
                updateTranscript(mp3File, '');
                showStatus(`נוקה טרנסקריפט עבור ${mp3File}`, 'success');
            }
        }
        
        function capitalizeTranscript(mp3File) {
            const transcriptBox = document.querySelector('#active-segment-editor .transcript-box');
            if (transcriptBox) {
                const currentText = transcriptBox.textContent;
                const capitalizedText = currentText.charAt(0).toUpperCase() + currentText.slice(1);
                transcriptBox.textContent = capitalizedText;
                updateTranscript(mp3File, capitalizedText);
                showStatus(`הוקפטלו אותיות ראשונות עבור ${mp3File}`, 'success');
            }
        }

        async function analyzeCurrentTranscript(mp3File) {
            if (!currentConversation || !emotionData[mp3File]) {
                showStatus('שגיאה: נתוני הקטע לא נמצאו', 'error');
                return;
            }

            // FIXED: Get transcript from the specific segment, not from active editor
            let currentTranscript = '';
            
            // First try to get from the inline editable transcript for this specific segment
            const segmentTranscriptEditor = document.querySelector(`[data-mp3="${mp3File}"].editable-transcript`);
            if (segmentTranscriptEditor) {
                currentTranscript = segmentTranscriptEditor.textContent.trim();
                console.log(`📝 Got transcript from inline editor for ${mp3File}: "${currentTranscript.substring(0, 50)}..."`);
            } else {
                // Fallback to existing transcript data for this specific segment
                currentTranscript = emotionData[mp3File].transcript || emotionData[mp3File].words || '';
                console.log(`📝 Got transcript from data for ${mp3File}: "${currentTranscript.substring(0, 50)}..."`);
            }

            if (!currentTranscript.trim()) {
                showStatus(`אין טקסט לניתוח בקטע ${mp3File} - אנא הוסף טרנסקריפט לקטע זה`, 'error');
                return;
            }

            const confirmMessage = `לנתח את הטקסט עבור קטע ${mp3File}?\n\n📝 הטקסט שינותח:\n\"${currentTranscript.substring(0, 100)}${currentTranscript.length > 100 ? '...' : ''}\"\n\n🤖 זה יעדכן את כל הפרמטרים (רגשות, טשטוש, ברק וכו') בהתאם לטקסט.\n\n⚠️ וודא שזה הטקסט הנכון לקטע ${mp3File}!`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            console.log(`✅ User confirmed transcript analysis for ${mp3File} with transcript: "${currentTranscript.substring(0, 50)}..."`);
            console.log(`🎯 Analysis will be applied to segment: ${mp3File}`);

            try {
                const emotionCount = Object.keys(emotionsConfig || {}).length;
                showLoading(`🤖 מנתח טקסט עבור ${mp3File} עם ${emotionCount} רגשות זמינים...`);
                
                // First save the transcript update
                updateTranscript(mp3File, currentTranscript);
                
                // Prepare analysis payload with current transcript
                const analysisData = {
                    conversation: currentConversation,
                    mp3File: mp3File,
                    transcript: currentTranscript,
                    currentEmotions: emotionData[mp3File].emotions || ['neutral'],
                    speaker: emotionData[mp3File].speaker || 0,
                    includeVolumeAnalysis: true,
                    advancedParameters: true
                };
                
                console.log(`🚀 Sending AI analysis request for ${mp3File}:`, {
                    segment: mp3File,
                    transcript_preview: currentTranscript.substring(0, 100) + '...',
                    transcript_length: currentTranscript.length,
                    speaker: analysisData.speaker,
                    emotions_available: Object.keys(emotionsConfig || {}).length
                });
                console.log(`🎭 Analysis will use ${Object.keys(emotionsConfig || {}).length} available emotions from config`);
                
                const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.analysis) {
                        // Calculate enhanced visual effects from transcript and emotions
                        const enhancedEffects = calculateEnhancedVisualEffects(
                            currentTranscript, 
                            result.analysis.emotions || ['neutral'],
                            result.analysis
                        );
                        
                        // Update with AI analysis results including enhanced visual effects
                        const updates = {
                            transcript: currentTranscript, // Make sure we keep the new transcript
                            words: currentTranscript,
                            emotions: result.analysis.emotions || ['neutral'],
                            blur: enhancedEffects.blur,
                            shine: enhancedEffects.shine,
                            humor: enhancedEffects.humor,
                            ai_analyzed: true,
                            ai_analysis_date: new Date().toISOString(),
                            transcript_updated: true,
                            last_transcript_analysis: new Date().toISOString(),
                            enhanced_effects: true
                        };
                        
                        // If emotions were detected, ensure they're available in the emotions dropdown
                        if (result.analysis.available_emotions && result.analysis.emotions) {
                            updateEmotionsAvailability(result.analysis.available_emotions, result.analysis.emotion_mapping);
                            
                            // Auto-add detected emotions to the segment
                            result.analysis.emotions.forEach(detectedEmotion => {
                                autoAddDetectedEmotion(mp3File, detectedEmotion);
                            });
                        }
                        
                        // Add advanced parameters if available (with AI constraints)
                        if (result.analysis.advanced) {
                            Object.assign(updates, {
                                // ✅ CONSTRAINTS: Apply AI analysis limits
                                godel_to_regesh: Math.max(1.0, result.analysis.advanced.godel_to_regesh || 1.2),
                                coloredCircleCharSize: Math.max(1.0, result.analysis.advanced.godel_to_regesh || 1.2),
                                regularAsciiCharSize: Math.max(1.0, result.analysis.advanced.godel_to_regular || 1.0),
                                kamut_to_regesh: result.analysis.advanced.kamut_to_regesh,
                                emotionCharAmount: result.analysis.advanced.kamut_to_regesh,
                                blob_size: Math.min(5, result.analysis.advanced.blob_size || 3),
                                blobSizeScale: Math.min(5, result.analysis.advanced.blob_size || 3),
                                blob_intensity: result.analysis.advanced.blob_intensity,
                                blobStrength: result.analysis.advanced.blob_intensity,
                                dominance: result.analysis.advanced.dominance,
                                blobiness: result.analysis.advanced.blobiness,
                                proximity: result.analysis.advanced.proximity,
                                tone: result.analysis.advanced.tone,
                                intention: result.analysis.advanced.intention,
                                advanced_params: true
                            });
                        }
                        
                        // Add volume analysis if available
                        if (result.volume) {
                            Object.assign(updates, {
                                volume_mean: result.volume.mean,
                                volume_max: result.volume.max,
                                volume_energy: result.volume.energy,
                                audio_duration: result.volume.duration,
                                volume_analyzed: true
                            });
                        }
                        
                        // Check if backend auto-saved the segment
                        const emotionsText = updates.emotions.join(', ');
                        
                        if (result.segment_updated && result.analysis.auto_saved) {
                            // Backend auto-saved - update local data directly
                            const savedUpdates = result.segment_updated.updates;
                            emotionData[mp3File] = { ...emotionData[mp3File], ...savedUpdates };
                            
                            // Clear pending changes for this segment
                            if (pendingChanges[mp3File]) {
                                delete pendingChanges[mp3File];
                            }
                            hasUnsavedChanges = Object.keys(pendingChanges).length > 0;
                            
                            showStatus(`✅ ניתוח הושלם ונשמר אוטומטית עבור ${mp3File}! רגשות: ${emotionsText}`, 'success');
                        } else {
                            // Fallback: manual save needed
                            emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                            pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                            hasUnsavedChanges = true;
                            
                            // Show analysis results summary
                            const effectsText = [];
                            if (updates.blur > 0) effectsText.push(`טשטוש: ${updates.blur}`);
                            if (updates.shine > 0) effectsText.push(`ברק: ${updates.shine}`);
                            if (updates.humor > 0) effectsText.push(`הומור: ${updates.humor}`);
                            
                            let summaryText = `✅ ניתוח הושלם עבור ${mp3File}!\n\n🎭 רגשות: ${emotionsText}`;
                            if (effectsText.length > 0) {
                                summaryText += `\n🎨 אפקטים: ${effectsText.join(', ')}`;
                            }
                            if (updates.tone) {
                                summaryText += `\n🎵 טון: ${updates.tone}`;
                            }
                            if (updates.intention) {
                                summaryText += `\n🎯 כוונה: ${updates.intention}`;
                            }
                            summaryText += `\n⚠️ נדרשת שמירה ידנית`;
                            
                            showStatus(summaryText, 'warning');
                        }
                        
                        // Update UI displays in both cases with comprehensive sync
                        console.log(`✅ AI analysis completed and applied to segment: ${mp3File}`);
                        console.log(`📊 Updated emotions for ${mp3File}:`, updates.emotions);
                        console.log(`🎨 Enhanced visual effects: blur=${updates.blur}, shine=${updates.shine}, humor=${updates.humor}`);
                        console.log(`🎭 Analysis used ${Object.keys(emotionsConfig || {}).length} available emotions from config`);
                        console.log(`🎯 Applied constraints: blobSize≤5, charSizes≥1.0`);
                        
                        // ✅ COMPREHENSIVE SYNC: Ensure all UI elements are updated after AI analysis
                        syncAllSegmentElements(mp3File);
                        displaySegments(); // Refresh segments list
                        
                        // Force update dropdowns with constrained values
                        setTimeout(() => {
                            initializeEnhancedSliders();
                        }, 100);
                        selectSegment(mp3File, emotionData[mp3File]); // Refresh editor with new data
                        updateSaveButtonState();
                        
                    } else {
                        showStatus('ניתוח נכשל - לא התקבלו תוצאות מ-AI', 'error');
                    }
                } else {
                    const error = await response.text();
                    showStatus(`שגיאה בניתוח AI: ${error}`, 'error');
                }
                
            } catch (error) {
                console.error('Error in transcript analysis:', error);
                showStatus('שגיאה בניתוח הטקסט עם AI', 'error');
            } finally {
                hideLoading();
            }
        }

        // ==================== COMPLETE AI ANALYSIS ====================
        // Inline editing functions
        function toggleInlineEditor(mp3File) {
            const editorPanel = document.getElementById(`inline-editor-${mp3File}`);
            const isVisible = editorPanel.style.display !== 'none';
            
            // Hide all other inline editors first
            document.querySelectorAll('[id^="inline-editor-"]').forEach(panel => {
                panel.style.display = 'none';
            });
            
            // Toggle current editor
            editorPanel.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                // Load current values from segment data when opening
                const segment = emotionData[mp3File];
                if (segment) {
                    const transcriptTextarea = document.getElementById(`inline-transcript-${mp3File}`);
                    const speakerSelect = document.getElementById(`inline-speaker-${mp3File}`);
                    
                    if (transcriptTextarea) {
                        transcriptTextarea.value = segment.transcript || segment.words || '';
                    }
                    if (speakerSelect) {
                        speakerSelect.value = segment.speaker || 0;
                    }
                }
                
                // Populate emotion dropdown options
                setTimeout(() => {
                    populateEmotionDropdown(mp3File);
                }, 100);
                
                // Focus on textarea when opening
                const textarea = document.getElementById(`inline-transcript-${mp3File}`);
                if (textarea) {
                    setTimeout(() => textarea.focus(), 150);
                }
            }
        }
        
        function saveInlineChanges(mp3File) {
            const transcriptTextarea = document.getElementById(`inline-transcript-${mp3File}`);
            const speakerSelect = document.getElementById(`inline-speaker-${mp3File}`);
            
            if (!emotionData[mp3File]) {
                showStatus('שגיאה: נתוני הקטע לא נמצאו', 'error');
                return;
            }
            
            // Update transcript using the existing function to maintain consistency
            const newTranscript = transcriptTextarea.value.trim();
            if (newTranscript !== (emotionData[mp3File].transcript || emotionData[mp3File].words || '')) {
                updateTranscript(mp3File, newTranscript);
            }
            
            // Update speaker using the existing function to maintain consistency
            const newSpeaker = parseInt(speakerSelect.value);
            if (newSpeaker !== (emotionData[mp3File].speaker || 0)) {
                updateParam(mp3File, 'speaker', newSpeaker);
            }
            
            // Update UI displays and sync with segment editor
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            // Hide editor
            document.getElementById(`inline-editor-${mp3File}`).style.display = 'none';
            
            // Save to backend (this will be handled by updateTranscript and updateParam)
            // saveEmotionData();
            
            // Refresh the segments display to ensure all changes are visible
            if (typeof displaySegments === 'function') {
                displaySegments();
            }
            
            showStatus(`✅ השינויים נשמרו עבור ${mp3File}`, 'success');
        }
        
        function addInlineEmotion(mp3File) {
            const emotionSelect = document.getElementById(`inline-emotion-${mp3File}`);
            const selectedEmotion = emotionSelect.value;
            
            if (!selectedEmotion) {
                showStatus('בחר רגש להוספה', 'warning');
                return;
            }
            
            if (!emotionData[mp3File]) {
                showStatus('שגיאה: נתוני הקטע לא נמצאו', 'error');
                return;
            }
            
            // Initialize emotions array if needed
            if (!emotionData[mp3File].emotions) {
                emotionData[mp3File].emotions = [];
            }
            
            // Check if emotion already exists
            if (emotionData[mp3File].emotions.includes(selectedEmotion)) {
                showStatus('הרגש כבר קיים ברשימה', 'warning');
                return;
            }
            
            // Add emotion using the existing system to maintain consistency
            emotionData[mp3File].emotions.push(selectedEmotion);
            
            // Mark as having changes for the backend
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            pendingChanges[mp3File].emotions = emotionData[mp3File].emotions;
            hasUnsavedChanges = true;
            
            // Update UI and sync with segment editor
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            // Reset select
            emotionSelect.value = '';
            
            // Schedule auto-save
            updateSaveButtonState();
            scheduleAutoSave();
            
            showStatus(`✅ הרגש ${selectedEmotion} נוסף לקטע ${mp3File}`, 'success');
        }
        
        function cancelInlineEdit(mp3File) {
            // Reset form to original values
            const segment = emotionData[mp3File];
            if (segment) {
                document.getElementById(`inline-transcript-${mp3File}`).value = segment.transcript || segment.words || '';
                document.getElementById(`inline-speaker-${mp3File}`).value = segment.speaker || 0;
                document.getElementById(`inline-emotion-${mp3File}`).value = '';
            }
            
            // Hide editor
            document.getElementById(`inline-editor-${mp3File}`).style.display = 'none';
        }
        
        function updateSegmentDisplays(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            // Update emotion display
            const emotions = segment.emotions || ['neutral'];
            const emotionDisplay = emotions.map(e => {
                const config = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                const emoji = config.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                const hebrew = config.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                return emoji ? `${emoji} ${hebrew}` : hebrew;
            }).join(', ');
            
            const emotionDisplayElement = document.getElementById(`emotion-display-${mp3File}`);
            if (emotionDisplayElement) {
                emotionDisplayElement.textContent = emotionDisplay;
            }
            
            // Update transcript display
            const transcript = segment.transcript || segment.words || '';
            const transcriptDisplayElement = document.getElementById(`transcript-display-${mp3File}`);
            if (transcriptDisplayElement) {
                transcriptDisplayElement.textContent = transcript.length > 80 ? transcript.substring(0, 80) + '...' : transcript;
            }
            
            // Update speaker display
            const speakerDisplayElement = document.getElementById(`speaker-display-${mp3File}`);
            if (speakerDisplayElement) {
                                    speakerDisplayElement.textContent = `🔊 ${getSpeakerName(segment.speaker || 0)}`;
            }
            
            // Update speaker indicator color
            const speakerIndicator = document.querySelector(`#segment-${mp3File} .speaker-indicator`);
            if (speakerIndicator) {
                speakerIndicator.style.background = segment.speaker === 1 ? '#4ECDC4' : '#FF6B6B';
                speakerIndicator.title = `${getSpeakerName(segment.speaker || 0)}`;
            }
            
            // Sync with inline editor if it exists and is open
            syncInlineEditor(mp3File);
            
            // Populate emotion dropdowns with latest options
            populateEmotionDropdown(mp3File);
        }
        
        function syncInlineEditor(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            // Update inline editor fields if they exist
            const inlineTranscript = document.getElementById(`inline-transcript-${mp3File}`);
            if (inlineTranscript) {
                inlineTranscript.value = segment.transcript || segment.words || '';
            }
            
            const inlineSpeaker = document.getElementById(`inline-speaker-${mp3File}`);
            if (inlineSpeaker) {
                inlineSpeaker.value = segment.speaker || 0;
            }
            
            // Update enhanced emotion display
            refreshInlineEmotionsDisplay(mp3File);
        }
        
        function syncSegmentEditor(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            // Update segment editor panel fields if they exist
            const transcriptEditor = document.querySelector('.transcript-editor');
            if (transcriptEditor && currentSelectedSegment === mp3File) {
                transcriptEditor.textContent = segment.transcript || segment.words || '';
            }
            
            // Update speaker select in segment panel
            const speakerSelect = document.querySelector(`select[onchange*="updateParam('${mp3File}', 'speaker'"]`);
            if (speakerSelect) {
                speakerSelect.value = segment.speaker || 0;
            }
            
            // Update emotion tags in segment panel
            const emotionTags = document.querySelector('.emotion-tags');
            if (emotionTags && currentSelectedSegment === mp3File) {
                // Regenerate emotion tags
                const emotions = segment.emotions || [];
                emotionTags.innerHTML = emotions.map((e, i) => {
                    const emotionConfig = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                    const color = emotionConfig.color || DEFAULT_EMOTIONS[e]?.color || '#e3f2fd';
                    const emoji = emotionConfig.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                    const hebrew = emotionConfig.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                    
                    return `
                        <div class="emotion-tag" style="background-color: ${color}15; border: 1px solid ${color}; color: ${color};">
                            ${emoji} ${hebrew}
                            <button class="remove-btn" onclick="removeEmotion('${mp3File}', ${i})">×</button>
                        </div>
                    `;
                }).join('');
            }
        }
        
        // ✅ COMPREHENSIVE PARAMETER SYNCHRONIZATION FUNCTIONS
        
        /**
         * Synchronizes a specific parameter value across all UI elements (sliders, inputs, selects)
         * This ensures that when a parameter is changed in one section, all other sections reflect the change
         */
        function syncAllParameterEditors(mp3File, param, value) {
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            // Find all parameter inputs for this mp3File and param (including dropdowns)
            const paramInputs = document.querySelectorAll(`
                input[onchange*="updateParam('${mp3File}', '${param}'"],
                select[onchange*="updateParam('${mp3File}', '${param}'"],
                input[oninput*="updateParam('${mp3File}', '${param}'"]
            `);
            
            paramInputs.forEach(input => {
                if (input.type === 'checkbox') {
                    input.checked = value === true || value === 'true';
                } else if (input.type === 'range' || input.type === 'number') {
                    input.value = parseFloat(value);
                } else if (input.tagName === 'SELECT') {
                    // Handle dropdown selects
                    input.value = value.toString();
                } else {
                    input.value = value;
                }
                
                // Update any associated display elements (for sliders with value displays)
                const paramDisplayId = `${param.replace(/([A-Z])/g, '-$1').toLowerCase()}-value-${mp3File}`;
                const displayElement = document.getElementById(paramDisplayId);
                if (displayElement) {
                    if (param === 'emotionCharAmount') {
                        displayElement.textContent = value + '%';
                    } else {
                        displayElement.textContent = value;
                    }
                }
            });
            
            console.log(`🔄 Synced parameter ${param} = ${value} across all editors for ${mp3File} (including dropdowns)`);
        }
        
        /**
         * Synchronizes transcript content across all transcript editor elements
         * This ensures that when transcript is changed in one place, all other places reflect the change
         */
        function syncAllTranscriptEditors(mp3File, transcriptValue) {
            // Update all transcript editor divs
            const transcriptEditors = document.querySelectorAll(`
                .transcript-editor[onblur*="updateTranscript('${mp3File}'"],
                .transcript-box[data-mp3="${mp3File}"]
            `);
            
            transcriptEditors.forEach(editor => {
                if (editor.textContent !== transcriptValue) {
                    editor.textContent = transcriptValue;
                }
            });
            
            // Update all transcript input fields
            const transcriptInputs = document.querySelectorAll(`
                input[id*="transcript"][id*="${mp3File}"],
                textarea[id*="transcript"][id*="${mp3File}"]
            `);
            
            transcriptInputs.forEach(input => {
                if (input.value !== transcriptValue) {
                    input.value = transcriptValue;
                }
            });
            
            // Update transcript display elements
            const transcriptDisplays = document.querySelectorAll(`[id*="transcript-display-${mp3File}"]`);
            transcriptDisplays.forEach(display => {
                const displayText = transcriptValue.length > 80 ? transcriptValue.substring(0, 80) + '...' : transcriptValue;
                if (display.textContent !== displayText) {
                    display.textContent = displayText;
                }
            });
            
            console.log(`🔄 Synced transcript across all editors for ${mp3File}: ${transcriptValue.substring(0, 50)}...`);
        }
        
        /**
         * Comprehensive synchronization function that ensures ALL UI elements are in sync for a segment
         * This is the master function that should be called when a segment is loaded or refreshed
         */
        function syncAllSegmentElements(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) {
                console.warn(`⚠️ No segment data found for ${mp3File}`);
                return;
            }
            
            console.log(`🔄 Full sync starting for segment: ${mp3File}`);
            
            // Sync all parameter values across all editors
            const paramKeys = ['speaker', 'blobSizeScale', 'blobStrength', 'volumeImpact', 'blur', 'humor', 
                'shine', 'blobiness', 'regularAsciiCharSize', 'coloredCircleCharSize', 'emotionCharAmount', 
                'gridResolution', 'blobHomeRegion', 'minBlobSpacing', 'blobGrowthPattern', 'connectBlobs', 'blobsVisible'];
                
            paramKeys.forEach(param => {
                if (segment[param] !== undefined && segment[param] !== null) {
                    syncAllParameterEditors(mp3File, param, segment[param]);
                }
            });
            
            // Sync transcript across all editors
            const transcript = segment.transcript || segment.words || '';
            if (transcript) {
                syncAllTranscriptEditors(mp3File, transcript);
            }
            
            // Sync standard editors
            syncInlineEditor(mp3File);
            syncSegmentEditor(mp3File);
            updateSegmentDisplays(mp3File);
            
            console.log(`✅ Full sync completed for segment: ${mp3File}`);
        }
        
        /**
         * ✨ ENHANCED SLIDER FUNCTIONALITY
         * Updates slider background to show current progress and applies color theming
         */
        function updateSliderBackground(slider) {
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const value = parseFloat(slider.value);
            const percentage = ((value - min) / (max - min)) * 100;
            
            // Get color from data attribute or use default
            const color = slider.dataset.color || '#667eea';
            
            // Update CSS custom properties for dynamic styling
            slider.style.setProperty('--slider-color', color);
            slider.style.setProperty('--slider-percent', percentage + '%');
            
            // Add visual feedback
            slider.style.background = `linear-gradient(to right, ${color} 0%, ${color} ${percentage}%, #e9ecef ${percentage}%, #e9ecef 100%)`;
            
            // Optional: Add glow effect on interaction
            if (percentage > 80) {
                slider.style.filter = 'drop-shadow(0 0 8px rgba(255, 215, 0, 0.3))';
            } else {
                slider.style.filter = 'none';
            }
        }

        /**
         * Initialize all enhanced sliders with proper styling and event handlers
         */
        function initializeEnhancedSliders() {
            const sliders = document.querySelectorAll('.enhanced-slider');
            sliders.forEach(slider => {
                // Set initial background
                updateSliderBackground(slider);
                
                // Add event listeners for real-time updates
                slider.addEventListener('input', function() {
                    updateSliderBackground(this);
                });
                
                slider.addEventListener('change', function() {
                    updateSliderBackground(this);
                });
            });
            
            // Also ensure dropdowns are properly initialized with current values
            initializeDropdownValues();
        }

        /**
         * Initialize dropdown values to ensure they're not empty when going to segments
         */
        function initializeDropdownValues() {
            Object.keys(emotionData).forEach(mp3File => {
                const segment = emotionData[mp3File];
                if (!segment) return;
                
                // Update blob size dropdown
                const blobSizeDropdown = document.getElementById(`blob-size-${mp3File}`);
                if (blobSizeDropdown && segment.blobSizeScale !== undefined) {
                    blobSizeDropdown.value = Math.min(5, segment.blobSizeScale); // Apply constraint
                }
                
                // Update emotion char size dropdown
                const emotionCharDropdown = document.getElementById(`emotion-char-size-${mp3File}`);
                if (emotionCharDropdown && segment.coloredCircleCharSize !== undefined) {
                    emotionCharDropdown.value = Math.max(1.0, segment.coloredCircleCharSize); // Apply constraint
                }
                
                // Update regular char size dropdown
                const regularCharDropdown = document.getElementById(`regular-char-size-${mp3File}`);
                if (regularCharDropdown && segment.regularAsciiCharSize !== undefined) {
                    regularCharDropdown.value = Math.max(1.0, segment.regularAsciiCharSize); // Apply constraint
                }
                
                // Update emotion amount dropdown
                const emotionAmountDropdown = document.getElementById(`emotion-amount-${mp3File}`);
                if (emotionAmountDropdown && segment.emotionCharAmount !== undefined) {
                    emotionAmountDropdown.value = segment.emotionCharAmount;
                }
            });
        }

        /**
         * 🎨 APPLY ENHANCED EFFECTS TO EXISTING SEGMENTS
         * Retroactively calculates and applies visual effects to segments that don't have them
         */
        function applyEnhancedEffectsToAllSegments() {
            console.log('🎨 Applying enhanced visual effects to all segments...');
            let enhancedCount = 0;
            
            Object.keys(emotionData).forEach(mp3File => {
                const segment = emotionData[mp3File];
                if (!segment || !mp3File.endsWith('.mp3')) return;
                
                const transcript = segment.transcript || segment.words || '';
                if (!transcript.trim()) return;
                
                // Only enhance if effects are minimal or missing
                if ((segment.blur || 0) <= 1 && (segment.shine || 0) <= 1 && (segment.humor || 0) <= 1) {
                    const enhancedEffects = calculateEnhancedVisualEffects(
                        transcript, 
                        segment.emotions || ['neutral'],
                        segment
                    );
                    
                    // Apply enhanced effects
                    Object.assign(segment, {
                        blur: enhancedEffects.blur,
                        shine: enhancedEffects.shine,
                        humor: enhancedEffects.humor,
                        enhanced_effects: true,
                        effects_enhanced_date: new Date().toISOString()
                    });
                    
                    enhancedCount++;
                    console.log(`🎨 Enhanced ${mp3File}: blur=${enhancedEffects.blur}, shine=${enhancedEffects.shine}, humor=${enhancedEffects.humor}`);
                }
            });
            
            if (enhancedCount > 0) {
                console.log(`✅ Enhanced visual effects for ${enhancedCount} segments`);
                showStatus(`🎨 שופרו אפקטים ויזואליים עבור ${enhancedCount} קטעים`, 'success');
                
                // Trigger UI refresh
                displaySegments();
            }
        }

        /**
         * 🎨 ENHANCE VISUAL EFFECTS FOR INDIVIDUAL SEGMENT
         * Manually enhances visual effects for a specific segment
         */
        function enhanceVisualEffectsForSegment(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) {
                showStatus(`שגיאה: לא נמצא קטע ${mp3File}`, 'error');
                return;
            }
            
            const transcript = segment.transcript || segment.words || '';
            if (!transcript.trim()) {
                showStatus(`שגיאה: אין טקסט לניתוח בקטע ${mp3File}`, 'error');
                return;
            }
            
            console.log(`🎨 Manually enhancing visual effects for ${mp3File}`);
            
            // Calculate enhanced effects
            const enhancedEffects = calculateEnhancedVisualEffects(
                transcript, 
                segment.emotions || ['neutral'],
                segment
            );
            
            // Apply enhanced effects
            Object.assign(segment, {
                blur: enhancedEffects.blur,
                shine: enhancedEffects.shine,
                humor: enhancedEffects.humor,
                enhanced_effects: true,
                effects_enhanced_date: new Date().toISOString()
            });
            
            // Mark as pending change for save
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            Object.assign(pendingChanges[mp3File], {
                blur: enhancedEffects.blur,
                shine: enhancedEffects.shine,
                humor: enhancedEffects.humor,
                enhanced_effects: true
            });
            hasUnsavedChanges = true;
            
            // Update UI
            updateSegmentDisplays(mp3File);
            displaySegments();
            updateSaveButtonState();
            
            showStatus(`🎨 שופרו אפקטים עבור ${mp3File}: טשטוש=${enhancedEffects.blur}, ברק=${enhancedEffects.shine}, הומור=${enhancedEffects.humor}`, 'success');
            
            console.log(`✅ Enhanced effects for ${mp3File}: blur=${enhancedEffects.blur}, shine=${enhancedEffects.shine}, humor=${enhancedEffects.humor}`);
        }

        /**
         * 🎬 GENERATE ALL PREVIEW VIDEOS  
         * Generate 15-second preview videos for all conversations without side panel
         */
        async function generateAllPreviewVideos() {
            const confirmed = confirm(
                `🎬 ייצור וידאו preview בן 15 שניות עבור כל השיחות?\n\n` +
                `• 42 שיחות ייווצרו\n` +
                `• 15 שניות לכל וידאו\n` +
                `• ללא פאנל צד\n` +
                `• איכות גבוהה (1080p)\n\n` +
                `זה עלול לקחת 10-15 דקות. להמשיך?`
            );
            
            if (!confirmed) return;

            try {
                showLoading('🎬 מתחיל ייצור video previews עבור כל השיחות...');

                // Generate enhanced 15-second previews for all conversations
                const enhancedVideoSettings = {
                    duration: 15,           // 15 seconds as requested
                    quality: 1080,          // High quality
                    fps: 30,                // Smooth playback
                    backgroundColor: '#f7f9f3',
                    frameSize: {
                        width: 1920,
                        height: 1080
                    },
                    cropArea: {
                        enabled: false      // Full frame, no cropping
                    },
                    advancedOptions: {
                        noSidepanel: true,  // ✅ Hide side panel as requested
                        hideUI: true,       // Hide UI elements
                        noTimeline: true,   // Hide timeline
                        visualOnly: true,   // Only visualization
                        canvasOnly: true,   // Clean canvas only
                        cleanCapture: true, // Clean capture mode
                        optimize: true,     // Optimized rendering
                        fullscreen: true    // Full screen mode
                    }
                };

                console.log('🎬 Starting enhanced preview generation for all conversations with settings:', enhancedVideoSettings);

                const response = await fetch(`${apiBaseUrl}/api/generate-all-enhanced-videos`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(enhancedVideoSettings)
                });

                if (!response.ok) {
                    throw new Error(`Failed to generate videos: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();

                hideLoading();
                showStatus(
                    `✅ הושלם ייצור preview videos!\n\n` +
                    `📊 סטטיסטיקות:\n` +
                    `• הצליחו: ${result.generated} שיחות\n` +
                    `• נכשלו: ${result.failed} שיחות\n` +
                    `• סה"כ: ${result.total} שיחות\n\n` +
                    `🎬 כל הוידאו previews בני 15 שניות ללא פאנל צד נוצרו בהצלחה!`,
                    'success'
                );

                console.log('✅ All preview videos generated successfully:', result);

            } catch (error) {
                hideLoading();
                console.error('Error generating preview videos:', error);
                showStatus(`❌ שגיאה בייצור preview videos: ${error.message}`, 'error');
            }
        }

        /**
         * Legacy function compatibility - redirect to updateParam for older slider calls
         */
        function updateSegmentParameter(mp3File, param, value) {
            console.warn(`⚠️ updateSegmentParameter is deprecated, using updateParam instead`);
            updateParam(mp3File, param, value);
        }

        /**
         * Show visual feedback when a dropdown parameter is changed
         */
        function showDropdownFeedback(mp3File, paramName) {
            // Check if this is a visual effect parameter
            const visualEffects = ['Blobiness', 'הומור', 'טשטוש', 'ברק'];
            const isVisualEffect = visualEffects.includes(paramName);
            
            const statusId = isVisualEffect ? `visual-effects-status-${mp3File}` : `param-status-${mp3File}`;
            const statusEl = document.getElementById(statusId);
            
            if (statusEl) {
                statusEl.textContent = isVisualEffect ? `✨ ${paramName} עודכן` : `✅ ${paramName} עודכן`;
                statusEl.style.opacity = '1';
                statusEl.style.color = '#28a745';
                
                setTimeout(() => {
                    statusEl.style.opacity = '0';
                }, 2000);
            }
            
            // Update the effects display in real-time if it's a visual effect
            if (isVisualEffect) {
                updateEffectsDisplay(mp3File);
                // Also sync to advanced editor if it's open
                syncToAdvancedEditor(mp3File, paramName);
            }
            
            // Show save indicator
            showSaveIndicator(mp3File);
            
            // Refresh visualization if it's currently showing this segment
            refreshVisualizationIfActive(mp3File);
        }
        
        /**
         * Refresh the visualization if the current segment is being viewed
         */
        function refreshVisualizationIfActive(mp3File) {
            // Check if the visualization is showing this segment
            const iframe = document.getElementById('segment-visualization');
            if (iframe && iframe.src.includes(mp3File)) {
                // Small delay to ensure the data is saved before refreshing
                setTimeout(() => {
                    iframe.src = iframe.src; // Refresh the iframe
                }, 300);
            }
        }
        
        /**
         * Sync changes from segment card back to advanced editor if it's open
         */
        function syncToAdvancedEditor(mp3File, paramName) {
            // Only sync if this segment is currently selected in the advanced editor
            if (currentSelectedSegment !== mp3File) return;
            
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            // Map parameter names to advanced editor slider IDs
            const paramMapping = {
                'Blobiness': 'blobiness-value',
                'הומור': 'humor-value',
                'טשטוש': 'blur-value',
                'ברק': 'shine-value'
            };
            
            const paramKey = paramMapping[paramName];
            if (!paramKey) return;
            
            // Update the slider value and display in advanced editor
            const sliderElement = document.querySelector(`input[oninput*="${paramKey}-${mp3File}"]`);
            const valueDisplay = document.getElementById(`${paramKey}-${mp3File}`);
            
            if (sliderElement && valueDisplay) {
                const newValue = segment[getParamKey(paramName)];
                if (newValue !== undefined) {
                    sliderElement.value = newValue;
                    valueDisplay.textContent = newValue;
                    // Update slider background color
                    updateSliderBackground(sliderElement);
                }
            }
        }
        
        /**
         * Get the parameter key for a given parameter name
         */
        function getParamKey(paramName) {
            const keyMapping = {
                'Blobiness': 'blobiness',
                'הומור': 'humor',
                'טשטוש': 'blur',
                'ברק': 'shine'
            };
            return keyMapping[paramName];
        }
        
        /**
         * Update the effects display in the segment card in real-time
         */
        function updateEffectsDisplay(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            // Find the segment card and update its effects display
            const segmentCard = document.getElementById(`segment-${mp3File}`);
            if (!segmentCard) return;
            
            // Create new effects display
            const effects = [];
            if (segment.blur > 0) effects.push(`🌫️ טשטוש: ${segment.blur}`);
            if (segment.humor > 0) effects.push(`😄 הומור: ${segment.humor}`);
            if (segment.shine > 0) effects.push(`✨ ברק: ${segment.shine}`);
            if (segment.blobiness && segment.blobiness !== 3.5) effects.push(`🫧 Blobiness: ${segment.blobiness}`);
            
            // Find and update the effects section in the card
            const effectsSection = segmentCard.querySelector('.enhanced-segment-card').innerHTML;
            const parser = new DOMParser();
            const doc = parser.parseFromString(effectsSection, 'text/html');
            
            // Recreate the segment element to update effects display
            setTimeout(() => {
                loadSegments(); // Refresh the entire segment list to show updated effects
            }, 100);
        }
        
        /**
         * Sync visual effects changes from advanced editor back to segment cards
         */
        function syncCardVisualEffects(mp3File) {
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            // Update the dropdowns in the enhanced segment card to match advanced editor values
            const cardBlobiness = document.getElementById(`blobiness-${mp3File}`);
            const cardHumor = document.getElementById(`humor-${mp3File}`);
            const cardBlur = document.getElementById(`blur-${mp3File}`);
            const cardShine = document.getElementById(`shine-${mp3File}`);
            
            if (cardBlobiness && segment.blobiness !== undefined) {
                cardBlobiness.value = segment.blobiness;
            }
            if (cardHumor && segment.humor !== undefined) {
                cardHumor.value = segment.humor;
            }
            if (cardBlur && segment.blur !== undefined) {
                cardBlur.value = segment.blur;
            }
            if (cardShine && segment.shine !== undefined) {
                cardShine.value = segment.shine;
            }
            
            // Update the effects display
            updateEffectsDisplay(mp3File);
            
            // Show visual effects status
            const statusEl = document.getElementById(`visual-effects-status-${mp3File}`);
            if (statusEl) {
                statusEl.textContent = '✨ אפקטים עודכנו מהעורך המתקדם';
                statusEl.style.opacity = '1';
                statusEl.style.color = '#28a745';
                
                setTimeout(() => {
                    statusEl.style.opacity = '0';
                }, 2000);
            }
            
            // Show save indicator
            showSaveIndicator(mp3File);
            
            // Refresh visualization for real-time preview
            refreshVisualizationIfActive(mp3File);
        }

        /**
         * 🎨 ENHANCED VISUAL EFFECTS ANALYSIS
         * Intelligently calculates blur, shine, and humor based on transcript and emotions
         */
        function calculateEnhancedVisualEffects(transcript, emotions, aiResults = {}) {
            const text = transcript.toLowerCase();
            const emotionsList = emotions || ['neutral'];
            
            // Base values from AI or defaults
            let blur = aiResults.blur || 0;
            let shine = aiResults.shine || 0;
            let humor = aiResults.humor || 0;
            
            console.log(`🎨 Calculating visual effects for: "${transcript.substring(0, 50)}..." with emotions: ${emotionsList.join(', ')}`);
            
            // ✨ SHINE (ברק) - Positive emotions, excitement, joy
            const shineKeywords = ['שמח', 'נהדר', 'מעולה', 'כיף', 'אהבה', 'אוהב', 'נפלא', 'יפה', 'ברק', 'זוהר', 'מאושר', 'שמחה', 'אש', 'מדליק', 'יאללה', 'בום'];
            const shineEmotions = ['happiness', 'joy', 'excitement', 'love', 'contentment', 'satisfaction', 'euphoria', 'elation'];
            
            let shineScore = 0;
            shineKeywords.forEach(keyword => {
                if (text.includes(keyword)) shineScore += 3; // Increased weight
            });
            shineEmotions.forEach(emotion => {
                if (emotionsList.includes(emotion)) shineScore += 4; // Increased weight
            });
            
            // Text length and intensity factor for shine
            if (text.includes('!!!') || text.includes('😍') || text.includes('🥰')) shineScore += 3;
            if (text.includes('!!')) shineScore += 2;
            if (text.includes('!')) shineScore += 1;
            
            // Hebrew positive expressions
            if (text.includes('וואי') || text.includes('וואו') || text.includes('אמאלה')) shineScore += 2;
            
            shine = Math.max(shine, Math.min(12, Math.floor(shineScore * 1.2))); // Boosted max and multiplier
            
            // 🌫️ BLUR (טשטוש) - Confusion, sadness, uncertainty, tiredness
            const blurKeywords = ['עייף', 'מבולבל', 'לא יודע', 'אולי', 'לא בטוח', 'עצוב', 'קשה', 'מסובך', 'בלבול', 'עמום', 'רך', 'נפש', 'כואב', 'דואג'];
            const blurEmotions = ['sadness', 'confusion', 'uncertainty', 'melancholy', 'fatigue', 'contemplation', 'worry', 'anxiety'];
            
            let blurScore = 0;
            blurKeywords.forEach(keyword => {
                if (text.includes(keyword)) blurScore += 3; // Increased weight
            });
            blurEmotions.forEach(emotion => {
                if (emotionsList.includes(emotion)) blurScore += 4; // Increased weight
            });
            
            // Uncertainty expressions
            if (text.includes('...') || text.includes('אממ') || text.includes('אהה')) blurScore += 2;
            if (text.includes('לא יודע') || text.includes('אולי')) blurScore += 3;
            if (text.includes('?') && text.length < 20) blurScore += 1; // Short questioning
            
            blur = Math.max(blur, Math.min(15, Math.floor(blurScore * 1.3))); // Boosted max and multiplier
            
            // 😄 HUMOR (הומור) - Funny words, laughter, jokes
            const humorKeywords = ['חח', 'ההה', 'לול', 'צוחק', 'מצחיק', 'שטויות', 'כיף', 'בצחוק', 'פלאפל', 'הומור', 'בדיחה', 'חחחח', 'בכיף', 'מקסים'];
            const humorEmotions = ['amusement', 'playfulness', 'humor', 'sarcasm', 'irony', 'teasing'];
            const funnyChars = ['😂', '😄', '😆', '🤣', '😁', '😊', '😉'];
            
            let humorScore = 0;
            humorKeywords.forEach(keyword => {
                if (text.includes(keyword)) humorScore += 4; // Higher weight for Hebrew humor
            });
            humorEmotions.forEach(emotion => {
                if (emotionsList.includes(emotion)) humorScore += 5; // Much higher weight
            });
            funnyChars.forEach(char => {
                if (text.includes(char)) humorScore += 3;
            });
            
            // Question marks often indicate playful tone in Hebrew
            if (text.includes('??') || text.includes('?!')) humorScore += 2;
            if (text.includes('רוצה פלאפל')) humorScore += 5; // Special case for the example
            
            // Informal Hebrew expressions
            if (text.includes('בא לך') || text.includes('איך אתה') || text.includes('מה קורה')) humorScore += 2;
            if (text.includes('שבת שלום') || text.includes('חג שמח')) humorScore += 1;
            
            humor = Math.max(humor, Math.min(15, Math.floor(humorScore * 1.5))); // Much higher max and multiplier
            
            console.log(`🎨 Enhanced effects calculated: blur=${blur}, shine=${shine}, humor=${humor}`);
            console.log(`   📊 Scores - blur: ${blurScore}, shine: ${shineScore}, humor: ${humorScore}`);
            
            return { blur, shine, humor };
        }
        
        // ==================== ENHANCED AUDIO PLAYBACK FUNCTIONS ====================
        
        // Global audio management
        let currentPlayingAudio = null;
        let currentPlayingSegment = null;
        let audioLoopMode = {};
        let sequentialPlaylist = [];
        let sequentialPlayIndex = 0;
        let isPlayingSequentially = false;
        
        // Play a specific segment audio
        function playSegmentAudio(mp3File) {
            // Stop any currently playing audio
            stopAllAudio();
            
            try {
                const audioUrl = `${apiBaseUrl}/conversations/${currentConversation}/${mp3File}`;
                currentPlayingAudio = new Audio(audioUrl);
                currentPlayingSegment = mp3File;
                
                // Show visual indicator
                showAudioStatus(mp3File, 'מנגן...', '🔊');
                
                // Handle audio events
                currentPlayingAudio.onended = () => {
                    if (audioLoopMode[mp3File]) {
                        // Restart if loop mode is on
                        setTimeout(() => {
                            if (audioLoopMode[mp3File]) {
                                playSegmentAudio(mp3File);
                            }
                        }, 500);
                    } else {
                        hideAudioStatus(mp3File);
                        currentPlayingAudio = null;
                        currentPlayingSegment = null;
                        
                        // If playing sequentially, move to next
                        if (isPlayingSequentially) {
                            playNextInSequence();
                        }
                    }
                };
                
                currentPlayingAudio.onerror = (error) => {
                    console.error('Audio playback error:', error);
                    showStatus(`שגיאה בהשמעת ${mp3File}`, 'error');
                    hideAudioStatus(mp3File);
                    currentPlayingAudio = null;
                    currentPlayingSegment = null;
                };
                
                currentPlayingAudio.onpause = () => {
                    hideAudioStatus(mp3File);
                };
                
                // Start playing
                currentPlayingAudio.play().then(() => {
                    showStatus(`🔊 משמיע ${mp3File}`, 'info');
                }).catch(error => {
                    console.error('Play error:', error);
                    showStatus(`שגיאה בהפעלת ${mp3File}`, 'error');
                    hideAudioStatus(mp3File);
                });
                
            } catch (error) {
                console.error('Error creating audio:', error);
                showStatus(`שגיאה בטעינת ${mp3File}`, 'error');
            }
        }
        
        // Stop a specific segment audio
        function stopSegmentAudio(mp3File) {
            if (currentPlayingAudio && currentPlayingSegment === mp3File) {
                currentPlayingAudio.pause();
                currentPlayingAudio = null;
                currentPlayingSegment = null;
                
                hideAudioStatus(mp3File);
                showStatus(`⏹️ הופסקה השמעת ${mp3File}`, 'info');
            }
            
            // Turn off loop mode
            audioLoopMode[mp3File] = false;
            updateLoopButton(mp3File, false);
            
            // Stop sequential play if this segment was part of it
            if (isPlayingSequentially) {
                isPlayingSequentially = false;
                showStatus('רצף השמעה הופסק', 'info');
            }
        }
        
        // Stop all audio playback
        function stopAllAudio() {
            if (currentPlayingAudio) {
                currentPlayingAudio.pause();
                if (currentPlayingSegment) {
                    hideAudioStatus(currentPlayingSegment);
                }
                currentPlayingAudio = null;
                currentPlayingSegment = null;
            }
            
            // Clear all loop modes
            Object.keys(audioLoopMode).forEach(mp3File => {
                audioLoopMode[mp3File] = false;
                updateLoopButton(mp3File, false);
            });
            
            isPlayingSequentially = false;
        }
        
        // Toggle loop mode for a segment
        function toggleSegmentLoop(mp3File) {
            const isCurrentlyLooping = audioLoopMode[mp3File] || false;
            audioLoopMode[mp3File] = !isCurrentlyLooping;
            
            updateLoopButton(mp3File, audioLoopMode[mp3File]);
            
            if (audioLoopMode[mp3File]) {
                showStatus(`🔁 לולאה פעילה עבור ${mp3File}`, 'success');
                // Start playing if not already playing
                if (currentPlayingSegment !== mp3File) {
                    playSegmentAudio(mp3File);
                }
            } else {
                showStatus(`⏹️ לולאה הופסקה עבור ${mp3File}`, 'info');
            }
        }
        
        // Play all segments sequentially
        function playAllSegmentsSequentially() {
            if (!emotionData || Object.keys(emotionData).length === 0) {
                showStatus('אין קטעים להשמעה', 'error');
                return;
            }
            
            // Stop any current playback
            stopAllAudio();
            
            // Get all MP3 files sorted
            sequentialPlaylist = Object.keys(emotionData || {})
                .filter(key => key.endsWith('.mp3'))
                .sort((a, b) => {
                    try {
                        return a.localeCompare(b, 'he', { numeric: true });
                    } catch(e) {
                        return a > b ? 1 : -1;
                    }
                });
            
            if (sequentialPlaylist.length === 0) {
                showStatus('אין קטעי MP3 להשמעה', 'error');
                return;
            }
            
            sequentialPlayIndex = 0;
            isPlayingSequentially = true;
            
            showStatus(`🎵 מתחיל השמעה רציפה של ${sequentialPlaylist.length} קטעים`, 'success');
            playNextInSequence();
        }
        
        // Play next segment in sequence
        function playNextInSequence() {
            if (!isPlayingSequentially || sequentialPlayIndex >= sequentialPlaylist.length) {
                showStatus('🎵 השמעה רציפה הושלמה', 'success');
                isPlayingSequentially = false;
                return;
            }
            
            const mp3File = sequentialPlaylist[sequentialPlayIndex];
            sequentialPlayIndex++;
            
            showStatus(`🎵 משמיע קטע ${sequentialPlayIndex}/${sequentialPlaylist.length}: ${mp3File}`, 'info');
            playSegmentAudio(mp3File);
        }
        
        // Show audio status indicator
        function showAudioStatus(mp3File, text, icon) {
            const statusDiv = document.getElementById(`audio-status-${mp3File}`);
            const textSpan = document.getElementById(`audio-text-${mp3File}`);
            const iconSpan = document.getElementById(`audio-icon-${mp3File}`);
            
            if (statusDiv && textSpan && iconSpan) {
                textSpan.textContent = text;
                iconSpan.textContent = icon;
                statusDiv.style.display = 'block';
                
                // Add glow effect to the segment
                const segmentDiv = document.getElementById(`segment-${mp3File}`);
                if (segmentDiv) {
                    segmentDiv.style.boxShadow = '0 0 15px rgba(23, 162, 184, 0.5)';
                    segmentDiv.style.border = '2px solid #17a2b8';
                }
            }
        }
        
        // Hide audio status indicator
        function hideAudioStatus(mp3File) {
            const statusDiv = document.getElementById(`audio-status-${mp3File}`);
            if (statusDiv) {
                statusDiv.style.display = 'none';
                
                // Remove glow effect from the segment
                const segmentDiv = document.getElementById(`segment-${mp3File}`);
                if (segmentDiv) {
                    segmentDiv.style.boxShadow = '';
                    segmentDiv.style.border = '1px solid #e0e0e0';
                }
            }
        }
        
        // Update loop button appearance
        function updateLoopButton(mp3File, isLooping) {
            const loopBtn = document.getElementById(`loop-btn-${mp3File}`);
            if (loopBtn) {
                if (isLooping) {
                    loopBtn.style.background = '#dc3545';
                    loopBtn.style.boxShadow = '0 0 10px rgba(220, 53, 69, 0.5)';
                    loopBtn.title = 'עצור לולאה';
                    loopBtn.innerHTML = '🔁 פעיל';
                } else {
                    loopBtn.style.background = '#6f42c1';
                    loopBtn.style.boxShadow = '';
                    loopBtn.title = 'לולאה רציפה';
                    loopBtn.innerHTML = '🔁 לולאה';
                }
            }
        }
        
        // Add keyboard shortcuts for audio control
        document.addEventListener('keydown', function(event) {
            // Only if not typing in an input field
            if (event.target.tagName.toLowerCase() === 'input' || 
                event.target.tagName.toLowerCase() === 'textarea' || 
                event.target.contentEditable === 'true') {
                return;
            }
            
            switch(event.key) {
                case ' ': // Spacebar - play/pause current segment
                    event.preventDefault();
                    if (currentPlayingAudio) {
                        if (currentPlayingAudio.paused) {
                            currentPlayingAudio.play();
                        } else {
                            currentPlayingAudio.pause();
                        }
                    }
                    break;
                case 'Escape': // Escape - stop all audio
                    event.preventDefault();
                    stopAllAudio();
                    showStatus('🔇 כל השמעה הופסקה', 'info');
                    break;
                case 'p': // P - play all sequentially
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        playAllSegmentsSequentially();
                    }
                    break;
            }
        });
        
        // ==================== SEARCHABLE EMOTION DROPDOWN FUNCTIONS ====================
        
        // Hebrew alphabet order for sorting
        const HEBREW_ALPHABET_ORDER = 'אבגדהוזחטיכלמנסעפצקרשת';
        
        // Get all available emotions sorted in Hebrew alphabetical order
        function getSortedEmotionsInHebrew() {
            const allEmotions = emotionsConfig ? 
                Object.keys(emotionsConfig).filter(emotion => emotionsConfig[emotion].active) :
                Object.keys(DEFAULT_EMOTIONS);
            
            return allEmotions.sort((a, b) => {
                const aConfig = (emotionsConfig && emotionsConfig[a]) || DEFAULT_EMOTIONS[a] || {};
                const bConfig = (emotionsConfig && emotionsConfig[b]) || DEFAULT_EMOTIONS[b] || {};
                const aHebrew = aConfig.hebrew || a;
                const bHebrew = bConfig.hebrew || b;
                
                // Sort by Hebrew alphabetical order
                return compareHebrewStrings(aHebrew, bHebrew);
            });
        }
        
        // Compare Hebrew strings for sorting
        function compareHebrewStrings(a, b) {
            const aFirst = a.charAt(0);
            const bFirst = b.charAt(0);
            const aIndex = HEBREW_ALPHABET_ORDER.indexOf(aFirst);
            const bIndex = HEBREW_ALPHABET_ORDER.indexOf(bFirst);
            
            if (aIndex !== -1 && bIndex !== -1) {
                if (aIndex !== bIndex) {
                    return aIndex - bIndex;
                }
            }
            
            // Fallback to standard comparison
            return a.localeCompare(b, 'he');
        }
        

        // Populate emotion dropdown with all available emotions
        function populateEmotionDropdown(mp3File) {
            // Find all emotion-select dropdowns for this mp3File
            const selects = document.querySelectorAll(`[id*="emotion-select-${mp3File}"]`);
            
            selects.forEach(select => {
                if (!select) return;
                
                // Get original placeholder text or use default
                const existingPlaceholder = select.querySelector('option[value=""]');
                const placeholderText = existingPlaceholder ? existingPlaceholder.textContent : 'בחר רגש...';
                
                // Clear all options
                select.innerHTML = '';
                
                // Add placeholder
                const newPlaceholder = document.createElement('option');
                newPlaceholder.value = '';
                newPlaceholder.textContent = placeholderText;
                select.appendChild(newPlaceholder);
                
                // Add all available emotions
                const availableEmotions = getAvailableEmotions();
                availableEmotions.forEach(emotion => {
                    const config = (emotionsConfig && emotionsConfig[emotion]) || DEFAULT_EMOTIONS[emotion] || {};
                    const hebrew = config.hebrew || emotion;
                    const emoji = config.emoji || '';
                    
                    const option = document.createElement('option');
                    option.value = emotion;
                    option.textContent = `${emoji} ${hebrew}`;
                    select.appendChild(option);
                });
            });
        }
        
        // Populate all emotion dropdowns in the interface
        function populateAllEmotionDropdowns() {
            // Find all emotion-select dropdowns and populate them
            const allSelects = document.querySelectorAll('[id^="emotion-select-"]');
            const processedFiles = new Set();
            
            allSelects.forEach(select => {
                const id = select.id;
                const match = id.match(/emotion-select-(.+)/);
                if (match && match[1]) {
                    const mp3File = match[1];
                    if (!processedFiles.has(mp3File)) {
                        populateEmotionDropdown(mp3File);
                        processedFiles.add(mp3File);
                    }
                }
            });
        }
        
        // Add emotion from simple dropdown
        function addEmotion(mp3File) {
            const select = document.getElementById(`emotion-select-${mp3File}`);
            if (!select || !select.value) {
                showStatus('בחר רגש להוספה', 'warning');
                return;
            }
            
            const selectedEmotion = select.value;
            
            // Add the emotion using existing function
            if (!emotionData[mp3File]) {
                showStatus('שגיאה: נתוני הקטע לא נמצאו', 'error');
                return;
            }
            
            // Initialize emotions array if needed
            if (!emotionData[mp3File].emotions) {
                emotionData[mp3File].emotions = [];
            }
            
            // Check if emotion already exists
            if (emotionData[mp3File].emotions.includes(selectedEmotion)) {
                showStatus('הרגש כבר קיים ברשימה', 'warning');
                return;
            }
            
            // Add emotion
            emotionData[mp3File].emotions.push(selectedEmotion);
            
            // Mark as having changes
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            pendingChanges[mp3File].emotions = emotionData[mp3File].emotions;
            hasUnsavedChanges = true;
            
            // Update displays
            refreshInlineEmotionsDisplay(mp3File);
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            // Reset select
            select.value = '';
            
            // Schedule auto-save
            updateSaveButtonState();
            scheduleAutoSave();
            
            const emotionConfig = (emotionsConfig && emotionsConfig[selectedEmotion]) || DEFAULT_EMOTIONS[selectedEmotion] || {};
            const emotionDisplay = emotionConfig.hebrew ? `${emotionConfig.emoji} ${emotionConfig.hebrew}` : selectedEmotion;
            showStatus(`✅ הרגש ${emotionDisplay} נוסף לקטע ${mp3File}`, 'success');
        }
        

        
        // ==================== ENHANCED INLINE EMOTION MANAGEMENT FUNCTIONS ====================
        
        // Add emotion from dropdown selector (Legacy - keeping for compatibility)
        function addInlineEmotionEnhanced(mp3File) {
            // Redirect to simple emotion system
            addEmotion(mp3File);
            return;
            
            const emotionSelect = document.getElementById(`inline-emotion-selector-${mp3File}`);
            const selectedEmotion = emotionSelect.value;
            
            if (!selectedEmotion) {
                showStatus('בחר רגש להוספה', 'warning');
                return;
            }
            
            if (!emotionData[mp3File]) {
                showStatus('שגיאה: נתוני הקטע לא נמצאו', 'error');
                return;
            }
            
            // Initialize emotions array if needed
            if (!emotionData[mp3File].emotions) {
                emotionData[mp3File].emotions = [];
            }
            
            // Check if emotion already exists
            if (emotionData[mp3File].emotions.includes(selectedEmotion)) {
                showStatus('הרגש כבר קיים ברשימה', 'warning');
                return;
            }
            
            // Add emotion
            emotionData[mp3File].emotions.push(selectedEmotion);
            
            // Mark as having changes
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            pendingChanges[mp3File].emotions = emotionData[mp3File].emotions;
            hasUnsavedChanges = true;
            
            // Update displays
            refreshInlineEmotionsDisplay(mp3File);
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            // Reset select
            emotionSelect.value = '';
            
            // Schedule auto-save
            updateSaveButtonState();
            scheduleAutoSave();
            
            const emotionConfig = (emotionsConfig && emotionsConfig[selectedEmotion]) || DEFAULT_EMOTIONS[selectedEmotion] || {};
            const emotionDisplay = emotionConfig.hebrew ? `${emotionConfig.emoji} ${emotionConfig.hebrew}` : selectedEmotion;
            showStatus(`✅ הרגש ${emotionDisplay} נוסף לקטע ${mp3File}`, 'success');
        }
        
        // Quick add emotion from quick buttons
        function addQuickInlineEmotion(mp3File, emotion) {
            if (!emotionData[mp3File]) {
                showStatus('שגיאה: נתוני הקטע לא נמצאו', 'error');
                return;
            }
            
            // Initialize emotions array if needed
            if (!emotionData[mp3File].emotions) {
                emotionData[mp3File].emotions = [];
            }
            
            // Check if emotion already exists
            if (emotionData[mp3File].emotions.includes(emotion)) {
                showStatus('הרגש כבר קיים ברשימה', 'warning');
                return;
            }
            
            // Add emotion
            emotionData[mp3File].emotions.push(emotion);
            
            // Mark as having changes
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            pendingChanges[mp3File].emotions = emotionData[mp3File].emotions;
            hasUnsavedChanges = true;
            
            // Update displays
            refreshInlineEmotionsDisplay(mp3File);
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            // Schedule auto-save
            updateSaveButtonState();
            scheduleAutoSave();
            
            const emotionConfig = (emotionsConfig && emotionsConfig[emotion]) || DEFAULT_EMOTIONS[emotion] || {};
            const emotionDisplay = emotionConfig.hebrew ? `${emotionConfig.emoji} ${emotionConfig.hebrew}` : emotion;
            showStatus(`🚀 הרגש ${emotionDisplay} נוסף במהירות לקטע ${mp3File}`, 'success');
        }
        
        // Remove specific emotion by index
        function removeInlineEmotion(mp3File, emotionIndex) {
            if (!emotionData[mp3File] || !emotionData[mp3File].emotions) return;
            
            const currentEmotions = emotionData[mp3File].emotions || [];
            
            if (currentEmotions.length <= 1) {
                showStatus('חייב להיות לפחות רגש אחד בקטע', 'error');
                return;
            }
            
            const emotionToRemove = currentEmotions[emotionIndex];
            const newEmotions = currentEmotions.filter((_, index) => index !== emotionIndex);
            
            // Update data
            emotionData[mp3File].emotions = newEmotions;
            
            // Mark as having changes
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            pendingChanges[mp3File].emotions = newEmotions;
            hasUnsavedChanges = true;
            
            // Update displays
            refreshInlineEmotionsDisplay(mp3File);
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            // Schedule auto-save
            updateSaveButtonState();
            scheduleAutoSave();
            
            const emotionConfig = (emotionsConfig && emotionsConfig[emotionToRemove]) || DEFAULT_EMOTIONS[emotionToRemove] || {};
            const emotionDisplay = emotionConfig.hebrew ? `${emotionConfig.emoji} ${emotionConfig.hebrew}` : emotionToRemove;
            showStatus(`🗑️ הוסר רגש ${emotionDisplay} מהקטע ${mp3File}`, 'success');
        }
        
        // Clear all emotions from segment
        function clearAllInlineEmotions(mp3File) {
            if (!emotionData[mp3File]) return;
            
            const confirmMessage = `לנקות את כל הרגשות מהקטע ${mp3File}?\n\nזה יוסיף רגש "ניטרלי" כברירת מחדל.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Set to neutral emotion only
            emotionData[mp3File].emotions = ['neutral'];
            
            // Mark as having changes
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            pendingChanges[mp3File].emotions = ['neutral'];
            hasUnsavedChanges = true;
            
            // Update displays
            refreshInlineEmotionsDisplay(mp3File);
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            // Schedule auto-save
            updateSaveButtonState();
            scheduleAutoSave();
            
            showStatus(`🗑️ נוקו כל הרגשות מהקטע ${mp3File}, הוגדר כ"ניטרלי"`, 'info');
        }
        
        // Refresh the inline emotions display
        function refreshInlineEmotionsDisplay(mp3File) {
            const emotionsContainer = document.getElementById(`inline-emotions-tags-${mp3File}`);
            if (!emotionsContainer) return;
            
            const segment = emotionData[mp3File];
            if (!segment) return;
            
            const emotions = segment.emotions || ['neutral'];
            
            // Update emotion count in label
            const label = emotionsContainer.parentElement.querySelector('label');
            if (label) {
                label.innerHTML = `🎭 רגשות נוכחיים: <span style="font-size: 0.8rem; color: #6c757d; font-weight: normal;">(${emotions.length} רגשות)</span>`;
            }
            
            // Generate emotion tags HTML
            const emotionTagsHTML = emotions.map((e, i) => {
                const emotionConfig = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                const color = emotionConfig.color || DEFAULT_EMOTIONS[e]?.color || '#6c757d';
                const emoji = emotionConfig.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                const hebrew = emotionConfig.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                
                return `
                    <div class="inline-emotion-tag" data-emotion="${e}" style="
                        background: ${color}25; 
                        border: 1.5px solid ${color}; 
                        color: ${color}; 
                        padding: 0.3rem 0.6rem; 
                        border-radius: 15px; 
                        font-size: 0.8rem; 
                        font-weight: 600;
                        display: flex;
                        align-items: center;
                        gap: 0.3rem;
                        transition: all 0.2s ease;
                        cursor: pointer;
                        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                    " 
                    onmouseover="this.style.background='${color}35'; this.style.transform='scale(1.05)'; this.style.boxShadow='0 2px 6px rgba(0,0,0,0.15)'"
                    onmouseout="this.style.background='${color}25'; this.style.transform='scale(1)'; this.style.boxShadow='0 1px 3px rgba(0,0,0,0.1)'"
                    title="לחץ כדי להסיר את ${hebrew}">
                        <span>${emoji} ${hebrew}</span>
                        <button onclick="event.stopPropagation(); removeInlineEmotion('${mp3File}', ${i})" 
                                style="background: none; border: none; color: ${color}; cursor: pointer; padding: 0; margin-left: 0.2rem; font-size: 1rem; font-weight: bold; opacity: 0.7; transition: opacity 0.2s;"
                                onmouseover="this.style.opacity='1'"
                                onmouseout="this.style.opacity='0.7'"
                                title="הסר רגש ${hebrew}">×</button>
                    </div>
                `;
            }).join('');
            
            // Update container content
            if (emotions.length === 0) {
                emotionsContainer.innerHTML = '<div style="color: #6c757d; font-style: italic; display: flex; align-items: center; justify-content: center; width: 100%; padding: 0.5rem;">📝 אין רגשות - הוסף רגש ראשון</div>';
            } else {
                emotionsContainer.innerHTML = emotionTagsHTML;
            }
        }
        
        // Auto-analysis toggle functionality
        function toggleAutoAnalysis() {
            window.autoAnalysisEnabled = !window.autoAnalysisEnabled;
            const button = document.getElementById('auto-analysis-toggle');
            const icon = button.querySelector('.material-icons');
            
            if (window.autoAnalysisEnabled) {
                button.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
                button.innerHTML = '<i class="material-icons">smart_toy</i>ניתוח אוטומטי: פעיל';
                button.title = 'ניתוח אוטומטי כשמעדכנים טרנסקריפט - פעיל';
                showStatus('🤖 ניתוח אוטומטי הופעל - רגשות יתעדכנו אוטומטיות כשמעדכנים טרנסקריפט', 'success');
            } else {
                button.style.background = 'linear-gradient(135deg, #6c757d, #495057)';
                button.innerHTML = '<i class="material-icons">smart_toy_disabled</i>ניתוח אוטומטי: כבוי';
                button.title = 'ניתוח אוטומטי כשמעדכנים טרנסקריפט - כבוי (לחץ להפעלה)';
                showStatus('⏸️ ניתוח אוטומטי הושבת - השתמש בכפתור AI לניתוח ידני', 'info');
            }
            
            // Save the setting to localStorage
            localStorage.setItem('autoAnalysisEnabled', window.autoAnalysisEnabled);
        }
        
        // Initialize auto-analysis setting on page load
        function initializeAutoAnalysis() {
            // Load setting from localStorage, default to true
            const saved = localStorage.getItem('autoAnalysisEnabled');
            window.autoAnalysisEnabled = saved !== null ? JSON.parse(saved) : true;
            
            // Update button appearance
            const button = document.getElementById('auto-analysis-toggle');
            if (button) {
                if (window.autoAnalysisEnabled) {
                    button.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
                    button.innerHTML = '<i class="material-icons">smart_toy</i>ניתוח אוטומטי: פעיל';
                    button.title = 'ניתוח אוטומטי כשמעדכנים טרנסקריפט - פעיל';
                } else {
                    button.style.background = 'linear-gradient(135deg, #6c757d, #495057)';
                    button.innerHTML = '<i class="material-icons">smart_toy_disabled</i>ניתוח אוטומטי: כבוי';
                    button.title = 'ניתוח אוטומטי כשמעדכנים טרנסקריפט - כבוי (לחץ להפעלה)';
                }
            }
        }
        
        async function startInlineAIAnalysis(mp3File) {
            // FIXED: Get current transcript from the correct source for this specific segment
            let currentTranscript = '';
            
            // First try to get from the inline editable transcript for this specific segment
            const segmentTranscriptEditor = document.querySelector(`[data-mp3="${mp3File}"].editable-transcript`);
            if (segmentTranscriptEditor) {
                currentTranscript = segmentTranscriptEditor.textContent.trim();
                console.log(`📝 Got transcript from inline editor for ${mp3File}: "${currentTranscript.substring(0, 50)}..."`);
            } else {
                // Fallback to old inline editor if it exists
                const transcriptTextarea = document.getElementById(`inline-transcript-${mp3File}`);
                if (transcriptTextarea) {
                    currentTranscript = transcriptTextarea.value.trim();
                } else {
                    // Final fallback to existing transcript data
                    currentTranscript = emotionData[mp3File]?.transcript || emotionData[mp3File]?.words || '';
                }
            }
            
            if (!currentTranscript) {
                showStatus(`אין טקסט לניתוח בקטע ${mp3File} - אנא הוסף טרנסקריפט קודם`, 'error');
                return;
            }
            
            // Update the transcript in data before analysis
            if (emotionData[mp3File]) {
                emotionData[mp3File].transcript = currentTranscript;
                emotionData[mp3File].words = currentTranscript;
            }
            
            // Hide old inline editor if it exists
            const inlineEditor = document.getElementById(`inline-editor-${mp3File}`);
            if (inlineEditor) {
                inlineEditor.style.display = 'none';
            }
            
            try {
                console.log(`🤖 Starting AI analysis for ${mp3File} with transcript: "${currentTranscript.substring(0, 100)}..."`);
                
                // Call the main AI analysis function
                await completeAIAnalysis(mp3File);
                
                // Refresh the entire segments display to show all updates
                if (typeof displaySegments === 'function') {
                    displaySegments();
                }
                
                showStatus(`🤖 ניתוח AI הושלם עבור ${mp3File}`, 'success');
            } catch (error) {
                console.error('AI Analysis Error:', error);
                showStatus('שגיאה בניתוח AI - נסה שוב', 'error');
            }
        }

        // Single comprehensive function that analyzes both MP3 audio and transcript
        async function completeAIAnalysis(mp3File) {
            if (!currentConversation || !emotionData[mp3File]) {
                showStatus('שגיאה: נתוני הקטע לא נמצאו', 'error');
                return;
            }

            // FIXED: Get transcript from the specific segment, not from active editor
            let currentTranscript = '';
            
            // First try to get from the inline editable transcript for this specific segment
            const segmentTranscriptEditor = document.querySelector(`[data-mp3="${mp3File}"].editable-transcript`);
            if (segmentTranscriptEditor) {
                currentTranscript = segmentTranscriptEditor.textContent.trim();
                console.log(`📝 Got transcript from inline editor for ${mp3File}: "${currentTranscript.substring(0, 50)}..."`);
            } else {
                // Fallback to existing transcript data for this specific segment
                currentTranscript = emotionData[mp3File].transcript || emotionData[mp3File].words || '';
                console.log(`📝 Got transcript from data for ${mp3File}: "${currentTranscript.substring(0, 50)}..."`);
            }

            if (!currentTranscript.trim()) {
                showStatus(`אין טקסט לניתוח בקטע ${mp3File} - אנא הוסף טרנסקריפט לקטע זה`, 'error');
                return;
            }

            const confirmMessage = `🎯 ניתוח מלא עבור קטע ${mp3File}?\n\n📝 הטקסט שינותח:\n\"${currentTranscript.substring(0, 100)}${currentTranscript.length > 100 ? '...' : ''}\"\n\n🔍 הניתוח יכלול:\n• ניתוח האודיו (עוצמת קול, אנרגיה)\n• ניתוח הטקסט עם ChatGPT\n• עדכון כל הפרמטרים (רגשות, טשטוש, ברק, הומור)\n• פרמטרים מתקדמים (טון, כוונה, גודל blob)\n\n⚠️ וודא שזה הטקסט הנכון לקטע ${mp3File}!`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            console.log(`✅ User confirmed AI analysis for ${mp3File} with transcript: "${currentTranscript.substring(0, 50)}..."`);
            console.log(`🎯 Analysis will be applied to segment: ${mp3File}`);

            try {
                const emotionCount = Object.keys(emotionsConfig || {}).length;
                showLoading(`🎯 ניתוח מלא עבור ${mp3File}...\n🔊 אודיו + 🤖 טקסט + 🎭 ${emotionCount} רגשות מ-ChatGPT`);
                
                // First save the transcript update
                updateTranscript(mp3File, currentTranscript);
                
                // Prepare comprehensive analysis payload
                const analysisData = {
                    conversation: currentConversation,
                    mp3File: mp3File,
                    transcript: currentTranscript,
                    currentEmotions: emotionData[mp3File].emotions || ['neutral'],
                    speaker: emotionData[mp3File].speaker || 0,
                    includeVolumeAnalysis: true,  // Audio analysis
                    advancedParameters: true,     // Advanced parameters
                    analyzeAudio: true,           // Full audio processing
                    comprehensiveAnalysis: true   // Complete analysis mode
                };
                
                console.log(`🚀 Sending comprehensive AI analysis request for ${mp3File}:`, {
                    segment: mp3File,
                    transcript_preview: currentTranscript.substring(0, 100) + '...',
                    transcript_length: currentTranscript.length,
                    speaker: analysisData.speaker,
                    mode: 'comprehensive'
                });
                
                const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.analysis) {
                        // Calculate enhanced visual effects from transcript and emotions
                        const enhancedEffects = calculateEnhancedVisualEffects(
                            currentTranscript, 
                            result.analysis.emotions || ['neutral'],
                            result.analysis
                        );
                        
                        // Update with complete AI analysis results including enhanced visual effects
                        const updates = {
                            transcript: currentTranscript,
                            words: currentTranscript,
                            emotions: result.analysis.emotions || ['neutral'],
                            blur: enhancedEffects.blur,
                            shine: enhancedEffects.shine,
                            humor: enhancedEffects.humor,
                            ai_analyzed: true,
                            ai_analysis_date: new Date().toISOString(),
                            transcript_updated: true,
                            last_complete_analysis: new Date().toISOString(),
                            complete_analysis: true,
                            enhanced_effects: true
                        };
                        
                        // Add advanced parameters if available (with AI constraints)
                        if (result.analysis.advanced) {
                            Object.assign(updates, {
                                // ✅ CONSTRAINTS: Apply AI analysis limits
                                godel_to_regesh: Math.max(1.0, result.analysis.advanced.godel_to_regesh || 1.2),
                                coloredCircleCharSize: Math.max(1.0, result.analysis.advanced.godel_to_regesh || 1.2),
                                regularAsciiCharSize: Math.max(1.0, result.analysis.advanced.godel_to_regular || 1.0),
                                kamut_to_regesh: result.analysis.advanced.kamut_to_regesh,
                                emotionCharAmount: result.analysis.advanced.kamut_to_regesh,
                                blob_size: Math.min(5, result.analysis.advanced.blob_size || 3),
                                blobSizeScale: Math.min(5, result.analysis.advanced.blob_size || 3),
                                blob_intensity: result.analysis.advanced.blob_intensity,
                                blobStrength: result.analysis.advanced.blob_intensity,
                                dominance: result.analysis.advanced.dominance,
                                blobiness: result.analysis.advanced.blobiness,
                                proximity: result.analysis.advanced.proximity,
                                tone: result.analysis.advanced.tone,
                                intention: result.analysis.advanced.intention,
                                advanced_params: true
                            });
                        }
                        
                        // Add comprehensive volume analysis if available
                        if (result.volume) {
                            Object.assign(updates, {
                                volume_mean: result.volume.mean,
                                volume_max: result.volume.max,
                                volume_energy: result.volume.energy,
                                volume_std: result.volume.std,
                                audio_duration: result.volume.duration,
                                volume_analyzed: true,
                                audio_analyzed: true
                            });
                        }
                        
                        // Update emotions availability in dropdowns
                        if (result.analysis && result.analysis.available_emotions && result.analysis.emotions) {
                            updateEmotionsAvailability(result.analysis.available_emotions, result.analysis.emotion_mapping);
                            
                            // Auto-add detected emotions to the segment
                            result.analysis.emotions.forEach(detectedEmotion => {
                                autoAddDetectedEmotion(mp3File, detectedEmotion);
                            });
                        }
                        
                        // Check if backend auto-saved the segment
                        const emotionsText = updates.emotions.join(', ');
                        
                        if (result.segment_updated && result.analysis.auto_saved) {
                            // Backend auto-saved - update local data directly
                            const savedUpdates = result.segment_updated.updates;
                            emotionData[mp3File] = { ...emotionData[mp3File], ...savedUpdates };
                            
                            // Clear pending changes for this segment
                            if (pendingChanges[mp3File]) {
                                delete pendingChanges[mp3File];
                            }
                            hasUnsavedChanges = Object.keys(pendingChanges).length > 0;
                            
                            showStatus(`🎯 ניתוח מלא הושלם ונשמר אוטומטית עבור ${mp3File}!\n\n🎭 רגשות: ${emotionsText}\n\n✅ הטקסט והאודיו נותחו בהצלחה עם ChatGPT!`, 'success');
                        } else {
                            // Fallback: manual save needed
                            emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                            pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                            hasUnsavedChanges = true;
                            
                            // Show comprehensive analysis results summary
                            const effectsText = [];
                            if (updates.blur > 0) effectsText.push(`טשטוש: ${updates.blur}`);
                            if (updates.shine > 0) effectsText.push(`ברק: ${updates.shine}`);
                            if (updates.humor > 0) effectsText.push(`הומור: ${updates.humor}`);
                            
                            let summaryText = `🎯 ניתוח מלא הושלם עבור ${mp3File}!\n\n🎭 רגשות: ${emotionsText}`;
                            
                            if (effectsText.length > 0) {
                                summaryText += `\n🎨 אפקטים: ${effectsText.join(', ')}`;
                            }
                            
                            if (updates.tone) {
                                summaryText += `\n🎵 טון: ${updates.tone}`;
                            }
                            
                            if (updates.intention) {
                                summaryText += `\n🎯 כוונה: ${updates.intention}`;
                            }
                            
                            if (updates.volume_mean) {
                                summaryText += `\n🔊 עוצמת קול: ${Math.round(updates.volume_mean * 100)}%`;
                            }
                            
                            if (updates.blob_size) {
                                summaryText += `\n⚪ גודל Blob: ${updates.blob_size}`;
                            }
                            
                            summaryText += `\n\n✅ הטקסט והאודיו נותחו בהצלחה עם ChatGPT!\n⚠️ נדרשת שמירה ידנית`;
                            
                            showStatus(summaryText, 'warning');
                        }
                        
                        // Update UI displays in both cases
                        console.log(`✅ Comprehensive AI analysis completed and applied to segment: ${mp3File}`);
                        console.log(`📊 Updated emotions for ${mp3File}:`, updates.emotions);
                        console.log(`🎨 Updated effects for ${mp3File}: blur=${updates.blur}, shine=${updates.shine}, humor=${updates.humor}`);
                        console.log(`🎭 Comprehensive analysis used ${Object.keys(emotionsConfig || {}).length} available emotions + audio analysis`);
                        displaySegments(); // Refresh segments list
                        selectSegment(mp3File, emotionData[mp3File]); // Refresh editor with new data
                        updateSaveButtonState();
                        
                    } else {
                        showStatus('ניתוח נכשל - לא התקבלו תוצאות מ-ChatGPT', 'error');
                    }
                } else {
                    const error = await response.text();
                    showStatus(`שגיאה בניתוח מלא: ${error}`, 'error');
                }
                
            } catch (error) {
                console.error('Error in complete AI analysis:', error);
                showStatus('שגיאה בניתוח המלא עם ChatGPT', 'error');
            } finally {
                hideLoading();
            }
        }

        // New comprehensive transcription + analysis for single segment
        async function transcribeAndAnalyzeSegment(mp3File) {
            console.log(`🎤 Transcription request for segment: ${mp3File}`);
            
            if (!currentConversation || !emotionData[mp3File]) {
                console.error('Missing conversation or emotion data:', { currentConversation, hasEmotionData: !!emotionData[mp3File] });
                showStatus('שגיאה: נתוני הקטע לא נמצאו', 'error');
                return;
            }

            // Show transcription method selection dialog
            const transcriptionMethod = await showTranscriptionMethodDialog();
            if (!transcriptionMethod) {
                return; // User cancelled
            }

            try {
                const emotionCount = Object.keys(emotionsConfig || {}).length;
                showLoading(`🎤🤖 תמלול + ניתוח מלא עבור ${mp3File}...\n🔊 תמלול אודיו + 🎭 ${emotionCount} רגשות מ-ChatGPT`);
                
                const analysisData = {
                    conversation: currentConversation,
                    mp3File: mp3File,
                    speaker: emotionData[mp3File].speaker || 0,
                    transcription_method: transcriptionMethod,
                    auto_save: true
                };

                console.log(`🚀 Sending transcription + analysis request for ${mp3File}:`, {
                    segment: mp3File,
                    speaker: analysisData.speaker,
                    transcription_method: transcriptionMethod,
                    emotions_available: Object.keys(emotionsConfig || {}).length
                });
                console.log(`🎭🎤 Transcription + Analysis will use ${Object.keys(emotionsConfig || {}).length} available emotions + transcription`);
                
                const response = await fetch(`${apiBaseUrl}/api/transcribe-and-analyze-segment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisData)
                });

                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.analysis && result.transcript) {
                        // Update with comprehensive analysis results including transcript
                        const updates = {
                            transcript: result.transcript,
                            words: result.transcript,
                            emotions: result.analysis.emotions || ['neutral'],
                            blur: result.analysis.blur || 0,
                            shine: result.analysis.shine || 0,
                            humor: result.analysis.humor || 0,
                            ai_analyzed: true,
                            transcribed: true,
                            transcription_method: result.transcription_method,
                            ai_analysis_date: new Date().toISOString(),
                            transcription_date: new Date().toISOString(),
                            transcript_updated: true,
                            last_transcript_analysis: new Date().toISOString()
                        };
                        
                        // Update emotion data
                        Object.assign(emotionData[mp3File], updates);
                        
                        // Update inline transcript editor if it exists
                        const segmentTranscriptEditor = document.querySelector(`[data-mp3="${mp3File}"].editable-transcript`);
                        if (segmentTranscriptEditor) {
                            segmentTranscriptEditor.textContent = result.transcript;
                            // Add visual feedback for successful transcription
                            segmentTranscriptEditor.style.background = 'rgba(40, 167, 69, 0.1)';
                            setTimeout(() => {
                                segmentTranscriptEditor.style.background = '';
                            }, 2000);
                        }
                        
                        console.log(`✅ Complete transcription + analysis completed for segment: ${mp3File}`);
                        console.log(`📝 New transcript: "${result.transcript.substring(0, 100)}..."`);
                        console.log(`📊 Updated emotions for ${mp3File}:`, updates.emotions);
                        console.log(`🎭🎤 Complete analysis used ${Object.keys(emotionsConfig || {}).length} available emotions + transcription`);
                        
                        // Force reload emotion data to ensure fresh data
                        await loadEmotionData(currentConversation);
                        
                        displaySegments(); // Refresh segments list
                        selectSegment(mp3File, emotionData[mp3File]); // Refresh editor with new data
                        
                        // Show success with detailed results and force UI refresh
                        showStatus(`🎤🤖 תמלול + ניתוח הושלם בהצלחה עבור ${mp3File}!\n\n📝 תמלול: "${result.transcript.substring(0, 80)}${result.transcript.length > 80 ? '...' : ''}"\n🎭 רגשות: ${updates.emotions.join(', ')}\n🎤 שיטת תמלול: ${result.transcription_method}\n\n🔄 הממשק עודכן עם התמלול החדש!`, 'success');
                    } else {
                        showStatus(`שגיאה בתמלול או ניתוח הקטע ${mp3File}`, 'error');
                    }
                } else {
                    const errorResult = await response.json();
                    showStatus(`שגיאה בתמלול + ניתוח: ${errorResult.error}`, 'error');
                }
            } catch (error) {
                showStatus(`שגיאה בתמלול + ניתוח: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        // New comprehensive transcription + analysis for entire conversation
        async function transcribeAndAnalyzeEntireConversation() {
            console.log(`🎤🎯 Full conversation transcription request for: ${currentConversation}`);
            
            if (!currentConversation) {
                console.error('No conversation selected');
                showStatus('שגיאה: לא נבחרה שיחה', 'error');
                return;
            }

            // Show transcription method selection dialog
            const transcriptionMethod = await showTranscriptionMethodDialog();
            if (!transcriptionMethod) {
                return; // User cancelled
            }

            const maxSegments = await showMaxSegmentsDialog();
            if (!maxSegments) {
                return; // User cancelled
            }

            if (!confirm(`🎤🤖 תמלול + ניתוח מלא עבור כל השיחה ${currentConversation}?\n\n📝 השלבים:\n• תמלול אוטומטי לכל הקטעים\n• ניתוח רגשות עם ChatGPT\n• עדכון כל הפרמטרים\n\n⚠️ זה עלול לקחת זמן רב!\n\n🔢 מקסימום קטעים: ${maxSegments}\n🎤 שיטת תמלול: ${transcriptionMethod === 'openai_fast' ? 'OpenAI + GPT-4' : 
                                      transcriptionMethod === 'azure_hebrew' ? 'Azure Speech עברית' :
                                      transcriptionMethod === 'google_hebrew' ? 'Google Speech עברית' :
                                      'שרשרת מתקדמת'}`)) {
                return;
            }

            try {
                const emotionCount = Object.keys(emotionsConfig || {}).length;
                showLoading(`🎤🤖 מתחיל תמלול + ניתוח מלא עבור ${currentConversation}...\n🔊 תמלול אודיו + 🎭 ${emotionCount} רגשות מ-ChatGPT\n📊 מקסימום ${maxSegments} קטעים`);
                
                // Show progress tracking
                setTimeout(() => {
                    showAnalysisProgress(0, maxSegments, 'מתכונן...', 'תמלול + ניתוח מלא');
                }, 500);
                
                const analysisData = {
                    conversationFolder: currentConversation,
                    transcription_method: transcriptionMethod,
                    max_segments: parseInt(maxSegments),
                    skip_existing_transcripts: true // Skip segments that already have transcripts
                };

                console.log(`🚀 Starting complete transcription + analysis for conversation ${currentConversation}:`, analysisData);
                
                const response = await fetch(`${apiBaseUrl}/api/transcribe-and-analyze-conversation`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisData)
                });

                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.success) {
                        const stats = result.stats;
                        
                        console.log(`✅ Complete conversation transcription + analysis finished for ${currentConversation}`);
                        console.log(`📊 Stats:`, stats);
                        
                        // Force reload emotion data to show all updates
                        await loadEmotionData(currentConversation);
                        
                        // Refresh the UI display
                        displaySegments();
                        
                        let summaryMessage = `🎤🤖 תמלול + ניתוח מלא הושלם עבור ${currentConversation}!\n\n📊 סטטיסטיקות:\n`;
                        summaryMessage += `• ✅ ${stats.transcribed} קטעים תומללו\n`;
                        summaryMessage += `• 🎭 ${stats.analyzed} קטעים נותחו\n`;
                        if (stats.skipped > 0) summaryMessage += `• ⏭️ ${stats.skipped} קטעים דולגו (יש כבר תמלול)\n`;
                        if (stats.errors > 0) summaryMessage += `• ❌ ${stats.errors} שגיאות\n`;
                        summaryMessage += `\n🎤 שיטת תמלול: ${transcriptionMethod}\n🎭 השתמש ב-${emotionCount} רגשות זמינים + תמלול אוטומטי\n\n🔄 הטקסטים וההרגשות עודכנו בממשק!`;
                        
                        showStatus(summaryMessage, stats.errors > 0 ? 'warning' : 'success');
                    } else {
                        showStatus(`שגיאה בתמלול + ניתוח השיחה: ${result.error}`, 'error');
                    }
                } else {
                    const errorResult = await response.json();
                    showStatus(`שגיאה בתמלול + ניתוח השיחה: ${errorResult.error}`, 'error');
                }
            } catch (error) {
                showStatus(`שגיאה בתמלול + ניתוח השיחה: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        // Helper function to show transcription method selection dialog
        async function showTranscriptionMethodDialog() {
            return new Promise((resolve) => {
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                dialog.innerHTML = `
                    <div style="background: white; padding: 2rem; border-radius: 12px; max-width: 500px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
                        <h3 style="margin-bottom: 1.5rem; color: #333;">🎤 בחר שיטת תמלול</h3>
                        <div style="margin-bottom: 2rem;">
                            <label style="display: block; margin-bottom: 1rem; padding: 1rem; border: 2px solid #e9ecef; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;">
                                <input type="radio" name="transcription" value="openai_fast" checked style="margin-left: 10px;">
                                <strong>📝 OpenAI + GPT-4 - מהיר ומשופר</strong><br>
                                <small style="color: #666;">Whisper + GPT-4 לתיקון וניקוי הטקסט העברי</small>
                            </label>
                            <label style="display: block; margin-bottom: 1rem; padding: 1rem; border: 2px solid #e9ecef; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;">
                                <input type="radio" name="transcription" value="whisper_accurate" style="margin-left: 10px;">
                                <strong>🎯 שרשרת מתקדמת - הכי מדויק</strong><br>
                                <small style="color: #666;">Azure → Google → WhisperX → OpenAI (עם חזרה אוטומטית)</small>
                            </label>
                            <label style="display: block; margin-bottom: 1rem; padding: 1rem; border: 2px solid #e9ecef; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;">
                                <input type="radio" name="transcription" value="azure_hebrew" style="margin-left: 10px;">
                                <strong>🇮🇱 Azure Speech - מותאם לעברית</strong><br>
                                <small style="color: #666;">שירות Microsoft מותאם במיוחד לעברית</small>
                            </label>
                            <label style="display: block; padding: 1rem; border: 2px solid #e9ecef; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;">
                                <input type="radio" name="transcription" value="google_hebrew" style="margin-left: 10px;">
                                <strong>🌐 Google Speech - מותאם לעברית</strong><br>
                                <small style="color: #666;">שירות Google מותאם במיוחד לעברית</small>
                            </label>
                        </div>
                        <div style="display: flex; gap: 1rem; justify-content: center;">
                            <button class="transcription-continue-btn" style="background: #28a745; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer;">
                                📝 התחל תמלול
                            </button>
                            <button class="transcription-cancel-btn" style="background: #6c757d; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer;">
                                ביטול
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(dialog);

                // Set up button handlers
                const continueBtn = dialog.querySelector('.transcription-continue-btn');
                const cancelBtn = dialog.querySelector('.transcription-cancel-btn');
                
                // Default to openai_fast
                let selectedMethod = 'openai_fast';
                
                continueBtn.onclick = () => {
                    resolve(selectedMethod);
                    document.body.removeChild(dialog);
                };
                
                cancelBtn.onclick = () => {
                    resolve(null);
                    document.body.removeChild(dialog);
                };

                // Handle radio button selection
                dialog.addEventListener('change', (e) => {
                    if (e.target.type === 'radio') {
                        selectedMethod = e.target.value;
                    }
                });

                // Handle escape key
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        resolve(null);
                        document.body.removeChild(dialog);
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
            });
        }

        // Helper function to show max segments dialog  
        async function showMaxSegmentsDialog() {
            return new Promise((resolve) => {
                const segments = Object.keys(emotionData || {}).length;
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                dialog.innerHTML = `
                    <div style="background: white; padding: 2rem; border-radius: 12px; max-width: 400px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
                        <h3 style="margin-bottom: 1.5rem; color: #333;">📊 מספר קטעים לעיבוד</h3>
                        <p style="margin-bottom: 1rem; color: #666;">השיחה מכילה ${segments} קטעים</p>
                        <input type="number" id="maxSegments" value="50" min="1" max="${segments}" style="width: 100%; padding: 0.75rem; border: 2px solid #e9ecef; border-radius: 6px; text-align: center; font-size: 1.1rem; margin-bottom: 1.5rem;">
                        <div style="display: flex; gap: 1rem; justify-content: center;">
                            <button class="segments-continue-btn" style="background: #28a745; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer;">
                                📝 המשך
                            </button>
                            <button class="segments-cancel-btn" style="background: #6c757d; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer;">
                                ביטול
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(dialog);

                // Set up button handlers
                const continueBtn = dialog.querySelector('.segments-continue-btn');
                const cancelBtn = dialog.querySelector('.segments-cancel-btn');
                const input = dialog.querySelector('#maxSegments');
                
                continueBtn.onclick = () => {
                    const value = parseInt(input.value) || 50;
                    resolve(value);
                    document.body.removeChild(dialog);
                };
                
                cancelBtn.onclick = () => {
                    resolve(null);
                    document.body.removeChild(dialog);
                };

                // Handle escape key
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        resolve(null);
                        document.body.removeChild(dialog);
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
            });
        }

        // Make transcription functions globally accessible
        window.transcribeAndAnalyzeSegment = transcribeAndAnalyzeSegment;
        window.transcribeAndAnalyzeEntireConversation = transcribeAndAnalyzeEntireConversation;

        function markTranscriptChanged(mp3File) {
            // Visual feedback for transcript changes
            const transcriptBox = document.querySelector('#active-segment-editor .transcript-box');
            if (transcriptBox) {
                transcriptBox.setAttribute('data-changed', 'true');
                transcriptBox.style.border = '2px solid #ffc107';
                
                // Update status
                const statusElement = document.getElementById(`transcript-status-${mp3File}`);
                if (statusElement) {
                    statusElement.innerHTML = '<span style="color: #ffc107;">⚠️ שונה - לחץ מחוץ לתיבה לשמירה</span>';
                }
            }
        }

        function removeEmotion(mp3File, emotionIndex) {
            if (!emotionData[mp3File] || !emotionData[mp3File].emotions) return;
            
            const currentEmotions = emotionData[mp3File].emotions || ['neutral'];
            
            if (currentEmotions.length <= 1) {
                showStatus('חייב להיות לפחות רגש אחד', 'error');
                return;
            }
            
            const emotionToRemove = currentEmotions[emotionIndex];
            const newEmotions = currentEmotions.filter((_, index) => index !== emotionIndex);
            
            updateParam(mp3File, 'emotions', newEmotions);
            refreshEmotionDisplay(mp3File);
            
            showStatus(`הוסר רגש "${emotionToRemove}"`, 'success');
        }

        function addEmotion(mp3File) {
            const select = document.getElementById(`emotion-select-${mp3File}`);
            const emotion = select.value;
            
            if (!emotion) {
                showStatus('בחר רגש מהרשימה', 'error');
                return;
            }
            
            if (!emotionData[mp3File]) return;
            
            // Get current emotions
            const currentEmotions = emotionData[mp3File].emotions || ['neutral'];
            
            // Check if emotion already exists
            if (currentEmotions.includes(emotion)) {
                showStatus(`הרגש "${emotion}" כבר קיים`, 'error');
                return;
            }
            
            // Debug: Check emotions config
            console.log('🎨 Adding emotion:', emotion);
            console.log('🎨 Current emotions config:', emotionsConfig);
            console.log('🎨 Emotion config for', emotion, ':', emotionsConfig[emotion]);
            
            // Add the new emotion
            const newEmotions = [...currentEmotions, emotion];
            updateParam(mp3File, 'emotions', newEmotions);
            
            // Refresh the emotion display
            refreshEmotionDisplay(mp3File);
            
            // Reset dropdown
            select.value = '';
            
            const emotionConfig = (emotionsConfig && emotionsConfig[emotion]) || {};
            const emotionDisplay = emotionConfig.hebrew ? `${emotionConfig.emoji} ${emotionConfig.hebrew}` : emotion;
            showStatus(`הוסף רגש "${emotionDisplay}"`, 'success');
        }
        
        function refreshEmotionDisplay(mp3File) {
            const emotions = emotionData[mp3File].emotions || ['neutral'];
            
            // Create emotion display with colors and names
            const emotionDisplayText = emotions.map(e => {
                const config = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                const emoji = config.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                const hebrew = config.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                return hebrew ? `${emoji} ${hebrew}` : e;
            }).join(', ');
            
            // Update the segment list
            const segmentDiv = document.getElementById(`segment-${mp3File}`);
            if (segmentDiv) {
                const emotionSpan = segmentDiv.querySelector('span[style*="background: #e3f2fd"]');
                if (emotionSpan) {
                    emotionSpan.textContent = emotionDisplayText;
                }
            }
            
            // Update the editor if this is the current segment
            if (currentSelectedSegment === mp3File) {
                const emotionTags = emotions.map((e, i) => {
                    // Ensure we have emotions config loaded, fallback to DEFAULT_EMOTIONS
                    const emotionConfig = (emotionsConfig && emotionsConfig[e]) || DEFAULT_EMOTIONS[e] || {};
                    const color = emotionConfig.color || DEFAULT_EMOTIONS[e]?.color || '#e3f2fd';
                    const emoji = emotionConfig.emoji || DEFAULT_EMOTIONS[e]?.emoji || '';
                    const hebrew = emotionConfig.hebrew || DEFAULT_EMOTIONS[e]?.hebrew || e;
                    
                    return `
                        <div class="emotion-tag" style="background-color: ${color}15; border: 1px solid ${color}; color: ${color};">
                            ${emoji} ${hebrew}
                            <button class="remove-btn" onclick="removeEmotion('${mp3File}', ${i})">×</button>
                        </div>
                    `;
                }).join('');
                
                const emotionsContainer = document.querySelector('#active-segment-editor .emotion-tags');
                if (emotionsContainer) {
                    emotionsContainer.innerHTML = emotionTags;
                }
                
                // Update visualization
                updateSegmentVisualization(mp3File);
            }
            
            // If this segment is currently looping, update the main visualization in real-time
            if (currentLoopingSegment === mp3File) {
                updateLoopingVisualization(mp3File);
            }
        }

        function updateParam(mp3File, param, value) {
            if (!emotionData[mp3File]) {
                console.error(`No emotion data found for ${mp3File}`);
                return;
            }
            
            // Convert numeric values
            if (['speaker', 'blobSizeScale', 'blobStrength', 'volumeImpact', 'blur', 'humor', 
                'shine', 'regularAsciiCharSize', 'coloredCircleCharSize', 'blobiness', 'emotionCharAmount', 'gridResolution'].includes(param)) {
                value = parseFloat(value);
                if (isNaN(value)) {
                    console.error(`Invalid numeric value for ${param}:`, value);
                    return;
                }
            }
            
            // Convert boolean values
            if (param === 'connectBlobs' || param === 'blobsVisible') {
                value = value === true || value === 'true';
            }
            
            // Check if value actually changed
            const currentValue = emotionData[mp3File][param];
            if (currentValue === value) {
                console.log(`No change for ${param}: ${currentValue} === ${value}`);
                return; // No change, don't add to pending
            }
            
            // Initialize pending changes for this file if not exists
            if (!pendingChanges[mp3File]) {
                pendingChanges[mp3File] = {};
            }
            
            pendingChanges[mp3File][param] = value;
            emotionData[mp3File][param] = value; // Update local copy immediately
            hasUnsavedChanges = true;
            
            console.log(`Updated ${mp3File}.${param}: ${currentValue} -> ${value}`);
            
            // Special handling for spacing changes - add visual feedback
            if (param === 'minBlobSpacing') {
                console.log(`🎯 SPACING UPDATE: ${mp3File} spacing changed from "${currentValue}" to "${value}"`);
                showStatus(`עודכן מרווח Blob: ${value}`, 'success');
            }
            
            // Update save button state and schedule auto-save (with smart debouncing)
            updateSaveButtonState();
            scheduleAutoSave();
            
            // ✅ OPTIMIZED REAL-TIME UPDATES: Only update what's necessary
            // Batch visualization updates to prevent excessive refreshing
            
            // Critical visual parameters that need immediate update
            const visualParameters = ['blur', 'humor', 'shine', 'blobSizeScale', 'blobStrength', 'emotions', 'blobiness'];
            const needsVisualizationUpdate = visualParameters.includes(param);
            
            if (needsVisualizationUpdate) {
                // Use requestAnimationFrame to batch updates and prevent excessive calls
                if (!window.pendingVisualizationUpdate) {
                    window.pendingVisualizationUpdate = true;
                    requestAnimationFrame(() => {
                        updateSegmentVisualization(mp3File);
                        updateLoopingVisualization(mp3File);
                        window.pendingVisualizationUpdate = false;
                    });
                }
            }
            
            // ✅ OPTIMIZED SYNC: Reduce sync frequency for UI elements
            // Only sync editors if it's a parameter that affects the UI directly
            const uiParameters = ['emotions', 'speaker', 'minBlobSpacing', 'gridResolution'];
            if (uiParameters.includes(param)) {
                syncInlineEditor(mp3File);
                syncSegmentEditor(mp3File);
                syncAllParameterEditors(mp3File, param, value);
            }
            
            // Special handling for speaker parameter
            if (param === 'speaker') {
                // Update speaker indicator tooltip with custom name
                const speakerIndicator = document.getElementById(`speaker-indicator-${mp3File}`);
                if (speakerIndicator) {
                    speakerIndicator.title = getSpeakerName(parseInt(value));
                    speakerIndicator.style.background = value == 1 ? '#4ECDC4' : '#FF6B6B';
                }
                
                // Update speaker display text
                const speakerDisplayElement = document.getElementById(`speaker-display-${mp3File}`);
                if (speakerDisplayElement) {
                    speakerDisplayElement.textContent = `🔊 ${getSpeakerName(parseInt(value))}`;
                }
            }
            
            // ✅ OPTIMIZED SEGMENT DISPLAYS: Only update when necessary
            if (['emotions', 'speaker'].includes(param)) {
                updateSegmentDisplays(mp3File);
            }
            
            // Update the segment list UI to reflect changes
            const segmentDiv = document.getElementById(`segment-${mp3File}`);
            if (segmentDiv) {
                const segment = emotionData[mp3File];
                const emotions = segment.emotions || ['neutral'];
                const emotionSpan = segmentDiv.querySelector('span[style*="background: #e3f2fd"]');
                if (emotionSpan && param === 'emotions') {
                    emotionSpan.textContent = emotions.join(', ');
                }
            }
            
            // Update the editor if this is the current segment
            if (currentSelectedSegment === mp3File) {
                updateSegmentVisualization(mp3File);
            }
            
            // If this segment is currently looping, update the main visualization in real-time
            if (currentLoopingSegment === mp3File) {
                updateLoopingVisualization(mp3File);
            }
        }
        
        function playSegment(mp3File) {
            const audio = new Audio(`conversations/${currentConversation}/${mp3File}`);
            audio.play().catch(error => {
                console.error('Error playing audio:', error);
                showStatus('שגיאה בניגון הקטע', 'error');
            });
        }
        
        function toggleLoop(mp3File) {
            const loopBtn = document.getElementById(`loop-btn-${mp3File}`);
            const headerLoopBtn = document.getElementById(`header-loop-btn-${mp3File}`);
            
            if (currentLoopingSegment === mp3File) {
                // Stop current loop
                stopLoop();
                if (loopBtn) {
                    loopBtn.classList.remove('active');
                    loopBtn.title = 'לולאה';
                }
                if (headerLoopBtn) {
                    headerLoopBtn.classList.remove('active');
                    headerLoopBtn.title = 'לולאה';
                }
                showStatus(`🔄 הופסקה לולאה עבור ${mp3File}`, 'info');
            } else {
                // Start new loop
                if (currentLoopingSegment) {
                    stopLoop();
                    const oldBtn = document.getElementById(`loop-btn-${currentLoopingSegment}`);
                    const oldHeaderBtn = document.getElementById(`header-loop-btn-${currentLoopingSegment}`);
                    if (oldBtn) {
                        oldBtn.classList.remove('active');
                        oldBtn.title = 'לולאה';
                    }
                    if (oldHeaderBtn) {
                        oldHeaderBtn.classList.remove('active');
                        oldHeaderBtn.title = 'לולאה';
                    }
                }
                
                startLoop(mp3File);
                if (loopBtn) {
                    loopBtn.classList.add('active');
                    loopBtn.title = '⏹️ עצור לולאה';
                }
                if (headerLoopBtn) {
                    headerLoopBtn.classList.add('active');
                    headerLoopBtn.title = '⏹️ עצור לולאה';
                }
                showStatus(`🔁 לולאה רציפה פעילה עבור ${mp3File} - כל שינוי יוחל מיד על הויזואליזציה!`, 'success');
            }
        }
        
        function startLoop(mp3File) {
            currentLoopingSegment = mp3File;
            
            // Tell visualization to loop this specific segment with current data
            const iframe = document.getElementById('segment-preview-iframe');
            if (iframe && iframe.contentWindow) {
                const segmentData = emotionData[mp3File] || {};
                iframe.contentWindow.postMessage({
                    action: 'startSegmentLoop',
                    segment: mp3File,
                    conversation: currentConversation,
                    segmentData: segmentData
                }, '*');
            }
            
            function playLoop() {
                currentLoopingAudio = new Audio(`conversations/${currentConversation}/${mp3File}`);
                currentLoopingAudio.onended = () => {
                    if (currentLoopingSegment === mp3File) {
                        // Restart after a short delay
                        setTimeout(playLoop, 500);
                    }
                };
                currentLoopingAudio.play().catch(error => {
                    console.error('Error in loop playback:', error);
                });
            }
            
            playLoop();
        }
        
        function stopLoop() {
            if (currentLoopingAudio) {
                currentLoopingAudio.pause();
                currentLoopingAudio = null;
            }
            
            // Tell visualization to stop segment loop and return to normal mode
            const iframe = document.getElementById('segment-preview-iframe');
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage({
                    action: 'stopSegmentLoop'
                }, '*');
            }
            
            currentLoopingSegment = null;
        }
        
        async function analyzeSegmentWithAI(mp3File) {
            if (!currentConversation || !emotionData[mp3File]) return;
            
            const confirmMessage = `לנתח את ${mp3File} עם AI?\n\nזה יחליף את הרגשות הקיימים של הקטע הזה.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                showLoading(`מנתח ${mp3File} עם AI...`);
                
                const segment = emotionData[mp3File];
                const transcript = segment.transcript || segment.words || '';
                
                if (!transcript.trim()) {
                    showStatus('אין טרנסקריפט לניתוח', 'error');
                    return;
                }
                
                const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversation: currentConversation,
                        mp3File: mp3File,
                        transcript: transcript,
                        currentEmotions: segment.emotions || [],
                        speaker: segment.speaker || 0
                    })
                });

                if (!response.ok) throw new Error('Analysis failed');
                
                const result = await response.json();
                
                if (result.success && result.analysis) {
                    // Check if the backend auto-saved the segment
                    if (result.segment_updated && result.analysis.auto_saved) {
                        // Backend auto-saved - update local data directly from saved values
                        const savedUpdates = result.segment_updated.updates;
                        
                        // Update local emotion data with the auto-saved values
                        emotionData[mp3File] = { ...emotionData[mp3File], ...savedUpdates };
                        
                        // Clear any pending changes for this segment since it's already saved
                        if (pendingChanges[mp3File]) {
                            delete pendingChanges[mp3File];
                        }
                        
                        // Check if there are any other pending changes
                        hasUnsavedChanges = Object.keys(pendingChanges).length > 0;
                        
                        showStatus(`✅ ניתוח AI הושלם ונשמר אוטומטית! רגשות: ${savedUpdates.emotions.join(', ')}`, 'success');
                        
                        console.log(`🎯 Auto-saved AI analysis for ${mp3File}:`, savedUpdates);
                    } else {
                        // Fallback: manual save needed (shouldn't happen with auto-save enabled)
                        const updates = {
                            emotions: result.analysis.emotions || ['neutral'],
                            blur: result.analysis.blur || 0,
                            shine: result.analysis.shine || 0,
                            humor: result.analysis.humor || 0,
                            ai_analyzed: true,
                            ai_analysis_date: new Date().toISOString()
                        };
                        
                        // Update local data
                        emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                        
                        // Mark as pending change
                        pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                        hasUnsavedChanges = true;
                        
                        showStatus(`ניתוח AI הושלם! רגשות: ${updates.emotions.join(', ')} - נדרשת שמירה ידנית`, 'warning');
                        
                        // Auto-save the changes if auto-save failed
                        await saveAllChanges();
                    }
                    
                    // Update emotions availability in dropdowns
                    if (result.analysis && result.analysis.available_emotions && result.analysis.emotions) {
                        updateEmotionsAvailability(result.analysis.available_emotions, result.analysis.emotion_mapping);
                        
                        // Auto-add detected emotions to the segment
                        result.analysis.emotions.forEach(detectedEmotion => {
                            autoAddDetectedEmotion(mp3File, detectedEmotion);
                        });
                    }
                    
                    // Update the UI in both cases
                    displaySegments();
                    
                    // If this is the currently selected segment, reload its editor
                    if (currentSelectedSegment === mp3File) {
                        loadSegmentEditor(mp3File, emotionData[mp3File]);
                        updateSegmentVisualization(mp3File);
                    }
                    
                    // Update save button state
                    updateSaveButtonState();
                    
                    // Auto-sync to production after AI analysis (non-blocking)
                    setTimeout(async () => {
                        try {
                            await syncToProduction(currentConversation, 'incremental');
                        } catch (error) {
                            console.warn('⚠️ Sync to production failed after AI analysis:', error);
                        }
                    }, 1000); // Small delay to ensure changes are processed
                    
                } else {
                    showStatus('שגיאה בניתוח AI - לא התקבלו תוצאות', 'error');
                }
            } catch (error) {
                console.error('Error analyzing segment:', error);
                showStatus(`שגיאה בניתוח AI: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        // Save changes
        async function saveAllChanges() {
            const changeCount = Object.keys(pendingChanges).length;
            if (changeCount === 0) {
                showStatus('אין שינויים לשמירה', 'error');
                return;
            }

            try {
                showLoading('שומר שינויים...');
                
                console.log('=== SAVE DEBUG INFO ===');
                console.log('Pending changes count:', changeCount);
                console.log('Pending changes:', pendingChanges);
                console.log('Current conversation:', currentConversation);
                
                // Save each changed segment
                for (const [filename, data] of Object.entries(pendingChanges)) {
                    console.log(`\n--- Saving ${filename} ---`);
                    console.log('Data being sent:', data);
                    console.log('Data type:', typeof data);
                    console.log('Data keys:', data ? Object.keys(data) : 'data is null/undefined');
                    
                    // Make sure data is valid
                    if (!data || typeof data !== 'object') {
                        console.error(`Invalid data for ${filename}:`, data);
                        continue;
                    }
                    
                    // Check if there are any actual changes
                    const changeKeys = Object.keys(data);
                    if (changeKeys.length === 0) {
                        console.warn(`No changes found for ${filename}, skipping`);
                        continue;
                    }
                    
                    // Validate required fields
                    if (!currentConversation) {
                        console.error('Missing currentConversation');
                        throw new Error('No conversation selected');
                    }
                    
                    if (!filename) {
                        console.error('Missing filename');
                        continue;
                    }
                    
                    const requestPayload = {
                        conversation: currentConversation,
                        filename: filename,
                        updates: data
                    };
                    
                    console.log('Full request payload:', JSON.stringify(requestPayload, null, 2));
                    console.log('Payload validation:');
                    console.log('- conversation:', requestPayload.conversation);
                    console.log('- filename:', requestPayload.filename);
                    console.log('- updates:', requestPayload.updates);
                    console.log('- updates is object:', typeof requestPayload.updates === 'object');
                    console.log('- updates is not null:', requestPayload.updates !== null);
                    console.log('- updates keys:', requestPayload.updates ? Object.keys(requestPayload.updates) : 'no updates');
                    
                    const response = await fetch(`${apiBaseUrl}/api/update-segment`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestPayload)
                    });
                    
                    console.log('Response status:', response.status);
                    console.log('Response OK:', response.ok);
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('Error response body:', errorText);
                        throw new Error(`Failed to save ${filename}: ${response.status} - ${errorText}`);
                    }
                    
                    const result = await response.json();
                    console.log('Save result:', result);
                }
                
                // Clear pending changes
                pendingChanges = {};
                hasUnsavedChanges = false;
                
                // Update save button state
                updateSaveButtonState();
                
                // DISABLED: Auto-sync to production after saving changes (causes slowness)
                // Users can manually sync when needed to prevent admin panel lag
                console.log('⚠️ Auto-sync disabled after analysis to prevent slowness - sync manually if needed');
                
                showStatus(`נשמרו ${changeCount} שינויים בהצלחה!`, 'success');
                
            } catch (error) {
                console.error('Error saving changes:', error);
                showStatus(`שגיאה בשמירת השינויים: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }



        // ==================== COMPREHENSIVE CONVERSATION ANALYSIS ====================
        // Analyzes entire conversation with ChatGPT using transcripts + audio for each segment
        async function analyzeEntireConversationComprehensive() {
            if (!currentConversation) {
                showStatus('אנא בחר שיחה לניתוח', 'error');
                return;
            }

            // Get all mp3 files from the conversation (with or without transcripts)
            const mp3Files = Object.keys(emotionData).filter(key => key.endsWith('.mp3'));
            
            if (mp3Files.length === 0) {
                showStatus('לא נמצאו קטעי MP3 לניתוח', 'error');
                return;
            }
            
            // Count how many have transcripts vs audio-only
            const withTranscripts = mp3Files.filter(key => {
                const segment = emotionData[key];
                const transcript = segment.transcript || segment.words || '';
                return transcript.trim().length > 0;
            });
            
            const audioOnly = mp3Files.length - withTranscripts.length;

            let confirmMessage = `🎯 ניתוח מלא עבור כל השיחה?\n\n📊 יותחו ${mp3Files.length} קטעים:`;
            if (withTranscripts.length > 0) {
                confirmMessage += `\n• ${withTranscripts.length} קטעים עם טקסט (רגשות מרובים + אודיו)`;
            }
            if (audioOnly > 0) {
                confirmMessage += `\n• ${audioOnly} קטעים ללא טקסט (ניתוח אודיו בלבד)`;
            }
            confirmMessage += `\n\n🎭 חדש: זיהוי רגשות מרובים בכל קטע!\n🤖 כל קטע יותח עם ChatGPT + כל 92 הרגשות\n🔊 ניתוח אודיו מתקדם עם פרמטרים ויזואליים\n⚠️ זה יעדכן את כל הפרמטרים (רגשות, טשטוש, ברק, הומור)!`;
            
            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                showLoading(`🎭 מנתח ${mp3Files.length} קטעים עם רגשות מרובים...\n\n🤖 ChatGPT + כל 92 הרגשות + ניתוח אודיו`);
                
                // Show progress indicator
                const analysisProgressIndicator = document.getElementById('analysis-progress');
                if (analysisProgressIndicator) {
                    analysisProgressIndicator.style.display = 'block';
                }
                
                let successCount = 0;
                let errorCount = 0;
                let processedSegments = [];
                
                // Analyze each segment
                for (let i = 0; i < mp3Files.length; i++) {
                    const mp3File = mp3Files[i];
                    try {
                        const segment = emotionData[mp3File];
                        const transcript = segment.transcript || segment.words || '';
                        const hasTranscript = transcript.trim().length > 0;
                        
                        // Determine analysis type
                        const analysisType = hasTranscript ? 'רגשות מרובים + אודיו' : 'ניתוח אודיו בלבד';
                        
                        // Show detailed progress
                        showAnalysisProgress(i + 1, mp3Files.length, mp3File, analysisType);
                        
                        // Log what type of analysis we're doing
                        if (hasTranscript) {
                            console.log(`🎯 Analyzing ${mp3File} with transcript + audio (${i + 1}/${mp3Files.length})`);
                        } else {
                            console.log(`🎵 Analyzing ${mp3File} with audio only (${i + 1}/${mp3Files.length})`);
                        }
                        
                        // Use optimal settings for comprehensive analysis
                        const includeVolumeAnalysis = true;     // Always include audio analysis
                        const advancedParameters = true;       // Always use advanced parameters  
                        const preserveExisting = false;        // Always overwrite for fresh analysis
                        
                        const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                conversation: currentConversation,
                                mp3File: mp3File,
                                transcript: transcript,
                                currentEmotions: segment.emotions || ['neutral'],
                                speaker: segment.speaker || 0,
                                includeVolumeAnalysis: includeVolumeAnalysis,
                                advancedParameters: advancedParameters,
                                preserveExisting: preserveExisting
                            })
                        });

                        if (response.ok) {
                            const result = await response.json();
                            if (result.success && result.analysis) {
                                // Build comprehensive updates object
                                const updates = {
                                    emotions: result.analysis.emotions || ['neutral'],
                                    blur: result.analysis.blur || 0,
                                    shine: result.analysis.shine || 0,
                                    humor: result.analysis.humor || 0,
                                    ai_analyzed: true,
                                    ai_analysis_date: new Date().toISOString()
                                };
                                
                                // Add advanced parameters if available
                                if (result.analysis.advanced) {
                                    Object.assign(updates, {
                                        godel_to_regesh: result.analysis.advanced.godel_to_regesh,
                                        kamut_to_regesh: result.analysis.advanced.kamut_to_regesh,
                                        blob_size: result.analysis.advanced.blob_size,
                                        blob_intensity: result.analysis.advanced.blob_intensity,
                                        dominance: result.analysis.advanced.dominance,
                                        blobiness: result.analysis.advanced.blobiness,
                                        proximity: result.analysis.advanced.proximity,
                                        tone: result.analysis.advanced.tone,
                                        intention: result.analysis.advanced.intention,
                                        advanced_params: true
                                    });
                                }
                                
                                // Add volume analysis if available
                                if (result.volume) {
                                    Object.assign(updates, {
                                        volume_mean: result.volume.mean,
                                        volume_max: result.volume.max,
                                        volume_energy: result.volume.energy,
                                        audio_duration: result.volume.duration,
                                        volume_analyzed: true
                                    });
                                }
                                
                                // Update local data
                                emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                                
                                // IMPORTANT: Save to server immediately
                                try {
                                    const updateResponse = await fetch(`${apiBaseUrl}/api/update-segment`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            conversation: currentConversation,
                                            filename: mp3File,
                                            updates: updates
                                        })
                                    });
                                    
                                    if (updateResponse.ok) {
                                        console.log(`✅ Successfully saved ${mp3File} analysis`);
                                    } else {
                                        console.error(`❌ Failed to save ${mp3File} analysis`);
                                    }
                                } catch (saveError) {
                                    console.error(`❌ Error saving ${mp3File}:`, saveError);
                                }
                                
                                successCount++;
                                processedSegments.push(mp3File);
                                
                                // Update UI less frequently to prevent slowness
                                if (processedSegments.length % 5 === 0) { // Update every 5 segments instead of every segment
                                    displaySegments();
                                }
                            }
                        } else {
                            errorCount++;
                            console.error(`Failed to analyze ${mp3File}: ${response.status}`);
                        }
                    } catch (error) {
                        errorCount++;
                        console.error(`Error analyzing ${mp3File}:`, error);
                    }
                }
                
                // Show completion status
                if (successCount > 0) {
                    const progressElement = document.getElementById('analysis-progress-text');
                    if (progressElement) {
                        progressElement.textContent = 'מסיים ניתוח...';
                    }
                }
                
                // Hide progress indicator
                const analysisProgressEnd = document.getElementById('analysis-progress');
                if (analysisProgressEnd) {
                    analysisProgressEnd.style.display = 'none';
                }
                
                // Reload emotion data to get fresh data and update UI
                if (successCount > 0) {
                    await loadEmotionData(currentConversation);
                    displaySegments(); // Refresh the segments display
                }
                
                // DISABLED: Auto-sync to production after bulk analysis (causes slowness)
                // Manual sync recommended after bulk operations
                if (false && successCount > 0) { // Disabled
                    setTimeout(async () => {
                        try {
                            await syncToProduction(currentConversation, 'incremental');
                        } catch (error) {
                            console.warn('⚠️ Sync to production failed after bulk analysis:', error);
                        }
                    }, 1000); // Small delay to ensure reload is complete
                }
                
                // Show detailed completion message
                let completionMessage = `🎭 ניתוח רגשות מרובים הושלם!\n\n✅ ${successCount} קטעים נותחו בהצלחה`;
                if (errorCount > 0) {
                    completionMessage += `\n❌ ${errorCount} שגיאות`;
                }
                completionMessage += `\n\n🎯 תכונות מתקדמות שפועלות:\n• זיהוי מעד 3 רגשות בכל קטע\n• גישה לכל 92 הרגשות במערכת\n• ניתוח אודיו מתקדם\n• פרמטרים ויזואליים מותאמים`;
                if (processedSegments.length > 0) {
                    completionMessage += `\n\n📋 קטעים שעודכנו:\n${processedSegments.slice(0, 10).join(', ')}`;
                    if (processedSegments.length > 10) {
                        completionMessage += `\n...ועוד ${processedSegments.length - 10}`;
                    }
                }
                completionMessage += '\n\n🔄 הנתונים נשמרו ועודכנו בממשק';
                
                showStatus(completionMessage, 'success');
                
            } catch (error) {
                console.error('Error analyzing conversation:', error);
                showStatus('שגיאה בניתוח AI', 'error');
                const analysisProgressError = document.getElementById('analysis-progress');
                if (analysisProgressError) {
                    analysisProgressError.style.display = 'none';
                }
            } finally {
                hideLoading();
            }
        }

        // ==================== INDIVIDUAL SEGMENT ADVANCED ANALYSIS ====================
        
        async function analyzeSegmentAdvanced(mp3File) {
            if (!currentConversation || !emotionData[mp3File]) {
                showStatus('שגיאה: נתוני הקטע לא נמצאו', 'error');
                return;
            }

            const segment = emotionData[mp3File];
            const confirmMessage = `לבצע ניתוח מתקדם עבור ${mp3File}?\n\n🔬 ניתוח כולל:\n• GPT-4 עם פרמטרים מתקדמים\n• ניתוח עוצמת קול\n• פרמטרים ויזואליים מפורטים`;
            
            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                showLoading(`מבצע ניתוח מתקדם עבור ${mp3File}...`);
                
                const analysisData = {
                    conversation: currentConversation,
                    mp3File: mp3File,
                    transcript: segment.transcript || segment.words || '',
                    currentEmotions: segment.emotions || ['neutral'],
                    speaker: segment.speaker || 0,
                    includeVolumeAnalysis: true,
                    advancedParameters: true
                };
                
                const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.analysis) {
                        const updates = {
                            emotions: result.analysis.emotions || ['neutral'],
                            blur: result.analysis.blur || 0,
                            shine: result.analysis.shine || 0,
                            humor: result.analysis.humor || 0,
                            ai_analyzed: true,
                            ai_analysis_date: new Date().toISOString()
                        };
                        
                        // Add advanced parameters
                        if (result.analysis.advanced) {
                            Object.assign(updates, {
                                godel_to_regesh: result.analysis.advanced.godel_to_regesh,
                                kamut_to_regesh: result.analysis.advanced.kamut_to_regesh,
                                blob_size: result.analysis.advanced.blob_size,
                                blob_intensity: result.analysis.advanced.blob_intensity,
                                dominance: result.analysis.advanced.dominance,
                                blobiness: result.analysis.advanced.blobiness,
                                proximity: result.analysis.advanced.proximity,
                                tone: result.analysis.advanced.tone,
                                intention: result.analysis.advanced.intention,
                                advanced_params: true
                            });
                        }
                        
                        // Add volume analysis
                        if (result.volume) {
                            Object.assign(updates, {
                                volume_mean: result.volume.mean,
                                volume_max: result.volume.max,
                                volume_energy: result.volume.energy,
                                audio_duration: result.volume.duration,
                                volume_analyzed: true,
                                volume_analysis_date: new Date().toISOString()
                            });
                        }
                        
                        // Update data
                        emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                        pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                        hasUnsavedChanges = true;
                        
                        // Refresh displays
                        displaySegments();
                        if (document.getElementById('active-segment-editor')) {
                            selectSegment(mp3File, emotionData[mp3File]);
                        }
                        
                        showStatus(`ניתוח מתקדם הושלם עבור ${mp3File}`, 'success');
                    } else {
                        showStatus('ניתוח נכשל - לא התקבלו תוצאות', 'error');
                    }
                } else {
                    const error = await response.text();
                    showStatus(`שגיאה בניתוח: ${error}`, 'error');
                }
                
            } catch (error) {
                console.error('Error in advanced segment analysis:', error);
                showStatus('שגיאה בניתוח מתקדם', 'error');
            } finally {
                hideLoading();
            }
        }

        async function analyzeVolumeOnly(mp3File) {
            if (!currentConversation || !emotionData[mp3File]) {
                showStatus('שגיאה: נתוני הקטע לא נמצאו', 'error');
                return;
            }

            try {
                showLoading(`מנתח עוצמת קול עבור ${mp3File}...`);
                
                const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversation: currentConversation,
                        mp3File: mp3File,
                        transcript: emotionData[mp3File].transcript || '',
                        volumeOnly: true
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.volume) {
                        const updates = {
                            volume_mean: result.volume.mean,
                            volume_max: result.volume.max,
                            volume_energy: result.volume.energy,
                            audio_duration: result.volume.duration,
                            volume_analyzed: true,
                            volume_analysis_date: new Date().toISOString()
                        };
                        
                        emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                        pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                        hasUnsavedChanges = true;
                        
                        // Refresh displays
                        displaySegments();
                        if (document.getElementById('active-segment-editor')) {
                            selectSegment(mp3File, emotionData[mp3File]);
                        }
                        
                        showStatus(`ניתוח קול הושלם עבור ${mp3File}`, 'success');
                    } else {
                        showStatus('ניתוח קול נכשל - לא התקבלו נתונים', 'error');
                    }
                } else {
                    const error = await response.text();
                    showStatus(`שגיאה בניתוח קול: ${error}`, 'error');
                }
                
            } catch (error) {
                console.error('Error in volume analysis:', error);
                showStatus('שגיאה בניתוח קול', 'error');
            } finally {
                hideLoading();
            }
        }

        // ==================== ADVANCED AI ANALYSIS FUNCTIONS ====================
        
        async function analyzeConversationAdvanced() {
            if (!currentConversation || !emotionData) {
                showStatus('יש לבחור שיחה קודם', 'error');
                return;
            }

            const confirmMessage = 'לבצע ניתוח מתקדם עם AI + ניתוח קול?\n\n🔬 זה כולל:\n• ניתוח טקסט מתקדם עם GPT-4\n• ניתוח עוצמת קול ואנרגיה\n• פרמטרים ויזואליים מפורטים\n• ניתוח רגשי מעמיק\n\n⚠️ התהליך עלול לקחת זמן רב!';
            
            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                showLoading('מבצע ניתוח מתקדם...');
                
                const includeVolume = document.getElementById('includeVolumeAnalysis').checked;
                const advancedParams = document.getElementById('advancedParameters').checked;
                
                let successCount = 0;
                let errorCount = 0;
                const mp3Files = Object.keys(emotionData);
                
                for (let i = 0; i < mp3Files.length; i++) {
                    const mp3File = mp3Files[i];
                    const segment = emotionData[mp3File];
                    
                    // Don't skip segments without transcripts - process all segments equally
                    if (!segment.transcript || segment.transcript.trim() === '') {
                        console.log(`⚠️ ${mp3File} has no transcript - will process with placeholder text`);
                        // Use a placeholder transcript to ensure the segment is still analyzed
                        segment.transcript = `[Audio segment ${mp3File}]`;
                    }
                    
                    try {
                        showLoading(`מנתח ${mp3File} (${i + 1}/${mp3Files.length})...`);
                        
                        // Prepare analysis payload
                        const analysisData = {
                            conversation: currentConversation,
                            mp3File: mp3File,
                            transcript: segment.transcript,
                            currentEmotions: segment.emotions || ['neutral'],
                            speaker: segment.speaker || 0,
                            includeVolumeAnalysis: includeVolume,
                            advancedParameters: advancedParams
                        };
                        
                        const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(analysisData)
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            
                            if (result.analysis) {
                                // Advanced parameter updates
                                const updates = {
                                    emotions: result.analysis.emotions || ['neutral'],
                                    blur: result.analysis.blur || 0,
                                    shine: result.analysis.shine || 0,
                                    humor: result.analysis.humor || 0,
                                    ai_analyzed: true,
                                    ai_analysis_date: new Date().toISOString()
                                };
                                
                                // Add advanced parameters if available
                                if (advancedParams && result.analysis.advanced) {
                                    Object.assign(updates, {
                                        godel_to_regesh: result.analysis.advanced.godel_to_regesh,
                                        kamut_to_regesh: result.analysis.advanced.kamut_to_regesh,
                                        blob_size: result.analysis.advanced.blob_size,
                                        blob_intensity: result.analysis.advanced.blob_intensity,
                                        dominance: result.analysis.advanced.dominance,
                                        blobiness: result.analysis.advanced.blobiness,
                                        proximity: result.analysis.advanced.proximity,
                                        tone: result.analysis.advanced.tone,
                                        intention: result.analysis.advanced.intention
                                    });
                                }
                                
                                // Add volume analysis if available  
                                if (includeVolume && result.volume) {
                                    Object.assign(updates, {
                                        volume_mean: result.volume.mean,
                                        volume_max: result.volume.max,
                                        volume_energy: result.volume.energy,
                                        audio_duration: result.volume.duration
                                    });
                                }
                                
                                // Update local data
                                emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                                pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                                hasUnsavedChanges = true;
                                
                                successCount++;
                                displaySegments(); // Update UI in real-time
                            }
                        } else {
                            errorCount++;
                            console.error(`Failed advanced analysis for ${mp3File}`);
                        }
                    } catch (error) {
                        errorCount++;
                        console.error(`Error in advanced analysis for ${mp3File}:`, error);
                    }
                }
                
                // Save changes
                if (successCount > 0) {
                    showLoading('שומר תוצאות ניתוח מתקדם...');
                    await saveAllChanges();
                }
                
                await loadEmotionData(currentConversation);
                showStatus(`ניתוח מתקדם הושלם! ${successCount} קטעים נותחו${errorCount > 0 ? `, ${errorCount} שגיאות` : ''}`, 'success');
                
            } catch (error) {
                console.error('Error in advanced conversation analysis:', error);
                showStatus('שגיאה בניתוח מתקדם', 'error');
            } finally {
                hideLoading();
            }
        }

        async function analyzeVolumeForAll() {
            if (!currentConversation || !emotionData) {
                showStatus('יש לבחור שיחה קודם', 'error');
                return;
            }

            const confirmMessage = 'לנתח עוצמת קול לכל הקטעים?\n\n🔊 זה יוסיף נתוני עוצמת קול ואנרגיה לכל המקטעים.';
            
            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                showLoading('מנתח עוצמת קול...');
                
                let successCount = 0;
                let errorCount = 0;
                const mp3Files = Object.keys(emotionData);
                
                for (let i = 0; i < mp3Files.length; i++) {
                    const mp3File = mp3Files[i];
                    
                    try {
                        showLoading(`מנתח קול ${mp3File} (${i + 1}/${mp3Files.length})...`);
                        
                        const response = await fetch(`${apiBaseUrl}/api/analyze-segment`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                conversation: currentConversation,
                                mp3File: mp3File,
                                transcript: emotionData[mp3File].transcript || '',
                                volumeOnly: true
                            })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            
                            if (result.volume) {
                                const updates = {
                                    volume_mean: result.volume.mean,
                                    volume_max: result.volume.max,
                                    volume_energy: result.volume.energy,
                                    audio_duration: result.volume.duration,
                                    volume_analyzed: true,
                                    volume_analysis_date: new Date().toISOString()
                                };
                                
                                emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                                pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                                hasUnsavedChanges = true;
                                
                                successCount++;
                            }
                        } else {
                            errorCount++;
                        }
                    } catch (error) {
                        errorCount++;
                        console.error(`Error analyzing volume for ${mp3File}:`, error);
                    }
                }
                
                if (successCount > 0) {
                    await saveAllChanges();
                    displaySegments();
                }
                
                showStatus(`ניתוח קול הושלם! ${successCount} קטעים נותחו${errorCount > 0 ? `, ${errorCount} שגיאות` : ''}`, 'success');
                
            } catch (error) {
                console.error('Error in volume analysis:', error);
                showStatus('שגיאה בניתוח קול', 'error');
            } finally {
                hideLoading();
            }
        }

        async function reanalyzeTranscripts() {
            if (!currentConversation || !emotionData) {
                showStatus('יש לבחור שיחה קודם', 'error');
                return;
            }

            const confirmMessage = 'לנתח מחדש את התמלולים עם AI?\n\n📝 זה ינתח את התמלולים הקיימים ויעדכן רגשות בהתאם.';
            
            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                showLoading('מנתח תמלולים מחדש...');
                
                const preserveExisting = document.getElementById('preserveExisting').checked;
                let successCount = 0;
                let errorCount = 0;
                const mp3Files = Object.keys(emotionData);
                
                for (let i = 0; i < mp3Files.length; i++) {
                    const mp3File = mp3Files[i];
                    const segment = emotionData[mp3File];
                    
                    if (!segment.transcript) {
                        console.log(`Skipping ${mp3File} - no transcript`);
                        continue;
                    }
                    
                    try {
                        showLoading(`מנתח תמלול ${mp3File} (${i + 1}/${mp3Files.length})...`);
                        
                        const response = await fetch(`${apiBaseUrl}/api/update-conversation-transcript`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                conversation: currentConversation,
                                mp3File: mp3File,
                                newTranscript: segment.transcript,
                                preserveExisting: preserveExisting
                            })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            
                            if (result.updated_segment) {
                                const updates = {
                                    ...result.updated_segment,
                                    transcript_reanalyzed: true,
                                    transcript_analysis_date: new Date().toISOString()
                                };
                                
                                emotionData[mp3File] = { ...emotionData[mp3File], ...updates };
                                pendingChanges[mp3File] = { ...pendingChanges[mp3File], ...updates };
                                hasUnsavedChanges = true;
                                
                                successCount++;
                            }
                        } else {
                            errorCount++;
                        }
                    } catch (error) {
                        errorCount++;
                        console.error(`Error reanalyzing transcript for ${mp3File}:`, error);
                    }
                }
                
                if (successCount > 0) {
                    await saveAllChanges();
                    displaySegments();
                }
                
                showStatus(`ניתוח תמלולים הושלם! ${successCount} קטעים נותחו${errorCount > 0 ? `, ${errorCount} שגיאות` : ''}`, 'success');
                
            } catch (error) {
                console.error('Error in transcript reanalysis:', error);
                showStatus('שגיאה בניתוח תמלולים', 'error');
            } finally {
                hideLoading();
            }
        }

        async function exportConversationData() {
            if (!currentConversation || !emotionData) {
                showStatus('יש לבחור שיחה קודם', 'error');
                return;
            }

            try {
                showLoading('מכין נתונים לייצוא...');
                
                // Prepare export data
                const exportData = {
                    conversation: currentConversation,
                    exportDate: new Date().toISOString(),
                    segments: {},
                    metadata: {
                        totalSegments: Object.keys(emotionData).length,
                        analyzedSegments: Object.values(emotionData).filter(s => s.ai_analyzed).length,
                        hasVolumeData: Object.values(emotionData).some(s => s.volume_mean !== undefined),
                        conversationData: conversationsData[currentConversation]
                    }
                };
                
                // Add segment data
                for (const [mp3File, segment] of Object.entries(emotionData)) {
                    exportData.segments[mp3File] = {
                        ...segment,
                        exportTimestamp: new Date().toISOString()
                    };
                }
                
                // Create downloadable file
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentConversation}_export_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus('נתונים יוצאו בהצלחה', 'success');
                
            } catch (error) {
                console.error('Error exporting conversation data:', error);
                showStatus('שגיאה בייצוא נתונים', 'error');
            } finally {
                hideLoading();
            }
        }

        // Upload & Process Functions
        function setupEventListeners() {
            // File input - only set up if elements exist (upload tab)
            const fileInput = document.getElementById('fileInput');
            const uploadArea = document.getElementById('upload-area');
            const processBtn = document.getElementById('processBtn');

            if (fileInput && uploadArea && processBtn) {
                fileInput.addEventListener('change', handleFileSelect);
                
                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        fileInput.files = files;
                        handleFileSelect({ target: fileInput });
                    }
                });

                uploadArea.addEventListener('click', () => fileInput.click());
                processBtn.addEventListener('click', processUploadedFile);
            }

            // Sensitivity slider - only set up if elements exist (experiments tab)
            const slider = document.getElementById('sensitivity-slider');
            const value = document.getElementById('sensitivity-value');
            if (slider && value) {
                slider.addEventListener('input', () => {
                    value.textContent = slider.value;
                });
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            // Check if file has supported audio extension
            const supportedExtensions = ['.mp3', '.m4a', '.wav', '.flac', '.aac', '.ogg'];
            const fileName = file.name.toLowerCase();
            const isSupported = supportedExtensions.some(ext => fileName.endsWith(ext));
            
            if (!isSupported) {
                showStatus('נא לבחור קובץ אודיו נתמך: MP3, M4A, WAV, FLAC, AAC, OGG', 'error');
                return;
            }

            uploadedFile = file;
            document.querySelector('.upload-area h3').textContent = file.name;
            document.getElementById('processBtn').disabled = false;
            
            // Populate target folders
            const select = document.getElementById('target-folder');
            select.innerHTML = '<option value="">בחר תיקייה...</option>';
            
            Object.entries(conversationsData).forEach(([folder, data]) => {
                const option = document.createElement('option');
                option.value = folder;
                option.textContent = `שיחה ${data.number} - ${folder}`;
                select.appendChild(option);
            });
        }

        async function processUploadedFile() {
            if (!uploadedFile) return;

            const targetFolder = document.getElementById('target-folder').value;
            if (!targetFolder) {
                showStatus('נא לבחור תיקיית יעד', 'error');
                return;
            }

            try {
                showLoading('מעלה ומעבד קובץ...');
                
                const formData = new FormData();
                formData.append('file', uploadedFile);
                formData.append('folder', targetFolder);
                
                const response = await fetch(`${apiBaseUrl}/api/upload-process`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) throw new Error('Upload failed');

                showStatus('הקובץ הועלה ומעובד בהצלחה!', 'success');
                
                // Auto-sync to production after file upload and processing (non-blocking)
                setTimeout(async () => {
                    try {
                        await syncToProduction(targetFolder, 'incremental');
                    } catch (error) {
                        console.warn('⚠️ Sync to production failed after file upload:', error);
                    }
                }, 2000); // Longer delay to ensure processing is complete
                
                // Reset form
                uploadedFile = null;
                document.getElementById('fileInput').value = '';
                document.querySelector('.upload-area h3').textContent = 'גרור קובץ לכאן או לחץ לבחירה';
                document.getElementById('processBtn').disabled = true;
                
            } catch (error) {
                console.error('Error uploading:', error);
                showStatus('שגיאה בהעלאת הקובץ', 'error');
            } finally {
                hideLoading();
            }
        }

        // Retranscription options
        async function populateRetranscriptionOptions() {
            const quickContainer = document.getElementById('quick-analysis-options');
            const fullContainer = document.getElementById('full-reprocess-options');
            
            if (!quickContainer || !fullContainer) return;
            
            quickContainer.innerHTML = '';
            fullContainer.innerHTML = '';

            // Make sure conversationsData is loaded
            if (!conversationsData || Object.keys(conversationsData).length === 0) {
                await loadConversations();
            }

            const sortedConvos = Object.entries(conversationsData)
                .sort(([,a], [,b]) => a.number - b.number);

            sortedConvos.forEach(([folder, data]) => {
                // Quick analysis button
                const quickBtn = document.createElement('button');
                quickBtn.className = 'process-option';
                quickBtn.textContent = `שיחה ${data.number}`;
                quickBtn.onclick = () => retranscribeConversation(folder, false);
                quickContainer.appendChild(quickBtn);

                // Full reprocess button
                const fullBtn = document.createElement('button');
                fullBtn.className = 'process-option';
                fullBtn.textContent = `שיחה ${data.number}`;
                fullBtn.onclick = () => retranscribeConversation(folder, true);
                fullContainer.appendChild(fullBtn);
            });
        }

        async function retranscribeConversation(folder, useWhisper) {
            const action = useWhisper ? 'תמלול וניתוח מלא' : 'ניתוח מהיר';
            
            if (!confirm(`האם לבצע ${action} עבור ${folder}?`)) {
                return;
            }

            try {
                showLoading(`מבצע ${action}...`);
                
                const response = await fetch(`${apiBaseUrl}/api/retranscribe`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder, useWhisper })
                });

                if (!response.ok) throw new Error('Retranscription failed');

                showStatus(`${action} הושלם בהצלחה!`, 'success');
            } catch (error) {
                console.error('Error retranscribing:', error);
                showStatus(`שגיאה ב${action}`, 'error');
            } finally {
                hideLoading();
            }
        }

        // Experiments
        function initializeExperiments() {
            const textInput = document.getElementById('test-text-input');
            const output = document.getElementById('analysis-output');
            
            if (!textInput || !output) return;

            let timeout;
            textInput.addEventListener('input', () => {
                clearTimeout(timeout);
                timeout = setTimeout(() => analyzeText(), 300);
            });

            // Initial analysis
            analyzeText();
        }

        async function analyzeText() {
            const text = document.getElementById('test-text-input').value;
            const output = document.getElementById('analysis-output');
            
            if (!text.trim()) {
                output.textContent = 'הקלד טקסט לניתוח...';
                return;
            }

            try {
                const response = await fetch(`${apiBaseUrl}/api/test-analysis`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        text,
                        sensitivity: parseFloat(document.getElementById('sensitivity-slider')?.value || 0.5),
                        mode: document.getElementById('analysis-mode')?.value || 'standard'
                    })
                });

                if (!response.ok) throw new Error(`Analysis failed: ${response.status} ${response.statusText}`);

                const responseText = await response.text();
                if (!responseText) {
                    throw new Error('Empty analysis response');
                }
                
                let result;
                try {
                    result = JSON.parse(responseText);
                } catch (parseError) {
                    throw new Error(`Invalid response JSON: ${parseError.message}`);
                }
                
                output.textContent = JSON.stringify(result, null, 2);
            } catch (error) {
                output.textContent = `שגיאה: ${error.message}`;
            }
        }

        // Settings
        function saveSettings() {
            const settings = {
                apiServer: document.getElementById('api-server').value,
                apiKey: document.getElementById('api-key').value,
                autoRefresh: document.getElementById('auto-refresh').checked,
                showDebug: document.getElementById('show-debug').checked
            };

            localStorage.setItem('adminSettings', JSON.stringify(settings));
            showStatus('ההגדרות נשמרו בהצלחה!', 'success');
        }



        // Removed duplicate function - using main definition above
        
        // Store ETags for efficient polling
        let emotionDataETag = null;
        
        // Smart refresh emotion data using ETags
        async function refreshEmotionData() {
            if (!currentConversation || isLoadingEmotionData) {
                console.log(`⏭️ Skipping refresh: currentConversation=${currentConversation}, isLoadingEmotionData=${isLoadingEmotionData}`);
                return;
            }
            console.log(`🔄 Refreshing emotion data for: ${currentConversation}`);
            
            try {
                if (!conversationsData) {
                    console.warn(`⚠️ Conversations data not loaded yet, skipping refresh`);
                    return;
                }
                
                const convData = conversationsData[currentConversation];
                if (!convData) {
                    console.warn(`⚠️ Conversation ${currentConversation} not found in conversations data, skipping refresh`);
                    console.log(`📋 Available conversations:`, Object.keys(conversationsData));
                    return;
                }
                let emotionFile = convData.ai_file || convData.emotion_file || `emotions${convData.number}_ai_analyzed.json`;
                
                // Fix path - ensure we don't double the conversations/folder part
                if (!emotionFile.startsWith('conversations/')) {
                    emotionFile = `conversations/${currentConversation}/${emotionFile}`;
                }
                
                const emotionUrl = `${apiBaseUrl}/${emotionFile}`;
                
                // Use If-None-Match header for efficient caching
                const headers = {};
                if (emotionDataETag) {
                    headers['If-None-Match'] = emotionDataETag;
                }
                
                // Add timeout for refresh requests
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout for refresh
                
                const response = await fetch(emotionUrl, { 
                    headers,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (response.status === 304) {
                    // Data hasn't changed
                    console.log('✅ Emotion data unchanged (304)');
                    return;
                }
                
                if (response.ok) {
                    // Store new ETag
                    const newETag = response.headers.get('ETag');
                    if (newETag) {
                        emotionDataETag = newETag;
                    }
                    
                    const freshData = await response.json();
                    
                    // Check if data has changed
                    const hasChanges = JSON.stringify(freshData) !== JSON.stringify(emotionData);
                    
                    if (hasChanges && !hasUnsavedChanges) {
                        console.log('🔄 Emotion data changed, updating UI...');
                        emotionData = freshData;
                        displaySegments();
                    }
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.warn('⚠️ Failed to refresh emotion data:', error);
                }
                // Don't show error messages for background refresh failures
            }
        }

        // Individual segment visualization handlers
        function handleSegmentVizLoad(mp3File) {
            console.log(`✅ Segment visualization loaded for ${mp3File}`);
            const statusDiv = document.getElementById(`segment-viz-status-${mp3File}`);
            if (statusDiv && emotionData[mp3File]) {
                const emotions = emotionData[mp3File].emotions || ['neutral'];
                const speaker = emotionData[mp3File].speaker || 0;
                statusDiv.innerHTML = `✅ <strong>ויזואליזציה פעילה</strong> | דובר ${speaker} | רגשות: <span style="font-weight: bold; color: #2196F3;">${emotions.join(', ')}</span>`;
                statusDiv.style.color = '#4CAF50';
            }
        }
        
        // Debug function to help troubleshoot segment display issues
        function debugSegmentDisplay() {
            console.log('🔍 DEBUG: Segment Display Status');
            console.log('=' .repeat(50));
            
            // Check if conversation is selected
            console.log('📁 Current conversation:', currentConversation);
            console.log('📊 Emotion data loaded:', !!(emotionData && Object.keys(emotionData).length > 0));
            
            if (emotionData) {
                const mp3Files = Object.keys(emotionData).filter(key => key.endsWith('.mp3'));
                console.log('🎵 MP3 files found:', mp3Files.length);
                console.log('🎵 First 5 files:', mp3Files.slice(0, 5));
            }
            
            // Check DOM elements
            const container = document.getElementById('segments-container');
            console.log('📦 Segments container found:', !!container);
            console.log('📦 Container content length:', container ? container.innerHTML.length : 'N/A');
            
            const editor = document.getElementById('conversation-editor');
            console.log('📝 Editor visible:', editor ? editor.style.display !== 'none' : false);
            
            // Try to force display segments
            if (emotionData && Object.keys(emotionData).length > 0) {
                console.log('🔄 Attempting to force display segments...');
                displaySegments();
            }
            
            console.log('🔍 Debug complete');
        }
        
        // Add global debug function for easy access in console
        window.debugSegments = debugSegmentDisplay;
        
        function handleSegmentVizError(mp3File) {
            console.error(`❌ Segment visualization failed to load for ${mp3File}`);
            const statusDiv = document.getElementById(`segment-viz-status-${mp3File}`);
            if (statusDiv) {
                statusDiv.innerHTML = '❌ <strong>שגיאה בטעינת ויזואליזציה</strong> - נסה שוב';
                statusDiv.style.color = '#f44336';
            }
        }
        
        function loadSegmentVisualization(mp3File) {
            const iframe = document.getElementById('segment-preview-iframe');
            
            if (iframe) {
                // Load the visualization for this specific segment
                const timestamp = new Date().getTime();
                iframe.src = `${apiBaseUrl}/visualization.html?folder=${currentConversation}&segment=${mp3File}&viewMode=segment&t=${timestamp}`;
                
                // Auto-start loop if the loop button is active
                const loopBtn = document.getElementById('main-loop-btn');
                if (loopBtn && loopBtn.classList.contains('active')) {
                    setTimeout(() => {
                        startSegmentLoop();
                    }, 1000);
                }
            }
        }
        
        function toggleSegmentLoop() {
            const loopBtn = document.getElementById('main-loop-btn');
            
            if (loopBtn.classList.contains('active')) {
                // Stop loop
                stopSegmentLoop();
                loopBtn.classList.remove('active');
                loopBtn.innerHTML = '<i class="material-icons">loop</i> לולאה רציפה';
            } else {
                // Start loop
                startSegmentLoop();
                loopBtn.classList.add('active');
                loopBtn.innerHTML = '<i class="material-icons">stop</i> עצור לולאה';
            }
        }
        
        function startSegmentLoop() {
            if (!currentSelectedSegment) return;
            
            const iframe = document.getElementById('segment-preview-iframe');
            if (iframe && iframe.contentWindow) {
                const segmentData = emotionData[currentSelectedSegment] || {};
                iframe.contentWindow.postMessage({
                    action: 'startSegmentLoop',
                    segment: currentSelectedSegment,
                    conversation: currentConversation,
                    segmentData: segmentData
                }, '*');
            }
            
            // Start audio loop
            currentLoopingSegment = currentSelectedSegment;
            startLoop(currentSelectedSegment);
        }
        
        function stopSegmentLoop() {
            stopLoop();
            
            const iframe = document.getElementById('segment-preview-iframe');
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage({
                    action: 'stopSegmentLoop'
                }, '*');
            }
        }
        
        function playCurrentSegment() {
            if (currentSelectedSegment) {
                playSegment(currentSelectedSegment);
            }
        }
        
        function updateSegmentVisualization(mp3File) {
            const iframe = document.getElementById('segment-preview-iframe');
            if (iframe && iframe.contentWindow) {
                const segmentData = emotionData[mp3File] || {};
                iframe.contentWindow.postMessage({
                    action: 'updateSegmentData',
                    segment: mp3File,
                    conversation: currentConversation,
                    segmentData: segmentData
                }, '*');
                
                console.log(`🔄 Updated visualization for ${mp3File}:`, segmentData);
            }
        }
        
        // Update visualization in real-time when looping
        function updateLoopingVisualization(mp3File) {
            if (currentLoopingSegment !== mp3File) return;
            
            const iframe = document.getElementById('segment-preview-iframe');
            if (iframe && iframe.contentWindow) {
                const segmentData = emotionData[mp3File] || {};
                iframe.contentWindow.postMessage({
                    action: 'updateLoopingSegment',
                    segment: mp3File,
                    conversation: currentConversation,
                    segmentData: segmentData
                }, '*');
                
                console.log(`🔄 Updated looping visualization for ${mp3File}:`, segmentData);
            }
        }

        // Warn before leaving with unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        // ==================== AI SUMMARY AND INSIGHTS GENERATION FUNCTIONS ====================
        
        // Function to refresh AI content in visualization windows
        function refreshVisualizationAIContent(conversationKey) {
            try {
                // First, try to refresh content in the same window (most common case)
                if (window.refreshAIContent && typeof window.refreshAIContent === 'function') {
                    console.log(`🔄 Refreshing AI content in same window for ${conversationKey}`);
                    window.refreshAIContent();
                }
                
                // Try to refresh content in any open visualization windows
                // This will work if the visualization page is open in the same browser
                if (window.opener && window.opener.refreshAIContent) {
                    console.log(`🔄 Refreshing AI content in opener window for ${conversationKey}`);
                    window.opener.refreshAIContent();
                }
                
                // Also try to refresh content in child windows (if any)
                if (window.childWindows) {
                    window.childWindows.forEach(childWindow => {
                        if (childWindow && childWindow.refreshAIContent) {
                            console.log(`🔄 Refreshing AI content in child window for ${conversationKey}`);
                            childWindow.refreshAIContent();
                        }
                    });
                }
                
                // Post message to all windows (as a fallback)
                try {
                    if (window.parent !== window) {
                        window.parent.postMessage({
                            type: 'refreshAIContent',
                            conversationKey: conversationKey
                        }, '*');
                    }
                } catch (e) {
                    // Ignore cross-origin errors
                }
                
                // Try to refresh insights directly if functions exist on this window
                if (typeof window.refreshAIContent === 'function') {
                    console.log(`🔄 Direct refresh: calling refreshAIContent`);
                    window.refreshAIContent();
                }
                
                // Try to refresh insights in any open visualization tabs
                if (typeof window.displayAIInsights === 'function') {
                    console.log(`🔄 Direct refresh: calling displayAIInsights`);
                    window.displayAIInsights();
                }
                
                console.log(`📨 AI content refresh triggered for ${conversationKey}`);
            } catch (error) {
                console.log(`⚠️ Could not refresh visualization content:`, error);
            }
        }
        
        // Functions for current conversation in editor
        async function generateCurrentConversationSummary() {
            if (!currentConversation) {
                showStatus('❌ אין שיחה נבחרת לעריכה', 'error');
                return;
            }
            await generateConversationSummary(currentConversation);
        }
        
        async function generateCurrentConversationInsights() {
            if (!currentConversation) {
                showStatus('❌ אין שיחה נבחרת לעריכה', 'error');
                return;
            }
            await generateConversationInsights(currentConversation);
        }
        
        async function generateCurrentConversationBoth() {
            if (!currentConversation) {
                showStatus('❌ אין שיחה נבחרת לעריכה', 'error');
                return;
            }
            await generateBothForConversation(currentConversation);
        }
        
        // Individual conversation AI generation functions
        async function generateConversationSummary(conversationKey) {
            if (!confirm(`🤖 לצור סיכום מבוסס AI עבור שיחה ${conversationKey}?`)) {
                return;
            }

            try {
                showLoading(`📝 יוצר סיכום AI עבור ${conversationKey}...`);
                
                // Get specific conversation from config
                const response = await fetch('config/conversations_config.json');
                const config = await response.json();
                const conversationData = config.conversations[conversationKey];
                
                if (!conversationData) {
                    throw new Error(`Conversation ${conversationKey} not found`);
                }
                
                // Generate AI summary for this conversation
                const summaryResult = await generateConversationSummaryAI(conversationKey, conversationData);
                
                if (summaryResult.success) {
                    showStatus(`✅ סיכום AI נוצר בהצלחה עבור ${conversationKey}!\n\n🎯 הסיכום יוצג בלשונית "סיכום" בפאנל הצד`, 'success');
                    // Refresh the conversations list to show updated indicators
                    await loadConversations();
                    // Refresh AI content in visualization windows
                    refreshVisualizationAIContent(conversationKey);
                } else {
                    showStatus(`❌ שגיאה ביצירת סיכום עבור ${conversationKey}: ${summaryResult.error}`, 'error');
                }
                
            } catch (error) {
                console.error(`Error generating summary for ${conversationKey}:`, error);
                showStatus(`שגיאה ביצירת סיכום: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }
        
        async function generateConversationInsights(conversationKey) {
            if (!confirm(`🔍 לצור תובנות מבוססות AI עבור שיחה ${conversationKey}?`)) {
                return;
            }

            try {
                showLoading(`💡 יוצר תובנות AI עבור ${conversationKey}...`);
                
                // Get specific conversation from config
                const response = await fetch('config/conversations_config.json');
                const config = await response.json();
                const conversationData = config.conversations[conversationKey];
                
                if (!conversationData) {
                    throw new Error(`Conversation ${conversationKey} not found`);
                }
                
                // Generate AI insights for this conversation
                const insightsResult = await generateConversationInsightsAI(conversationKey, conversationData);
                
                if (insightsResult.success) {
                    showStatus(`✅ תובנות AI נוצרו בהצלחה עבור ${conversationKey}!\n\n💡 התובנות יוצגו בלשונית "תובנות" בפאנל הצד`, 'success');
                    // Refresh the conversations list to show updated indicators
                    await loadConversations();
                    // Refresh AI content in visualization windows
                    refreshVisualizationAIContent(conversationKey);
                    
                    // Store insights in localStorage for offline access
                    setTimeout(async () => {
                        try {
                            console.log('🔄 Storing insights locally and triggering refresh...');
                            
                            // Store insights in localStorage
                            if (insightsResult.insights) {
                                const insightKey = `insights_${conversationKey}`;
                                localStorage.setItem(insightKey, JSON.stringify(insightsResult.insights));
                                console.log(`💾 Insights stored locally for ${conversationKey}`);
                            }
                            
                            // Reset conversations config cache in all possible windows
                            if (typeof window.conversationsConfig !== 'undefined') {
                                window.conversationsConfig = null;
                            }
                            if (window.opener && typeof window.opener.conversationsConfig !== 'undefined') {
                                window.opener.conversationsConfig = null;
                            }
                            
                            // Trigger insights display in current window
                            if (typeof window.displayAIInsights === 'function') {
                                await window.displayAIInsights();
                                console.log('✅ Direct insights refresh completed');
                            }
                            
                            // Trigger insights display in opener window using new UI function
                            if (window.opener && typeof window.opener.displayInsightsUI === 'function') {
                                const container = window.opener.document.getElementById('insight-content-dynamic');
                                if (container && insightsResult.insights) {
                                    window.opener.displayInsightsUI(insightsResult.insights, conversationKey, container);
                                    console.log('✅ Opener insights UI refresh completed');
                                }
                            }
                            
                            // Try to trigger simple refresh in opener window
                            if (window.opener && typeof window.opener.simpleInsightsRefresh === 'function') {
                                window.opener.simpleInsightsRefresh();
                                console.log('✅ Opener simple refresh completed');
                            }
                        } catch (e) {
                            console.log('ℹ️ Additional refresh attempt completed');
                        }
                    }, 1500);
                } else {
                    showStatus(`❌ שגיאה ביצירת תובנות עבור ${conversationKey}: ${insightsResult.error}`, 'error');
                }
                
            } catch (error) {
                console.error(`Error generating insights for ${conversationKey}:`, error);
                showStatus(`שגיאה ביצירת תובנות: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }
        
        async function generateBothForConversation(conversationKey) {
            if (!confirm(`🚀 לצור סיכום ותובנות מבוססי AI עבור שיחה ${conversationKey}?`)) {
                return;
            }

            try {
                showLoading(`🚀 יוצר סיכום ותובנות AI עבור ${conversationKey}...`);
                
                // Get specific conversation from config
                const response = await fetch('config/conversations_config.json');
                const config = await response.json();
                const conversationData = config.conversations[conversationKey];
                
                if (!conversationData) {
                    throw new Error(`Conversation ${conversationKey} not found`);
                }
                
                // Generate both summary and insights
                const summaryResult = await generateConversationSummaryAI(conversationKey, conversationData);
                const insightsResult = await generateConversationInsightsAI(conversationKey, conversationData);
                
                const summarySuccess = summaryResult.success;
                const insightsSuccess = insightsResult.success;
                
                if (summarySuccess && insightsSuccess) {
                    showStatus(`✅ סיכום ותובנות AI נוצרו בהצלחה עבור ${conversationKey}!\n\n🎯 התוכן יוצג בלשוניות "סיכום" ו"תובנות" בפאנל הצד`, 'success');
                } else if (summarySuccess || insightsSuccess) {
                    const successPart = summarySuccess ? 'סיכום' : 'תובנות';
                    const failPart = !summarySuccess ? 'סיכום' : 'תובנות';
                    showStatus(`⚠️ ${successPart} נוצר בהצלחה אך ${failPart} נכשל עבור ${conversationKey}`, 'warning');
                } else {
                    showStatus(`❌ שגיאה ביצירת סיכום ותובנות עבור ${conversationKey}`, 'error');
                }
                
                // Refresh the conversations list to show updated indicators
                await loadConversations();
                
                // Refresh AI content in visualization windows
                if (summarySuccess || insightsSuccess) {
                    refreshVisualizationAIContent(conversationKey);
                }
                
            } catch (error) {
                console.error(`Error generating content for ${conversationKey}:`, error);
                showStatus(`שגיאה ביצירת תוכן: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }
        
        async function generateConversationSummaryAI(conversationKey, conversationData) {
            try {
                // Load conversation emotion data
                const emotionFilePath = conversationData.ai_file || conversationData.emotion_file;
                if (!emotionFilePath) {
                    console.warn(`No emotion file found for ${conversationKey}`);
                    return { success: false, error: 'No emotion file' };
                }
                
                const emotionResponse = await fetch(emotionFilePath);
                const emotionData = await emotionResponse.json();
                
                // Prepare conversation data for AI analysis
                const segments = Object.keys(emotionData)
                    .filter(key => key.endsWith('.mp3'))
                    .map(key => ({
                        file: key,
                        transcript: emotionData[key].transcript || emotionData[key].words || '',
                        emotions: emotionData[key].emotions || ['neutral'],
                        speaker: emotionData[key].speaker || 0
                    }))
                    .filter(segment => segment.transcript.trim().length > 0);
                
                if (segments.length === 0) {
                    console.warn(`No transcript segments found for ${conversationKey}`);
                    return { success: false, error: 'No transcript segments' };
                }
                
                // Call AI to generate summary
                const summaryRequest = {
                    conversation_key: conversationKey,
                    conversation_number: conversationData.number,
                    segments: segments,
                    metadata: conversationData.metadata || {},
                    type: 'summary'
                };
                
                const response = await fetch(`${apiBaseUrl}/api/generate-conversation-summary`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(summaryRequest)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log(`✅ Generated summary for ${conversationKey}:`, result);
                    return { success: true, data: result };
                } else {
                    console.error(`Failed to generate summary for ${conversationKey}:`, response.statusText);
                    return { success: false, error: response.statusText };
                }
                
            } catch (error) {
                console.error(`Error generating summary for ${conversationKey}:`, error);
                return { success: false, error: error.message };
            }
        }
        
        async function generateConversationInsightsAI(conversationKey, conversationData) {
            try {
                // Load conversation emotion data
                const emotionFilePath = conversationData.ai_file || conversationData.emotion_file;
                if (!emotionFilePath) {
                    console.warn(`No emotion file found for ${conversationKey}`);
                    return { success: false, error: 'No emotion file' };
                }
                
                const emotionResponse = await fetch(emotionFilePath);
                const emotionData = await emotionResponse.json();
                
                // Prepare conversation data for AI analysis
                const segments = Object.keys(emotionData)
                    .filter(key => key.endsWith('.mp3'))
                    .map(key => ({
                        file: key,
                        transcript: emotionData[key].transcript || emotionData[key].words || '',
                        emotions: emotionData[key].emotions || ['neutral'],
                        speaker: emotionData[key].speaker || 0,
                        humor: emotionData[key].humor || 0,
                        blur: emotionData[key].blur || 0,
                        spark: emotionData[key].spark || 0
                    }))
                    .filter(segment => segment.transcript.trim().length > 0);
                
                if (segments.length === 0) {
                    console.warn(`No transcript segments found for ${conversationKey}`);
                    return { success: false, error: 'No transcript segments' };
                }
                
                // Call AI to generate insights
                const insightsRequest = {
                    conversation_key: conversationKey,
                    conversation_number: conversationData.number,
                    segments: segments,
                    metadata: conversationData.metadata || {},
                    type: 'insights'
                };
                
                const response = await fetch(`${apiBaseUrl}/api/generate-conversation-insights`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(insightsRequest)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log(`✅ Generated insights for ${conversationKey}:`, result);
                    return { success: true, data: result };
                } else {
                    console.error(`Failed to generate insights for ${conversationKey}:`, response.statusText);
                    return { success: false, error: response.statusText };
                }
                
            } catch (error) {
                console.error(`Error generating insights for ${conversationKey}:`, error);
                return { success: false, error: error.message };
            }
        }

        // ==================== METADATA MANAGEMENT FUNCTIONS ====================
        let currentMetadataConversation = null;
        let conversationMetadata = {};
        let metadataCache = {};
        
        // Populate main emotions selector with all 92 emotions from config
        async function populateMainEmotionsSelector() {
            try {
                console.log('🎭 Starting to populate emotions selector...');
                const container = document.getElementById('main-emotions-selector');
                if (!container) {
                    console.error('❌ Emotions container not found');
                    return;
                }
                
                // Ensure emotions config is loaded - try multiple times
                if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                    console.log('⏳ Loading emotions config...');
                    await loadEmotionsConfig();
                    
                    // If still empty, wait and try again
                    if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                        console.log('⏳ Retrying emotions config load...');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        await loadEmotionsConfig();
                    }
                }
                
                console.log('📋 Emotions config status:', emotionsConfig ? Object.keys(emotionsConfig).length : 0, 'emotions');
                
                if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                    console.error('❌ Failed to load emotions config');
                    container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #ff6b6b; padding: 1rem;">שגיאה בטעינת רגשות - לא ניתן לטעון את קובץ הקונפיגורציה</div>';
                    return;
                }
                
                // Clear loading message
                container.innerHTML = '';
                
                // Get all emotions and sort alphabetically in Hebrew
                const allEmotions = Object.entries(emotionsConfig);
                allEmotions.sort((a, b) => {
                    try {
                        // Hebrew keys are the emotion names themselves
                        return a[0].localeCompare(b[0], 'he');
                    } catch(e) {
                        return a[0] > b[0] ? 1 : -1;
                    }
                });
                
                console.log('🔤 Sorted emotions:', allEmotions.slice(0, 5).map(([name]) => name));
                
                // Create checkboxes for all emotions
                allEmotions.forEach(([emotion, config]) => {
                    const label = document.createElement('label');
                    label.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; cursor: pointer; padding: 0.25rem; border-radius: 4px; transition: background-color 0.2s ease;';
                    
                    // Add hover effect
                    label.addEventListener('mouseenter', () => {
                        label.style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
                    });
                    label.addEventListener('mouseleave', () => {
                        label.style.backgroundColor = 'transparent';
                    });
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    // Use Hebrew name as the value since our emotion data now uses Hebrew
                    checkbox.value = emotion;
                    // Add English name as data attribute for compatibility
                    checkbox.setAttribute('data-english', config.english || emotion);
                    
                    const text = document.createElement('span');
                    text.textContent = `${config.emoji || '😐'} ${emotion}`;
                    
                    label.appendChild(checkbox);
                    label.appendChild(text);
                    container.appendChild(label);
                });
                
                console.log(`✅ Successfully populated ${allEmotions.length} emotions in metadata selector`);
                
                // Set up search functionality
                setupEmotionsSearch();
                
            } catch (error) {
                console.error('❌ Error populating emotions selector:', error);
                const container = document.getElementById('main-emotions-selector');
                if (container) {
                    container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #ff6b6b; padding: 1rem;">שגיאה בטעינת רגשות: ' + error.message + '</div>';
                }
            }
        }

        // Set up emotions search functionality
        function setupEmotionsSearch() {
            const searchInput = document.getElementById('emotions-search');
            if (!searchInput) return;
            
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                const emotionLabels = document.querySelectorAll('#main-emotions-selector label');
                
                emotionLabels.forEach(label => {
                    const emotionText = label.textContent.toLowerCase();
                    const shouldShow = emotionText.includes(searchTerm);
                    label.style.display = shouldShow ? 'flex' : 'none';
                });
            });
        }

        // Select all visible emotions
        function selectAllEmotions() {
            const checkboxes = document.querySelectorAll('#main-emotions-selector input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                const label = checkbox.closest('label');
                if (label && label.style.display !== 'none') {
                    checkbox.checked = true;
                }
            });
        }

        // Clear all emotion selections
        function clearAllEmotions() {
            const checkboxes = document.querySelectorAll('#main-emotions-selector input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
        }
        
        // Force load emotions with extra debugging and retry logic
        async function forceLoadEmotions() {
            try {
                console.log('🔄 Force loading emotions...');
                showLoading('טוען רגשות...');
                
                // Clear any existing emotions
                const container = document.getElementById('main-emotions-selector');
                if (container) {
                    container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #666; padding: 1rem;">🔄 טוען רגשות...</div>';
                }
                
                // Force reload emotions config
                emotionsConfig = null;
                await loadEmotionsConfig();
                
                // Wait a bit then populate
                await new Promise(resolve => setTimeout(resolve, 500));
                await populateMainEmotionsSelector();
                
                hideLoading();
                showStatus('רגשות נטענו בהצלחה!', 'success');
                
            } catch (error) {
                console.error('❌ Error force loading emotions:', error);
                hideLoading();
                showStatus('שגיאה בטעינת רגשות', 'error');
                
                // Show fallback message
                const container = document.getElementById('main-emotions-selector');
                if (container) {
                    container.innerHTML = `
                        <div style="grid-column: 1/-1; text-align: center; color: #ff6b6b; padding: 1rem;">
                            שגיאה בטעינת רגשות<br>
                            <button onclick="window.location.reload()" class="btn btn-primary btn-sm" style="margin-top: 0.5rem;">
                                רענן דף
                            </button>
                        </div>
                    `;
                }
            }
        }

        // Initialize metadata functionality
        async function initializeMetadata() {
            try {
                console.log('🚀 Initializing metadata with forced refresh...');
                await loadConversationMetadata(true); // Force refresh on initialization
                setupMetadataEventListeners();
                displayMetadataConversations();
                
                // Populate emotions selector with all 92 emotions
                await populateMainEmotionsSelector();
                
                // Ensure emotions are visible after metadata loads
                setTimeout(async () => {
                    const emotionsContainer = document.getElementById('main-emotions-selector');
                    if (emotionsContainer && emotionsContainer.innerHTML.includes('טוען רגשות...')) {
                        console.log('🔄 Emotions still loading, retrying...');
                        await populateMainEmotionsSelector();
                    }
                }, 2000);
            } catch (error) {
                console.error('Error initializing metadata:', error);
                showStatus('שגיאה בטעינת נתוני השיחות', 'error');
            }
        }
        
        // Load conversation metadata from config
        async function loadConversationMetadata(forceRefresh = false) {
            try {
                // 🔍 ENHANCED CACHE-BUSTING: Always prevent stale config after refresh
                const cacheBuster = forceRefresh ? `?v=${Date.now()}&refresh=true` : `?v=${Date.now()}`;
                const configUrl = `${apiBaseUrl}/config/conversations_config.json${cacheBuster}`;
                
                console.log(`📡 Loading conversation metadata from: ${configUrl}`);
                
                const response = await fetch(configUrl, {
                    cache: 'no-cache',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to load conversations config: ${response.status} ${response.statusText}`);
                }
                
                const config = await response.json();
                console.log('📄 Raw config loaded:', config);
                
                conversationMetadata = config.conversations || {};
                console.log(`📊 Found ${Object.keys(conversationMetadata).length} conversations`);
                
                // Enhance with metadata if available
                for (const [folder, data] of Object.entries(conversationMetadata)) {
                    // Add default metadata if not present
                    if (!data.metadata) {
                        data.metadata = {
                            date: '',
                            name: `שיחה ${data.number}`,
                            participants: [],
                            mainEmotions: [],
                            emotionalIntensity: 5,
                            duration: '',
                            totalWords: 0,
                            notes: '',
                            tags: [],
                            isImportant: false,
                            isPrivate: false,
                            needsReview: false
                        };
                    }
                    console.log(`📝 Processed conversation ${folder}:`, data);
                }
                
                console.log('✅ Loaded conversation metadata:', conversationMetadata);
            } catch (error) {
                console.error('❌ Error loading conversation metadata:', error);
                throw error;
            }
        }
        
        // Display conversations list with metadata preview
        function displayMetadataConversations() {
            console.log('🎨 Displaying metadata conversations...');
            const container = document.getElementById('metadata-conversations-list');
            if (!container) {
                console.error('❌ Container #metadata-conversations-list not found!');
                return;
            }
            
            container.innerHTML = '';
            
            console.log('📊 Current conversationMetadata:', conversationMetadata);
            console.log('📊 Metadata keys count:', Object.keys(conversationMetadata || {}).length);
            
            if (!conversationMetadata || Object.keys(conversationMetadata).length === 0) {
                console.log('⚠️ No conversation metadata available, showing empty state');
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: #999;">
                        <i class="material-icons" style="font-size: 48px; display: block; margin-bottom: 1rem;">chat_bubble_outline</i>
                        <p>אין שיחות זמינות</p>
                        <button onclick="refreshMetadataList()" class="btn btn-primary btn-sm" style="margin-top: 1rem;">
                            <i class="material-icons">refresh</i>
                            טען מחדש
                        </button>
                    </div>
                `;
                return;
            }
            
            const sortedConvos = Object.entries(conversationMetadata)
                .sort(([,a], [,b]) => a.number - b.number);
            
            console.log(`🎯 Displaying ${sortedConvos.length} conversations`);
            
            sortedConvos.forEach(([folder, data]) => {
                console.log(`📝 Processing conversation ${folder}:`, data);
                const metadata = data.metadata || {};
                const item = document.createElement('div');
                item.className = 'conversation-item';
                item.onclick = () => selectMetadataConversation(folder);
                
                // Calculate duration preview
                const durationText = metadata.duration || 'לא מחושב';
                const emotionsText = metadata.mainEmotions?.length ? 
                    metadata.mainEmotions.map(e => getEmotionEmoji(e)).join('') : 
                    '😐';
                
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                        <div style="flex: 1;">
                            <h4 style="margin: 0 0 0.5rem 0; display: flex; align-items: center; gap: 0.5rem;">
                                ${metadata.name || `שיחה ${data.number}`}
                                ${metadata.isImportant ? '<span style="color: #f44336;">⭐</span>' : ''}
                                ${metadata.isPrivate ? '<span style="color: #9c27b0;">🔒</span>' : ''}
                                ${metadata.needsReview ? '<span style="color: #ff9800;">⚠️</span>' : ''}
                            </h4>
                            <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">
                                📅 ${metadata.date || 'ללא תאריך'} | ⏱️ ${durationText}
                            </div>
                            <div style="font-size: 0.9rem; margin-bottom: 0.5rem;">
                                ${emotionsText} ${metadata.mainEmotions?.join(', ') || 'ללא רגשות מוגדרים'}
                            </div>
                        </div>
                        <div style="text-align: right; font-size: 0.8rem; color: #999; margin-left: 1rem;">
                            <div>📁 ${folder}</div>
                            <div>🎵 ${data.mp3_count || 0} קטעים</div>
                            <div>📝 ${metadata.totalWords || 0} מילים</div>
                            <button onclick="deleteConversation('${folder}'); event.stopPropagation();" 
                                    class="btn btn-danger" 
                                    style="margin-top: 0.5rem; padding: 0.25rem 0.5rem; font-size: 0.8rem;" 
                                    title="מחק שיחה זו לצמיתות">
                                <i class="material-icons" style="font-size: 16px;">delete</i>
                                מחק
                            </button>
                        </div>
                    </div>
                    <div class="conversation-stats">
                        <span>משתתפים: ${metadata.participants?.join(', ') || 'לא הוגדר'}</span>
                        <span>עוצמה: ${metadata.emotionalIntensity || 5}/10</span>
                    </div>
                `;
                
                container.appendChild(item);
            });
        }
        
        // Select conversation for metadata editing
        async function selectMetadataConversation(folder) {
            try {
                console.log(`📝 Selecting conversation for metadata: ${folder}`);
                
                // Update UI
                document.querySelectorAll('#metadata-conversations-list .conversation-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                event.target.closest('.conversation-item').classList.add('active');
                
                currentMetadataConversation = folder;
                const data = conversationMetadata[folder];
                
                if (!data) {
                    showStatus(`לא נמצאו נתונים עבור ${folder}`, 'error');
                    return;
                }
                
                // Clear previous main emotion analysis result when switching conversations
                const emotionAnalysisResult = document.getElementById('main-emotion-analysis-result');
                if (emotionAnalysisResult) {
                    emotionAnalysisResult.style.display = 'none';
                    // Clear the content as well
                    document.getElementById('detected-main-emotion').textContent = '';
                    document.getElementById('emotion-explanation').textContent = '';
                    document.getElementById('segments-count').textContent = '';
                    document.getElementById('confidence-score').textContent = '';
                }
                
                // Show editor
                document.getElementById('no-metadata-selection').style.display = 'none';
                document.getElementById('metadata-editor-panel').style.display = 'flex';
                const titleEl = document.getElementById('metadata-conversation-title');
            if (titleEl) titleEl.textContent = `נתוני ${data.metadata?.name || `שיחה ${data.number}`}`;
                
                // Load conversation data and calculate statistics
                await loadMetadataForm(folder, data);
                await calculateMetadataStatistics(folder);
                
            } catch (error) {
                console.error('Error selecting conversation for metadata:', error);
                showStatus('שגיאה בטעינת נתוני השיחה', 'error');
            }
        }
        
        // Load metadata form with conversation data
        function loadMetadataForm(folder, data) {
            const metadata = data.metadata || {};
            
            // Basic info
            document.getElementById('conversation-date').value = metadata.date || '';
            document.getElementById('conversation-name').value = metadata.name || `שיחה ${data.number}`;
            document.getElementById('main-participant').value = metadata.mainParticipant || '';
            document.getElementById('custom-participant-name').value = metadata.customParticipantName || '';
            
            // Speaker names
            document.getElementById('speaker-1-name').value = metadata.speaker1Name || '';
            document.getElementById('speaker-2-name').value = metadata.speaker2Name || '';
            
            // Refresh speaker displays if this is the current conversation
            if (currentConversation === folder && emotionData) {
                refreshSpeakerDisplays();
            }
            
            // Show/hide custom participant input
            const showCustom = document.getElementById('main-participant').value === 'custom';
            document.getElementById('custom-participant-input').style.display = showCustom ? 'block' : 'none';
            
            // Conversation Topics - load both predefined and custom topics
            const savedTopics = metadata.conversationTopics || [];
            const predefinedTopics = ['family', 'work', 'relationships', 'health', 'personal', 'therapy', 'memories', 'future', 'emotions', 'decisions'];
            
            // Clear and set predefined topic checkboxes
            const topicCheckboxes = document.querySelectorAll('#conversation-topics input[type="checkbox"]');
            topicCheckboxes.forEach(checkbox => {
                checkbox.checked = savedTopics.includes(checkbox.value);
            });
            
            // Set custom topics (topics not in predefined list)
            const customTopics = savedTopics.filter(topic => !predefinedTopics.includes(topic));
            document.getElementById('custom-topics').value = customTopics.join(', ');
            
            // Main emotions checkboxes
            const emotionCheckboxes = document.querySelectorAll('#main-emotions-selector input[type="checkbox"]');
            emotionCheckboxes.forEach(checkbox => {
                checkbox.checked = metadata.mainEmotions?.includes(checkbox.value) || false;
            });
            
            // Emotional intensity
            const intensitySlider = document.getElementById('emotional-intensity');
            intensitySlider.value = metadata.emotionalIntensity || 5;
            const intensityDisplayEl = document.getElementById('intensity-display');
            if (intensityDisplayEl) intensityDisplayEl.textContent = intensitySlider.value;
            
            // Basic statistics (elements may not exist)
            const segmentsCountEl = document.getElementById('segments-count');
            if (segmentsCountEl) segmentsCountEl.textContent = data.mp3_count || 0;
            
            const totalDurationEl = document.getElementById('total-duration');
            if (totalDurationEl) totalDurationEl.textContent = metadata.duration || 'מחשב...';
            
            const totalWordsEl = document.getElementById('total-words');
            if (totalWordsEl) totalWordsEl.textContent = metadata.totalWords || 'מחשב...';
            
            // Notes and tags (elements removed)
            const notesEl = document.getElementById('conversation-notes');
            if (notesEl) notesEl.value = metadata.notes || '';
            
            const tagsEl = document.getElementById('conversation-tags');
            if (tagsEl) tagsEl.value = metadata.tags?.join(', ') || '';
            
            // Flags (elements removed)
            const importantEl = document.getElementById('is-important');
            if (importantEl) importantEl.checked = metadata.isImportant || false;
            
            const privateEl = document.getElementById('is-private');
            if (privateEl) privateEl.checked = metadata.isPrivate || false;
            
            const reviewEl = document.getElementById('needs-review');
            if (reviewEl) reviewEl.checked = metadata.needsReview || false;
        }
        
        // Calculate conversation statistics (duration, words, emotions)
        async function calculateMetadataStatistics(folder) {
            try {
                showLoading('מחשב סטטיסטיקות...');
                
                const convData = conversationMetadata[folder];
                let emotionFile = convData.ai_file || convData.emotion_file || `emotions${convData.number}_ai_analyzed.json`;
                
                if (!emotionFile.startsWith('conversations/')) {
                    emotionFile = `conversations/${folder}/${emotionFile}`;
                }
                
                // Load emotion data
                const response = await fetch(`${apiBaseUrl}/${emotionFile}`);
                if (!response.ok) throw new Error('Failed to load emotion data');
                
                const emotionData = await response.json();
                
                // Calculate statistics
                let totalWords = 0;
                let totalDurationMs = 0;
                const emotionCounts = {};
                
                for (const [filename, data] of Object.entries(emotionData)) {
                    if (filename === 'conversation_details') continue;
                    
                    // Count words
                    if (data.word_count) {
                        totalWords += data.word_count;
                    } else if (data.words) {
                        totalWords += data.words.split(' ').length;
                    }
                    
                    // Estimate duration (roughly 1-2 seconds per MP3 segment)
                    totalDurationMs += 1500; // Approximate 1.5 seconds per segment
                    
                    // Count emotions
                    if (data.emotions && Array.isArray(data.emotions)) {
                        data.emotions.forEach(emotion => {
                            emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                        });
                    }
                }
                
                // Convert duration to readable format
                const totalSeconds = Math.round(totalDurationMs / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const durationText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Calculate average segment duration
                const segmentCount = Object.keys(emotionData).filter(k => k !== 'conversation_details').length;
                const avgSegmentDuration = segmentCount > 0 ? (totalSeconds / segmentCount).toFixed(1) : 0;
                
                // Update UI with null checks
                const totalDurationEl = document.getElementById('total-duration');
                if (totalDurationEl) totalDurationEl.textContent = durationText;
                
                const totalWordsEl = document.getElementById('total-words');
                if (totalWordsEl) totalWordsEl.textContent = totalWords.toLocaleString();
                
                const avgSegmentDurationEl = document.getElementById('avg-segment-duration');
                if (avgSegmentDurationEl) avgSegmentDurationEl.textContent = `${avgSegmentDuration}s`;
                
                // Store in metadata cache
                metadataCache[folder] = {
                    duration: durationText,
                    totalWords: totalWords,
                    avgSegmentDuration: avgSegmentDuration,
                    emotionCounts: emotionCounts,
                    totalSegments: segmentCount
                };
                
                console.log(`📊 Calculated statistics for ${folder}:`, metadataCache[folder]);
                
            } catch (error) {
                console.error('Error calculating statistics:', error);
                showStatus('שגיאה בחישוב הסטטיסטיקות', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // Analyze emotional profile from conversation data
        async function analyzeEmotionalProfile() {
            if (!currentMetadataConversation) return;
            
            try {
                showLoading('מנתח פרופיל רגשי...');
                
                const cached = metadataCache[currentMetadataConversation];
                if (!cached || !cached.emotionCounts) {
                    await calculateMetadataStatistics(currentMetadataConversation);
                }
                
                const emotionCounts = metadataCache[currentMetadataConversation]?.emotionCounts || {};
                
                // Find top emotions
                const sortedEmotions = Object.entries(emotionCounts)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 5);
                
                // Update emotion checkboxes based on analysis
                const emotionCheckboxes = document.querySelectorAll('#main-emotions-selector input[type="checkbox"]');
                emotionCheckboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // Check top 3 emotions
                sortedEmotions.slice(0, 3).forEach(([emotion, count]) => {
                    // Try multiple ways to find the emotion checkbox
                    let checkbox = 
                        // 1. Try by exact value match (Hebrew)
                        document.querySelector(`#main-emotions-selector input[value="${emotion}"]`) ||
                        // 2. Try by English data attribute  
                        document.querySelector(`#main-emotions-selector input[data-english="${emotion}"]`) ||
                        // 3. Try by English equivalent lookup if emotion is English
                        (function() {
                            // Search for Hebrew key that has this English value
                            for (const [hebrewKey, config] of Object.entries(emotionsConfig || {})) {
                                if (config.english === emotion || config.english === emotion.toLowerCase()) {
                                    return document.querySelector(`#main-emotions-selector input[value="${hebrewKey}"]`);
                                }
                            }
                            return null;
                        })();
                    
                    if (checkbox) {
                        checkbox.checked = true;
                    } else {
                        console.warn(`Could not find checkbox for emotion: ${emotion}`);
                    }
                });
                
                // Calculate intensity based on emotion variety and counts
                const totalSegments = metadataCache[currentMetadataConversation]?.totalSegments || 1;
                const emotionVariety = Object.keys(emotionCounts).length;
                const maxEmotionCount = Math.max(...Object.values(emotionCounts));
                const intensity = Math.min(10, Math.max(1, Math.round((emotionVariety * 2) + (maxEmotionCount / totalSegments * 5))));
                
                const emotionalIntensityEl = document.getElementById('emotional-intensity');
                if (emotionalIntensityEl) emotionalIntensityEl.value = intensity;
                
                const intensityDisplayEl = document.getElementById('intensity-display');
                if (intensityDisplayEl) intensityDisplayEl.textContent = intensity;
                
                showStatus(`נמצאו ${emotionVariety} רגשות שונים. עוצמה מוערכת: ${intensity}/10`, 'success');
                
            } catch (error) {
                console.error('Error analyzing emotional profile:', error);
                showStatus('שגיאה בניתוח הפרופיל הרגשי', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // Calculate duration for current conversation
        async function calculateCurrentDuration() {
            if (!currentMetadataConversation) return;
            
            await calculateMetadataStatistics(currentMetadataConversation);
            showStatus('המשך חושב מחדש בהצלחה', 'success');
        }
        
        // Calculate durations for all conversations
        async function calculateAllDurations() {
            try {
                showLoading('מחשב משכי זמן לכל השיחות...');
                
                let processed = 0;
                const total = Object.keys(conversationMetadata).length;
                
                for (const folder of Object.keys(conversationMetadata)) {
                    await calculateMetadataStatistics(folder);
                    processed++;
                    
                    // Update loading text
                    document.getElementById('loading-text').textContent = 
                        `מחשב משכי זמן... (${processed}/${total})`;
                }
                
                // Refresh display
                displayMetadataConversations();
                showStatus(`חושבו משכי זמן עבור ${total} שיחות`, 'success');
                
            } catch (error) {
                console.error('Error calculating all durations:', error);
                showStatus('שגיאה בחישוב משכי הזמן', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // Save conversation metadata
        async function saveMetadata() {
            if (!currentMetadataConversation) {
                console.error('❌ No conversation selected for metadata save');
                showStatus('אין שיחה נבחרת לשמירה', 'error');
                return;
            }
            
            console.log('💾 Starting metadata save for:', currentMetadataConversation);
            
            try {
                showLoading('שומר נתוני שיחה...');
                
                // Collect form data
                const metadata = {
                    date: document.getElementById('conversation-date').value,
                    name: document.getElementById('conversation-name').value,
                    mainParticipant: document.getElementById('main-participant').value,
                    customParticipantName: document.getElementById('custom-participant-name').value,
                    
                    // Speaker names
                    speaker1Name: document.getElementById('speaker-1-name').value,
                    speaker2Name: document.getElementById('speaker-2-name').value,
                    
                    // Conversation Topics - collect both predefined and custom
                    conversationTopics: [
                        ...Array.from(document.querySelectorAll('#conversation-topics input[type="checkbox"]:checked'))
                            .map(checkbox => checkbox.value),
                        ...document.getElementById('custom-topics').value
                            .split(',')
                            .map(topic => topic.trim())
                            .filter(topic => topic.length > 0)
                    ],
                    
                    // Main Emotions
                    mainEmotions: Array.from(document.querySelectorAll('#main-emotions-selector input[type="checkbox"]:checked'))
                        .map(checkbox => checkbox.value),
                    emotionalIntensity: parseInt(document.getElementById('emotional-intensity').value),
                    
                    // Notes and Tags (elements may not exist)
                    notes: document.getElementById('conversation-notes')?.value || '',
                    tags: (document.getElementById('conversation-tags')?.value || '')
                        .split(',')
                        .map(tag => tag.trim())
                        .filter(tag => tag.length > 0),
                    
                    // Status Flags (elements may not exist)
                    isImportant: document.getElementById('is-important')?.checked || false,
                    isPrivate: document.getElementById('is-private')?.checked || false,
                    needsReview: document.getElementById('needs-review')?.checked || false,
                    lastModified: new Date().toISOString()
                };
                
                // Add calculated statistics
                const cached = metadataCache[currentMetadataConversation];
                if (cached) {
                    metadata.duration = cached.duration;
                    metadata.totalWords = cached.totalWords;
                    metadata.avgSegmentDuration = cached.avgSegmentDuration;
                }
                
                // Determine participants list
                metadata.participants = [];
                if (metadata.mainParticipant === 'custom' && metadata.customParticipantName) {
                    metadata.participants.push(metadata.customParticipantName);
                } else if (metadata.mainParticipant) {
                    metadata.participants.push(metadata.mainParticipant);
                }
                
                // 🔍 ENHANCED DEBUGGING: Log the collected metadata  
                console.log('📝 Collected metadata for save:', {
                    conversation: currentMetadataConversation,
                    name: metadata.name,
                    metadata: metadata
                });
                
                // 🔍 ENHANCED DEBUGGING: Verify we have the conversation data
                if (!conversationMetadata[currentMetadataConversation]) {
                    console.error('❌ No conversation data found for:', currentMetadataConversation);
                    throw new Error(`No conversation data found for ${currentMetadataConversation}`);
                }
                
                // Update local data
                conversationMetadata[currentMetadataConversation].metadata = metadata;
                console.log('✅ Updated local metadata for:', currentMetadataConversation);
                
                // Save to server
                const updatedConfig = {
                    conversations: conversationMetadata,
                    total_conversations: Object.keys(conversationMetadata).length,
                    file_mappings: Object.fromEntries(
                        Object.entries(conversationMetadata).map(([folder, data]) => [
                            folder,
                            data.emotion_file || `conversations/${folder}/emotions${data.number}.json`
                        ])
                    ),
                    last_metadata_update: new Date().toISOString()
                };
                
                // 🔍 ENHANCED DEBUGGING: Log the config before saving
                console.log('🌐 Config to be saved:', {
                    conversation: currentMetadataConversation,
                    conversationName: updatedConfig.conversations[currentMetadataConversation]?.metadata?.name,
                    totalConversations: updatedConfig.total_conversations,
                    lastUpdate: updatedConfig.last_metadata_update
                });
                
                console.log('🌐 Sending save request to server...');
                
                // 🔍 ENHANCED DEBUGGING: Add timeout and better error handling
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    console.error('❌ Save request timed out after 30 seconds');
                }, 30000);
                
                const response = await fetch(`${apiBaseUrl}/api/save-config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: 'config/conversations_config.json',
                        content: updatedConfig
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                console.log('📡 Server response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Server error:', {
                        status: response.status,
                        statusText: response.statusText,
                        error: errorText
                    });
                    throw new Error(`Failed to save metadata: ${response.status} - ${errorText}`);
                }
                
                const responseData = await response.json();
                console.log('✅ Server response:', responseData);
                
                // 🔍 ENHANCED DEBUGGING: Verify the save was successful
                if (responseData.success) {
                    console.log('✅ Server confirmed successful save');
                } else {
                    console.warn('⚠️ Server response indicates save may have failed:', responseData);
                }
                
                // 🔄 FORCE METADATA RELOAD: Essential for ensuring fresh data after save
                console.log('🔄 Forcing metadata reload after save...');
                await loadConversationMetadata(true); // Force refresh with cache-busting
                
                // 🔄 FORCE CONVERSATIONS RELOAD: Essential for edit parameters tab
                console.log('🔄 Forcing conversations reload for edit parameters tab...');
                await loadConversations(true); // Force refresh with cache-busting
                
                // Refresh displays everywhere
                displayMetadataConversations();
                
                // Also refresh the main conversations list (in editor tab)
                conversationsData = conversationMetadata;
                displayConversations();
                
                // 🔄 NOTIFY MAIN INTERFACE: Essential for syncing conversation name changes
                notifyMainVisualizationOfChanges();
                
                // 🔄 FORCE GLOBAL CONFIG REFRESH: Ensure all components reload fresh config
                window.lastConfigUpdate = Date.now();
                
                // 🔄 Force reload conversation config in all interfaces
                try {
                    // Notify visualization iframe directly
                    const iframe = document.querySelector('iframe[src*="visualization.html"]');
                    if (iframe && iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'force-config-reload',
                            conversation: currentMetadataConversation,
                            metadata: metadata
                        }, '*');
                        
                        // Also send a specific conversation title update message
                        iframe.contentWindow.postMessage({
                            type: 'update-conversation-title',
                            conversation: currentMetadataConversation,
                            name: metadata.name,
                            metadata: metadata
                        }, '*');
                    }
                    
                    // Find and notify index.html window if it exists
                    if (window.parent !== window) {
                        window.parent.postMessage({
                            type: 'force-config-reload',
                            conversation: currentMetadataConversation,
                            metadata: metadata
                        }, '*');
                        
                        window.parent.postMessage({
                            type: 'update-conversation-title',
                            conversation: currentMetadataConversation,
                            name: metadata.name,
                            metadata: metadata
                        }, '*');
                    }
                    
                    // Also broadcast via BroadcastChannel for other tabs/components
                    if (typeof BroadcastChannel !== 'undefined') {
                        const configChannel = new BroadcastChannel('conversation-sync');
                        configChannel.postMessage({
                            type: 'force-config-reload',
                            conversation: currentMetadataConversation,
                            metadata: metadata,
                            timestamp: Date.now()
                        });
                        
                        // Send specific title update broadcast
                        configChannel.postMessage({
                            type: 'update-conversation-title',
                            conversation: currentMetadataConversation,
                            name: metadata.name,
                            metadata: metadata,
                            timestamp: Date.now()
                        });
                        
                        configChannel.close();
                        console.log('📻 Broadcasted force config reload and title update to all components');
                    }
                } catch (error) {
                    console.warn('⚠️ Could not notify all interfaces:', error);
                }
                
                // Refresh the segments display to show updated speaker names
                if (currentConversation === currentMetadataConversation && emotionData) {
                    console.log('🔄 Refreshing segments display with new speaker names...');
                    displaySegments();
                }
                
                // Sync to production after metadata changes (optional - don't block on failure)
                setTimeout(async () => {
                    try {
                        await syncToProduction(currentMetadataConversation, 'incremental');
                    } catch (error) {
                        console.warn('⚠️ Sync to production failed, but metadata was saved successfully:', error);
                        // Don't show error to user - metadata save was successful
                    }
                }, 500);
                
                console.log('🎉 METADATA SAVE COMPLETED SUCCESSFULLY!');
                
                // Show success notification with fallback
                try {
                    showStatus('נתוני השיחה נשמרו בהצלחה!', 'success');
                } catch (statusError) {
                    console.warn('Status function failed, using alert fallback:', statusError);
                    alert('✅ נתוני השיחה נשמרו בהצלחה!');
                }
                
            } catch (error) {
                console.error('❌ ERROR SAVING METADATA:', error);
                
                // Show error notification with fallback
                try {
                    showStatus(`שגיאה בשמירת נתוני השיחה: ${error.message}`, 'error');
                } catch (statusError) {
                    console.warn('Status function failed, using alert fallback:', statusError);
                    alert(`❌ שגיאה בשמירת נתוני השיחה: ${error.message}`);
                }
            } finally {
                hideLoading();
            }
        }
        
        // Preview metadata (show what will be displayed on hover)
        function previewMetadata() {
            if (!currentMetadataConversation) return;
            
            const metadata = conversationMetadata[currentMetadataConversation]?.metadata || {};
            const cached = metadataCache[currentMetadataConversation] || {};
            
            const preview = `
📝 ${metadata.name || 'שיחה ללא שם'}
📅 תאריך: ${metadata.date || 'לא הוגדר'}
👥 משתתפים: ${metadata.participants?.join(', ') || 'לא הוגדר'}
💬 נושאים: ${metadata.conversationTopics?.length ? metadata.conversationTopics.join(', ') : 'לא הוגדר'}
⏱️  משך: ${cached.duration || 'לא מחושב'}
😊 רגשות עיקריים: ${metadata.mainEmotions?.map(e => getEmotionEmoji(e) + ' ' + e).join(', ') || 'לא הוגדר'}
📊 עוצמה רגשית: ${metadata.emotionalIntensity || 5}/10
📝 ${cached.totalWords || 0} מילים | 🎵 ${cached.totalSegments || 0} קטעים
🏷️  תגיות: ${metadata.tags?.join(', ') || 'ללא תגיות'}
${metadata.notes ? '📋 הערות: ' + metadata.notes : ''}
${metadata.isImportant ? '⭐ שיחה חשובה' : ''}
${metadata.isPrivate ? '🔒 שיחה פרטית' : ''}
${metadata.needsReview ? '⚠️ דורש בדיקה' : ''}
            `.trim();
            
            alert(`תצוגה מקדימה של מידע בעת ריחוף:\n\n${preview}`);
        }
        
        // Refresh metadata list
        async function refreshMetadataList() {
            try {
                await loadConversationMetadata();
                displayMetadataConversations();
                showStatus('רשימת השיחות עודכנה', 'success');
            } catch (error) {
                console.error('Error refreshing metadata list:', error);
                showStatus('שגיאה ברענון הרשימה', 'error');
            }
        }
        
        // Setup event listeners for metadata form
        function setupMetadataEventListeners() {
            // Main participant selector
            const participantSelect = document.getElementById('main-participant');
            if (participantSelect) {
                participantSelect.addEventListener('change', function() {
                    const showCustom = this.value === 'custom';
                    document.getElementById('custom-participant-input').style.display = 
                        showCustom ? 'block' : 'none';
                });
            }
            
            // Emotional intensity slider
            const intensitySlider = document.getElementById('emotional-intensity');
            if (intensitySlider) {
                intensitySlider.addEventListener('input', function() {
                    document.getElementById('intensity-display').textContent = this.value;
                });
            }
            
            // Add topic selection helpers
            const topicCheckboxes = document.querySelectorAll('#conversation-topics input[type="checkbox"]');
            topicCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    // Optional: Add visual feedback when topics are selected
                    const selectedCount = document.querySelectorAll('#conversation-topics input[type="checkbox"]:checked').length;
                    console.log(`📋 Selected ${selectedCount} conversation topics`);
                });
            });
        }
        
        // Initialize metadata tab when it's loaded
        function initializeMetadata() {
            console.log('🎛️ Initializing metadata tab...');
            
            // Clear any previous main emotion analysis result on tab initialization
            const emotionAnalysisResult = document.getElementById('main-emotion-analysis-result');
            if (emotionAnalysisResult) {
                emotionAnalysisResult.style.display = 'none';
            }
            
            // Set up event listeners
            setupMetadataEventListeners();
            
            // Load conversation metadata if not already loaded
            if (Object.keys(conversationMetadata).length === 0) {
                loadConversationMetadata().then(() => {
                    displayMetadataConversations();
                });
            } else {
                displayMetadataConversations();
            }
            
            console.log('✅ Metadata tab initialized');
        }
        
        // Analyze main emotion of the conversation using ChatGPT
        async function analyzeMainEmotionWithChatGPT() {
            if (!currentMetadataConversation) {
                showStatus('אין שיחה נבחרת לניתוח', 'error');
                return;
            }
            
            try {
                showLoading('מנתח רגש עיקרי עם ChatGPT...');
                
                console.log('🤖 Starting main emotion analysis for:', currentMetadataConversation);
                
                const response = await fetch('/api/analyze-main-emotion', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        conversationFolder: currentMetadataConversation
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.error) {
                    throw new Error(result.error);
                }
                
                // Display the result
                const resultDiv = document.getElementById('main-emotion-analysis-result');
                const emotionDiv = document.getElementById('detected-main-emotion');
                
                if (result.mainEmotion) {
                    emotionDiv.textContent = result.mainEmotion;
                    resultDiv.style.display = 'block';
                    
                    // Show explanation if available
                    const explanationDiv = document.getElementById('emotion-explanation');
                    if (result.explanation && explanationDiv) {
                        explanationDiv.textContent = `💡 ${result.explanation}`;
                        explanationDiv.style.display = 'block';
                    }
                    
                    // Show analysis statistics
                    const statsDiv = document.getElementById('analysis-stats');
                    if (statsDiv) {
                        document.getElementById('segments-count').textContent = `📊 ${result.segmentsAnalyzed || 0} קטעים`;
                        document.getElementById('confidence-score').textContent = `🎯 ביטחון: ${Math.round((result.confidence || 0) * 100)}%`;
                        statsDiv.style.display = 'flex';
                    }
                    
                    // Clear all emotion checkboxes first, then select only the detected main emotion
                    const emotionCheckboxes = document.querySelectorAll('#main-emotions-selector input[type="checkbox"]');
                    emotionCheckboxes.forEach(checkbox => {
                        checkbox.checked = false; // Clear all first
                    });
                    
                    // Now find and check only the detected main emotion
                    emotionCheckboxes.forEach(checkbox => {
                        if (checkbox.value === result.mainEmotion || checkbox.nextElementSibling?.textContent?.trim() === result.mainEmotion) {
                            checkbox.checked = true;
                            console.log(`✅ Selected main emotion checkbox: ${result.mainEmotion}`);
                        }
                    });
                    
                    // Update intensity if provided
                    if (result.intensity) {
                        document.getElementById('emotional-intensity').value = result.intensity;
                        document.getElementById('intensity-display').textContent = result.intensity;
                    }
                    
                    showStatus(`הרגש העיקרי זוהה: ${result.mainEmotion} (${Math.round((result.confidence || 0) * 100)}% ביטחון)`, 'success');
                    console.log('✅ Main emotion analysis completed:', result);
                } else {
                    throw new Error('לא נמצא רגש עיקרי בתוצאות');
                }
                
            } catch (error) {
                console.error('❌ Main emotion analysis error:', error);
                showStatus(`שגיאה בניתוח: ${error.message}`, 'error');
                
                // Hide result div on error
                document.getElementById('main-emotion-analysis-result').style.display = 'none';
            } finally {
                hideLoading();
            }
        }
        
        // ==================== PEOPLE MANAGEMENT FUNCTIONS ====================
        
        // Global variables for people management
        let peopleData = {};
        let currentPersonId = null;
        
        // Load people data from server
        async function loadPeopleData() {
            try {
                const response = await fetch('/api/get-people-data');
                if (response.ok) {
                    peopleData = await response.json();
                    console.log('👥 Loaded people data:', peopleData);
                } else {
                    console.warn('⚠️ Failed to load people data, creating empty structure');
                    peopleData = { people: {} };
                }
            } catch (error) {
                console.error('❌ Error loading people data:', error);
                peopleData = { people: {} };
            }
        }
        
        // Save people data to server
        async function savePeopleData() {
            try {
                const response = await fetch('/api/save-people-data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(peopleData)
                });
                
                if (!response.ok) throw new Error('Failed to save people data');
                
                console.log('✅ People data saved successfully');
                return true;
            } catch (error) {
                console.error('❌ Error saving people data:', error);
                return false;
            }
        }
        
        // Display people list
        function displayPeopleList() {
            const peopleList = document.getElementById('people-list');
            if (!peopleList) return;
            
            peopleList.innerHTML = '';
            
            if (Object.keys(peopleData.people || {}).length === 0) {
                peopleList.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: #999;">
                        <i class="material-icons" style="font-size: 48px; display: block; margin-bottom: 1rem;">people</i>
                        <p>אין אנשים מוגדרים</p>
                        <button onclick="addNewPerson()" class="btn btn-primary">
                            <i class="material-icons">person_add</i>
                            הוסף אדם ראשון
                        </button>
                    </div>
                `;
                return;
            }
            
            Object.entries(peopleData.people).forEach(([personId, person]) => {
                const personCard = document.createElement('div');
                personCard.className = 'modern-conversation-card';
                personCard.onclick = () => selectPerson(personId);
                
                const conversationsCount = person.conversations?.length || 0;
                const totalSegments = person.totalSegments || 0;
                
                personCard.innerHTML = `
                    <div class="conversation-card-header">
                        <div class="conversation-card-title">
                            <div style="width: 12px; height: 12px; border-radius: 50%; background: ${person.color || '#667eea'}; margin-left: 0.5rem;"></div>
                            ${person.name}
                        </div>
                        <div class="conversation-card-meta">
                            <span>${conversationsCount} שיחות</span>
                            <span>${totalSegments} קטעים</span>
                        </div>
                    </div>
                    <div class="conversation-card-body">
                        <div class="conversation-stats">
                            <div class="stat-item">
                                <i class="material-icons" style="font-size: 16px;">person</i>
                                ${person.status || 'active'}
                            </div>
                            ${person.description ? `<div class="stat-item">${person.description}</div>` : ''}
                        </div>
                    </div>
                `;
                
                peopleList.appendChild(personCard);
            });
        }
        
        // Select a person for editing
        function selectPerson(personId) {
            currentPersonId = personId;
            const person = peopleData.people[personId];
            if (!person) return;
            
            // Show editor panel
            document.getElementById('no-person-selection').style.display = 'none';
            document.getElementById('person-editor-panel').style.display = 'block';
            
            // Update title
            document.getElementById('person-editor-title').textContent = `עריכת אדם: ${person.name}`;
            
            // Fill form fields
            document.getElementById('person-name').value = person.name || '';
            document.getElementById('person-description').value = person.description || '';
            document.getElementById('person-color').value = person.color || '#667eea';
            document.getElementById('person-status').value = person.status || 'active';
            document.getElementById('person-default-speaker').value = person.defaultSpeaker || '0';
            
            // Load available conversations
            loadAvailableConversations();
            
            // Update statistics
            updatePersonStatistics(personId);
            
            // Highlight selected card
            document.querySelectorAll('#people-list .modern-conversation-card').forEach(card => {
                card.classList.remove('active');
            });
            event.target.closest('.modern-conversation-card')?.classList.add('active');
        }
        
        // Load available conversations for assignment
        function loadAvailableConversations() {
            const availableContainer = document.getElementById('available-conversations');
            const assignedContainer = document.getElementById('assigned-conversations');
            
            if (!availableContainer || !assignedContainer) return;
            
            availableContainer.innerHTML = '';
            assignedContainer.innerHTML = '';
            
            const currentPerson = peopleData.people[currentPersonId];
            const assignedConversations = currentPerson?.conversations || [];
            
            // Get all conversations from metadata
            const allConversations = Object.entries(conversationMetadata || {});
            
            allConversations.forEach(([conversationId, conversation]) => {
                const conversationName = conversation.metadata?.name || conversationId;
                const isAssigned = assignedConversations.includes(conversationId);
                
                const conversationItem = document.createElement('div');
                conversationItem.style.cssText = `
                    padding: 0.5rem; margin: 0.25rem 0; border-radius: 4px; 
                    background: ${isAssigned ? '#e8f5e8' : '#f8f9fa'}; 
                    border: 1px solid ${isAssigned ? '#28a745' : '#dee2e6'};
                `;
                
                if (isAssigned) {
                    // For assigned conversations, show speaker selection
                    const speakerMapping = peopleData.speakerMappings?.[conversationId] || {};
                    const currentSpeaker = Object.keys(speakerMapping).find(speaker => 
                        speakerMapping[speaker] === currentPersonId) || currentPerson.defaultSpeaker || '0';
                    
                    conversationItem.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <strong>${conversationName}</strong>
                                <div style="font-size: 0.8rem; color: #666; margin-top: 0.25rem;">
                                    ID: ${conversationId}
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <select onchange="updateSpeakerMapping('${conversationId}', this.value)" 
                                        style="padding: 0.25rem; font-size: 0.8rem; min-width: 90px;">
                                    <option value="0" ${currentSpeaker === '0' ? 'selected' : ''}>דובר 0</option>
                                    <option value="1" ${currentSpeaker === '1' ? 'selected' : ''}>דובר 1</option>
                                    <option value="2" ${currentSpeaker === '2' ? 'selected' : ''}>דובר 2</option>
                                    <option value="3" ${currentSpeaker === '3' ? 'selected' : ''}>דובר 3</option>
                                </select>
                                <button onclick="toggleConversationAssignment('${conversationId}')" 
                                        class="btn btn-sm btn-danger" 
                                        style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">
                                    הסר
                                </button>
                            </div>
                        </div>
                    `;
                    assignedContainer.appendChild(conversationItem);
                } else {
                    conversationItem.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>${conversationName}</span>
                            <button onclick="toggleConversationAssignment('${conversationId}')" 
                                    class="btn btn-sm btn-success" 
                                    style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">
                                הוסף
                            </button>
                        </div>
                    `;
                    availableContainer.appendChild(conversationItem);
                }
            });
        }
        
        // Toggle conversation assignment to person
        function toggleConversationAssignment(conversationId) {
            if (!currentPersonId || !peopleData.people[currentPersonId]) return;
            
            const person = peopleData.people[currentPersonId];
            const assignedConversations = person.conversations || [];
            
            const isAssigned = assignedConversations.includes(conversationId);
            
            if (isAssigned) {
                // Remove conversation
                person.conversations = assignedConversations.filter(id => id !== conversationId);
                
                // Remove from conversation assignments
                if (!peopleData.conversationAssignments) peopleData.conversationAssignments = {};
                if (peopleData.conversationAssignments[conversationId]) {
                    peopleData.conversationAssignments[conversationId] = 
                        peopleData.conversationAssignments[conversationId].filter(p => p !== currentPersonId);
                    if (peopleData.conversationAssignments[conversationId].length === 0) {
                        delete peopleData.conversationAssignments[conversationId];
                    }
                }
                
                // Remove speaker mapping
                if (!peopleData.speakerMappings) peopleData.speakerMappings = {};
                if (peopleData.speakerMappings[conversationId]) {
                    Object.keys(peopleData.speakerMappings[conversationId]).forEach(speaker => {
                        if (peopleData.speakerMappings[conversationId][speaker] === currentPersonId) {
                            delete peopleData.speakerMappings[conversationId][speaker];
                        }
                    });
                    if (Object.keys(peopleData.speakerMappings[conversationId]).length === 0) {
                        delete peopleData.speakerMappings[conversationId];
                    }
                }
            } else {
                // Add conversation
                person.conversations = [...assignedConversations, conversationId];
                
                // Add to conversation assignments
                if (!peopleData.conversationAssignments) peopleData.conversationAssignments = {};
                if (!peopleData.conversationAssignments[conversationId]) {
                    peopleData.conversationAssignments[conversationId] = [];
                }
                if (!peopleData.conversationAssignments[conversationId].includes(currentPersonId)) {
                    peopleData.conversationAssignments[conversationId].push(currentPersonId);
                }
                
                // Add speaker mapping (use default speaker)
                if (!peopleData.speakerMappings) peopleData.speakerMappings = {};
                if (!peopleData.speakerMappings[conversationId]) {
                    peopleData.speakerMappings[conversationId] = {};
                }
                const defaultSpeaker = person.defaultSpeaker || '0';
                peopleData.speakerMappings[conversationId][defaultSpeaker] = currentPersonId;
            }
            
            // Reload conversation lists
            loadAvailableConversations();
            
            // Update statistics
            updatePersonStatistics(currentPersonId);
        }
        
        // Update speaker mapping for a conversation
        function updateSpeakerMapping(conversationId, newSpeaker) {
            if (!currentPersonId || !peopleData.people[currentPersonId]) return;
            
            if (!peopleData.speakerMappings) peopleData.speakerMappings = {};
            if (!peopleData.speakerMappings[conversationId]) {
                peopleData.speakerMappings[conversationId] = {};
            }
            
            // Remove current person from all speakers in this conversation
            Object.keys(peopleData.speakerMappings[conversationId]).forEach(speaker => {
                if (peopleData.speakerMappings[conversationId][speaker] === currentPersonId) {
                    delete peopleData.speakerMappings[conversationId][speaker];
                }
            });
            
            // Add person to new speaker
            peopleData.speakerMappings[conversationId][newSpeaker] = currentPersonId;
            
            console.log(`🎙️ Updated speaker mapping: ${conversationId} speaker ${newSpeaker} = ${currentPersonId}`);
            
            // Show temporary status
            showStatus(`עודכן: ${peopleData.people[currentPersonId].name} הוא כעת דובר ${newSpeaker} בשיחה ${conversationId}`, 'info');
        }
        
        // Update person statistics
        function updatePersonStatistics(personId) {
            const person = peopleData.people[personId];
            if (!person) return;
            
            const conversations = person.conversations || [];
            let totalSegments = 0;
            let totalDuration = 0;
            
            // Calculate statistics from assigned conversations
            conversations.forEach(conversationId => {
                const conversation = conversationMetadata[conversationId];
                if (conversation) {
                    totalSegments += conversation.mp3_count || 0;
                    // Add duration calculation if available
                }
            });
            
            // Update display
            document.getElementById('person-conversations-count').textContent = conversations.length;
            document.getElementById('person-segments-count').textContent = totalSegments;
            document.getElementById('person-total-duration').textContent = formatDuration(totalDuration);
            document.getElementById('person-status-display').textContent = person.status || 'active';
            
            // Update person data
            person.totalSegments = totalSegments;
            person.totalDuration = totalDuration;
        }
        
        // Add new person
        function addNewPerson() {
            currentPersonId = 'person_' + Date.now();
            
            // Create new person
            peopleData.people[currentPersonId] = {
                name: 'אדם חדש',
                description: '',
                color: '#667eea',
                status: 'active',
                conversations: [],
                totalSegments: 0,
                totalDuration: 0,
                defaultSpeaker: '0',
                createdAt: new Date().toISOString(),
                lastModified: new Date().toISOString()
            };
            
            // Show editor
            selectPerson(currentPersonId);
            
            // Focus on name field
            setTimeout(() => {
                document.getElementById('person-name').focus();
            }, 100);
        }
        
        // Save person
        async function savePerson() {
            if (!currentPersonId || !peopleData.people[currentPersonId]) return;
            
            const person = peopleData.people[currentPersonId];
            
            // Update person data from form
            person.name = document.getElementById('person-name').value.trim();
            person.description = document.getElementById('person-description').value.trim();
            person.color = document.getElementById('person-color').value;
            person.status = document.getElementById('person-status').value;
            person.defaultSpeaker = document.getElementById('person-default-speaker').value;
            person.lastModified = new Date().toISOString();
            
            if (!person.name) {
                showStatus('שם האדם הוא שדה חובה', 'error');
                return;
            }
            
            try {
                showLoading();
                
                // Save to server
                const success = await savePeopleData();
                if (success) {
                    // Synchronize speaker names with conversation metadata
                    await synchronizeSpeakerNames();
                    
                    // Refresh display
                    displayPeopleList();
                    showStatus('האדם נשמר בהצלחה!', 'success');
                } else {
                    showStatus('שגיאה בשמירת האדם', 'error');
                }
            } catch (error) {
                console.error('Error saving person:', error);
                showStatus('שגיאה בשמירת האדם', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // Delete person
        async function deletePerson() {
            if (!currentPersonId || !peopleData.people[currentPersonId]) return;
            
            const person = peopleData.people[currentPersonId];
            
            if (!confirm(`האם אתה בטוח שברצונך למחוק את "${person.name}"?`)) {
                return;
            }
            
            try {
                showLoading();
                
                // Remove person
                delete peopleData.people[currentPersonId];
                
                // Save to server
                const success = await savePeopleData();
                if (success) {
                    // Reset selection
                    currentPersonId = null;
                    document.getElementById('no-person-selection').style.display = 'block';
                    document.getElementById('person-editor-panel').style.display = 'none';
                    
                    // Refresh display
                    displayPeopleList();
                    showStatus('האדם נמחק בהצלחה!', 'success');
                } else {
                    showStatus('שגיאה במחיקת האדם', 'error');
                }
            } catch (error) {
                console.error('Error deleting person:', error);
                showStatus('שגיאה במחיקת האדם', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // Refresh people list
        async function refreshPeopleList() {
            try {
                await loadPeopleData();
                displayPeopleList();
                showStatus('רשימת האנשים עודכנה', 'success');
            } catch (error) {
                console.error('Error refreshing people list:', error);
                showStatus('שגיאה ברענון הרשימה', 'error');
            }
        }
        
        // Initialize people management tab
        function initializePeople() {
            console.log('👥 Initializing people management tab...');
            
            // Load people data
            loadPeopleData().then(() => {
                displayPeopleList();
            });
            
            console.log('✅ People management tab initialized');
        }
        
        // Helper function to get emotion emoji
        function getEmotionEmoji(emotion) {
            const emojiMap = {
                'happiness': '😊',
                'sadness': '😢',
                'anger': '😠',
                'fear': '😨',
                'surprise': '😲',
                'disgust': '🤢',
                'curiosity': '🤔',
                'confusion': '😵',
                'excitement': '🤩',
                'neutral': '😐',
                'annoyance': '😤',
                'frustration': '😫',
                'caring': '🤗',
                'love': '❤️'
            };
            return emojiMap[emotion] || '😐';
        }
        
        // ==================== CONVERSATION DELETION FUNCTIONS ====================
        
        // Delete a single conversation
        async function deleteConversation(folder) {
            if (!folder) return;
            
            const conversationData = conversationMetadata[folder];
            const conversationName = conversationData?.metadata?.name || `שיחה ${conversationData?.number}`;
            
            // Show confirmation dialog
            const confirmMessage = `האם אתה בטוח שברצונך למחוק את "${conversationName}" (${folder})?\n\nפעולה זו תמחק:\n• את כל קבצי ה-MP3 בתיקייה\n• את קבצי הנתונים הרגשיים\n• את המטאדאטה של השיחה\n\nלא ניתן לבטל פעולה זו!`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                showLoading(`מוחק את ${conversationName}...`);
                
                // Call backend to delete the conversation
                const response = await fetch(`${apiBaseUrl}/api/delete-conversation`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folder,
                        conversationName: conversationName
                    })
                });
                
                const result = await response.json();
                
                if (!response.ok) {
                    throw new Error(result.error || 'Failed to delete conversation');
                }
                
                // Remove from local data
                delete conversationMetadata[folder];
                
                // Clear current selection if this conversation was selected
                if (currentMetadataConversation === folder) {
                    currentMetadataConversation = null;
                    document.getElementById('no-metadata-selection').style.display = 'block';
                    document.getElementById('metadata-editor-panel').style.display = 'none';
                }
                
                // Refresh the conversations list
                displayMetadataConversations();
                
                // Notify main visualization about the deletion
                notifyMainVisualizationOfDeletion(folder);
                
                showStatus(`השיחה "${conversationName}" נמחקה בהצלחה`, 'success');
                console.log(`🗑️ Deleted conversation: ${folder}`);
                
            } catch (error) {
                console.error('Error deleting conversation:', error);
                showStatus(`שגיאה במחיקת השיחה: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }
        
        // Show multiple deletion confirmation dialog
        function showDeleteAllConfirm() {
            const conversationList = Object.keys(conversationMetadata);
            if (conversationList.length === 0) {
                alert('אין שיחות למחיקה');
                return;
            }
            
            // Create a selection dialog
            const dialogHtml = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; justify-content: center; align-items: center;">
                    <div style="background: white; padding: 2rem; border-radius: 12px; max-width: 600px; max-height: 80vh; overflow-y: auto; direction: rtl;">
                        <h3 style="margin: 0 0 1rem 0; color: #d32f2f;">מחיקה מרובה של שיחות</h3>
                        <p style="color: #666; margin-bottom: 1.5rem;">בחר את השיחות שברצונך למחוק. <strong>פעולה זו בלתי הפיכה!</strong></p>
                        
                        <div style="max-height: 300px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 8px; padding: 1rem;">
                            ${conversationList.map(folder => {
                                const data = conversationMetadata[folder];
                                const metadata = data.metadata || {};
                                const name = metadata.name || `שיחה ${data.number}`;
                                return `
                                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; cursor: pointer;">
                                        <input type="checkbox" value="${folder}" class="delete-conversation-checkbox">
                                        <span>${name} (${folder}) - ${data.mp3_count || 0} קטעים</span>
                                    </label>
                                `;
                            }).join('')}
                        </div>
                        
                        <div style="margin-top: 1.5rem; display: flex; gap: 1rem; justify-content: flex-end;">
                            <button onclick="closeDeleteDialog()" class="btn btn-secondary">ביטול</button>
                            <button onclick="selectAllConversations()" class="btn btn-secondary">בחר הכל</button>
                            <button onclick="executeMultipleDelete()" class="btn btn-danger">מחק נבחרים</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add dialog to page
            const dialogDiv = document.createElement('div');
            dialogDiv.id = 'delete-dialog';
            dialogDiv.innerHTML = dialogHtml;
            document.body.appendChild(dialogDiv);
        }
        
        // Close delete dialog
        function closeDeleteDialog() {
            const dialog = document.getElementById('delete-dialog');
            if (dialog) {
                dialog.remove();
            }
        }
        
        // Select all conversations in delete dialog
        function selectAllConversations() {
            const checkboxes = document.querySelectorAll('.delete-conversation-checkbox');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = !allChecked;
            });
        }
        
        // Execute multiple conversation deletion
        async function executeMultipleDelete() {
            const selectedCheckboxes = document.querySelectorAll('.delete-conversation-checkbox:checked');
            const selectedFolders = Array.from(selectedCheckboxes).map(cb => cb.value);
            
            if (selectedFolders.length === 0) {
                alert('לא נבחרו שיחות למחיקה');
                return;
            }
            
            const confirmMessage = `האם אתה בטוח שברצונך למחוק ${selectedFolders.length} שיחות?\n\nשיחות שנבחרו:\n${selectedFolders.map(folder => `• ${conversationMetadata[folder]?.metadata?.name || folder}`).join('\n')}\n\nפעולה זו בלתי הפיכה!`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            closeDeleteDialog();
            
            try {
                showLoading(`מוחק ${selectedFolders.length} שיחות...`);
                
                let successCount = 0;
                let errorCount = 0;
                
                for (const folder of selectedFolders) {
                    try {
                        document.getElementById('loading-text').textContent = 
                            `מוחק שיחות... (${successCount + errorCount + 1}/${selectedFolders.length})`;
                        
                        const response = await fetch(`${apiBaseUrl}/api/delete-conversation`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folder,
                                conversationName: conversationMetadata[folder]?.metadata?.name || folder
                            })
                        });
                        
                        if (response.ok) {
                            delete conversationMetadata[folder];
                            successCount++;
                            console.log(`🗑️ Deleted conversation: ${folder}`);
                        } else {
                            errorCount++;
                            console.error(`❌ Failed to delete: ${folder}`);
                        }
                        
                    } catch (error) {
                        errorCount++;
                        console.error(`❌ Error deleting ${folder}:`, error);
                    }
                }
                
                // Clear current selection if it was deleted
                if (currentMetadataConversation && selectedFolders.includes(currentMetadataConversation)) {
                    currentMetadataConversation = null;
                    document.getElementById('no-metadata-selection').style.display = 'block';
                    document.getElementById('metadata-editor-panel').style.display = 'none';
                }
                
                // Refresh the conversations list
                displayMetadataConversations();
                
                // Notify main visualization about the multiple deletions
                if (successCount > 0) {
                    notifyMainVisualizationOfChanges();
                }
                
                // Show results
                let message = `הושלמה מחיקה מרובה:\n• ${successCount} שיחות נמחקו בהצלחה`;
                if (errorCount > 0) {
                    message += `\n• ${errorCount} שיחות נכשלו במחיקה`;
                }
                
                showStatus(message.replace('\n', ' | '), successCount > 0 ? 'success' : 'error');
                
            } catch (error) {
                console.error('Error in multiple deletion:', error);
                showStatus('שגיאה במחיקה מרובה', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // ==================== MAIN VISUALIZATION NOTIFICATION ====================
        
        // Notify main visualization about conversation deletion
        function notifyMainVisualizationOfDeletion(folder) {
            try {
                // Check if main visualization is open in another tab/window
                if (window.opener) {
                    // If admin panel was opened from main visualization
                    window.opener.postMessage({
                        type: 'conversation-deleted',
                        folder: folder,
                        timestamp: Date.now()
                    }, '*');
                    console.log(`📡 Notified main visualization about deletion of ${folder}`);
                }
                
                // Also try to send message to any iframe that might contain main visualization
                const iframes = document.getElementsByTagName('iframe');
                for (let iframe of iframes) {
                    try {
                        iframe.contentWindow.postMessage({
                            type: 'conversation-deleted',
                            folder: folder,
                            timestamp: Date.now()
                        }, '*');
                    } catch (e) {
                        // Ignore cross-origin errors
                    }
                }
                
                // Try using BroadcastChannel for same-origin communication
                if (typeof BroadcastChannel !== 'undefined') {
                    const channel = new BroadcastChannel('conversation-sync');
                    channel.postMessage({
                        type: 'conversation-deleted',
                        folder: folder,
                        timestamp: Date.now()
                    });
                    channel.close();
                    console.log(`📻 Broadcast deletion notification for ${folder}`);
                }
                
            } catch (error) {
                console.warn('⚠️ Failed to notify main visualization:', error);
            }
        }
        
        // Notify main visualization about general changes
        function notifyMainVisualizationOfChanges() {
            try {
                // Check if main visualization is open in another tab/window
                if (window.opener) {
                    window.opener.postMessage({
                        type: 'refresh-conversations',
                        timestamp: Date.now()
                    }, '*');
                    console.log(`📡 Notified main visualization about conversation changes`);
                }
                
                // Also try to send message to any iframe
                const iframes = document.getElementsByTagName('iframe');
                for (let iframe of iframes) {
                    try {
                        iframe.contentWindow.postMessage({
                            type: 'refresh-conversations',
                            timestamp: Date.now()
                        }, '*');
                    } catch (e) {
                        // Ignore cross-origin errors
                    }
                }
                
                // Try using BroadcastChannel
                if (typeof BroadcastChannel !== 'undefined') {
                    const channel = new BroadcastChannel('conversation-sync');
                    channel.postMessage({
                        type: 'refresh-conversations',
                        timestamp: Date.now()
                    });
                    channel.close();
                    console.log(`📻 Broadcast conversation refresh notification`);
                }
                
            } catch (error) {
                console.warn('⚠️ Failed to notify main visualization:', error);
            }
        }
        
        // ==================== END MAIN VISUALIZATION NOTIFICATION ====================
        
        // ==================== EMOTION COLOR REQUEST HANDLER ====================
        
        // Listen for emotion color requests from editor visualizations
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'requestEmotionColors') {
                console.log('🔄 Received emotion colors request from:', event.data.source, 'sketchId:', event.data.sketchId);
                console.log('📊 Current emotions config status:', {
                    loaded: !!(emotionsConfig && Object.keys(emotionsConfig).length > 0),
                    count: emotionsConfig ? Object.keys(emotionsConfig).length : 0
                });
                
                // Check if we have emotions config loaded
                if (emotionsConfig && Object.keys(emotionsConfig).length > 0) {
                    // Prepare emotion colors for visualization
                    const emotionColorsForViz = {};
                    let activeCount = 0;
                    Object.entries(emotionsConfig).forEach(([emotion, config]) => {
                        if (config.active && config.color) {
                            // Convert hex to RGB array for visualization
                            const rgbColor = hexToRgb(config.color);
                            
                            // Store with Hebrew name (original key)
                            emotionColorsForViz[emotion] = rgbColor;
                            
                            // Also store with English equivalent if available for better compatibility
                            if (config.english) {
                                emotionColorsForViz[config.english] = rgbColor;
                            }
                            
                            activeCount++;
                        }
                    });
                    
                    console.log(`🎨 Sending current emotion colors to ${event.data.sketchId || 'unknown'}:`, {
                        totalEmotions: Object.keys(emotionColorsForViz).length,
                        activeEmotions: activeCount,
                        sampleColors: Object.keys(emotionColorsForViz).slice(0, 5)
                    });
                    
                    // Send response back to the requesting window
                    const responseMessage = {
                        type: 'emotionColorsResponse',
                        emotionColorMap: emotionColorsForViz,
                        emotions: emotionsConfig,
                        targetSketch: event.data.sketchId,
                        timestamp: Date.now()
                    };
                    
                    // Send to the source that requested it
                    if (event.source && event.source !== window) {
                        try {
                            event.source.postMessage(responseMessage, '*');
                            console.log(`✅ Sent emotion colors response to ${event.data.sketchId || 'unknown'} (${Object.keys(emotionColorsForViz).length} emotions)`);
                        } catch (error) {
                            console.warn('Could not send response to requesting window:', error);
                        }
                    }
                    
                    // Also send to all iframes as backup
                    const iframes = document.querySelectorAll('iframe');
                    iframes.forEach((iframe, index) => {
                        try {
                            iframe.contentWindow.postMessage(responseMessage, '*');
                            console.log(`🔄 Backup: Sent colors to iframe ${index}`);
                        } catch (e) {
                            // Ignore cross-origin errors
                        }
                    });
                    
                    // Also broadcast to all targets to make sure everyone gets it
                    setTimeout(() => {
                        updateVisualizationColors();
                    }, 100);
                    
                } else {
                    console.log('⚠️ No emotions config available to send - will load default config');
                    
                    // Try to load emotions config if not loaded
                    if (!emotionsConfig) {
                        loadEmotionsConfig().then(() => {
                            // Retry sending colors after loading
                            if (emotionsConfig && Object.keys(emotionsConfig).length > 0) {
                                console.log('✅ Emotions config loaded, retrying color send...');
                                // Re-trigger the same request
                                window.dispatchEvent(new MessageEvent('message', { data: event.data, source: event.source }));
                            }
                        }).catch(err => {
                            console.error('Failed to load emotions config:', err);
                        });
                    }
                    
                    // Send empty response
                    const emptyResponse = {
                        type: 'emotionColorsResponse',
                        emotionColorMap: {},
                        emotions: {},
                        targetSketch: event.data.sketchId,
                        timestamp: Date.now()
                    };
                    
                    if (event.source && event.source !== window) {
                        try {
                            event.source.postMessage(emptyResponse, '*');
                            console.log('📤 Sent empty emotion colors response');
            } catch (error) {
                            console.warn('Could not send empty response:', error);
                        }
                    }
                }
            }
        });
        
        // Also listen for BroadcastChannel requests
        if (typeof BroadcastChannel !== 'undefined') {
            const emotionColorsRequestChannel = new BroadcastChannel('emotion-colors-sync');
            emotionColorsRequestChannel.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'requestEmotionColors') {
                    console.log('📻 Received BroadcastChannel emotion colors request from:', event.data.source);
                    
                    // Send current colors via broadcast
                    if (emotionsConfig && Object.keys(emotionsConfig).length > 0) {
                        const emotionColorsForViz = {};
                        Object.entries(emotionsConfig).forEach(([emotion, config]) => {
                            if (config.active && config.color) {
                                emotionColorsForViz[emotion] = hexToRgb(config.color);
                            }
                        });
                        
                        emotionColorsRequestChannel.postMessage({
                            type: 'emotionColorsResponse',
                            emotionColorMap: emotionColorsForViz,
                            emotions: emotionsConfig,
                            timestamp: Date.now()
                        });
                        
                        console.log('📻 Broadcast emotion colors response via BroadcastChannel');
                    }
                }
            });
            
            console.log('🎨 BroadcastChannel listener for emotion color requests initialized');
        }
        
        // ==================== END EMOTION COLOR REQUEST HANDLER ====================
        
        // Setup emotion color synchronization system
        function setupEmotionColorSync() {
            console.log('🎨 Setting up emotion color synchronization system...');
            
            // Send colors immediately when emotions tab is opened
            const originalSwitchTab = window.switchTab;
            window.switchTab = function(tabName) {
                // Call original function
                const result = originalSwitchTab.apply(this, arguments);
                
                // If switching to emotions tab, ensure colors are synchronized
                if (tabName === 'emotions') {
                    console.log('🎭 Emotions tab opened - synchronizing colors with visualizations...');
                    setTimeout(() => {
                        updateVisualizationColors();
                    }, 500); // Small delay to ensure tab is fully loaded
                }
                
                return result;
            };
            
            // Send colors when page is focused (user returns to admin panel)
            window.addEventListener('focus', () => {
                console.log('🎨 Admin panel focused - checking emotion color sync...');
                if (emotionsConfig && Object.keys(emotionsConfig).length > 0) {
                    updateVisualizationColors();
                }
            });
            
            // Send colors when page becomes visible
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    console.log('🎨 Admin panel visible - ensuring emotion color sync...');
                    if (emotionsConfig && Object.keys(emotionsConfig).length > 0) {
                        updateVisualizationColors();
                    }
                }
            });
            
            console.log('✅ Emotion color synchronization system initialized');
        }
        
        // ==================== END CONVERSATION DELETION ====================
        
        // Tab switching is now handled in the main switchTab function above
        
        // Initialize the admin panel when DOM is loaded
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('🎛️ Admin Panel initializing...');
            
            // Only set API base URL if not already set by the main initialization
            if (!apiBaseUrl) {
                apiBaseUrl = window.location.origin;
                console.log(`🔧 Set default API base URL: ${apiBaseUrl}`);
            }
            
            // Initialize on load
            await detectApiServer();
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            
            await loadConversations();
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            
            // Load emotion configuration early to ensure colors are available
            await loadEmotionsConfig();
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            
            populateRetranscriptionOptions();
            setupEventListeners();
            initializeExperiments();
            
            // Initialize auto-sync functionality
            addManualSyncButton();
            createSyncStatusIndicator();
            console.log('🔄 Auto-sync functionality initialized');
            
            // Smart auto-refresh with focus detection
            let isPageVisible = true;
            let lastRefreshTime = Date.now();
            
            // Detect page visibility
            document.addEventListener('visibilitychange', () => {
                isPageVisible = !document.hidden;
                if (isPageVisible && Date.now() - lastRefreshTime > 60000 && !isLoadingEmotionData) {
                    // Refresh if page becomes visible and hasn't refreshed in 60s
                    refreshEmotionData();
                }
            });
            
            // Smart refresh interval - only when page is visible and no loading in progress
            refreshInterval = setInterval(async () => {
                if (currentConversation && !hasUnsavedChanges && isPageVisible && !isLoadingEmotionData) {
                    await refreshEmotionData();
                    lastRefreshTime = Date.now();
                }
            }, 120000); // Refresh every 2 minutes to reduce server load
            
            // Initialize the first tab (editor) as active
            const firstTab = document.querySelector('.tab-button.active');
            if (firstTab) {
                const tabName = firstTab.getAttribute('onclick').match(/switchTab\('(.*)'\)/)?.[1];
                if (tabName) {
                    // Don't call switchTab directly since it might interfere with the default state
                    // Just ensure the correct tab content is visible
                    console.log(`🎯 Default tab: ${tabName}`);
                    
                    // Initialize the default tab's functionality
                    if (tabName === 'editor') {
                        setTimeout(() => {
                            if (typeof loadConversations === 'function') {
                                loadConversations();
                            }
                        }, 500);
                    }
                }
            }
            
            console.log('✅ Admin Panel initialized');
        });

        // Modern Parameter Editor Functions
        function toggleParameterSection(header) {
            const section = header.parentElement;
            const body = section.querySelector('.parameter-section-body');
            const toggle = header.querySelector('.parameter-section-toggle');
            
            section.classList.toggle('collapsed');
            
            if (section.classList.contains('collapsed')) {
                body.style.maxHeight = '0';
                body.style.paddingTop = '0';
                body.style.paddingBottom = '0';
            } else {
                body.style.maxHeight = body.scrollHeight + 'px';
                body.style.paddingTop = '1.5rem';
                body.style.paddingBottom = '1.5rem';
            }
        }
        
        // ==================== ENHANCED UPLOAD SYSTEM ====================
        let processingInProgress = false;
        
        // Quality selection function
        function selectQuality(quality) {
            console.log('🎯 Selected quality:', quality);
            
            // Remove active class from all options
            document.querySelectorAll('.quality-option').forEach(option => {
                option.style.borderColor = '#e0e0e0';
                option.style.background = 'white';
                option.style.transform = 'scale(1)';
            });
            
            // Add active class to selected option
            const selectedOption = event.target.closest('.quality-option');
            if (selectedOption) {
                selectedOption.style.borderColor = '#4caf50';
                selectedOption.style.background = '#f0f8f0';
                selectedOption.style.transform = 'scale(1.02)';
            }
            
            // Update hidden input
            document.getElementById('selected-quality').value = quality;
            
            // Show quality description
            const qualityDescriptions = {
                'chatgpt4_best': '🎯 תמלול מתקדם עם GPT-4 לעברית מושלמת - האיכות הגבוהה ביותר',
                'whisper_accurate': '🎯 Whisper עם שיפור GPT-4 לעברית מדויקת',
                'openai_fast': '⚡ תמלול מהיר עם שיפור בסיסי'
            };
            
            showStatus(qualityDescriptions[quality] || 'איכות נבחרה', 'info');
        }
        
        function initializeUpload() {
            const uploadArea = document.getElementById('upload-area');
            const fileInput = document.getElementById('fileInput');
            const startBtn = document.getElementById('start-processing-btn');
            const cancelBtn = document.getElementById('cancel-upload-btn');
            
            if (!uploadArea || !fileInput) return;

            // Drag and drop handling
            uploadArea.addEventListener('click', () => fileInput.click());
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });

            if (startBtn) startBtn.addEventListener('click', startProcessingNewConversation);
            if (cancelBtn) cancelBtn.addEventListener('click', cancelUpload);
        }

        function handleDragOver(e) {
            e.preventDefault();
            const uploadArea = document.getElementById('upload-area');
            uploadArea.style.borderColor = '#4CAF50';
            uploadArea.style.background = '#f0f8f0';
            uploadArea.style.transform = 'scale(1.02)';
        }

        function handleDragLeave() {
            const uploadArea = document.getElementById('upload-area');
            uploadArea.style.borderColor = '#667eea';
            uploadArea.style.background = '#f8f9ff';
            uploadArea.style.transform = 'scale(1)';
        }

        function handleDrop(e) {
            e.preventDefault();
            handleDragLeave();
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileUpload(files[0]);
            }
        }

        async function handleFileUpload(file) {
            console.log('📁 File upload initiated:', file.name, file.size, file.type);
            
            // Validate file type - check for audio MIME type or supported extensions
            const supportedExtensions = ['.mp3', '.m4a', '.wav', '.flac', '.aac', '.ogg'];
            const fileName = file.name.toLowerCase();
            const isSupported = file.type.includes('audio') || supportedExtensions.some(ext => fileName.endsWith(ext));
            
            if (!isSupported) {
                showStatus('❌ נא להעלות קובץ אודיו נתמך: MP3, M4A, WAV, FLAC, AAC, OGG', 'error');
                return;
            }

            // Validate file size (100MB limit)
            const maxSize = 100 * 1024 * 1024; // 100MB
            if (file.size > maxSize) {
                showStatus('❌ הקובץ גדול מדי. מקסימום 100MB', 'error');
                return;
            }

            uploadedFile = file;
            
            // Update upload status
            document.getElementById('upload-status').innerHTML = `
                <div style="padding: 1rem; background: #e8f5e8; border-radius: 8px; color: #2e7d32;">
                    <i class="material-icons" style="vertical-align: middle;">check_circle</i>
                    <strong>קובץ הועלה בהצלחה!</strong><br>
                    📁 <strong>${file.name}</strong><br>
                    📊 גודל: ${(file.size / 1024 / 1024).toFixed(2)} MB<br>
                    ⏱️ משך משוער: ${Math.round(file.size / (1024 * 10))} שניות
                </div>
            `;
            
            // Show processing options
            document.getElementById('processing-options').style.display = 'block';
            
            // Update file info
            updateFileInfo(file);
            
            // Suggest conversation name based on file name (remove any audio extension)
            const audioExtensions = ['.mp3', '.m4a', '.wav', '.flac', '.aac', '.ogg'];
            let suggestedName = file.name;
            audioExtensions.forEach(ext => {
                if (suggestedName.toLowerCase().endsWith(ext)) {
                    suggestedName = suggestedName.slice(0, -ext.length);
                }
            });
            suggestedName = suggestedName.replace(/[_-]/g, ' ');
            document.getElementById('new-conversation-name').value = suggestedName;
        }

        function updateFileInfo(file) {
            const fileInfoDiv = document.getElementById('file-info');
            const duration = Math.round(file.size / (1024 * 10)); // Rough estimate
            const estimatedSegments = Math.ceil(duration / 20); // 20 second segments
            
            fileInfoDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; text-align: center;">
                    <div style="background: white; padding: 1rem; border-radius: 6px;">
                        <div style="font-size: 1.5rem; color: #2196f3;">📁</div>
                        <div style="font-size: 0.9rem; color: #666;">קובץ</div>
                        <div style="font-weight: bold;">${uploadedFile.name}</div>
                    </div>
                    <div style="background: white; padding: 1rem; border-radius: 6px;">
                        <div style="font-size: 1.5rem; color: #4caf50;">📊</div>
                        <div style="font-size: 0.9rem; color: #666;">גודל</div>
                        <div style="font-weight: bold;">${(uploadedFile.size / 1024 / 1024).toFixed(1)} MB</div>
                    </div>
                    <div style="background: white; padding: 1rem; border-radius: 6px;">
                        <div style="font-size: 1.5rem; color: #ff9800;">⏱️</div>
                        <div style="font-size: 0.9rem; color: #666;">משך משוער</div>
                        <div style="font-weight: bold;">${Math.floor(duration / 60)}:${(duration % 60).toString().padStart(2, '0')}</div>
                    </div>
                    <div style="background: white; padding: 1rem; border-radius: 6px;">
                        <div style="font-size: 1.5rem; color: #9c27b0;">🎵</div>
                        <div style="font-size: 0.9rem; color: #666;">קטעים משוערים</div>
                        <div style="font-weight: bold;">${estimatedSegments}</div>
                    </div>
                </div>
            `;
        }

        async function startProcessingNewConversation() {
            if (!uploadedFile || processingInProgress) {
                return;
            }

            const conversationName = document.getElementById('new-conversation-name').value.trim();
            const conversationType = document.getElementById('conversation-type').value;
            const segmentLength = parseInt(document.getElementById('segment-length').value);
            const transcriptionQuality = document.getElementById('selected-quality').value;
            const emotionAnalysisLevel = document.getElementById('emotion-analysis-level').value;

            if (!conversationName) {
                showStatus('❌ נא להזין שם לשיחה', 'error');
                return;
            }

            processingInProgress = true;
            
            try {
                // Show processing progress and reset tracking
                document.getElementById('processing-progress').style.display = 'block';
                resetProgress();
                updateProgress(0, 'מכין לעיבוד...');

                console.log('🚀 Starting new conversation processing:', {
                    name: conversationName,
                    type: conversationType,
                    segmentLength,
                    transcriptionQuality,
                    fileSize: uploadedFile.size
                });

                // Step 1: Upload and create conversation folder
                updateProgress(10, 'יוצר תיקיית שיחה חדשה...');
                const formData = new FormData();
                formData.append('mp3File', uploadedFile);
                formData.append('conversationName', conversationName);
                formData.append('conversationType', conversationType);
                formData.append('segmentLength', segmentLength);
                formData.append('transcriptionQuality', transcriptionQuality);
                formData.append('emotionAnalysisLevel', emotionAnalysisLevel);

                const uploadResponse = await fetch(`${apiBaseUrl}/api/upload-and-process`, {
                    method: 'POST',
                    body: formData
                });

                if (!uploadResponse.ok) {
                    throw new Error(`Upload failed: ${uploadResponse.status} ${uploadResponse.statusText}`);
                }

                const uploadResult = await uploadResponse.json();
                const conversationFolder = uploadResult.conversationFolder;
                
                updateProgress(25, `נוצרה תיקייה: ${conversationFolder}`);
                
                // Step 2: Segment the audio
                updateProgress(30, 'מחלק את האודיו לקטעים...');
                await new Promise(resolve => setTimeout(resolve, 1000)); // Allow UI update
                
                const segmentResponse = await fetch(`${apiBaseUrl}/api/segment-audio`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversationFolder,
                        segmentLength,
                        originalFile: uploadResult.uploadedPath
                    })
                });

                if (!segmentResponse.ok) {
                    throw new Error('Audio segmentation failed');
                }

                const segmentResult = await segmentResponse.json();
                updateProgress(60, `נוצרו ${segmentResult.segmentCount} קטעי אודיו`);

                // Step 3: Auto-transcribe and analyze all segments  
                updateProgress(70, 'מתמלל ומנתח רגשות באופן אוטומטי...');
                await generateEmotionAnalysis(conversationFolder, transcriptionQuality);

                // Step 4: Update configurations and integrate
                updateProgress(95, 'משלב במערכת...');
                await updateSystemConfiguration(conversationFolder, {
                    name: conversationName,
                    type: conversationType,
                    segmentCount: segmentResult.segmentCount,
                    duration: segmentResult.totalDuration
                });

                // Final success update with celebration
                hideSubProgress();
                updateProgress(100, '🎉 השיחה נוצרה בהצלחה ומוכנה לשימוש!');

                // Success feedback
                setTimeout(() => {
                    showStatus(`🎉 השיחה "${conversationName}" נוצרה בהצלחה ומוכנה לשימוש! השיחה נוספה אוטומטית למערכת הראשית.`, 'success');
                    resetUploadForm();
                    refreshAfterUpload();
                    
                    // Hide progress after a delay to let user see the completion
                    setTimeout(() => {
                        const progressContainer = document.getElementById('processing-progress');
                        if (progressContainer) {
                            progressContainer.style.display = 'none';
                        }
                    }, 3000);
                }, 1000);

            } catch (error) {
                console.error('❌ Processing error:', error);
                hideSubProgress();
                updateProgress(0, `❌ שגיאה: ${error.message}`);
                showStatus(`שגיאה בעיבוד: ${error.message}`, 'error');
                
                // Hide progress display after error
                setTimeout(() => {
                    const progressContainer = document.getElementById('processing-progress');
                    if (progressContainer) {
                        progressContainer.style.display = 'none';
                    }
                }, 5000); // Show error longer than success
            } finally {
                processingInProgress = false;
            }
        }

        async function processTranscription(conversationFolder, quality) {
            try {
                const response = await fetch(`${apiBaseUrl}/api/transcribe`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversationFolder,
                        quality
                    })
                });

                if (!response.ok) {
                    throw new Error('Transcription failed');
                }

                return await response.json();
            } catch (error) {
                console.warn('⚠️ Transcription failed, continuing with basic analysis:', error);
                return { status: 'skipped', reason: 'transcription_failed' };
            }
        }

        async function generateEmotionAnalysis(conversationFolder, transcriptionQuality = 'openai_fast') {
            console.log(`🎤 Starting transcription and analysis for ${conversationFolder} with quality: ${transcriptionQuality}`);
            
            try {
                // First, get the number of segments to set up progress tracking
                const segmentCountResponse = await fetch(`${apiBaseUrl}/conversations/${conversationFolder}/`);
                let totalSegments = 0;
                
                if (segmentCountResponse.ok) {
                    const folderListing = await segmentCountResponse.text();
                    const mp3Matches = folderListing.match(/\.mp3/g);
                    totalSegments = mp3Matches ? mp3Matches.length - 1 : 0; // Subtract 1 for original file
                }

                console.log(`📊 Found ${totalSegments} segments to process`);
                
                // Set up initial progress
                updateProgress(75, 'מתחיל תמלול וניתוח...', {
                    title: 'מכין לתמלול',
                    current: 0,
                    total: totalSegments,
                    currentItem: null
                });

                // Start the processing with a promise that tracks progress
                const result = await processWithDetailedProgress(conversationFolder, transcriptionQuality, totalSegments);
                
                console.log('✅ Transcription and analysis completed:', result);
                
                // Final progress update
                hideSubProgress();
                if (result.success) {
                    updateProgress(90, `✅ תמלול הושלם: ${result.transcribedCount} קטעים, ניתוח: ${result.analyzedCount} קטעים`);
                }
                
                return result;
                
            } catch (error) {
                console.error('❌ Error in generateEmotionAnalysis:', error);
                hideSubProgress();
                throw error;
            }
        }

        async function processWithDetailedProgress(conversationFolder, transcriptionQuality, totalSegments) {
            // Start the actual processing
            const processingPromise = fetch(`${apiBaseUrl}/api/auto-transcribe-and-analyze`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    conversationFolder,
                    quality: transcriptionQuality === 'whisper' ? 'whisper_accurate' : 'openai_fast'
                })
            });

            // Simulate detailed progress tracking based on estimated timing
            let currentSegment = 0;
            const progressInterval = setInterval(async () => {
                if (currentSegment < totalSegments) {
                    currentSegment++;
                    
                    // Update sub-progress
                    const subTaskData = {
                        title: 'מתמלל ומנתח',
                        current: currentSegment,
                        total: totalSegments,
                        currentItem: `קטע ${currentSegment.toString().padStart(3, '0')}.mp3`
                    };
                    
                    // Calculate overall progress (75% to 90% range for this step)
                    const stepProgress = (currentSegment / totalSegments) * 15; // 15% of total progress
                    updateProgress(75 + stepProgress, `מעבד קטע ${currentSegment} מתוך ${totalSegments}`, subTaskData);
                }
            }, 2000); // Update every 2 seconds (estimate ~2 seconds per segment)

            try {
                const response = await processingPromise;
                clearInterval(progressInterval);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Auto-transcription failed:', errorText);
                    throw new Error(`Auto-transcription failed: ${response.status} - ${errorText}`);
                }

                const result = await response.json();
                
                // Final sub-progress update
                if (result.success) {
                    updateSubProgress('הושלם!', totalSegments, totalSegments, '✅ כל הקטעים עובדו');
                    setTimeout(hideSubProgress, 1500); // Hide after 1.5 seconds
                }
                
                return result;
            } catch (error) {
                clearInterval(progressInterval);
                throw error;
            }
        }

        async function updateSystemConfiguration(conversationFolder, metadata) {
            console.log('🔄 Updating system configuration for:', conversationFolder, metadata);
            
            const response = await fetch(`${apiBaseUrl}/api/update-system-config`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    conversationFolder,
                    metadata
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('❌ System configuration update failed:', errorText);
                throw new Error(`System configuration update failed: ${response.status} ${response.statusText}`);
            }

            const result = await response.json();
            console.log('✅ System configuration updated successfully:', result);
            
            // Force refresh the main visualization page to show the new conversation
            if (window.opener) {
                window.opener.postMessage({
                    type: 'conversation-added',
                    conversationFolder: conversationFolder,
                    timestamp: Date.now()
                }, '*');
            }
            
            // Broadcast to other tabs
            if (typeof BroadcastChannel !== 'undefined') {
                const channel = new BroadcastChannel('conversation-sync');
                channel.postMessage({
                    type: 'conversation-added',
                    conversationFolder: conversationFolder,
                    timestamp: Date.now()
                });
                channel.close();
            }
            
            return result;
        }

        // Enhanced progress tracking
        let processStartTime = null;
        let lastProgressUpdate = null;
        let progressHistory = [];

        function updateProgress(percentage, message, subTaskData = null) {
            const now = Date.now();
            if (!processStartTime) processStartTime = now;
            
            // Update main progress
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const progressPercentageEl = document.getElementById('progress-percentage');
            const timeElapsedEl = document.getElementById('time-elapsed');
            const timeRemainingEl = document.getElementById('time-remaining');
            const progressSteps = document.getElementById('progress-steps');

            if (progressBar) progressBar.style.width = `${percentage}%`;
            if (progressText) progressText.textContent = message;
            if (progressPercentageEl) progressPercentageEl.textContent = `${Math.round(percentage)}%`;

            // Calculate and update time tracking
            const elapsedMs = now - processStartTime;
            const elapsedMinutes = Math.floor(elapsedMs / 60000);
            const elapsedSeconds = Math.floor((elapsedMs % 60000) / 1000);
            
            if (timeElapsedEl) {
                timeElapsedEl.textContent = `${elapsedMinutes.toString().padStart(2, '0')}:${elapsedSeconds.toString().padStart(2, '0')}`;
            }

            // Estimate remaining time based on progress
            if (percentage > 5 && timeRemainingEl) {
                const estimatedTotalMs = (elapsedMs / percentage) * 100;
                const remainingMs = estimatedTotalMs - elapsedMs;
                const remainingMinutes = Math.floor(remainingMs / 60000);
                const remainingSeconds = Math.floor((remainingMs % 60000) / 1000);
                
                if (remainingMs > 0) {
                    timeRemainingEl.textContent = `${remainingMinutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
                } else {
                    timeRemainingEl.textContent = '00:00';
                }
            }

            // Update sub-task progress if provided
            if (subTaskData) {
                updateSubProgress(subTaskData.title, subTaskData.current, subTaskData.total, subTaskData.currentItem);
            }

            // Add step to progress log with timestamp
            if (progressSteps && message) {
                const timeStr = `${elapsedMinutes.toString().padStart(2, '0')}:${elapsedSeconds.toString().padStart(2, '0')}`;
                const step = document.createElement('div');
                step.style.cssText = 'margin-bottom: 0.4rem; padding: 0.25rem; border-left: 3px solid #4caf50; padding-left: 0.5rem; background: rgba(76, 175, 80, 0.1);';
                step.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span><span style="color: #4caf50; font-weight: bold;">✓</span> ${message}</span>
                        <span style="color: #666; font-size: 0.75rem;">${timeStr}</span>
                    </div>
                `;
                progressSteps.appendChild(step);
                progressSteps.scrollTop = progressSteps.scrollHeight;
            }

            // Store progress history for better time estimation
            progressHistory.push({ time: now, percentage });
            if (progressHistory.length > 10) progressHistory.shift(); // Keep last 10 points

            lastProgressUpdate = now;
        }

        function updateSubProgress(title, current, total, currentItem = null) {
            const subContainer = document.getElementById('sub-progress-container');
            const subTitle = document.getElementById('sub-progress-title');
            const subCounter = document.getElementById('sub-progress-counter');
            const subBar = document.getElementById('sub-progress-bar');

            if (!subContainer || !subTitle || !subCounter || !subBar) return;

            // Show sub-progress container
            subContainer.style.display = 'block';

            // Update title and counter
            if (currentItem) {
                subTitle.textContent = `${title} - ${currentItem}`;
            } else {
                subTitle.textContent = title;
            }
            subCounter.textContent = `${current}/${total}`;

            // Update progress bar
            const percentage = total > 0 ? (current / total) * 100 : 0;
            subBar.style.width = `${percentage}%`;

            // Change color based on completion
            if (current === total) {
                subBar.style.background = '#28a745'; // Green when complete
            } else {
                subBar.style.background = '#17a2b8'; // Blue during progress
            }
        }

        function hideSubProgress() {
            const subContainer = document.getElementById('sub-progress-container');
            if (subContainer) {
                subContainer.style.display = 'none';
            }
        }

        function resetProgress() {
            processStartTime = null;
            lastProgressUpdate = null;
            progressHistory = [];
            
            const progressSteps = document.getElementById('progress-steps');
            if (progressSteps) {
                progressSteps.innerHTML = '';
            }
            
            hideSubProgress();
            updateProgress(0, 'מכין לעיבוד...');
        }

        function cancelUpload() {
            uploadedFile = null;
            processingInProgress = false;
            resetUploadForm();
            showStatus('העלאה בוטלה', 'info');
        }

        function resetUploadForm() {
            document.getElementById('upload-status').innerHTML = '';
            document.getElementById('processing-options').style.display = 'none';
            document.getElementById('processing-progress').style.display = 'none';
            document.getElementById('new-conversation-name').value = '';
            document.getElementById('conversation-type').value = 'general';
            document.getElementById('segment-length').value = '20';
            document.getElementById('transcription-quality').value = 'basic';
            document.getElementById('fileInput').value = '';
            document.getElementById('progress-steps').innerHTML = '';
        }

        async function refreshAfterUpload() {
            console.log('🔄 Refreshing after upload...');
            
            // Refresh conversations list
            await loadConversations();
            await loadConversationMetadata();
            displayMetadataConversations();
            
            // Notify main visualization about new conversation
            if (window.opener) {
                window.opener.postMessage({
                    type: 'conversation-added',
                    timestamp: Date.now()
                }, '*');
            }
            
            // Broadcast to other tabs
            if (typeof BroadcastChannel !== 'undefined') {
                const channel = new BroadcastChannel('conversation-sync');
                channel.postMessage({
                    type: 'conversation-added',
                    timestamp: Date.now()
                });
                channel.close();
            }
            
            // Force reload the main page to show new conversation
            try {
                const mainPage = window.opener || window.parent;
                if (mainPage && mainPage.location.href.includes('index.html')) {
                    console.log('🔄 Reloading main page to show new conversation...');
                    mainPage.location.reload();
                }
            } catch (e) {
                console.log('⚠️ Could not reload main page:', e.message);
            }
        }

        // ==================== END ENHANCED UPLOAD SYSTEM ====================

        // ==================== END METADATA MANAGEMENT ====================

        // ==================== VIDEO GENERATION FUNCTIONS ====================
        
        let videoGenerationInProgress = false;
        
        // Update duration value display
        document.addEventListener('DOMContentLoaded', () => {
            const durationSlider = document.getElementById('video-duration');
            const durationValue = document.getElementById('duration-value');
            
            if (durationSlider && durationValue) {
                durationSlider.addEventListener('input', (e) => {
                    durationValue.textContent = e.target.value;
                });
            }
        });

        async function generateAllVideos() {
            if (videoGenerationInProgress) {
                showStatus('ייצור וידאו כבר בתהליך', 'info');
                return;
            }

            // Get enhanced video settings
            const videoSettings = getEnhancedVideoSettings();
            
            // Check conversation selection
            const selectedConversation = document.getElementById('generation-conversation-select').value;
            
            let conversationsToProcess = [];
            
            if (selectedConversation === 'all' || !selectedConversation) {
                // Process all conversations
                if (!conversationsData || Object.keys(conversationsData).length === 0) {
                    await loadConversations();
                }

                if (!conversationsData || Object.keys(conversationsData).length === 0) {
                    showStatus('אין שיחות זמינות לייצור וידאו', 'error');
                    return;
                }
                
                conversationsToProcess = Object.keys(conversationsData);
            } else {
                // Process only selected conversation
                conversationsToProcess = [selectedConversation];
                
                // Make sure we have conversation data
                if (!conversationsData || Object.keys(conversationsData).length === 0) {
                    await loadConversations();
                }
            }

            videoGenerationInProgress = true;
            showVideoProgress();

            try {
                const totalConversations = conversationsToProcess.length;
                let completedCount = 0;

                const modeText = selectedConversation === 'all' || !selectedConversation ? 'כל השיחות' : 'שיחה נבחרת';
                updateVideoProgress(0, `מתחיל ייצור וידאו מתקדם עבור ${modeText}...`);

                for (const conversationFolder of conversationsToProcess) {
                    const conversationData = conversationsData[conversationFolder];
                    const displayName = conversationData?.metadata?.name || `שיחה ${conversationFolder.replace('convo', '')}`;
                    
                    updateVideoProgress(
                        (completedCount / totalConversations) * 100,
                        `מייצר וידאו מתקדם עבור ${displayName} (${completedCount + 1}/${totalConversations})`
                    );

                    try {
                        await generateEnhancedVideoForConversation(conversationFolder, videoSettings);
                        
                        completedCount++;
                        
                        // Add step to progress log
                        addVideoProgressStep(`✅ הושלם: ${displayName}`);
                        
                    } catch (error) {
                        console.error(`Error generating enhanced video for ${conversationFolder}:`, error);
                        addVideoProgressStep(`❌ נכשל: ${displayName} - ${error.message}`);
                    }
                }

                updateVideoProgress(100, '✅ ייצור הוידאו המתקדם הושלם!');
                showStatus(`הושלם ייצור וידאו מתקדם עבור ${completedCount} מתוך ${totalConversations} שיחות`, 'success');
                
                // Refresh video list
                await loadEnhancedVideoList();

            } catch (error) {
                console.error('Error in enhanced video generation:', error);
                showStatus(`שגיאה בייצור וידאו מתקדם: ${error.message}`, 'error');
            } finally {
                videoGenerationInProgress = false;
                setTimeout(() => {
                    hideVideoProgress();
                }, 3000);
            }
        }

        async function generateVideoForConversation(conversationFolder, options) {
            const response = await fetch(`${apiBaseUrl}/api/generate-video`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    conversationFolder,
                    options
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Video generation failed: ${response.status} - ${errorText}`);
            }

            return await response.json();
        }
        
        async function generateEnhancedVideoForConversation(conversationFolder, enhancedSettings) {
            const response = await fetch(`${apiBaseUrl}/api/generate-enhanced-video`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    conversation: conversationFolder,
                    ...enhancedSettings
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Enhanced video generation failed: ${response.status} - ${errorText}`);
            }

            return await response.json();
        }

        async function deleteAllVideos() {
            if (!confirm('⚠️ האם אתה בטוח שברצונך למחוק את כל קבצי הוידאו?\n\nפעולה זו לא ניתנת לביטול!')) {
                return;
            }

            try {
                showLoading('מוחק קבצי וידאו...');
                
                const response = await fetch(`${apiBaseUrl}/api/delete-all-videos`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error(`Delete failed: ${response.status}`);
                }

                const result = await response.json();
                showStatus(`נמחקו ${result.deletedCount} קבצי וידאו`, 'success');
                
                // Refresh video list
                await loadVideoList();
                
            } catch (error) {
                console.error('Error deleting videos:', error);
                showStatus(`שגיאה במחיקת וידאו: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        async function loadVideoList() {
            try {
                const response = await fetch(`${apiBaseUrl}/api/list-videos`);
                if (!response.ok) {
                    throw new Error(`Failed to load videos: ${response.status}`);
                }

                const videos = await response.json();
                displayVideoList(videos);
                
            } catch (error) {
                console.error('Error loading video list:', error);
                document.getElementById('video-files-container').innerHTML = 
                    '<p style="color: #999; text-align: center;">שגיאה בטעינת רשימת הוידאו</p>';
            }
        }

        function displayVideoList(videos) {
            const container = document.getElementById('video-files-container');
            
            if (!videos || videos.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center;">אין קבצי וידאו זמינים</p>';
                return;
            }

            container.innerHTML = videos.map(video => `
                <div style="background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 8px; padding: 1rem; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h4 style="margin: 0 0 0.5rem 0;">${video.conversationName}</h4>
                        <div style="font-size: 0.9rem; color: #666;">
                            📁 ${video.filename} | 
                            📊 ${video.fileSize} | 
                            🎬 ${video.quality}p ${video.fps}fps | 
                            ⏱️ ${video.duration}s
                        </div>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="previewVideo('${video.conversationFolder}')" class="btn btn-sm btn-primary">
                            <i class="material-icons">play_circle</i>
                            תצוגה מקדימה
                        </button>
                        <button onclick="downloadVideo('${video.conversationFolder}')" class="btn btn-sm btn-secondary">
                            <i class="material-icons">download</i>
                            הורד
                        </button>
                        <button onclick="deleteVideo('${video.conversationFolder}')" class="btn btn-sm btn-danger">
                            <i class="material-icons">delete</i>
                            מחק
                        </button>
                    </div>
                </div>
            `).join('');
        }

        async function previewVideo(conversationFolder) {
            try {
                const videoUrl = `${apiBaseUrl}/videos/${conversationFolder}.mp4`;
                
                // Create modal preview
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;
                
                modal.innerHTML = `
                    <div style="background: white; border-radius: 12px; padding: 2rem; max-width: 80vw; max-height: 80vh; position: relative;">
                        <button onclick="this.parentElement.parentElement.remove()" style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 24px; cursor: pointer;">×</button>
                        <h3 style="margin: 0 0 1rem 0;">תצוגה מקדימה - ${conversationFolder}</h3>
                        <video controls autoplay loop muted style="width: 100%; max-width: 600px; height: auto; border-radius: 8px;">
                            <source src="${videoUrl}" type="video/mp4">
                            הדפדפן שלך לא תומך בתצוגת וידאו
                        </video>
                    </div>
                `;
                
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                document.body.appendChild(modal);
                
            } catch (error) {
                console.error('Error previewing video:', error);
                showStatus(`שגיאה בתצוגה מקדימה: ${error.message}`, 'error');
            }
        }

        function downloadVideo(conversationFolder) {
            const videoUrl = `${apiBaseUrl}/videos/${conversationFolder}.mp4`;
            const link = document.createElement('a');
            link.href = videoUrl;
            link.download = `${conversationFolder}_visualization.mp4`;
            link.click();
        }

        async function deleteVideo(conversationFolder) {
            if (!confirm(`האם אתה בטוח שברצונך למחוק את הוידאו של ${conversationFolder}?`)) {
                return;
            }

            try {
                const response = await fetch(`${apiBaseUrl}/api/delete-video/${conversationFolder}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error(`Delete failed: ${response.status}`);
                }

                showStatus(`וידאו של ${conversationFolder} נמחק בהצלחה`, 'success');
                await loadVideoList();
                
            } catch (error) {
                console.error('Error deleting video:', error);
                showStatus(`שגיאה במחיקת וידאו: ${error.message}`, 'error');
            }
        }

        function showVideoProgress() {
            const progressDiv = document.getElementById('video-generation-progress');
            if (progressDiv) {
                progressDiv.style.display = 'block';
                document.getElementById('video-progress-steps').innerHTML = '';
            }
        }

        function hideVideoProgress() {
            const progressDiv = document.getElementById('video-generation-progress');
            if (progressDiv) {
                progressDiv.style.display = 'none';
            }
        }

        function updateVideoProgress(percentage, message) {
            const progressBar = document.getElementById('video-progress-bar');
            const progressText = document.getElementById('video-progress-text');

            if (progressBar) progressBar.style.width = `${percentage}%`;
            if (progressText) progressText.textContent = message;
        }

        function addVideoProgressStep(message) {
            const stepsContainer = document.getElementById('video-progress-steps');
            if (stepsContainer) {
                const step = document.createElement('div');
                step.style.cssText = 'font-size: 0.9rem; color: #666; margin-bottom: 0.25rem;';
                step.textContent = message;
                stepsContainer.appendChild(step);
                stepsContainer.scrollTop = stepsContainer.scrollHeight;
            }
        }

        // Load video list when videos tab is activated
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'tab-switched' && event.data.tab === 'videos') {
                loadVideoList();
                checkVideoStatus();
            }
        });

        async function checkVideoStatus() {
            try {
                const response = await fetch(`${apiBaseUrl}/api/video-status`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const status = await response.json();
                displayVideoStatus(status);

            } catch (error) {
                console.error('Error checking video status:', error);
                document.getElementById('video-status-details').innerHTML = 
                    '<span style="color: #f44336;">❌ שגיאה בבדיקת סטטוס</span>';
            }
        }

        // ==================== ENHANCED VIDEO MANAGEMENT FUNCTIONS ====================
        
        let videoManagementData = {
            conversations: [],
            videos: [],
            selectedVideos: []
        };
        
        function updateDurationDisplay(value) {
            document.getElementById('duration-display').textContent = `${value} שניות`;
        }
        
        // ==================== FRAME SIZE & CROP AREA FUNCTIONS ====================
        
        const frameSizePresets = {
            'full': { width: 1920, height: 1080, aspectRatio: '16:9' },
            '16:9': { width: 1920, height: 1080, aspectRatio: '16:9' },
            '4:3': { width: 1440, height: 1080, aspectRatio: '4:3' },
            '1:1': { width: 1080, height: 1080, aspectRatio: '1:1' },
            '9:16': { width: 1080, height: 1920, aspectRatio: '9:16' },
            '21:9': { width: 2560, height: 1080, aspectRatio: '21:9' }
        };
        
        function updateFrameSizeFields() {
            const preset = document.getElementById('frame-size-preset').value;
            const customDiv = document.getElementById('custom-dimensions');
            
            if (preset === 'custom') {
                customDiv.style.display = 'block';
            } else {
                customDiv.style.display = 'none';
                
                if (frameSizePresets[preset]) {
                    const { width, height } = frameSizePresets[preset];
                    document.getElementById('custom-width').value = width;
                    document.getElementById('custom-height').value = height;
                    
                    // Update crop area max values
                    updateCropLimits(width, height);
                }
            }
            
            // Show frame size info
            updateFrameSizeDisplay();
        }
        
        function updateCropLimits(maxWidth, maxHeight) {
            document.getElementById('crop-x').max = maxWidth;
            document.getElementById('crop-y').max = maxHeight;
            document.getElementById('crop-width').max = maxWidth;
            document.getElementById('crop-height').max = maxHeight;
            
            // Reset crop values if they exceed new limits
            const cropX = parseInt(document.getElementById('crop-x').value);
            const cropY = parseInt(document.getElementById('crop-y').value);
            const cropWidth = parseInt(document.getElementById('crop-width').value);
            const cropHeight = parseInt(document.getElementById('crop-height').value);
            
            if (cropX >= maxWidth) document.getElementById('crop-x').value = 0;
            if (cropY >= maxHeight) document.getElementById('crop-y').value = 0;
            if (cropWidth > maxWidth) document.getElementById('crop-width').value = maxWidth;
            if (cropHeight > maxHeight) document.getElementById('crop-height').value = maxHeight;
        }
        
        function updateFrameSizeDisplay() {
            const preset = document.getElementById('frame-size-preset').value;
            let displayText = '';
            
            if (preset === 'custom') {
                const width = document.getElementById('custom-width').value;
                const height = document.getElementById('custom-height').value;
                displayText = `${width}x${height} (מותאם אישית)`;
            } else if (frameSizePresets[preset]) {
                const { width, height, aspectRatio } = frameSizePresets[preset];
                displayText = `${width}x${height} (${aspectRatio})`;
            }
            
            // Update any display elements (can be added later)
            console.log(`Frame size: ${displayText}`);
        }
        
        function toggleCropControls() {
            const isEnabled = document.getElementById('enable-crop').checked;
            const controls = document.getElementById('crop-controls');
            controls.style.display = isEnabled ? 'block' : 'none';
            
            if (isEnabled) {
                resetCropArea();
            }
        }
        
        function previewCropArea() {
            const cropData = getCropAreaData();
            
            // Create preview modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10000; display: flex;
                align-items: center; justify-content: center; flex-direction: column;
            `;
            
            const preview = document.createElement('div');
            preview.style.cssText = `
                background: white; padding: 2rem; border-radius: 12px;
                max-width: 80%; max-height: 80%; overflow: auto;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            `;
            
            preview.innerHTML = `
                <h3 style="margin: 0 0 1rem 0; text-align: center;">תצוגה מקדימה - אזור הקלטה</h3>
                <div style="background: #f0f0f0; border: 2px solid #ddd; position: relative; margin: 1rem 0;">
                    <div style="
                        position: absolute; 
                        left: ${(cropData.x / cropData.frameWidth) * 100}%; 
                        top: ${(cropData.y / cropData.frameHeight) * 100}%;
                        width: ${(cropData.width / cropData.frameWidth) * 100}%; 
                        height: ${(cropData.height / cropData.frameHeight) * 100}%;
                        background: rgba(0, 123, 255, 0.3); 
                        border: 2px solid #007bff;
                        box-sizing: border-box;
                    "></div>
                    <div style="
                        width: 400px; height: ${400 * (cropData.frameHeight / cropData.frameWidth)}px;
                        background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                                    linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                                    linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
                                    linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
                        background-size: 20px 20px;
                        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
                    "></div>
                </div>
                <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <strong>פרטי אזור הקלטה:</strong><br>
                    מיקום: (${cropData.x}, ${cropData.y})<br>
                    גודל: ${cropData.width} × ${cropData.height}<br>
                    מסגרת: ${cropData.frameWidth} × ${cropData.frameHeight}<br>
                    יחס גובה-רוחב: ${(cropData.width / cropData.height).toFixed(2)}:1
                </div>
                <div style="text-align: center;">
                    <button onclick="this.closest('.preview-modal').remove()" class="btn btn-primary">סגור</button>
                </div>
            `;
            
            modal.className = 'preview-modal';
            modal.appendChild(preview);
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        function centerCropArea() {
            const frameData = getFrameSizeData();
            const cropWidth = parseInt(document.getElementById('crop-width').value) || frameData.width / 2;
            const cropHeight = parseInt(document.getElementById('crop-height').value) || frameData.height / 2;
            
            const centerX = Math.max(0, (frameData.width - cropWidth) / 2);
            const centerY = Math.max(0, (frameData.height - cropHeight) / 2);
            
            document.getElementById('crop-x').value = Math.floor(centerX);
            document.getElementById('crop-y').value = Math.floor(centerY);
            document.getElementById('crop-width').value = cropWidth;
            document.getElementById('crop-height').value = cropHeight;
            
            showStatus('אזור הקלטה ממורכז', 'success');
        }
        
        function resetCropArea() {
            const frameData = getFrameSizeData();
            
            document.getElementById('crop-x').value = 0;
            document.getElementById('crop-y').value = 0;
            document.getElementById('crop-width').value = frameData.width;
            document.getElementById('crop-height').value = frameData.height;
            
            showStatus('אזור הקלטה אופס', 'info');
        }
        
        function getFrameSizeData() {
            const preset = document.getElementById('frame-size-preset').value;
            
            if (preset === 'custom') {
                return {
                    width: parseInt(document.getElementById('custom-width').value) || 1920,
                    height: parseInt(document.getElementById('custom-height').value) || 1080
                };
            } else if (frameSizePresets[preset]) {
                return frameSizePresets[preset];
            }
            
            return { width: 1920, height: 1080 }; // Default
        }
        
        function getCropAreaData() {
            const frameData = getFrameSizeData();
            const isCustomCrop = document.getElementById('enable-crop').checked;
            
            if (!isCustomCrop) {
                return {
                    x: 0,
                    y: 0,
                    width: frameData.width,
                    height: frameData.height,
                    frameWidth: frameData.width,
                    frameHeight: frameData.height
                };
            }
            
            return {
                x: parseInt(document.getElementById('crop-x').value) || 0,
                y: parseInt(document.getElementById('crop-y').value) || 0,
                width: parseInt(document.getElementById('crop-width').value) || frameData.width,
                height: parseInt(document.getElementById('crop-height').value) || frameData.height,
                frameWidth: frameData.width,
                frameHeight: frameData.height
            };
        }
        
        function getAdvancedVideoSettings() {
            return {
                smoothMotion: document.getElementById('enable-smooth-motion').checked,
                backgroundBlur: document.getElementById('enable-background-blur').checked,
                fadeEffects: document.getElementById('enable-fade-effects').checked,
                audioSync: document.getElementById('enable-audio-sync').checked
            };
        }
        
        async function handleCustomVideoUpload(files) {
            const uploadArea = document.getElementById('custom-upload-area');
            const maxSize = 100 * 1024 * 1024; // 100MB
            
            for (let file of files) {
                if (file.size > maxSize) {
                    showStatus(`קובץ ${file.name} גדול מדי (מעל 100MB)`, 'error');
                    continue;
                }
                
                if (!file.type.startsWith('video/')) {
                    showStatus(`קובץ ${file.name} אינו קובץ וידאו תקין`, 'error');
                    continue;
                }
                
                await uploadCustomVideo(file);
            }
        }
        
        async function uploadCustomVideo(file) {
            try {
                // Get selected conversation from dropdown
                let conversationId = document.getElementById('upload-conversation-select').value;
                
                // If no conversation selected, show selection dialog
                if (!conversationId) {
                    conversationId = await showConversationSelectionDialog();
                    if (!conversationId) return;
                }
                
                const formData = new FormData();
                formData.append('video', file);
                formData.append('conversation', conversationId);
                formData.append('source', 'custom');
                
                showStatus(`מעלה ${file.name} עבור ${conversationId}...`, 'info');
                
                const response = await fetch(`${apiBaseUrl}/api/upload-custom-video`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                showStatus(`וידאו ${file.name} הועלה בהצלחה עבור ${conversationId}`, 'success');
                
                // Refresh video list
                await loadEnhancedVideoList();
                
            } catch (error) {
                console.error('Error uploading custom video:', error);
                showStatus(`שגיאה בהעלאת ${file.name}: ${error.message}`, 'error');
            }
        }
        
        async function showConversationSelectionDialog() {
            return new Promise((resolve) => {
                // Create modal dialog
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.5); z-index: 10000; display: flex;
                    align-items: center; justify-content: center;
                `;
                
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: white; padding: 2rem; border-radius: 12px;
                    max-width: 500px; width: 90%; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;
                
                dialog.innerHTML = `
                    <h3 style="margin: 0 0 1rem 0;">בחר שיחה עבור הוידאו</h3>
                    <select id="conversation-select" style="width: 100%; padding: 0.75rem; margin-bottom: 1rem; border: 1px solid #ddd; border-radius: 4px;">
                        ${videoManagementData.conversations.map(conv => 
                            `<option value="${conv.id}">${conv.name || conv.id}</option>`
                        ).join('')}
                    </select>
                    <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                        <button onclick="this.closest('.modal').remove(); resolve(null);" class="btn btn-secondary">ביטול</button>
                        <button onclick="
                            const selected = document.getElementById('conversation-select').value;
                            this.closest('.modal').remove();
                            resolve(selected);
                        " class="btn btn-primary">אישור</button>
                    </div>
                `;
                
                modal.className = 'modal';
                modal.appendChild(dialog);
                document.body.appendChild(modal);
                
                // Handle button clicks with proper scope
                modal.querySelectorAll('button').forEach(btn => {
                    btn.onclick = function() {
                        const isConfirm = this.classList.contains('btn-primary');
                        const selected = isConfirm ? document.getElementById('conversation-select').value : null;
                        modal.remove();
                        resolve(selected);
                    };
                });
            });
        }
        
        async function loadEnhancedVideoList() {
            try {
                // Load conversations
                const convResponse = await fetch(`${apiBaseUrl}/api/conversations`);
                if (convResponse.ok) {
                    const data = await convResponse.json();
                    // Handle different API response formats
                    if (data.conversations && Array.isArray(data.conversations)) {
                        // API returns {conversations: [...]}
                        const convList = data.conversations;
                        const conversations = {};
                        convList.forEach(convId => {
                            conversations[convId] = {
                                metadata: { name: `שיחה ${convId.replace('convo', '')}` }
                            };
                        });
                        videoManagementData.conversations = conversations;
                    } else if (typeof data === 'object') {
                        // API returns conversation object directly
                        videoManagementData.conversations = data;
                    }
                } else {
                    console.warn('Could not load conversations, using empty list');
                    videoManagementData.conversations = {};
                }
                
                // Load existing videos
                const videosResponse = await fetch(`${apiBaseUrl}/api/videos`);
                if (videosResponse.ok) {
                    videoManagementData.videos = await videosResponse.json();
                } else {
                    console.warn('Could not load videos, using empty list');
                    videoManagementData.videos = [];
                }
                
                // Populate conversation select dropdowns
                await populateConversationSelects();
                
                renderVideoManagementGrid();
                
            } catch (error) {
                console.error('Error loading video management data:', error);
                showStatus('שגיאה בטעינת נתוני וידאו', 'error');
                
                // Initialize with empty data to allow UI to render
                videoManagementData.conversations = {};
                videoManagementData.videos = [];
                await populateConversationSelects();
                renderVideoManagementGrid();
            }
        }
        
        async function populateConversationSelects() {
            const uploadSelect = document.getElementById('upload-conversation-select');
            const generationSelect = document.getElementById('generation-conversation-select');
            
            if (!uploadSelect || !generationSelect) return;
            
            // Clear existing options except defaults
            uploadSelect.innerHTML = '<option value="">-- בחר שיחה --</option>';
            generationSelect.innerHTML = '<option value="all">כל השיחות</option><option value="">-- בחר שיחה ספציפית --</option>';
            
            // Get conversations
            let conversations = videoManagementData.conversations || {};
            
            // Try to load conversations if empty
            if (Object.keys(conversations).length === 0) {
                try {
                    const response = await fetch(`${apiBaseUrl}/api/conversations`);
                    if (response.ok) {
                        const data = await response.json();
                        // Handle different API response formats
                        if (data.conversations && Array.isArray(data.conversations)) {
                            // API returns {conversations: [...]}
                            const convList = data.conversations;
                            conversations = {};
                            convList.forEach(convId => {
                                conversations[convId] = {
                                    metadata: { name: `שיחה ${convId.replace('convo', '')}` }
                                };
                            });
                        } else if (typeof data === 'object') {
                            // API returns conversation object directly
                            conversations = data;
                        }
                        videoManagementData.conversations = conversations;
                    }
                } catch (error) {
                    console.warn('Could not load conversations for selects');
                }
            }
            
            let conversationList = [];
            if (Object.keys(conversations).length > 0) {
                conversationList = Object.keys(conversations);
            } else {
                // Fallback to known conversations
                conversationList = ['convo1', 'convo2', 'convo3', 'convo4', 'convo5', 'convo6', 'convo7', 'convo8', 'convo10', 'convo12', 'convo13'];
            }
            
            // Populate both selects
            conversationList.forEach(convId => {
                const convData = conversations[convId];
                let displayName;
                
                // Better display name logic
                if (convData && convData.metadata && convData.metadata.name) {
                    displayName = convData.metadata.name;
                } else if (convId.startsWith('convo')) {
                    displayName = `שיחה ${convId.replace('convo', '')}`;
                } else {
                    displayName = convId;
                }
                
                // Upload select
                const uploadOption = document.createElement('option');
                uploadOption.value = convId;
                uploadOption.textContent = displayName;
                uploadSelect.appendChild(uploadOption);
                
                // Generation select
                const generationOption = document.createElement('option');
                generationOption.value = convId;
                generationOption.textContent = displayName;
                generationSelect.appendChild(generationOption);
            });
        }
        
        function renderVideoManagementGrid() {
            const grid = document.getElementById('video-management-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            // Handle both array and object formats for conversations
            let conversationList = [];
            if (Array.isArray(videoManagementData.conversations)) {
                conversationList = videoManagementData.conversations;
            } else if (typeof videoManagementData.conversations === 'object') {
                conversationList = Object.keys(videoManagementData.conversations).map(key => ({
                    id: key,
                    name: videoManagementData.conversations[key].metadata?.name || key
                }));
            }
            
            conversationList.forEach(conv => {
                const convId = conv.id || conv;
                const existingVideo = videoManagementData.videos.find(v => 
                    v.conversationFolder === convId || v.conversation === convId
                );
                const card = createVideoManagementCard(conv, existingVideo);
                grid.appendChild(card);
            });
            
            if (conversationList.length === 0) {
                grid.innerHTML = '<div style="text-align: center; color: #666; padding: 2rem;">אין שיחות זמינות</div>';
            }
        }
        
        function createVideoManagementCard(conversation, existingVideo) {
            const card = document.createElement('div');
            card.className = 'video-management-card';
            card.style.cssText = `
                border: 1px solid #e9ecef; border-radius: 12px; padding: 1rem;
                background: white; transition: all 0.3s ease;
                position: relative; overflow: hidden;
            `;
            
            const hasVideo = !!existingVideo;
            const isCustom = existingVideo?.source === 'custom';
            const statusColor = hasVideo ? (isCustom ? '#f39c12' : '#28a745') : '#dc3545';
            const statusText = hasVideo ? (isCustom ? 'מותאם אישית' : 'מערכת') : 'חסר';
            
            card.innerHTML = `
                <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem;">
                    <input type="checkbox" class="video-select" data-conversation="${conversation.id}" 
                           style="transform: scale(1.2);">
                    <h4 style="margin: 0; flex: 1; color: #333;">${conversation.name || conversation.id}</h4>
                    <span style="
                        background: ${statusColor}; color: white; padding: 0.25rem 0.75rem;
                        border-radius: 12px; font-size: 0.8rem; font-weight: 500;
                    ">${statusText}</span>
                </div>
                
                ${hasVideo ? `
                    <div style="margin-bottom: 1rem;">
                        <video controls style="width: 100%; max-height: 150px; border-radius: 8px;">
                            <source src="${existingVideo.url || `${apiBaseUrl}/videos/${conversation.id || conversation}.mp4`}" type="video/mp4">
                        </video>
                        <div style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
                            <div>📊 גודל: ${formatFileSize(existingVideo.size || 0)}</div>
                            <div>⏱️ משך: ${existingVideo.duration || 'לא ידוע'}</div>
                            <div>📅 נוצר: ${formatDate(existingVideo.created)}</div>
                        </div>
                    </div>
                ` : `
                    <div style="
                        background: #f8f9fa; border: 2px dashed #dee2e6; 
                        border-radius: 8px; padding: 2rem; text-align: center;
                        color: #6c757d; margin-bottom: 1rem;
                    ">
                        <i class="material-icons" style="font-size: 2rem; margin-bottom: 0.5rem;">video_call</i>
                        <div>אין וידאו</div>
                    </div>
                `}
                
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                    ${hasVideo ? `
                        <button onclick="downloadVideo('${conversation.id}')" class="btn btn-sm btn-success" style="flex: 1;">
                            <i class="material-icons" style="font-size: 1rem;">download</i>
                            הורד
                        </button>
                        <button onclick="replaceVideo('${conversation.id}')" class="btn btn-sm btn-secondary">
                            <i class="material-icons" style="font-size: 1rem;">swap_horiz</i>
                            החלף
                        </button>
                        <button onclick="deleteVideo('${conversation.id}')" class="btn btn-sm btn-danger">
                            <i class="material-icons" style="font-size: 1rem;">delete</i>
                            מחק
                        </button>
                    ` : `
                        <button onclick="generateSingleVideo('${conversation.id}')" class="btn btn-sm btn-primary" style="flex: 1;">
                            <i class="material-icons" style="font-size: 1rem;">smart_display</i>
                            צור מהמערכת
                        </button>
                        <button onclick="uploadForConversation('${conversation.id}')" class="btn btn-sm btn-secondary">
                            <i class="material-icons" style="font-size: 1rem;">cloud_upload</i>
                            העלה
                        </button>
                    `}
                </div>
            `;
            
            return card;
        }
        
        // Helper functions
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function formatDate(dateString) {
            if (!dateString) return 'לא ידוע';
            return new Date(dateString).toLocaleDateString('he-IL');
        }
        
        // Enhanced Video management functions
        async function generateSingleVideo(conversationId) {
            try {
                const videoSettings = getEnhancedVideoSettings();
                
                showStatus(`יוצר וידאו מתקדם עבור ${conversationId}...`, 'info');
                
                const response = await fetch(`${apiBaseUrl}/api/generate-enhanced-video`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversation: conversationId,
                        ...videoSettings
                    })
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const result = await response.json();
                showStatus(`וידאו מתקדם עבור ${conversationId} נוצר בהצלחה`, 'success');
                await loadEnhancedVideoList();
                
            } catch (error) {
                console.error('Error generating enhanced video:', error);
                showStatus(`שגיאה ביצירת וידאו עבור ${conversationId}`, 'error');
            }
        }
        
        function getEnhancedVideoSettings() {
            const frameData = getFrameSizeData();
            const cropData = getCropAreaData();
            const advancedSettings = getAdvancedVideoSettings();
            
            return {
                // Basic video settings
                quality: parseInt(document.getElementById('video-quality').value),
                duration: parseInt(document.getElementById('video-duration').value),
                fps: parseInt(document.getElementById('video-fps').value),
                
                // Frame and crop settings
                frameSize: {
                    width: frameData.width,
                    height: frameData.height,
                    preset: document.getElementById('frame-size-preset').value
                },
                
                cropArea: {
                    enabled: document.getElementById('enable-crop').checked,
                    x: cropData.x,
                    y: cropData.y,
                    width: cropData.width,
                    height: cropData.height
                },
                
                // Advanced options
                advancedOptions: advancedSettings,
                
                // Background color (ensure it matches current setting)
                backgroundColor: '#f7f9f3'
            };
        }
        
        // ==================== VISUAL CONVERSATION SELECTION SYSTEM ====================
        
        function openConversationVisualSelector(mode) {
            console.log(`🎯 Opening visual conversation selector for mode: ${mode}`);
            
            // Create fullscreen modal for visual conversation selection
            const modal = document.createElement('div');
            modal.id = 'conversation-visual-selector';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.9); z-index: 10000; display: flex;
                flex-direction: column; padding: 2rem; box-sizing: border-box;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 12px; height: 100%; display: flex; flex-direction: column; overflow: hidden;">
                    <!-- Header -->
                    <div style="padding: 1.5rem; border-bottom: 1px solid #ddd; display: flex; justify-content: space-between; align-items: center;">
                        <h2 style="margin: 0; color: #333;">
                            <i class="material-icons" style="vertical-align: middle; margin-left: 0.5rem;">visibility</i>
                            בחירה ויזואלית של שיחה
                        </h2>
                        <button onclick="closeConversationVisualSelector()" style="background: #f44336; color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer;">
                            <i class="material-icons">close</i>
                        </button>
                    </div>
                    
                    <!-- Instructions -->
                    <div style="padding: 1rem; background: #f8f9fa; border-bottom: 1px solid #ddd;">
                        <p style="margin: 0; color: #666; font-size: 0.9rem;">
                            <i class="material-icons" style="font-size: 1rem; vertical-align: middle; color: #2196f3;">info</i>
                            לחץ על כל שיחה לראות תצוגה מקדימה ולבחור אותה
                        </p>
                    </div>
                    
                    <!-- Loading -->
                    <div id="conversation-loading" style="flex: 1; display: flex; align-items: center; justify-content: center;">
                        <div style="text-align: center; color: #666;">
                            <i class="material-icons" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5; animation: spin 2s linear infinite;">refresh</i>
                            <p>טוען שיחות...</p>
                        </div>
                    </div>
                    
                    <!-- Conversation Grid -->
                    <div id="conversation-grid-container" style="flex: 1; padding: 1.5rem; overflow-y: auto; display: none;">
                        <div id="visual-conversation-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 1.5rem;">
                            <!-- Conversation cards will be populated here -->
                        </div>
                    </div>
                    
                    <!-- Footer -->
                    <div style="padding: 1rem; border-top: 1px solid #ddd; text-align: center;">
                        <button onclick="closeConversationVisualSelector()" class="btn btn-secondary">
                            ביטול
                        </button>
                    </div>
                </div>
                
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
            
            document.body.appendChild(modal);
            
            // Load conversations asynchronously
            loadVisualConversationGrid(mode).then(() => {
                const loading = document.getElementById('conversation-loading');
                const container = document.getElementById('conversation-grid-container');
                if (loading) loading.style.display = 'none';
                if (container) container.style.display = 'block';
            }).catch(error => {
                console.error('Error loading conversation grid:', error);
                const loading = document.getElementById('conversation-loading');
                if (loading) {
                    loading.innerHTML = `
                        <div style="text-align: center; color: #f44336;">
                            <i class="material-icons" style="font-size: 3rem; margin-bottom: 1rem;">error</i>
                            <p>שגיאה בטעינת שיחות</p>
                        </div>
                    `;
                }
            });
        }
        
        async function loadVisualConversationGrid(mode) {
            const grid = document.getElementById('visual-conversation-grid');
            if (!grid) return;
            
            // Get conversations data
            let conversations = videoManagementData.conversations || {};
            let conversationList = [];
            
            // Try to load conversations if empty
            if (Object.keys(conversations).length === 0) {
                console.log('📡 Loading conversations from API...');
                try {
                    const response = await fetch(`${apiBaseUrl}/api/conversations`);
                    if (response.ok) {
                        const data = await response.json();
                        // Handle different API response formats
                        if (data.conversations && Array.isArray(data.conversations)) {
                            // API returns {conversations: [...]}
                            const convList = data.conversations;
                            conversations = {};
                            convList.forEach(convId => {
                                conversations[convId] = {
                                    metadata: { name: `שיחה ${convId.replace('convo', '')}` }
                                };
                            });
                        } else if (typeof data === 'object') {
                            // API returns conversation object directly
                            conversations = data;
                        }
                        videoManagementData.conversations = conversations;
                        console.log('✅ Loaded conversations:', Object.keys(conversations));
                    } else {
                        console.warn('❌ API response not ok:', response.status);
                    }
                } catch (error) {
                    console.warn('❌ Could not load conversations for visual grid:', error);
                }
            } else {
                console.log('📋 Using cached conversations:', Object.keys(conversations));
            }
            
            // Create conversation list
            if (Object.keys(conversations).length > 0) {
                conversationList = Object.keys(conversations);
            } else {
                // Fallback to known conversations
                conversationList = ['convo1', 'convo2', 'convo3', 'convo4', 'convo5', 'convo6', 'convo7', 'convo8', 'convo10', 'convo12', 'convo13'];
            }
            
            grid.innerHTML = '';
            
            // Add "All Conversations" option for generation mode
            if (mode === 'generation') {
                const allCard = document.createElement('div');
                allCard.className = 'visual-conversation-card';
                allCard.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    border: 2px solid #667eea;
                    border-radius: 12px;
                    padding: 1rem;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    position: relative;
                    overflow: hidden;
                    text-align: center;
                `;
                
                allCard.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; min-height: 200px;">
                        <i class="material-icons" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.9;">video_library</i>
                        <h4 style="margin: 0 0 0.5rem 0; color: white;">כל השיחות</h4>
                        <p style="margin: 0 0 1rem 0; color: rgba(255,255,255,0.8); font-size: 0.8rem;">צור וידאו לכל השיחות</p>
                        <button onclick="selectConversationFromVisual('all', 'כל השיחות', '${mode}')" class="btn" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); width: 100%;">
                            <i class="material-icons" style="font-size: 1rem; vertical-align: middle;">check</i>
                            בחר כל השיחות
                        </button>
                    </div>
                `;
                
                allCard.addEventListener('mouseenter', () => {
                    allCard.style.transform = 'scale(1.02)';
                    allCard.style.boxShadow = '0 8px 25px rgba(102, 126, 234, 0.4)';
                });
                
                allCard.addEventListener('mouseleave', () => {
                    allCard.style.transform = 'scale(1)';
                    allCard.style.boxShadow = 'none';
                });
                
                grid.appendChild(allCard);
            }
            
            conversationList.forEach(convId => {
                const convData = conversations[convId];
                let displayName;
                
                // Better display name logic
                if (convData && convData.metadata && convData.metadata.name) {
                    displayName = convData.metadata.name;
                } else if (convId.startsWith('convo')) {
                    displayName = `שיחה ${convId.replace('convo', '')}`;
                } else {
                    displayName = convId;
                }
                
                const card = document.createElement('div');
                card.className = 'visual-conversation-card';
                card.style.cssText = `
                    background: white;
                    border: 2px solid #ddd;
                    border-radius: 12px;
                    padding: 1rem;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    position: relative;
                    overflow: hidden;
                `;
                
                card.innerHTML = `
                    <div style="text-align: center; margin-bottom: 1rem;">
                        <h4 style="margin: 0 0 0.5rem 0; color: #333;">${displayName}</h4>
                        <p style="margin: 0; color: #666; font-size: 0.8rem;">${convId}</p>
                    </div>
                    
                    <!-- Live Preview Iframe -->
                    <div style="position: relative; width: 100%; height: 150px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; background: #f5f5f5;">
                        <iframe 
                            src="visualization.html?conversation=${convId}&static=true&scale=0.3&hideControls=true"
                            style="width: 333%; height: 333%; transform: scale(0.3); transform-origin: 0 0; border: none;"
                            scrolling="no">
                        </iframe>
                    </div>
                    
                    <div style="margin-top: 1rem; text-align: center;">
                        <button onclick="selectConversationFromVisual('${convId}', '${displayName.replace(/'/g, "\\'")}', '${mode}')" class="btn btn-primary" style="width: 100%;">
                            <i class="material-icons" style="font-size: 1rem; vertical-align: middle;">check</i>
                            בחר שיחה זו
                        </button>
                    </div>
                `;
                
                // Add hover effects
                card.addEventListener('mouseenter', () => {
                    card.style.borderColor = '#2196f3';
                    card.style.boxShadow = '0 4px 12px rgba(33, 150, 243, 0.3)';
                });
                
                card.addEventListener('mouseleave', () => {
                    card.style.borderColor = '#ddd';
                    card.style.boxShadow = 'none';
                });
                
                grid.appendChild(card);
            });
            
            // Add loading message if no conversations found
            if (conversationList.length === 0) {
                grid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 2rem; color: #666;">
                        <i class="material-icons" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5;">chat</i>
                        <p>לא נמצאו שיחות זמינות</p>
                    </div>
                `;
            }
        }
        
        function selectConversationFromVisual(convId, displayName, mode) {
            // Ensure displayName is not undefined
            if (!displayName || displayName === 'undefined') {
                if (convId === 'all') {
                    displayName = 'כל השיחות';
                } else if (convId && convId.startsWith('convo')) {
                    displayName = `שיחה ${convId.replace('convo', '')}`;
                } else {
                    displayName = convId || 'שיחה לא ידועה';
                }
            }
            
            if (mode === 'upload') {
                // Update upload conversation selection
                document.getElementById('upload-conversation-select').value = convId;
                document.getElementById('selected-conversation-name').textContent = displayName;
                document.getElementById('selected-conversation-info').style.display = 'block';
            } else if (mode === 'generation') {
                // Update generation conversation selection
                document.getElementById('generation-conversation-select').value = convId;
                document.getElementById('generation-conversation-name').textContent = displayName;
                document.getElementById('generation-conversation-info').style.display = 'block';
            } else if (mode === 'editor') {
                // Update editor tab conversation selection - call the original selectConversation function
                // We need to use a different approach since we already have a selectConversation function
                setTimeout(() => {
                    // Call the original editor selectConversation function
                    if (typeof selectConversationImmediate === 'function') {
                        selectConversationImmediate(convId);
                    } else {
                        console.warn('selectConversationImmediate function not found');
                    }
                }, 100);
            }
            
            closeConversationVisualSelector();
            showStatus(`נבחרה שיחה: ${displayName}`, 'success');
        }
        
        function closeConversationVisualSelector() {
            const modal = document.getElementById('conversation-visual-selector');
            if (modal) {
                modal.remove();
            }
        }
        
        // ==================== VISUAL CROP SELECTOR (macOS style) ====================
        
        function openVisualCropSelector() {
            // Get selected conversation
            const selectedConv = document.getElementById('generation-conversation-select').value;
            if (!selectedConv || selectedConv === 'all') {
                showStatus('בחר שיחה ספציפית תחילה', 'error');
                return;
            }
            
            // Create fullscreen crop selector
            const modal = document.createElement('div');
            modal.id = 'visual-crop-selector';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10001; cursor: crosshair;
                user-select: none;
            `;
            
            // Create the visualization iframe as background
            const iframe = document.createElement('iframe');
            iframe.src = `visualization.html?conversation=${selectedConv}&static=true&hideControls=true`;
            iframe.style.cssText = `
                position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                border: none; pointer-events: none;
            `;
            
            // Create crop overlay
            const cropOverlay = document.createElement('div');
            cropOverlay.id = 'crop-overlay';
            cropOverlay.style.cssText = `
                position: absolute; border: 2px solid #2196f3; background: rgba(33, 150, 243, 0.1);
                display: none; pointer-events: none;
            `;
            
            // Create instructions
            const instructions = document.createElement('div');
            instructions.style.cssText = `
                position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
                background: rgba(0,0,0,0.8); color: white; padding: 1rem 2rem;
                border-radius: 8px; text-align: center; z-index: 10002;
            `;
            instructions.innerHTML = `
                <h3 style="margin: 0 0 0.5rem 0;">חיתוך ויזואלי - סגנון macOS</h3>
                <p style="margin: 0; font-size: 0.9rem;">גרור לבחירת אזור הקלטה • ESC לביטול • Enter לאישור</p>
            `;
            
            // Create control panel
            const controlPanel = document.createElement('div');
            controlPanel.style.cssText = `
                position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                background: rgba(0,0,0,0.8); color: white; padding: 1rem 2rem;
                border-radius: 8px; display: flex; gap: 1rem; align-items: center;
            `;
            controlPanel.innerHTML = `
                <div style="font-size: 0.9rem;">
                    אזור: <span id="crop-dimensions">0 × 0</span> |
                    מיקום: <span id="crop-position">0, 0</span>
                </div>
                <button onclick="applyCropSelection()" class="btn btn-success" style="margin: 0;">
                    <i class="material-icons" style="font-size: 1rem; vertical-align: middle;">check</i>
                    אישור
                </button>
                <button onclick="cancelCropSelection()" class="btn btn-danger" style="margin: 0;">
                    <i class="material-icons" style="font-size: 1rem; vertical-align: middle;">close</i>
                    ביטול
                </button>
            `;
            
            modal.appendChild(iframe);
            modal.appendChild(cropOverlay);
            modal.appendChild(instructions);
            modal.appendChild(controlPanel);
            document.body.appendChild(modal);
            
            // Initialize crop selection
            initializeCropSelection(modal);
        }
        
        let cropSelection = { startX: 0, startY: 0, endX: 0, endY: 0, isSelecting: false };
        
        function initializeCropSelection(modal) {
            const overlay = document.getElementById('crop-overlay');
            
            modal.addEventListener('mousedown', (e) => {
                if (e.target === modal) {
                    cropSelection.isSelecting = true;
                    cropSelection.startX = e.clientX;
                    cropSelection.startY = e.clientY;
                    overlay.style.left = e.clientX + 'px';
                    overlay.style.top = e.clientY + 'px';
                    overlay.style.width = '0px';
                    overlay.style.height = '0px';
                    overlay.style.display = 'block';
                }
            });
            
            modal.addEventListener('mousemove', (e) => {
                if (cropSelection.isSelecting) {
                    const width = Math.abs(e.clientX - cropSelection.startX);
                    const height = Math.abs(e.clientY - cropSelection.startY);
                    const left = Math.min(e.clientX, cropSelection.startX);
                    const top = Math.min(e.clientY, cropSelection.startY);
                    
                    overlay.style.left = left + 'px';
                    overlay.style.top = top + 'px';
                    overlay.style.width = width + 'px';
                    overlay.style.height = height + 'px';
                    
                    // Update display
                    document.getElementById('crop-dimensions').textContent = `${width} × ${height}`;
                    document.getElementById('crop-position').textContent = `${left}, ${top}`;
                }
            });
            
            modal.addEventListener('mouseup', (e) => {
                if (cropSelection.isSelecting) {
                    cropSelection.isSelecting = false;
                    cropSelection.endX = e.clientX;
                    cropSelection.endY = e.clientY;
                }
            });
            
            // Keyboard controls
            document.addEventListener('keydown', handleCropKeydown);
        }
        
        function handleCropKeydown(e) {
            if (document.getElementById('visual-crop-selector')) {
                if (e.key === 'Escape') {
                    cancelCropSelection();
                } else if (e.key === 'Enter') {
                    applyCropSelection();
                }
            }
        }
        
        function applyCropSelection() {
            const overlay = document.getElementById('crop-overlay');
            if (!overlay || overlay.style.display === 'none') {
                showStatus('בחר אזור קלטה תחילה', 'error');
                return;
            }
            
            // Get crop dimensions
            const left = parseInt(overlay.style.left);
            const top = parseInt(overlay.style.top);
            const width = parseInt(overlay.style.width);
            const height = parseInt(overlay.style.height);
            
            // Update crop controls in the main panel
            document.getElementById('enable-crop').checked = true;
            document.getElementById('crop-x').value = left;
            document.getElementById('crop-y').value = top;
            document.getElementById('crop-width').value = width;
            document.getElementById('crop-height').value = height;
            
            // Show crop controls
            toggleCropControls();
            
            // Close modal
            cancelCropSelection();
            
            showStatus(`אזור קלטה נבחר: ${width}×${height} ב-(${left}, ${top})`, 'success');
        }
        
        function cancelCropSelection() {
            const modal = document.getElementById('visual-crop-selector');
            if (modal) {
                modal.remove();
            }
            document.removeEventListener('keydown', handleCropKeydown);
        }
        
        // ==================== ENHANCED UPLOAD HANDLING ====================
        
        function handleUploadAreaClick() {
            const selectedConv = document.getElementById('upload-conversation-select').value;
            if (!selectedConv) {
                showStatus('בחר שיחה תחילה', 'error');
                return;
            }
            document.getElementById('custom-video-input').click();
        }
        
        // Additional video management helper functions
        async function previewVideo(conversationId) {
            const videoUrl = `${apiBaseUrl}/videos/${conversationId}.mp4`;
            
            // Create preview modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10000; display: flex;
                align-items: center; justify-content: center; flex-direction: column;
            `;
            
            const preview = document.createElement('div');
            preview.style.cssText = `
                background: white; padding: 2rem; border-radius: 12px;
                max-width: 90%; max-height: 90%; overflow: auto;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            `;
            
            preview.innerHTML = `
                <h3 style="margin: 0 0 1rem 0; text-align: center;">תצוגה מקדימה - ${conversationId}</h3>
                <video controls style="width: 100%; max-width: 600px; height: auto;">
                    <source src="${videoUrl}" type="video/mp4">
                    הדפדפן שלך לא תומך בווידאו HTML5.
                </video>
                <div style="text-align: center; margin-top: 1rem;">
                    <button onclick="this.closest('.preview-modal').remove()" class="btn btn-primary">סגור</button>
                </div>
            `;
            
            modal.className = 'preview-modal';
            modal.appendChild(preview);
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        async function deleteVideo(conversationId) {
            if (!confirm(`האם אתה בטוח שברצונך למחוק את הווידאו של ${conversationId}?`)) {
                return;
            }
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/delete-video/${conversationId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    showStatus(`וידאו של ${conversationId} נמחק בהצלחה`, 'success');
                    await loadEnhancedVideoList();
                } else {
                    throw new Error(`Delete failed: ${response.status}`);
                }
                
            } catch (error) {
                console.error('Error deleting video:', error);
                showStatus(`שגיאה במחיקת וידאו של ${conversationId}`, 'error');
            }
        }
        
        function uploadForConversation(conversationId) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'video/*';
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (file) {
                    await uploadCustomVideoForConversation(file, conversationId);
                }
            };
            input.click();
        }
        
        async function uploadCustomVideoForConversation(file, conversationId) {
            try {
                const formData = new FormData();
                formData.append('video', file);
                formData.append('conversation', conversationId);
                formData.append('source', 'custom');
                
                showStatus(`מעלה וידאו עבור ${conversationId}...`, 'info');
                
                const response = await fetch(`${apiBaseUrl}/api/upload-custom-video`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                showStatus(`וידאו הועלה בהצלחה עבור ${conversationId}`, 'success');
                await loadEnhancedVideoList();
                
            } catch (error) {
                console.error('Error uploading video:', error);
                showStatus(`שגיאה בהעלאת וידאו עבור ${conversationId}`, 'error');
            }
        }
        
        function filterVideoList() {
            const filter = document.getElementById('video-filter').value;
            const cards = document.querySelectorAll('.video-management-card');
            
            cards.forEach(card => {
                const statusSpan = card.querySelector('span');
                const statusText = statusSpan.textContent;
                
                let show = true;
                switch(filter) {
                    case 'system':
                        show = statusText === 'מערכת';
                        break;
                    case 'custom':
                        show = statusText === 'מותאם אישית';
                        break;
                    case 'missing':
                        show = statusText === 'חסר';
                        break;
                    case 'all':
                    default:
                        show = true;
                }
                
                card.style.display = show ? 'block' : 'none';
            });
        }
        
        function selectAllVideos() {
            document.querySelectorAll('.video-select:not([style*="display: none"])').forEach(cb => {
                cb.checked = true;
            });
        }
        
        function deselectAllVideos() {
            document.querySelectorAll('.video-select').forEach(cb => {
                cb.checked = false;
            });
        }
        
        async function regenerateSelectedVideos() {
            const selected = getSelectedConversations();
            if (selected.length === 0) {
                showStatus('לא נבחרו שיחות', 'warning');
                return;
            }
            
            showStatus(`יוצר מחדש ${selected.length} וידאו...`, 'info');
            
            for (const conversationId of selected) {
                await generateSingleVideo(conversationId);
            }
        }
        
        function getSelectedConversations() {
            return Array.from(document.querySelectorAll('.video-select:checked'))
                .map(cb => cb.dataset.conversation);
        }
        
        async function downloadSelectedVideos() {
            const selected = getSelectedConversations();
            if (selected.length === 0) {
                showStatus('לא נבחרו שיחות', 'warning');
                return;
            }
            
            // Create zip file with selected videos
            showStatus(`מכין קובץ ZIP עם ${selected.length} וידאו...`, 'info');
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/download-videos`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ conversations: selected })
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `videos_${new Date().toISOString().split('T')[0]}.zip`;
                a.click();
                window.URL.revokeObjectURL(url);
                
                showStatus('הורדה הושלמה בהצלחה', 'success');
                
            } catch (error) {
                console.error('Error downloading videos:', error);
                showStatus('שגיאה בהורדת וידאו', 'error');
            }
        }
        
        async function deleteSelectedVideos() {
            const selected = getSelectedConversations();
            if (selected.length === 0) {
                showStatus('לא נבחרו שיחות', 'warning');
                return;
            }
            
            if (!confirm(`האם אתה בטוח שברצונך למחוק ${selected.length} וידאו?`)) {
                return;
            }
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/delete-videos`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ conversations: selected })
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                showStatus(`${selected.length} וידאו נמחקו בהצלחה`, 'success');
                await loadEnhancedVideoList();
                
            } catch (error) {
                console.error('Error deleting videos:', error);
                showStatus('שגיאה במחיקת וידאו', 'error');
            }
        }
        
        // Add drag and drop functionality
        document.addEventListener('DOMContentLoaded', function() {
            const uploadArea = document.getElementById('custom-upload-area');
            if (uploadArea) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, preventDefaults, false);
                });
                
                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, highlight, false);
                });
                
                ['dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, unhighlight, false);
                });
                
                uploadArea.addEventListener('drop', handleDrop, false);
            }
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            function highlight(e) {
                uploadArea.style.background = 'rgba(255, 193, 7, 0.2)';
                uploadArea.style.borderColor = '#f39c12';
            }
            
            function unhighlight(e) {
                uploadArea.style.background = 'rgba(255, 193, 7, 0.1)';
                uploadArea.style.borderColor = '#f39c12';
            }
            
            function handleDrop(e) {
                const files = e.dataTransfer.files;
                handleCustomVideoUpload(files);
            }
                 });

        // Individual video management functions
        async function downloadVideo(conversationId) {
            try {
                const response = await fetch(`${apiBaseUrl}/api/download-video/${conversationId}`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${conversationId}.mp4`;
                a.click();
                window.URL.revokeObjectURL(url);
                
                showStatus(`וידאו ${conversationId} הורד בהצלחה`, 'success');
                
            } catch (error) {
                console.error('Error downloading video:', error);
                showStatus(`שגיאה בהורדת וידאו ${conversationId}`, 'error');
            }
        }
        
        function replaceVideo(conversationId) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'video/*';
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (file) {
                    if (confirm(`האם אתה בטוח שברצונך להחליף את הוידאו עבור ${conversationId}?`)) {
                        await uploadCustomVideoForConversation(file, conversationId);
                    }
                }
            };
            input.click();
        }
        
        async function deleteVideo(conversationId) {
            if (!confirm(`האם אתה בטוח שברצונך למחוק את הוידאו עבור ${conversationId}?`)) {
                return;
            }
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/delete-video/${conversationId}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                showStatus(`וידאו ${conversationId} נמחק בהצלחה`, 'success');
                await loadEnhancedVideoList();
                
            } catch (error) {
                console.error('Error deleting video:', error);
                showStatus(`שגיאה במחיקת וידאו ${conversationId}`, 'error');
            }
        }
        
        function refreshVideoList() {
            loadEnhancedVideoList();
        }
        
        function exportVideoList() {
            const data = {
                conversations: videoManagementData.conversations,
                videos: videoManagementData.videos,
                exportDate: new Date().toISOString(),
                summary: {
                    totalConversations: videoManagementData.conversations.length,
                    totalVideos: videoManagementData.videos.length,
                    systemGenerated: videoManagementData.videos.filter(v => v.source !== 'custom').length,
                    customUploaded: videoManagementData.videos.filter(v => v.source === 'custom').length
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `video_list_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            window.URL.revokeObjectURL(url);
            
            showStatus('רשימת וידאו יוצאה בהצלחה', 'success');
        }

        function displayVideoStatus(status) {
            const container = document.getElementById('video-status-details');
            
            let html = '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; font-size: 0.9rem;">';
            
            // Status indicators
            html += '<div>';
            html += `<div style="margin-bottom: 0.5rem;">
                <span style="color: ${status.selenium_available ? '#4caf50' : '#f44336'};">
                    ${status.selenium_available ? '✅' : '❌'} Selenium WebDriver
                </span>
            </div>`;
            
            html += `<div style="margin-bottom: 0.5rem;">
                <span style="color: ${status.ffmpeg_available ? '#4caf50' : '#f44336'};">
                    ${status.ffmpeg_available ? '✅' : '❌'} FFmpeg
                </span>
            </div>`;
            
            html += `<div style="margin-bottom: 0.5rem;">
                <span style="color: ${status.chrome_available ? '#4caf50' : '#f44336'};">
                    ${status.chrome_available ? '✅' : '❌'} Chrome Browser
                </span>
            </div>`;
            html += '</div>';
            
            // Method and quality info
            html += '<div>';
            html += `<div style="margin-bottom: 0.5rem;">
                <strong>שיטה:</strong> ${getMethodDisplayName(status.video_generation_method)}
            </div>`;
            
            html += `<div style="margin-bottom: 0.5rem;">
                <strong>איכות:</strong> ${getQualityDisplayName(status.quality)}
            </div>`;
            html += '</div>';
            
            html += '</div>';
            
            // Installation instructions if needed
            if (status.install_instructions) {
                html += '<div style="margin-top: 1rem; padding: 1rem; background: #fff3cd; border-radius: 6px; border: 1px solid #ffc107;">';
                html += '<h4 style="margin: 0 0 0.5rem 0; color: #856404;">🔧 להתקנת יכולות וידאו מלאות:</h4>';
                html += '<div style="font-family: monospace; font-size: 0.8rem; line-height: 1.4;">';
                
                if (status.install_instructions.selenium) {
                    html += `<div style="margin-bottom: 0.5rem;">1. ${status.install_instructions.selenium}</div>`;
                }
                if (status.install_instructions.chromedriver) {
                    html += `<div style="margin-bottom: 0.5rem;">2. ${status.install_instructions.chromedriver}</div>`;
                }
                if (status.install_instructions.ffmpeg) {
                    html += `<div style="margin-bottom: 0.5rem;">3. ${status.install_instructions.ffmpeg}</div>`;
                }
                
                html += '</div>';
                html += '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #856404;">';
                html += 'לאחר התקנה, הרץ מחדש את השרת וחזור לבדוק את הסטטוס.';
                html += '</div>';
                html += '</div>';
            }
            
            container.innerHTML = html;
        }

        function getMethodDisplayName(method) {
            const methods = {
                'selenium_webdriver': 'Selenium WebDriver (מומלץ)',
                'ffmpeg_test_pattern': 'FFmpeg Test Pattern',
                'simple_fallback': 'Python Fallback',
                'none': 'לא זמין'
            };
            return methods[method] || method;
        }

        function getQualityDisplayName(quality) {
            const qualities = {
                'high_quality_real_capture': 'איכות גבוהה - צילום אמיתי',
                'test_pattern_only': 'תבנית בדיקה בלבד',
                'basic_mp4_file': 'קובץ MP4 בסיסי',
                'none': 'לא זמין'
            };
            return qualities[quality] || quality;
        }

        // ==================== END VIDEO GENERATION FUNCTIONS ====================

        // ==================== EMOTIONS AVAILABILITY UPDATE FUNCTIONS ====================
        
        function updateEmotionsAvailability(availableEmotions, emotionMapping) {
            console.log('🎭 Updating emotions availability with:', availableEmotions);
            
            // Update all emotion dropdowns to include the detected emotions
            setTimeout(() => {
                populateAllEmotionDropdowns();
                
                // Force refresh of all emotion displays
                refreshAllEmotionDisplays();
                
                console.log('✅ Emotions dropdown updated with detected emotions');
            }, 100);
        }
        
        function autoAddDetectedEmotion(mp3File, detectedEmotion) {
            console.log(`🎯 Auto-adding detected emotion '${detectedEmotion}' to ${mp3File}`);
            
            if (!emotionData[mp3File]) {
                console.error(`❌ No emotion data found for ${mp3File}`);
                return;
            }
            
            // 🎯 SMART EMOTION HANDLING: Map both Hebrew and English emotions to proper config keys
            let finalEmotion = detectedEmotion;
            let emotionDisplay = detectedEmotion;
            let emotionKey = null;
            
            // Check if this is a Hebrew emotion (contains Hebrew characters)
            // 🎭 Hebrew-only config - emotions are now Hebrew keys
            console.log(`🎭 Processing emotion: ${detectedEmotion}`);
            
            // Check if the emotion exists in the Hebrew-based config
            if (emotionsConfig && emotionsConfig[detectedEmotion]) {
                emotionKey = detectedEmotion;
                finalEmotion = detectedEmotion;  // Use Hebrew emotion directly
                const config = emotionsConfig[detectedEmotion];
                emotionDisplay = `${config.emoji} ${detectedEmotion}`;
                console.log(`✅ Found emotion in Hebrew config: ${detectedEmotion}`);
            } else {
                console.warn(`⚠️ Emotion '${detectedEmotion}' not found in emotions config`);
                // Use as-is if not found in config
                finalEmotion = detectedEmotion;
                emotionDisplay = detectedEmotion;
            }
            
            // Get current emotions
            const currentEmotions = emotionData[mp3File].emotions || ['neutral'];
            
            // Check if emotion already exists
            if (currentEmotions.includes(finalEmotion)) {
                console.log(`⚠️ Emotion '${detectedEmotion}' already exists in ${mp3File}`);
                return;
            }
            
            // Replace current emotions with the detected one (since AI analysis should set the primary emotion)
            const newEmotions = [finalEmotion];
            
            // Update the emotion data
            updateParam(mp3File, 'emotions', newEmotions);
            
            // Refresh the emotion display
            refreshEmotionDisplay(mp3File);
            
            // Update UI displays
            updateSegmentDisplays(mp3File);
            syncSegmentEditor(mp3File);
            
            console.log(`✅ Auto-added emotion '${emotionDisplay}' to ${mp3File}`);
            showStatus(`🤖 AI זיהה והגדיר רגש: ${emotionDisplay}`, 'success');
        }

        // ==================== EMOTIONS MANAGEMENT FUNCTIONS ====================
        
        let emotionsConfig = {};
        let defaultEmotionsConfig = {};
        
        // Default emotions configuration with colors and emojis
        const DEFAULT_EMOTIONS = {
            'happiness': { color: '#FFD700', emoji: '😊', hebrew: 'שמחה', active: true },
            'sadness': { color: '#4169E1', emoji: '😢', hebrew: 'עצב', active: true },
            'anger': { color: '#FF4500', emoji: '😠', hebrew: 'כעס', active: true },
            'fear': { color: '#8B008B', emoji: '😨', hebrew: 'פחד', active: true },
            'surprise': { color: '#FF69B4', emoji: '😲', hebrew: 'הפתעה', active: true },
            'disgust': { color: '#228B22', emoji: '🤢', hebrew: 'גועל', active: true },
            'neutral': { color: '#808080', emoji: '😐', hebrew: 'ניטרלי', active: true },
            'curiosity': { color: '#00CED1', emoji: '🤔', hebrew: 'סקרנות', active: true },
            'confusion': { color: '#DDA0DD', emoji: '😵', hebrew: 'בלבול', active: true },
            'excitement': { color: '#FF1493', emoji: '🤩', hebrew: 'התרגשות', active: true },
            'annoyance': { color: '#CD853F', emoji: '😤', hebrew: 'עצבנות', active: true },
            'frustration': { color: '#B22222', emoji: '😫', hebrew: 'תסכול', active: true },
            'caring': { color: '#20B2AA', emoji: '🤗', hebrew: 'דאגה', active: true },
            'love': { color: '#DC143C', emoji: '❤️', hebrew: 'אהבה', active: true },
            'anxiety': { color: '#9370DB', emoji: '😰', hebrew: 'חרדה', active: true },
            'hope': { color: '#32CD32', emoji: '🌟', hebrew: 'תקווה', active: true },
            'pride': { color: '#FF8C00', emoji: '😤', hebrew: 'גאווה', active: true },
            'joy': { color: '#FFFF00', emoji: '😄', hebrew: 'שמחה גדולה', active: true },
            'embarrassment': { color: '#FF69B4', emoji: '😳', hebrew: 'מבוכה', active: true },
            'gratitude': { color: '#90EE90', emoji: '🙏', hebrew: 'הכרת תודה', active: true }
        };
        
        // Recommended color palette
        const RECOMMENDED_COLORS = [
            '#FF4500', '#FFD700', '#32CD32', '#00CED1', '#4169E1', '#8B008B',
            '#FF69B4', '#FF1493', '#228B22', '#DC143C', '#9370DB', '#FF8C00',
            '#20B2AA', '#DDA0DD', '#CD853F', '#B22222', '#90EE90', '#FFFF00',
            '#808080', '#696969', '#2F4F4F', '#483D8B', '#6B8E23', '#8B4513',
            '#556B2F', '#8FBC8F', '#B8860B', '#DAA520', '#CD5C5C', '#F0E68C'
        ];
        
        // Load emotions configuration
        async function loadEmotionsConfig() {
            try {
                showLoading('טוען הגדרות רגשות...');
                
                // Try to load from server
                const response = await fetch(`${apiBaseUrl}/config/emotions_config.json?t=${Date.now()}`);
                if (response.ok) {
                    emotionsConfig = await response.json();
                    console.log('📥 Loaded emotions config from server:', emotionsConfig);
                    console.log('📥 Loaded config has', Object.keys(emotionsConfig).length, 'emotions');
                    
                    // Log a few sample colors for verification
                    Object.entries(emotionsConfig).slice(0, 3).forEach(([emotion, config]) => {
                        console.log(`📥 Loaded: ${emotion} = ${config.color} (active: ${config.active})`);
                    });
                } else {
                    console.warn('⚠️ Could not load emotions config from server, using defaults. Response:', response.status);
                    // Use default configuration
                    emotionsConfig = JSON.parse(JSON.stringify(DEFAULT_EMOTIONS));
                    console.log('📥 Using default emotions config');
                }
                
                // Store default configuration
                defaultEmotionsConfig = JSON.parse(JSON.stringify(DEFAULT_EMOTIONS));
                
                // Count active emotions
                const activeEmotions = Object.keys(emotionsConfig).filter(key => emotionsConfig[key].active);
                
                // Display emotions
                displayEmotionsList();
                displayColorPalette();
                updateEmotionsStats();
                
                console.log('🎨 Emotions list updated with current configuration');
                
                // Refresh all emotion dropdowns with new config
                setTimeout(() => {
                    populateAllEmotionDropdowns();
                }, 100);
                
                // Send emotion colors to visualization immediately after loading
                setTimeout(() => {
                    updateVisualizationColors();
                    console.log('🎨 Initial emotion colors sent to visualizations');
                }, 1000); // Small delay to ensure visualizations are ready
                
                // Also send colors multiple times to catch any visualizations that load later
                setTimeout(() => {
                    updateVisualizationColors();
                    console.log('🎨 Second wave of emotion colors sent');
                }, 3000);
                
                setTimeout(() => {
                    updateVisualizationColors();
                    console.log('🎨 Final wave of emotion colors sent');
                }, 5000);
                
                showStatus(`🎭 ${activeEmotions.length} רגשות נטענו! AI יוכל לנתח עם כל הרגשות הזמינים`, 'success');
                
                // Immediately send colors to any open visualizations
                setTimeout(() => {
                    updateVisualizationColors();
                    console.log('🎨 Sent initial emotion colors to visualizations after config load');
                }, 100);
                
            } catch (error) {
                console.error('Error loading emotions config:', error);
                showStatus(`שגיאה בטעינת הגדרות רגשות: ${error.message}`, 'error');
                
                // Fallback to default
                emotionsConfig = JSON.parse(JSON.stringify(DEFAULT_EMOTIONS));
                defaultEmotionsConfig = JSON.parse(JSON.stringify(DEFAULT_EMOTIONS));
                
                displayEmotionsList();
                displayColorPalette();
                updateEmotionsStats();
                
                // Refresh all emotion dropdowns with fallback config
                setTimeout(() => {
                    populateAllEmotionDropdowns();
                }, 100);
                
                // Still send colors even with default config
                setTimeout(() => {
                    updateVisualizationColors();
                }, 1000);
            } finally {
                hideLoading();
            }
        }
        
        // Display emotions list
        function displayEmotionsList() {
            const container = document.getElementById('emotions-list');
            if (!container) return;
            
            container.innerHTML = '';
            
            const emotions = Object.entries(emotionsConfig);
            emotions.sort((a, b) => {
                try {
                    // Hebrew keys are the emotion names themselves
                    return a[0].localeCompare(b[0], 'he');
                } catch(e) {
                    return a[0] > b[0] ? 1 : -1;
                }
            });
            
            emotions.forEach(([emotion, config]) => {
                const emotionItem = document.createElement('div');
                emotionItem.className = 'emotion-item';
                emotionItem.style.cssText = `
                    background: white;
                    border: 2px solid ${config.active ? '#e0e0e0' : '#ffcccb'};
                    border-radius: 8px;
                    padding: 1rem;
                    transition: all 0.3s ease;
                    ${config.active ? '' : 'opacity: 0.7;'}
                `;
                
                emotionItem.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <span style="font-size: 1.5rem;">${config.emoji}</span>
                            <div>
                                <div style="font-weight: bold; font-size: 1.1rem;">${emotion}</div>
                                <div style="color: #666; font-size: 0.9rem;">${config.english || emotion}</div>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
                                <input type="checkbox" ${config.active ? 'checked' : ''} 
                                       onchange="toggleEmotionActive('${emotion}', this.checked)">
                                <span style="font-size: 0.9rem;">פעיל</span>
                            </label>
                            <button onclick="deleteEmotion('${emotion}')" class="btn btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">
                                <i class="material-icons" style="font-size: 14px;">delete</i>
                            </button>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                        <div>
                            <label style="display: block; margin-bottom: 0.3rem; font-size: 0.9rem;">צבע:</label>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <input type="color" value="${config.color}" 
                                       onchange="updateEmotionColor('${emotion}', this.value)"
                                       style="width: 40px; height: 40px; border: none; border-radius: 4px; cursor: pointer;">
                                <input type="text" value="${config.color}" 
                                       onchange="updateEmotionColor('${emotion}', this.value)"
                                       style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 0.9rem;">
                            </div>
                        </div>
                        
                        <div>
                            <label style="display: block; margin-bottom: 0.3rem; font-size: 0.9rem;">אמוג'י:</label>
                            <input type="text" value="${config.emoji}" 
                                   onchange="updateEmotionEmoji('${emotion}', this.value)"
                                   style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1.2rem; text-align: center;">
                        </div>
                    </div>
                    
                    <div>
                        <label style="display: block; margin-bottom: 0.3rem; font-size: 0.9rem;">שם בעברית:</label>
                        <input type="text" value="${emotion}" 
                               onchange="updateEmotionHebrew('${emotion}', this.value)"
                               style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;"
                               readonly title="השם בעברית הוא המפתח - לא ניתן לשנות ישירות">
                    </div>
                `;
                
                container.appendChild(emotionItem);
            });
        }
        
        // Display color palette
        function displayColorPalette() {
            const container = document.getElementById('color-palette');
            if (!container) return;
            
            container.innerHTML = '';
            
            RECOMMENDED_COLORS.forEach(color => {
                const colorItem = document.createElement('div');
                colorItem.style.cssText = `
                    background: ${color};
                    height: 60px;
                    border-radius: 8px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: ${getContrastColor(color)};
                    font-weight: bold;
                    font-size: 0.8rem;
                    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
                `;
                
                colorItem.textContent = color;
                colorItem.onclick = () => copyToClipboard(color);
                colorItem.title = `לחץ להעתקת ${color}`;
                
                colorItem.addEventListener('mouseenter', () => {
                    colorItem.style.transform = 'scale(1.1)';
                    colorItem.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
                });
                
                colorItem.addEventListener('mouseleave', () => {
                    colorItem.style.transform = 'scale(1)';
                    colorItem.style.boxShadow = 'none';
                });
                
                container.appendChild(colorItem);
            });
        }
        
        // Update emotions statistics
        function updateEmotionsStats() {
            const totalCount = Object.keys(emotionsConfig).length;
            const activeCount = Object.values(emotionsConfig).filter(e => e.active).length;
            const customCount = Object.values(emotionsConfig).filter(e => 
                !DEFAULT_EMOTIONS[Object.keys(emotionsConfig).find(key => emotionsConfig[key] === e)]
            ).length;
            
            document.getElementById('total-emotions-count').textContent = totalCount;
            document.getElementById('active-emotions-count').textContent = activeCount;
            document.getElementById('custom-colors-count').textContent = customCount;
        }
        
        // Test emotion colors function
        function testEmotionColors() {
            console.log('🧪 Testing emotion colors system...');
            
            // Check if emotions config is loaded
            if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                alert('❌ אין הגדרות רגשות זמינות!\nנא לטעון תחילה את הגדרות הרגשות.');
                return;
            }
            
            console.log('🎭 Available emotions:', Object.keys(emotionsConfig));
            
            // Test color preparation
            const testColors = {};
            Object.entries(emotionsConfig).forEach(([emotion, config]) => {
                if (config.active && config.color) {
                    testColors[emotion] = hexToRgb(config.color);
                    console.log(`🎨 Test: "${emotion}" → ${config.color} → [${testColors[emotion].join(', ')}]`);
                }
            });
            
            console.log('🎨 Test colors prepared:', testColors);
            
            // Force update visualization multiple times for thorough testing
            console.log('🔄 Sending test color updates...');
            updateVisualizationColors();
            
            setTimeout(() => {
                updateVisualizationColors();
                console.log('🔄 Sent second test update');
            }, 200);
            
            setTimeout(() => {
                updateVisualizationColors();
                console.log('🔄 Sent third test update');
            }, 500);
            
            const activeCount = Object.keys(testColors).length;
            const totalCount = Object.keys(emotionsConfig).length;
            
            alert(`✅ בדיקת צבעי רגשות הושלמה!
            
📊 סטטיסטיקות:
• סה"כ רגשות: ${totalCount}
• רגשות פעילים: ${activeCount}
• צבעים נשלחו לויזואליזציה 3 פעמים
            
🔍 בדוק את הקונסול לפרטים נוספים.
💡 נסה לשנות צבע של רגש כלשהו - השינוי אמור להופיע מיד!`);
        }
        
        // Toggle emotion active state
        function toggleEmotionActive(emotion, isActive) {
            if (emotionsConfig[emotion]) {
                emotionsConfig[emotion].active = isActive;
                displayEmotionsList();
                updateEmotionsStats();
                
                // Auto-save configuration after state change
                scheduleEmotionConfigAutoSave();
                
                showStatus(`רגש "${emotionsConfig[emotion].hebrew}" ${isActive ? 'הופעל' : 'הושבת'}`, 'success');
            }
        }
        
        // Update emotion color
        function updateEmotionColor(emotion, color) {
            if (emotionsConfig[emotion]) {
                const oldColor = emotionsConfig[emotion].color;
                emotionsConfig[emotion].color = color;
                
                console.log(`🎨 Emotion color updated: "${emotion}" from ${oldColor} to ${color}`);
                console.log(`🎨 New emotions config for ${emotion}:`, emotionsConfig[emotion]);
                
                // Immediately update the emotion item color in the list
                const colorInputs = document.querySelectorAll(`input[onchange*="updateEmotionColor('${emotion}'"]`);
                colorInputs.forEach(input => {
                    if (input.type === 'color') {
                        input.value = color;
                    } else if (input.type === 'text') {
                        input.value = color;
                    }
                });
                
                // Refresh the emotions list display
                displayEmotionsList();
                
                // Update visualization colors in real-time with immediate effect
                console.log('🔄 Sending immediate color update to visualizations...');
                updateVisualizationColors();
                
                // Force reload colors in visualization from emotions_config.json
                setTimeout(() => {
                    reloadVisualizationColors();
                }, 500);
                
                // Also force update in any open conversation visualization windows
                setTimeout(() => {
                    console.log('🔄 Broadcasting to all open visualization windows...');
                    // Send to parent window (main index page)
                    if (window.opener) {
                        window.opener.postMessage({
                            type: 'emotionColorsUpdated',
                            timestamp: Date.now()
                        }, '*');
                        console.log('📤 Sent emotionColorsUpdated to opener (main index)');
                    }
                    // Also send through broadcast channel for any other open tabs
                    try {
                        const bc = new BroadcastChannel('emotion-updates');
                        bc.postMessage({
                            type: 'emotionColorsUpdated',
                            timestamp: Date.now()
                        });
                        bc.close();
                        console.log('📻 Broadcast emotionColorsUpdated to all tabs');
                    } catch (e) {
                        console.log('📻 BroadcastChannel not available, skipping...');
                    }
                }, 1000);
                
                // Also immediately update the emotions list display to show new color
                displayEmotionsList();
                
                // Send additional updates to ensure all visualizations get the change
                setTimeout(() => {
                    console.log('🔄 Sending delayed color update for reliability...');
                    updateVisualizationColors();
                }, 100);
                
                setTimeout(() => {
                    console.log('🔄 Sending final color update for maximum reliability...');
                    updateVisualizationColors();
                }, 500);
                
                setTimeout(() => {
                    console.log('🔄 Sending extra delayed color update...');
                    updateVisualizationColors();
                }, 1000);
                
                // Update current conversation data if available
                updateCurrentConversationEmotionColors();
                
                // Auto-save configuration after color change (debounced)
                scheduleEmotionConfigAutoSave();
                
                // Show immediate feedback with saving indicator
                showStatus(`צבע של "${emotionsConfig[emotion].hebrew}" עודכן ל-${color} (שומר...)`, 'info');
            }
        }
        
        // Update current conversation emotion colors after config change
        async function updateCurrentConversationEmotionColors() {
            if (!currentConversation || !emotionData) {
                console.log('⏭️ No current conversation loaded, skipping emotion color update');
                return;
            }
            
            try {
                console.log('🎨 Updating emotion colors in current conversation data...');
                
                let hasChanges = false;
                const mp3Files = Object.keys(emotionData).filter(key => key.endsWith('.mp3'));
                
                // Update emotion colors in local emotion data
                mp3Files.forEach(mp3File => {
                    const segment = emotionData[mp3File];
                    if (segment && segment.emotions && Array.isArray(segment.emotions)) {
                        segment.emotions.forEach(emotion => {
                            if (emotionsConfig[emotion] && emotionsConfig[emotion].color) {
                                // Store the color in the segment data for future reference
                                if (!segment.emotionColors) {
                                    segment.emotionColors = {};
                                }
                                
                                // Only update if color actually changed
                                const newColor = emotionsConfig[emotion].color;
                                if (segment.emotionColors[emotion] !== newColor) {
                                    segment.emotionColors[emotion] = newColor;
                                    hasChanges = true;
                                    
                                    // Mark this segment as changed for auto-save
                                    if (!pendingChanges[mp3File]) {
                                        pendingChanges[mp3File] = {};
                                    }
                                    pendingChanges[mp3File].emotionColors = segment.emotionColors;
                                }
                            }
                        });
                    }
                });
                
                if (hasChanges) {
                    hasUnsavedChanges = true;
                    updateSaveButtonState();
                    
                    // Auto-save the changes after a short delay
                    scheduleAutoSave();
                    
                    console.log('✅ Updated emotion colors in conversation data, auto-save scheduled');
                    
                    // Refresh displays to show updated colors
                    refreshAllEmotionDisplays();
                } else {
                    console.log('ℹ️ No emotion color changes needed in current conversation');
                }
                
            } catch (error) {
                console.error('❌ Error updating conversation emotion colors:', error);
            }
        }
        
        // Update all conversations with new emotion colors (bulk update)
        async function updateAllConversationsEmotionColors() {
            try {
                console.log('🔄 Triggering bulk emotion color update for all conversations...');
                
                const response = await fetch(`${apiBaseUrl}/api/update-all-emotion-colors`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        emotionsConfig: emotionsConfig
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log(`✅ Updated emotion colors in ${result.updatedConversations || 0} conversations`);
                } else {
                    console.warn('⚠️ Bulk emotion color update failed, but continuing...');
                }
                
            } catch (error) {
                console.warn('⚠️ Error in bulk emotion color update:', error);
                // Don't show error to user since this is a background operation
            }
        }
        
        // Update emotion emoji
        function updateEmotionEmoji(emotion, emoji) {
            if (emotionsConfig[emotion]) {
                emotionsConfig[emotion].emoji = emoji;
                displayEmotionsList();
                
                // Update visualization and current conversation
                updateVisualizationColors();
                refreshAllEmotionDisplays();
                
                // Auto-save configuration after emoji change
                scheduleEmotionConfigAutoSave();
                
                showStatus(`אמוג'י של "${emotionsConfig[emotion].hebrew}" עודכן`, 'success');
            }
        }
        
        // Update emotion Hebrew name
        function updateEmotionHebrew(emotion, hebrew) {
            if (emotionsConfig[emotion]) {
                emotionsConfig[emotion].hebrew = hebrew;
                displayEmotionsList();
                
                // Update visualization and current conversation
                updateVisualizationColors();
                refreshAllEmotionDisplays();
                
                // Auto-save configuration after name change
                scheduleEmotionConfigAutoSave();
                
                showStatus(`שם עברי של "${emotion}" עודכן`, 'success');
            }
        }
        
        // Add new emotion
        function addNewEmotion() {
            const emotion = prompt('הזן שם רגש חדש באנגלית (ללא רווחים):');
            if (!emotion) return;
            
            const cleanEmotion = emotion.toLowerCase().replace(/\s+/g, '_');
            
            if (emotionsConfig[cleanEmotion]) {
                showStatus(`הרגש "${cleanEmotion}" כבר קיים`, 'error');
                return;
            }
            
            const hebrew = prompt('הזן שם הרגש בעברית:');
            if (!hebrew) return;
            
            const emoji = prompt('הזן אמוג\'י לרגש (אופציונלי):') || '😐';
            
            // Generate random color
            const randomColor = RECOMMENDED_COLORS[Math.floor(Math.random() * RECOMMENDED_COLORS.length)];
            
            emotionsConfig[cleanEmotion] = {
                color: randomColor,
                emoji: emoji,
                hebrew: hebrew,
                active: true
            };
            
            displayEmotionsList();
            updateEmotionsStats();
            
            // Refresh all emotion dropdowns with new emotion
            setTimeout(() => {
                populateAllEmotionDropdowns();
            }, 100);
            
            // Auto-save configuration after adding new emotion
            scheduleEmotionConfigAutoSave();
            
            showStatus(`רגש חדש "${hebrew}" נוסף בהצלחה`, 'success');
        }
        
        // Delete emotion
        function deleteEmotion(emotion) {
            if (!confirm(`האם אתה בטוח שברצונך למחוק את הרגש "${emotionsConfig[emotion].hebrew}"?`)) {
                return;
            }
            
            delete emotionsConfig[emotion];
            displayEmotionsList();
            updateEmotionsStats();
            
            // Refresh all emotion dropdowns after deletion
            setTimeout(() => {
                populateAllEmotionDropdowns();
            }, 100);
            
            // Auto-save configuration after deleting emotion
            scheduleEmotionConfigAutoSave();
            
            showStatus(`רגש "${emotion}" נמחק בהצלחה`, 'success');
        }
        
        // Reset emotions to default
        function resetEmotionsToDefault() {
            if (!confirm('האם אתה בטוח שברצונך לשחזר את כל הרגשות לברירת המחדל?\n\nפעולה זו תמחק את כל ההתאמות האישיות!')) {
                return;
            }
            
            emotionsConfig = JSON.parse(JSON.stringify(DEFAULT_EMOTIONS));
            displayEmotionsList();
            updateEmotionsStats();
            
            // Refresh all emotion dropdowns with default emotions
            setTimeout(() => {
                populateAllEmotionDropdowns();
            }, 100);
            
            showStatus('הרגשות שוחזרו לברירת המחדל', 'success');
        }
        
        // Save emotions configuration
        async function saveEmotionsConfig(isAutoSave = false) {
            try {
                if (!isAutoSave) {
                    showLoading('שומר הגדרות רגשות...');
                }
                
                // Log what we're trying to save
                console.log('💾 Saving emotions configuration:', emotionsConfig);
                console.log('💾 Emotions config has', Object.keys(emotionsConfig).length, 'emotions');
                
                // Log a few sample colors for verification
                Object.entries(emotionsConfig).slice(0, 3).forEach(([emotion, config]) => {
                    console.log(`💾 Sample: ${emotion} = ${config.color} (active: ${config.active})`);
                });
                
                const response = await fetch(`${apiBaseUrl}/api/save-emotions-config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(emotionsConfig)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Save failed with response:', response.status, errorText);
                    throw new Error(`שגיאה בשמירה: ${response.status} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('✅ Save successful, server response:', result);
                
                // Update all visualizations with new emotion colors
                updateVisualizationColors();
                
                // Refresh all emotion dropdowns with updated config
                setTimeout(() => {
                    populateAllEmotionDropdowns();
                }, 100);
                
                // Update current conversation if loaded
                await updateCurrentConversationEmotionColors();
                
                // Also trigger bulk update for all conversations with these emotions
                updateAllConversationsEmotionColors();
                
                if (!isAutoSave) {
                    showStatus('הגדרות הרגשות נשמרו ועודכנו בכל השיחות והוויזואליזציה!', 'success');
                }
                
            } catch (error) {
                console.error('Error saving emotions config:', error);
                if (!isAutoSave) {
                    showStatus(`שגיאה בשמירת הגדרות: ${error.message}`, 'error');
                }
            } finally {
                if (!isAutoSave) {
                    hideLoading();
                }
            }
        }
        
        // Update visualization colors when emotions config changes
        function updateVisualizationColors() {
            try {
                console.log('🎨 Updating visualization with new emotion colors...');
                
                // Ensure emotions config is loaded
                if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                    console.warn('⚠️ No emotions config available - cannot update visualization colors');
                    return;
                }
                
                // Prepare emotion colors for visualization
                const emotionColorsForViz = {};
                let activeCount = 0;
                Object.entries(emotionsConfig).forEach(([emotion, config]) => {
                    if (config.active && config.color) {
                        // Convert hex to RGB array for visualization
                        const rgbColor = hexToRgb(config.color);
                        
                        // Store with Hebrew name (original key)
                        emotionColorsForViz[emotion] = rgbColor;
                        
                        // Also store with English equivalent if available for better compatibility
                        if (config.english) {
                            emotionColorsForViz[config.english] = rgbColor;
                            console.log(`🎨 Prepared color for "${emotion}" (${config.english}): ${config.color} → [${rgbColor.join(', ')}]`);
                        } else {
                            console.log(`🎨 Prepared color for "${emotion}": ${config.color} → [${rgbColor.join(', ')}]`);
                        }
                        
                        activeCount++;
                    }
                });
                
                console.log(`🎨 Sending ${activeCount} emotion colors to visualization:`, emotionColorsForViz);
                
                // Debug: Log each color being sent
                Object.entries(emotionColorsForViz).forEach(([emotion, rgbArray]) => {
                    const hexColor = emotionsConfig[emotion]?.color || 'unknown';
                    console.log(`🎨 ${emotion}: ${hexColor} → RGB[${rgbArray.join(', ')}]`);
                });
                
                const updateMessage = {
                    type: 'updateEmotions',
                    emotions: emotionsConfig,
                        emotionColorMap: emotionColorsForViz,
                        timestamp: Date.now()
                    };
                    
                console.log('📤 Full update message being sent:', updateMessage);
                    
                // 1. Send update to visualization iframes (admin panel previews)
                const visualizationIframes = document.querySelectorAll('iframe');
                console.log(`📺 Found ${visualizationIframes.length} iframes to update`);
                visualizationIframes.forEach((iframe, index) => {
                    try {
                        iframe.contentWindow.postMessage(updateMessage, '*');
                        console.log(`🎨 Sent color update to iframe ${index + 1}/${visualizationIframes.length}`);
                    } catch (error) {
                        console.warn(`Could not update iframe ${index + 1}:`, error);
                    }
                });
                
                // 2. Send to parent window (if admin panel is embedded)
                if (window.parent && window.parent !== window) {
                    try {
                        window.parent.postMessage(updateMessage, '*');
                        console.log('🎨 Sent color update to parent window');
                    } catch (error) {
                        console.warn('Could not update parent visualization:', error);
                    }
                } else {
                    console.log('📄 No parent window to update');
                }
                
                // 3. Send to opener window (if admin panel was opened from main page)
                if (window.opener && window.opener !== window) {
                    try {
                        window.opener.postMessage(updateMessage, '*');
                        console.log('🎨 Sent color update to opener window');
                        
                        // Also send a refresh message specifically for the main index page
                        setTimeout(() => {
                            window.opener.postMessage({
                                type: 'forceVisualRefresh',
                                timestamp: Date.now()
                            }, '*');
                            console.log('🔄 Sent forceVisualRefresh to opener (main index)');
                        }, 500);
                        
                    } catch (error) {
                        console.warn('Could not update opener visualization:', error);
                    }
                } else {
                    console.log('🔗 No opener window to update');
                }
                
                // 4. Broadcast to other tabs/windows using same origin
                if (typeof BroadcastChannel !== 'undefined') {
                    const channel = new BroadcastChannel('emotion-colors-sync');
                    channel.postMessage(updateMessage);
                    channel.close();
                    console.log(`📻 Broadcast color update to all tabs (${activeCount} colors)`);
                } else {
                    console.log('📻 BroadcastChannel not available');
                }
                
                // 5. Send to all known visualization windows
                if (window.visualizationWindows) {
                    window.visualizationWindows.forEach(vizWindow => {
                        try {
                            if (vizWindow && !vizWindow.closed) {
                                vizWindow.postMessage(updateMessage, '*');
                                console.log('🎨 Sent color update to known visualization window');
                            }
                        } catch (error) {
                            console.warn('Could not update known visualization window:', error);
                        }
                    });
                }
                
                // 6. Try sending to main visualization window by name (skip if no valid window)
                try {
                    // Only try to access existing window, don't create new blank ones
                    if (window.visualizationMainWindow && !window.visualizationMainWindow.closed) {
                        window.visualizationMainWindow.postMessage(updateMessage, '*');
                        console.log('🎨 Sent color update to main visualization window');
                    }
                } catch (error) {
                    // Silently ignore - window might not exist
                }
                
                // 7. Update local displays in admin panel
                refreshAllEmotionDisplays();
                
                console.log('✅ Emotion color updates sent to all visualizations and displays');
                
            } catch (error) {
                console.error('Error updating visualization colors:', error);
            }
        }
        
        // Refresh all emotion displays in the edit parameters tab
        function refreshAllEmotionDisplays() {
            try {
                console.log('🎨 Refreshing all emotion displays in edit parameters tab...');
                
                // Only refresh if we have loaded conversations and emotion data
                if (!emotionData || !currentConversation) {
                    console.log('⏭️ Skipping emotion display refresh - no conversation loaded');
                    return;
                }
                
                // Refresh all segment displays
                const mp3Files = Object.keys(emotionData).filter(key => key.endsWith('.mp3'));
                mp3Files.forEach(mp3File => {
                    if (emotionData[mp3File] && emotionData[mp3File].emotions) {
                        refreshEmotionDisplay(mp3File);
                    }
                });
                
                // Refresh the segments container
                if (typeof displaySegments === 'function') {
                    displaySegments();
                }
                
                // If there's a currently selected segment, refresh its editor
                if (currentSelectedSegment && emotionData[currentSelectedSegment]) {
                    loadSegmentEditor(currentSelectedSegment, emotionData[currentSelectedSegment]);
                }
                
                console.log('✅ All emotion displays refreshed with new colors');
                
                        } catch (error) {
                console.error('Error refreshing emotion displays:', error);
            }
        }
        
        // Force color update function for debugging
        async function forceColorUpdate() {
            console.log('🔧 FORCING COLOR UPDATE FOR DEBUGGING...');
            console.log('🎨 Current emotions config:', emotionsConfig);
            
            // Check if emotions config is loaded
            if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                alert('❌ אין הגדרות רגשות נטענות! לחץ על "רענן צבעים" קודם.');
                return;
            }
            
            // Count active emotions with colors
            const activeEmotions = Object.entries(emotionsConfig).filter(([emotion, config]) => config.active && config.color);
            console.log(`🎯 Found ${activeEmotions.length} active emotions with colors:`, activeEmotions);
            
            // Test: reload emotions config from server to compare
            try {
                const response = await fetch(`${apiBaseUrl}/config/emotions_config.json`);
                if (response.ok) {
                    const serverConfig = await response.json();
                    console.log('🌐 Server emotions config:', serverConfig);
                    
                    // Compare with current config
                    let differences = 0;
                    Object.keys(emotionsConfig).forEach(emotion => {
                        if (serverConfig[emotion] && emotionsConfig[emotion].color !== serverConfig[emotion].color) {
                            console.log(`🔍 Color difference for ${emotion}: local=${emotionsConfig[emotion].color}, server=${serverConfig[emotion].color}`);
                            differences++;
                        }
                    });
                    
                    if (differences > 0) {
                        console.warn(`⚠️ Found ${differences} color differences between local and server config!`);
                    } else {
                        console.log('✅ Local and server configurations match');
                    }
                }
            } catch (error) {
                console.error('❌ Could not load server config for comparison:', error);
            }
            
            // Force update visualization colors
            updateVisualizationColors();
            
            // Also refresh the display
            displayEmotionsList();
            
            // Show detailed debug info
            const debugInfo = activeEmotions.map(([emotion, config]) => 
                `${config.hebrew} (${emotion}): ${config.color}`
            ).join('\n');
            
            alert(`🔧 עדכון צבעים נאלץ!\n\n📊 רגשות פעילים: ${activeEmotions.length}\n\n${debugInfo}\n\n✅ בדוק את קונסול הדפדפן לפרטים נוספים`);
        }
        
        // Test color persistence function
        async function testColorPersistence() {
            console.log('🧪 TESTING COLOR PERSISTENCE...');
            
            if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                alert('❌ אין הגדרות רגשות נטענות!');
                return;
            }
            
            // Pick a random emotion to test
            const emotions = Object.keys(emotionsConfig);
            const testEmotion = emotions[0]; // Use first emotion for test
            const originalColor = emotionsConfig[testEmotion].color;
            const testColor = originalColor === '#FF0000' ? '#00FF00' : '#FF0000'; // Toggle between red and green
            
            try {
                console.log(`🎯 Testing with emotion: ${testEmotion}`);
                console.log(`🎨 Original color: ${originalColor}`);
                console.log(`🎨 Test color: ${testColor}`);
                
                // 1. Change color locally
                emotionsConfig[testEmotion].color = testColor;
                displayEmotionsList();
                updateVisualizationColors();
                
                // 2. Save to server
                console.log('💾 Saving to server...');
                await saveEmotionsConfig(true); // silent save
                
                // 3. Wait a moment
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // 4. Reload from server
                console.log('📥 Reloading from server...');
                const response = await fetch(`${apiBaseUrl}/config/emotions_config.json`);
                if (response.ok) {
                    const serverConfig = await response.json();
                    const serverColor = serverConfig[testEmotion]?.color;
                    
                    console.log(`🌐 Server color: ${serverColor}`);
                    
                    if (serverColor === testColor) {
                        console.log('✅ SUCCESS: Color was saved and loaded correctly!');
                        alert(`✅ בדיקת שמירת צבעים הצליחה!\n\nרגש: ${emotionsConfig[testEmotion].hebrew}\nצבע נשמר: ${testColor}`);
                    } else {
                        console.error('❌ FAILED: Color was not saved correctly!');
                        alert(`❌ בדיקת שמירת צבעים נכשלה!\n\nצפוי: ${testColor}\nנטען מהשרת: ${serverColor}`);
                    }
                } else {
                    throw new Error('Could not load from server');
                }
                
                // 5. Restore original color
                emotionsConfig[testEmotion].color = originalColor;
                displayEmotionsList();
                await saveEmotionsConfig(true);
                
            } catch (error) {
                console.error('❌ Test failed:', error);
                alert(`❌ שגיאה בבדיקה: ${error.message}`);
                
                // Restore original color on error
                emotionsConfig[testEmotion].color = originalColor;
                displayEmotionsList();
            }
        }
        
        // Manual save function with verification
        async function manualSaveEmotions() {
            console.log('📝 MANUAL SAVE TRIGGERED');
            
            try {
                // Show what we're about to save
                console.log('💾 About to save emotions config:', emotionsConfig);
                
                // Call the regular save function
                await saveEmotionsConfig(false); // not auto-save
                
                // Wait a moment then verify
                setTimeout(async () => {
                    console.log('🔍 Verifying manual save...');
                    await verifyColorSave();
                }, 1000);
                
            } catch (error) {
                console.error('❌ Manual save failed:', error);
                showStatus(`שגיאה בשמירה ידנית: ${error.message}`, 'error');
            }
        }
        
        // Verify color save function
        async function verifyColorSave() {
            console.log('🔍 VERIFYING COLOR SAVE...');
            
            try {
                // Get current emotions config from memory
                const currentConfig = emotionsConfig;
                console.log('🧠 Current in-memory config:', currentConfig);
                
                // Pick a test emotion to verify
                const testEmotions = ['love', 'happiness', 'anger', 'sadness'].filter(e => currentConfig[e]);
                if (testEmotions.length === 0) {
                    console.warn('⚠️ No test emotions found');
                    return;
                }
                
                const testEmotion = testEmotions[0];
                const memoryColor = currentConfig[testEmotion]?.color;
                console.log(`🧠 In memory: ${testEmotion} = ${memoryColor}`);
                
                // Force save current config
                console.log('💾 Force saving current config...');
                await saveEmotionsConfig(true);
                
                // Wait a moment
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Load fresh from server
                console.log('📥 Loading fresh from server...');
                const response = await fetch(`${apiBaseUrl}/config/emotions_config.json?t=${Date.now()}`);
                
                if (response.ok) {
                    const serverConfig = await response.json();
                    const serverColor = serverConfig[testEmotion]?.color;
                    console.log(`📥 From server: ${testEmotion} = ${serverColor}`);
                    
                    const match = memoryColor === serverColor;
                    const status = match ? 'MATCH ✅' : 'MISMATCH ❌';
                    
                    console.log(`🔍 Verification result: ${status}`);
                    
                    // Show result to user
                    const message = match 
                        ? `✅ שמירה תקינה!\n\nרגש: ${testEmotion}\nצבע בזיכרון: ${memoryColor}\nצבע בשרת: ${serverColor}`
                        : `❌ בעיה בשמירה!\n\nרגש: ${testEmotion}\nצבע בזיכרון: ${memoryColor}\nצבע בשרת: ${serverColor}\n\nהצבע לא נשמר כראוי!`;
                    
                    alert(message);
                    
                    if (!match) {
                        showStatus('❌ בעיה בשמירת צבעים - בדוק את הקונסול', 'error');
                    } else {
                        showStatus('✅ שמירת צבעים פועלת כראוי', 'success');
                    }
                    
                } else {
                    console.error('❌ Failed to load from server:', response.status);
                    alert('❌ שגיאה בטעינה מהשרת');
                }
                
            } catch (error) {
                console.error('❌ Error in verification:', error);
                alert(`❌ שגיאה בבדיקה: ${error.message}`);
            }
        }
        
        // Reload visualization colors function
        async function reloadVisualizationColors() {
            console.log('🔄 RELOADING VISUALIZATION COLORS...');
            
            try {
                // Send reload message to all iframes
                const iframes = document.querySelectorAll('iframe');
                iframes.forEach((iframe, index) => {
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'reloadEmotionColors',
                            timestamp: Date.now()
                        }, '*');
                        console.log(`✅ Sent reload colors message to iframe ${index + 1}`);
                    }
                });
                
                // Also send to other windows
                if (window.opener) {
                    window.opener.postMessage({
                        type: 'reloadEmotionColors',
                        timestamp: Date.now()
                    }, '*');
                    console.log('✅ Sent reload colors to opener window');
                }
                
                // Also try broadcasting
                if (typeof BroadcastChannel !== 'undefined') {
                    try {
                        const channel = new BroadcastChannel('emotion-colors');
                        channel.postMessage({
                            type: 'reloadEmotionColors',
                            timestamp: Date.now()
                        });
                        console.log('✅ Broadcast reload colors message');
                    } catch (e) {
                        console.log('⚠️ BroadcastChannel not available:', e.message);
                    }
                }
                
                // Try to directly call the global function if available
                setTimeout(() => {
                    if (window.forceUpdateAllBlobColors) {
                        window.forceUpdateAllBlobColors();
                        console.log('✅ Called global forceUpdateAllBlobColors');
                    }
                    
                    // Also try on iframe windows
                    iframes.forEach((iframe, index) => {
                        try {
                            if (iframe.contentWindow && iframe.contentWindow.forceUpdateAllBlobColors) {
                                iframe.contentWindow.forceUpdateAllBlobColors();
                                console.log(`✅ Called forceUpdateAllBlobColors on iframe ${index + 1}`);
                            }
                        } catch (e) {
                            console.log(`⚠️ Could not call forceUpdateAllBlobColors on iframe ${index + 1}:`, e.message);
                        }
                    });
                }, 1000);
                
                showStatus('🎨 הודעת טעינת צבעים נשלחה לכל הוויזואליזציות', 'success');
                
            } catch (error) {
                console.error('❌ Error reloading visualization colors:', error);
                showStatus('שגיאה בטעינת צבעים מחדש', 'error');
            }
        }
        
        // Force visualization reload function
        async function forceVisualizationReload() {
            console.log('🔄 FORCING COMPLETE VISUALIZATION RELOAD...');
            
            try {
                // Send force reload message to all iframes
                const iframes = document.querySelectorAll('iframe');
                iframes.forEach((iframe, index) => {
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'forceCompleteReload',
                            timestamp: Date.now()
                        }, '*');
                        console.log(`✅ Sent force reload to iframe ${index + 1}`);
                    }
                });
                
                // Also send to other windows
                if (window.opener) {
                    window.opener.postMessage({
                        type: 'forceCompleteReload',
                        timestamp: Date.now()
                    }, '*');
                    console.log('✅ Sent force reload to opener window');
                }
                
                // Try to directly reload visualizations after a short delay
                setTimeout(() => {
                    // Refresh any visualization iframes completely
                    iframes.forEach((iframe, index) => {
                        if (iframe.src && iframe.src.includes('visualization.html')) {
                            console.log(`🔄 Reloading visualization iframe ${index + 1}`);
                            const currentSrc = iframe.src;
                            iframe.src = currentSrc + (currentSrc.includes('?') ? '&' : '?') + 'reload=' + Date.now();
                        }
                    });
                }, 1000);
                
                showStatus('🔄 כפיית רענון מלא של הוויזואליזציה', 'warning');
                
            } catch (error) {
                console.error('❌ Error forcing visualization reload:', error);
                showStatus('שגיאה ברענון ויזואליזציה', 'error');
            }
        }
        
        // Test direct color update function
        function testDirectColorUpdate() {
            console.log('🧪 TESTING DIRECT COLOR UPDATE...');
            
            try {
                // Try to call the global function directly
                if (window.forceUpdateAllBlobColors) {
                    window.forceUpdateAllBlobColors();
                    showStatus('✅ נקרא פונקציית עדכון ישיר', 'success');
                } else {
                    console.log('⚠️ Global forceUpdateAllBlobColors not available');
                    showStatus('⚠️ פונקציה גלובלית לא זמינה', 'warning');
                }
                
                // Also try on any iframe windows
                const iframes = document.querySelectorAll('iframe');
                let foundIframes = 0;
                
                iframes.forEach((iframe, index) => {
                    try {
                        if (iframe.contentWindow && iframe.contentWindow.forceUpdateAllBlobColors) {
                            iframe.contentWindow.forceUpdateAllBlobColors();
                            foundIframes++;
                            console.log(`✅ Called direct update on iframe ${index + 1}`);
                        }
                    } catch (e) {
                        console.log(`⚠️ Could not call direct update on iframe ${index + 1}:`, e.message);
                    }
                });
                
                if (foundIframes > 0) {
                    showStatus(`✅ עדכון ישיר נשלח ל-${foundIframes} ויזואליזציות`, 'success');
                } else {
                    showStatus('⚠️ לא נמצאו ויזואליזציות פעילות', 'warning');
                }
                
            } catch (error) {
                console.error('❌ Error in direct color update:', error);
                showStatus('❌ שגיאה בעדכון ישיר', 'error');
            }
        }
        
        // Test conversation colors function
        function testConversationColors() {
            console.log('🧪 TESTING CONVERSATION COLORS...');
            
            try {
                // Open a test conversation visualization in a new window
                const testConversation = 'convo1'; // You can change this to any conversation
                const testUrl = `/visualization.html?folder=${testConversation}&t=${Date.now()}`;
                
                console.log(`🔄 Opening test conversation: ${testUrl}`);
                
                const testWindow = window.open(testUrl, 'testConversation', 'width=800,height=600');
                
                if (testWindow) {
                    // Wait for the window to load then send color update
                    setTimeout(() => {
                        console.log('📤 Sending color update to test conversation...');
                        testWindow.postMessage({
                            type: 'reloadEmotionColors',
                            timestamp: Date.now()
                        }, '*');
                        
                        setTimeout(() => {
                            testWindow.postMessage({
                                type: 'forceVisualRefresh',
                                timestamp: Date.now()
                            }, '*');
                        }, 1000);
                        
                    }, 3000); // Wait for conversation to load
                    
                    showStatus(`🔄 פתח שיחת בדיקה: ${testConversation}`, 'info');
                } else {
                    showStatus('❌ לא ניתן לפתוח שיחת בדיקה', 'error');
                }
                
            } catch (error) {
                console.error('❌ Error testing conversation colors:', error);
                showStatus('❌ שגיאה בבדיקת צבעי שיחה', 'error');
            }
        }
        
        // Test index page colors function
        function testIndexPageColors() {
            console.log('🏠 TESTING INDEX PAGE CONVERSATION COLORS...');
            
            try {
                if (window.opener && window.opener !== window) {
                    console.log('📤 Sending test messages to main index page...');
                    
                    // Send multiple update messages with delays
                    const messages = [
                        { type: 'emotionColorsUpdated', timestamp: Date.now() },
                        { type: 'reloadEmotionColors', timestamp: Date.now() + 100 },
                        { type: 'forceVisualRefresh', timestamp: Date.now() + 200 }
                    ];
                    
                    messages.forEach((message, index) => {
                        setTimeout(() => {
                            window.opener.postMessage(message, '*');
                            console.log(`📤 Sent ${message.type} to main index page (${index + 1}/${messages.length})`);
                        }, index * 300);
                    });
                    
                    showStatus('🔄 שלח עדכוני צבעים לעמוד הראשי', 'success');
                } else {
                    showStatus('❌ לא ניתן למצוא עמוד ראשי', 'error');
                    console.log('❌ No opener window found (admin panel may not be opened from main index)');
                }
                
            } catch (error) {
                console.error('❌ Error testing index page colors:', error);
                showStatus('❌ שגיאה בבדיקת עמוד ראשי', 'error');
            }
        }
        
        // Immediate visual refresh function
        async function immediateVisualRefresh() {
            console.log('🚀 IMMEDIATE VISUAL REFRESH TRIGGERED');
            
            try {
                // 1. Force update all emotion displays
                displayEmotionsList();
                console.log('✅ Refreshed emotions list display');
                
                // 2. Force visualization color update
                updateVisualizationColors();
                console.log('✅ Sent visualization color updates');
                
                // 3. Wait a moment then force another update
                setTimeout(() => {
                    updateVisualizationColors();
                    console.log('✅ Sent delayed visualization update');
                }, 500);
                
                // 4. Send direct force refresh message to all iframes
                const iframes = document.querySelectorAll('iframe');
                iframes.forEach((iframe, index) => {
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'forceVisualRefresh',
                            timestamp: Date.now()
                        }, '*');
                        console.log(`✅ Sent force refresh to iframe ${index + 1}`);
                    }
                });
                
                // 5. Also broadcast to other windows
                if (window.opener) {
                    window.opener.postMessage({
                        type: 'forceVisualRefresh',
                        timestamp: Date.now()
                    }, '*');
                    console.log('✅ Sent force refresh to opener window');
                }
                
                showStatus('🎨 כפיית רענון מיידי של הוויזואליזציה - בדוק את התצוגה עכשיו!', 'success');
                
            } catch (error) {
                console.error('❌ Error in immediate visual refresh:', error);
                showStatus('שגיאה ברענון מיידי', 'error');
            }
        }
        
        // Hex to RGB conversion function
        function hexToRgb(hex) {
            // Remove # if present
            hex = hex.replace('#', '');
            
            // Parse RGB values
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            return [r, g, b];
        }
        
        // Filter emotions
        function filterEmotions(searchTerm) {
            const emotionItems = document.querySelectorAll('.emotion-item');
            const term = searchTerm.toLowerCase();
            
            emotionItems.forEach(item => {
                const emotionText = item.textContent.toLowerCase();
                const isVisible = emotionText.includes(term);
                item.style.display = isVisible ? 'block' : 'none';
            });
        }
        
        // Helper function to get contrast color
        function getContrastColor(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128 ? '#000000' : '#ffffff';
        }
        
        // Copy to clipboard
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showStatus(`צבע ${text} הועתק ללוח`, 'success');
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                showStatus('שגיאה בהעתקה', 'error');
            });
        }
        
        // ENHANCED: Force immediate color update test function
        window.forceEmotionColorUpdate = function() {
            console.log('🚀 FORCING IMMEDIATE EMOTION COLOR UPDATE');
            
            if (!emotionsConfig || Object.keys(emotionsConfig).length === 0) {
                console.error('❌ No emotions config loaded!');
                return false;
            }
            
            console.log('🎨 Current emotions config:', emotionsConfig);
            
            // Force an immediate update
            updateVisualizationColors();
            
            // Also try to refresh any open visualization
            const iframe = document.getElementById('segment-preview-iframe');
            if (iframe && iframe.contentWindow) {
                        const emotionColorsForViz = {};
                        Object.entries(emotionsConfig).forEach(([emotion, config]) => {
                            if (config.active && config.color) {
                                emotionColorsForViz[emotion] = hexToRgb(config.color);
                            }
                        });
                        
                iframe.contentWindow.postMessage({
                    type: 'updateEmotions',
                            emotionColorMap: emotionColorsForViz,
                            emotions: emotionsConfig,
                            timestamp: Date.now()
                }, '*');
                
                console.log('🎨 Sent direct update to preview iframe:', emotionColorsForViz);
            }
            
            return true;
        };
        
        // Comprehensive test function to debug emotion colors
        window.testEmotionColors = function() {
            console.log('🧪 COMPREHENSIVE EMOTION COLOR TEST');
            console.log('=' .repeat(50));
            
            // 1. Check emotions config
            console.log('1️⃣ EMOTIONS CONFIG CHECK:');
            console.log('🎨 Current emotions config:', emotionsConfig);
            console.log('🎨 Emotions config keys:', Object.keys(emotionsConfig || {}));
            console.log('🎨 Config loaded:', !!(emotionsConfig && Object.keys(emotionsConfig).length > 0));
            
            // Test love emotion specifically
            console.log('\n🔍 LOVE EMOTION DETAILED CHECK:');
            const loveConfig = emotionsConfig['love'];
            if (loveConfig) {
                console.log('✅ Love emotion config found:', loveConfig);
                console.log('🎯 Love color:', loveConfig.color);
                console.log('🎯 Love RGB:', hexToRgb(loveConfig.color));
                console.log('🎯 Love hebrew:', loveConfig.hebrew);
                console.log('🎯 Love emoji:', loveConfig.emoji);
                console.log('🎯 Love active:', loveConfig.active);
            } else {
                console.log('❌ No love emotion config found!');
                console.log('Available emotions:', Object.keys(emotionsConfig || {}));
            }
            
            // 2. Check conversation data
            console.log('\n2️⃣ CONVERSATION DATA CHECK:');
            console.log('🎨 Current conversation:', currentConversation);
            console.log('🎨 Current emotion data loaded:', !!(emotionData && Object.keys(emotionData).length > 0));
            console.log('🎨 Emotion data keys count:', Object.keys(emotionData || {}).length);
            
            // 3. Check if any segments have love emotion
            console.log('\n3️⃣ SEGMENTS WITH LOVE EMOTION:');
            if (emotionData) {
                const mp3Files = Object.keys(emotionData).filter(key => key.endsWith('.mp3'));
                let loveCount = 0;
                mp3Files.slice(0, 10).forEach(mp3File => {
                    const segment = emotionData[mp3File];
                    if (segment && segment.emotions && segment.emotions.includes('love')) {
                        loveCount++;
                        console.log(`💝 ${mp3File}: emotions = [${segment.emotions.join(', ')}]`);
                        if (segment.emotionColors) {
                            console.log(`   💾 emotionColors:`, segment.emotionColors);
                        }
                    }
                });
                console.log(`📊 Found ${loveCount} segments with love emotion (from first 10 checked)`);
            }
            
            // 4. Test color conversion
            console.log('\n4️⃣ COLOR CONVERSION TEST:');
            if (loveConfig && loveConfig.color) {
                const hexColor = loveConfig.color;
                const rgbColor = hexToRgb(hexColor);
                console.log(`🎨 Love Hex color: ${hexColor}`);
                console.log(`🎨 Love RGB color: [${rgbColor.join(', ')}]`);
                
                // Test visualization message format
                const emotionColorsForViz = {};
                emotionColorsForViz['love'] = rgbColor;
                console.log(`🎨 Message format for love:`, emotionColorsForViz);
            }
            
            // 5. Force color updates
            console.log('\n5️⃣ FORCING COLOR UPDATES:');
            try {
                console.log('🔄 Calling updateVisualizationColors()...');
                updateVisualizationColors();
                
                console.log('🔄 Calling refreshAllEmotionDisplays()...');
                refreshAllEmotionDisplays();
                
                console.log('🔄 Calling updateCurrentConversationEmotionColors()...');
                updateCurrentConversationEmotionColors();
                
                console.log('✅ All update functions called successfully');
            } catch (error) {
                console.error('❌ Error calling update functions:', error);
            }
            
            // 6. Check iframe targets
            console.log('\n6️⃣ IFRAME AND WINDOW TARGETS:');
            const iframes = document.querySelectorAll('iframe');
            console.log(`📺 Found ${iframes.length} iframes on page`);
            iframes.forEach((iframe, i) => {
                console.log(`   iframe ${i}: src = ${iframe.src}`);
                if (iframe.contentWindow) {
                    console.log(`   iframe ${i}: contentWindow available`);
                }
            });
            
            if (window.opener) {
                console.log('🔗 Window opener available:', !!window.opener);
            }
            if (window.parent !== window) {
                console.log('🔗 Window parent available:', !!window.parent);
            }
            
            // 7. Test direct iframe update
            console.log('\n7️⃣ DIRECT IFRAME UPDATE TEST:');
            const previewIframe = document.getElementById('segment-preview-iframe');
            if (previewIframe && previewIframe.contentWindow) {
                console.log('📺 Found preview iframe, sending direct update...');
                
                const emotionColorsForViz = {};
                Object.entries(emotionsConfig).forEach(([emotion, config]) => {
                    if (config.active && config.color) {
                        emotionColorsForViz[emotion] = hexToRgb(config.color);
                    }
                });
                
                previewIframe.contentWindow.postMessage({
                    type: 'updateEmotions',
                    emotionColorMap: emotionColorsForViz,
                    emotions: emotionsConfig,
                    timestamp: Date.now()
                }, '*');
                
                console.log('✅ Sent direct update to preview iframe');
                console.log('🎨 Emotion colors sent:', emotionColorsForViz);
            } else {
                console.log('❌ No preview iframe found or contentWindow not available');
            }
            
            console.log('\n✅ COMPREHENSIVE TEST COMPLETE');
            console.log('=' .repeat(50));
            
            return {
                emotionsConfigLoaded: !!(emotionsConfig && Object.keys(emotionsConfig).length > 0),
                conversationLoaded: !!currentConversation,
                emotionDataLoaded: !!(emotionData && Object.keys(emotionData).length > 0),
                loveConfigExists: !!(emotionsConfig && emotionsConfig['love']),
                loveColor: emotionsConfig?.['love']?.color,
                iframeCount: document.querySelectorAll('iframe').length,
                previewIframeAvailable: !!(document.getElementById('segment-preview-iframe')),
                broadcastSupported: typeof BroadcastChannel !== 'undefined'
            };
        };
        
        // Simple test to force update a specific emotion color
        window.forceUpdateNeutralColor = function(newColor = '#FF0000') {
            console.log(`🔴 FORCING NEUTRAL COLOR UPDATE TO: ${newColor}`);
            
            if (!emotionsConfig || !emotionsConfig['neutral']) {
                console.error('❌ No neutral emotion config found!');
                return false;
            }
            
            // Update the config
            emotionsConfig['neutral'].color = newColor;
            console.log('✅ Updated emotions config');
            
            // Update all visualizations
            updateVisualizationColors();
            console.log('✅ Called updateVisualizationColors');
            
            // Update displays
            refreshAllEmotionDisplays();
            console.log('✅ Called refreshAllEmotionDisplays');
            
            // Update conversation data
            updateCurrentConversationEmotionColors();
            console.log('✅ Called updateCurrentConversationEmotionColors');
            
            console.log(`🎨 Neutral color should now be: ${newColor}`);
            return true;
        };
        
        // ==================== ENHANCED EMOTIONS VIEW FUNCTIONS ====================
        
        // Enhanced Emotions View Functions
        window.analyzeConversationEmotions = function() {
            console.log('🎭 Analyzing conversation emotions...');
            
            fetch('/api/conversations')
                .then(response => response.json())
                .then(data => {
                    const conversations = data.conversations || [];
                    const emotionGroups = {};
                    let totalConversations = 0;
                    
                    // Group conversations by main emotions
                    conversations.forEach(conv => {
                        const mainEmotions = conv.metadata?.mainEmotions || ['neutral'];
                        totalConversations++;
                        
                        mainEmotions.forEach(emotion => {
                            if (!emotionGroups[emotion]) {
                                emotionGroups[emotion] = [];
                            }
                            emotionGroups[emotion].push(conv);
                        });
                    });
                    
                    // Update stats
                    const emotionCount = Object.keys(emotionGroups).length;
                    const analysisStats = `${totalConversations} שיחות, ${emotionCount} רגשות שונים`;
                    const circlesStats = `${emotionCount} מעגלי רגשות פעילים`;
                    
                    document.getElementById('emotion-analysis-stats').innerHTML = analysisStats;
                    document.getElementById('emotion-circles-stats').innerHTML = circlesStats;
                    
                    // Update emotion groups preview
                    updateEmotionGroupsPreview(emotionGroups);
                    
                    console.log(`✅ Emotion analysis complete: ${emotionCount} emotions, ${totalConversations} conversations`);
                })
                .catch(error => {
                    console.error('❌ Error analyzing emotions:', error);
                    document.getElementById('emotion-analysis-stats').innerHTML = 'שגיאה בניתוח';
                    document.getElementById('emotion-circles-stats').innerHTML = 'שגיאה בניתוח';
                });
        };
        
        window.generateEmotionReport = function() {
            console.log('📊 Generating emotion report...');
            
            fetch('/api/conversations')
                .then(response => response.json())
                .then(data => {
                    const conversations = data.conversations || [];
                    const emotionStats = {};
                    
                    conversations.forEach(conv => {
                        const mainEmotions = conv.metadata?.mainEmotions || ['neutral'];
                        mainEmotions.forEach(emotion => {
                            emotionStats[emotion] = (emotionStats[emotion] || 0) + 1;
                        });
                    });
                    
                    // Sort emotions by frequency
                    const sortedEmotions = Object.entries(emotionStats)
                        .sort(([,a], [,b]) => b - a)
                        .map(([emotion, count]) => `${emotion}: ${count} שיחות`)
                        .join('\n');
                    
                    const reportText = `דוח רגשות - ${new Date().toLocaleDateString('he-IL')}\n\n${sortedEmotions}`;
                    
                    // Create download link
                    const blob = new Blob([reportText], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `emotion_report_${new Date().toISOString().split('T')[0]}.txt`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    alert('✅ דוח רגשות הופק בהצלחה!');
                })
                .catch(error => {
                    console.error('❌ Error generating report:', error);
                    alert('❌ שגיאה ביצירת הדוח');
                });
        };
        
        window.refreshEmotionView = function() {
            console.log('🔄 Refreshing emotion view...');
            analyzeConversationEmotions();
            
            // Refresh the main emotions view if it's open
            const mainWindow = window.opener || window.parent;
            if (mainWindow && mainWindow.refreshLayoutCache) {
                mainWindow.refreshLayoutCache('emotions');
            }
            
            setTimeout(() => {
                alert('✅ תצוגת הרגשות רוענה בהצלחה!');
            }, 1000);
        };
        
        function updateEmotionGroupsPreview(emotionGroups) {
            const container = document.getElementById('emotion-groups-preview');
            if (!container) return;
            
            container.innerHTML = '';
            
            Object.entries(emotionGroups).forEach(([emotion, conversations]) => {
                const emotionCard = document.createElement('div');
                emotionCard.style.cssText = `
                    background: linear-gradient(135deg, #f8f9ff 0%, #e8ecff 100%);
                    border: 1px solid #667eea;
                    border-radius: 8px;
                    padding: 1rem;
                    text-align: center;
                `;
                
                emotionCard.innerHTML = `
                    <div style="font-size: 24px; margin-bottom: 0.5rem;">🎭</div>
                    <div style="font-weight: bold; color: #333; margin-bottom: 0.25rem;">${emotion}</div>
                    <div style="color: #666; font-size: 0.9rem;">${conversations.length} שיחות</div>
                    <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #888;">
                        ${conversations.map(conv => conv.metadata?.name || conv.id).slice(0, 3).join(', ')}
                        ${conversations.length > 3 ? '...' : ''}
                    </div>
                `;
                
                container.appendChild(emotionCard);
            });
        }
        
        // Initialize enhanced emotions view when tab is opened
        window.initializeEmotions = function() {
            console.log('🎭 Initializing enhanced emotions view...');
            
            // Reload emotions configuration to get latest changes
            loadEmotionsConfig().then(() => {
                console.log('🎨 Emotions configuration reloaded successfully');
                
                // Auto-analyze emotions when the tab opens
                setTimeout(() => {
                    analyzeConversationEmotions();
                }, 500);
            }).catch(error => {
                console.error('❌ Error reloading emotions config:', error);
                showStatus('שגיאה בטעינת הגדרות רגשות', 'error');
            });
        };
        
        // ==================== END EMOTIONS MANAGEMENT FUNCTIONS ====================
        
        // ==================== PREVENT FORM SUBMISSIONS & BLANK TABS ====================
        
        // Comprehensive fix for preventing blank tabs and form submissions
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🔧 Applying admin panel button fixes...');
            
            // Prevent all form submissions in the admin panel
            document.addEventListener('submit', function(e) {
                e.preventDefault();
                console.warn('⚠️ Form submission prevented to avoid blank tabs');
                return false;
            });
            
            // Ensure all buttons with onclick handlers have type="button"
            const buttons = document.querySelectorAll('button[onclick]:not([type])');
            buttons.forEach(button => {
                button.setAttribute('type', 'button');
                console.log('🔧 Fixed button:', button.getAttribute('onclick'));
            });
            
            // More aggressive prevention of form submissions and blank tabs
            document.addEventListener('click', function(e) {
                // Prevent any form submission attempts
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
                    // Only prevent default if the button might cause navigation
                    if (e.target.type === 'submit' || !e.target.type || e.target.type === '') {
                        e.preventDefault();
                        console.log('🚫 Prevented potential form submission from:', e.target.outerHTML.substring(0, 100));
                        return false;
                    }
                }
            }, true); // Use capture phase
            
            // Also prevent any accidental form submissions at the document level
            document.addEventListener('submit', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.warn('🚫 Form submission blocked at document level');
                return false;
            }, true);
            
            // Prevent any window navigation that might open blank tabs
            const originalOpen = window.open;
            window.open = function(...args) {
                // Only block if it's likely to be an unwanted blank tab
                if (args.length === 0 || args[0] === '' || args[0] === 'about:blank') {
                    console.warn('🚫 Blocked blank/empty window.open call with args:', args);
                    console.trace('window.open call stack:');
                    return null;
                } else {
                    console.log('🔗 Allowing legitimate window.open to:', args[0]);
                    return originalOpen.apply(window, args);
                }
            };
            
            // Block location.assign only to blank/empty URLs
            const originalAssign = window.location.assign;
            window.location.assign = function(url) {
                if (!url || url === '' || url === 'about:blank') {
                    console.warn('🚫 Blocked blank/empty location.assign to:', url);
                    console.trace('location.assign call stack:');
                } else {
                    console.log('🔗 Allowing legitimate location.assign to:', url);
                    return originalAssign.call(window.location, url);
                }
            };
            
            console.log('✅ Admin panel button fixes and navigation blocks applied');
        });
        
        // ==================== END BUTTON FIXES ====================
        
        // ==================== PEOPLE MANAGER FUNCTIONS ====================
        
        let currentPeopleData = {};
        
        // Open the people manager modal
        function openPeopleManager() {
            console.log('📋 Opening people manager...');
            loadPeopleForManager();
            document.getElementById('people-manager-modal').style.display = 'block';
        }
        
        // Close the people manager modal
        function closePeopleManager() {
            document.getElementById('people-manager-modal').style.display = 'none';
            document.getElementById('new-person-name').value = '';
            document.getElementById('new-person-color').value = '#667eea';
        }
        
        // Load people data for the manager
        async function loadPeopleForManager() {
            try {
                console.log('📡 Loading people data for manager...');
                const response = await fetch('/config/people_data.json');
                const data = await response.json();
                currentPeopleData = data;
                
                displayExistingPeople(data.people || {});
                updateMainParticipantDropdown(data.people || {});
                
                console.log('✅ People data loaded for manager');
            } catch (error) {
                console.error('❌ Error loading people data:', error);
                showStatus('שגיאה בטעינת נתוני אנשים', 'error');
            }
        }
        
        // Display existing people in the manager
        function displayExistingPeople(people) {
            const listContainer = document.getElementById('existing-people-list');
            
            if (Object.keys(people).length === 0) {
                listContainer.innerHTML = '<div style="text-align: center; color: #999; padding: 2rem;">אין אנשים במערכת</div>';
                return;
            }
            
            let html = '';
            Object.entries(people).forEach(([personId, person]) => {
                html += `
                    <div class="person-item" data-person-id="${personId}" style="display: flex; align-items: center; gap: 1rem; padding: 0.75rem; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 0.5rem; background: white;">
                        <div style="width: 30px; height: 30px; background: ${person.color}; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
                        <input type="text" value="${person.name}" data-field="name" style="flex: 1; padding: 0.25rem; border: 1px solid #ccc; border-radius: 3px;">
                        <input type="color" value="${person.color}" data-field="color" style="width: 40px; padding: 0; border: 1px solid #ccc; border-radius: 3px;">
                        <button onclick="removePersonFromList('${personId}')" class="btn btn-danger btn-sm" style="background: #dc3545; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 3px; cursor: pointer;">
                            <i class="material-icons" style="font-size: 14px;">delete</i>
                        </button>
                    </div>
                `;
            });
            
            listContainer.innerHTML = html;
        }
        
        // Update the main participant dropdown
        function updateMainParticipantDropdown(people) {
            const dropdown = document.getElementById('main-participant');
            const currentValue = dropdown.value;
            
            // Clear existing options (except the first "select" option)
            dropdown.innerHTML = '<option value="">בחר משתתף...</option>';
            
            // Add people from data
            Object.entries(people).forEach(([personId, person]) => {
                const option = document.createElement('option');
                option.value = person.name;
                option.textContent = person.name;
                dropdown.appendChild(option);
            });
            
            // Add custom option
            const customOption = document.createElement('option');
            customOption.value = 'custom';
            customOption.textContent = 'מותאם אישית...';
            dropdown.appendChild(customOption);
            
            // Restore previous selection if it still exists
            if (currentValue && [...dropdown.options].some(opt => opt.value === currentValue)) {
                dropdown.value = currentValue;
            }
        }
        
        // Add a new person to the list
        function addNewPersonToList() {
            const nameInput = document.getElementById('new-person-name');
            const colorInput = document.getElementById('new-person-color');
            
            const name = nameInput.value.trim();
            const color = colorInput.value;
            
            if (!name) {
                showStatus('יש להזין שם לאדם החדש', 'warning');
                return;
            }
            
            // Check if name already exists
            const existingNames = Object.values(currentPeopleData.people || {}).map(p => p.name.toLowerCase());
            if (existingNames.includes(name.toLowerCase())) {
                showStatus('שם זה כבר קיים במערכת', 'warning');
                return;
            }
            
            // Generate new person ID
            const personId = 'person_' + name.toLowerCase().replace(/\s+/g, '_').replace(/[^\w]/g, '');
            
            // Add to current data
            if (!currentPeopleData.people) currentPeopleData.people = {};
            currentPeopleData.people[personId] = {
                name: name,
                description: `נוסף דרך ניהול שיחות`,
                color: color,
                status: 'active',
                conversations: [],
                totalSegments: 0,
                totalDuration: 0,
                defaultSpeaker: 0,
                createdAt: new Date().toISOString(),
                lastModified: new Date().toISOString()
            };
            
            // Refresh display
            displayExistingPeople(currentPeopleData.people);
            updateMainParticipantDropdown(currentPeopleData.people);
            
            // Clear inputs
            nameInput.value = '';
            colorInput.value = '#667eea';
            
            showStatus(`נוסף אדם חדש: ${name}`, 'success');
        }
        
        // Remove a person from the list
        function removePersonFromList(personId) {
            const person = currentPeopleData.people[personId];
            if (!person) return;
            
            if (confirm(`האם אתה בטוח שברצונך למחוק את ${person.name}?`)) {
                delete currentPeopleData.people[personId];
                
                // Also remove from conversation assignments
                if (currentPeopleData.conversationAssignments) {
                    Object.keys(currentPeopleData.conversationAssignments).forEach(convId => {
                        currentPeopleData.conversationAssignments[convId] = 
                            currentPeopleData.conversationAssignments[convId].filter(id => id !== personId);
                        
                        if (currentPeopleData.conversationAssignments[convId].length === 0) {
                            delete currentPeopleData.conversationAssignments[convId];
                        }
                    });
                }
                
                // Remove from speaker mappings
                if (currentPeopleData.speakerMappings) {
                    Object.keys(currentPeopleData.speakerMappings).forEach(convId => {
                        if (currentPeopleData.speakerMappings[convId]) {
                            Object.keys(currentPeopleData.speakerMappings[convId]).forEach(speaker => {
                                if (currentPeopleData.speakerMappings[convId][speaker] === personId) {
                                    delete currentPeopleData.speakerMappings[convId][speaker];
                                }
                            });
                            
                            if (Object.keys(currentPeopleData.speakerMappings[convId]).length === 0) {
                                delete currentPeopleData.speakerMappings[convId];
                            }
                        }
                    });
                }
                
                displayExistingPeople(currentPeopleData.people);
                updateMainParticipantDropdown(currentPeopleData.people);
                showStatus(`נמחק: ${person.name}`, 'info');
            }
        }
        
        // Save changes to people data
        async function savePeopleChanges() {
            try {
                console.log('💾 Saving people changes...');
                
                // Collect changes from the form
                const personItems = document.querySelectorAll('.person-item');
                personItems.forEach(item => {
                    const personId = item.dataset.personId;
                    const nameInput = item.querySelector('[data-field="name"]');
                    const colorInput = item.querySelector('[data-field="color"]');
                    
                    if (currentPeopleData.people[personId]) {
                        currentPeopleData.people[personId].name = nameInput.value.trim();
                        currentPeopleData.people[personId].color = colorInput.value;
                        currentPeopleData.people[personId].lastModified = new Date().toISOString();
                    }
                });
                
                // Update last modified time
                currentPeopleData.lastUpdated = new Date().toISOString();
                
                // Save to server
                const response = await fetch('/api/save-people-data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(currentPeopleData)
                });
                
                if (response.ok) {
                    // Synchronize speaker names with conversation metadata
                    await synchronizeSpeakerNames();
                    
                    showStatus('שינויים נשמרו בהצלחה', 'success');
                    closePeopleManager();
                    
                    // Reload the people list to ensure consistency
                    setTimeout(() => {
                        loadPeopleForManager();
                    }, 500);
                } else {
                    throw new Error('Failed to save people data');
                }
                
            } catch (error) {
                console.error('❌ Error saving people changes:', error);
                showStatus('שגיאה בשמירת השינויים', 'error');
            }
        }
        
        // Synchronize speaker names from people data to conversation metadata
        async function synchronizeSpeakerNames() {
            try {
                console.log('🔄 Synchronizing speaker names with conversation metadata...');
                
                // Check if we have speaker mappings
                if (!currentPeopleData.speakerMappings) {
                    console.log('⚠️ No speaker mappings found');
                    return;
                }
                
                // Get current conversation metadata
                if (!conversationMetadata) {
                    console.log('⚠️ No conversation metadata loaded');
                    return;
                }
                
                let hasChanges = false;
                
                // For each conversation in speaker mappings
                Object.keys(currentPeopleData.speakerMappings).forEach(conversationId => {
                    const speakerMapping = currentPeopleData.speakerMappings[conversationId];
                    
                    // Skip if conversation doesn't exist in metadata
                    if (!conversationMetadata[conversationId]) {
                        return;
                    }
                    
                    const metadata = conversationMetadata[conversationId].metadata || {};
                    
                    // Update speaker1Name if mapped
                    if (speakerMapping['0'] && currentPeopleData.people[speakerMapping['0']]) {
                        const newName = currentPeopleData.people[speakerMapping['0']].name;
                        if (metadata.speaker1Name !== newName) {
                            metadata.speaker1Name = newName;
                            hasChanges = true;
                            console.log(`🎭 Updated ${conversationId} speaker1Name: ${newName}`);
                        }
                    }
                    
                    // Update speaker2Name if mapped
                    if (speakerMapping['1'] && currentPeopleData.people[speakerMapping['1']]) {
                        const newName = currentPeopleData.people[speakerMapping['1']].name;
                        if (metadata.speaker2Name !== newName) {
                            metadata.speaker2Name = newName;
                            hasChanges = true;
                            console.log(`🎭 Updated ${conversationId} speaker2Name: ${newName}`);
                        }
                    }
                    
                    // Update lastModified timestamp
                    if (hasChanges) {
                        metadata.lastModified = new Date().toISOString();
                    }
                });
                
                // Save conversation metadata if changes were made
                if (hasChanges) {
                    console.log('💾 Saving updated conversation metadata...');
                    await saveConversationMetadata();
                    
                    // Refresh the metadata form if we're currently viewing it
                    if (currentMetadataConversation) {
                        loadMetadataForm(currentMetadataConversation, conversationMetadata[currentMetadataConversation]);
                    }
                    
                    console.log('✅ Speaker names synchronized successfully');
                } else {
                    console.log('ℹ️ No changes needed - speaker names already synchronized');
                }
                
            } catch (error) {
                console.error('❌ Error synchronizing speaker names:', error);
                showStatus('שגיאה בסנכרון שמות הדוברים', 'error');
            }
        }
        
        // Override the existing initializeMetadata function to include people loading
        const originalInitializeMetadata = window.initializeMetadata;
        window.initializeMetadata = function() {
            console.log('📊 Initializing metadata tab with people manager...');
            
            // Call original function if it exists
            if (originalInitializeMetadata && typeof originalInitializeMetadata === 'function') {
                originalInitializeMetadata();
            } else {
                // Fallback initialization with force refresh
                loadConversationMetadata(true);
            }
            
            // Load people data for dropdown
            loadPeopleForManager();
        };
        
        // ==================== END PEOPLE MANAGER FUNCTIONS ====================
    </script>

    <!-- People Manager Modal -->
    <div id="people-manager-modal" class="modal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);" onclick="if(event.target === this) closePeopleManager();">
        <div class="modal-content" style="background-color: #fefefe; margin: 5% auto; padding: 0; border: none; border-radius: 12px; width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.3);" onclick="event.stopPropagation();">
            <div class="modal-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1.5rem; border-radius: 12px 12px 0 0; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; font-size: 1.5rem;">ניהול רשימת אנשים</h2>
                <span class="close" onclick="closePeopleManager()" style="color: white; float: right; font-size: 28px; font-weight: bold; cursor: pointer; line-height: 1;">&times;</span>
            </div>
            <div class="modal-body" style="padding: 2rem;">
                <div style="margin-bottom: 2rem; background: #f8f9ff; padding: 1.5rem; border-radius: 8px;">
                    <h3 style="margin: 0 0 1rem 0; color: #667eea;">הוסף אדם חדש</h3>
                    <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                                                 <input type="text" id="new-person-name" placeholder="שם האדם החדש" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;" onkeypress="if(event.key==='Enter') addNewPersonToList();">
                        <input type="color" id="new-person-color" value="#667eea" style="width: 60px; padding: 0; border: 1px solid #ddd; border-radius: 4px;">
                        <button onclick="addNewPersonToList()" class="btn btn-success btn-sm" style="background: #28a745; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">
                            <i class="material-icons" style="font-size: 16px;">add</i>
                            הוסף
                        </button>
                    </div>
                </div>
                
                <div>
                    <h3 style="margin: 0 0 1rem 0; color: #e53e3e;">רשימת אנשים קיימת</h3>
                    <div id="existing-people-list" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; padding: 1rem; background: #f8f9fa;">
                        <!-- Existing people will be loaded here -->
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="background: #f8f9fa; padding: 1.5rem; border-radius: 0 0 12px 12px; display: flex; gap: 1rem; justify-content: flex-end;">
                <button onclick="savePeopleChanges()" class="btn btn-success" style="background: #28a745; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 4px; cursor: pointer;">
                    <i class="material-icons" style="font-size: 16px;">save</i>
                    שמור שינויים
                </button>
                <button onclick="closePeopleManager()" class="btn btn-secondary" style="background: #6c757d; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 4px; cursor: pointer;">
                    <i class="material-icons" style="font-size: 16px;">close</i>
                    ביטול
                </button>
            </div>
        </div>
    </div>
</body>
</html> 